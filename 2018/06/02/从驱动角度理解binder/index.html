<!DOCTYPE html>
<html lang="en">
    <!-- title -->




<!-- keywords -->




<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" >
    <meta name="author" content="QuincyJiang">
    <meta name="renderer" content="webkit">
    <meta name="copyright" content="QuincyJiang">
    
    <meta name="keywords" content="binder,android,江夏秋">
    
    <meta name="description" content="">
    <meta http-equiv="Cache-control" content="no-cache">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
    <title>从驱动角度理解binder · 瘟疫青年</title>
    <style type="text/css">
    @font-face {
        font-family: 'Oswald-Regular';
        src: url("/font/Oswald-Regular.ttf");
    }

    body {
        margin: 0;
    }

    header,
    footer,
    .back-top,
    .sidebar,
    .container,
    .site-intro-meta,
    .toc-wrapper {
        display: none;
    }

    .site-intro {
        position: relative;
        z-index: 3;
        width: 100%;
        /* height: 50vh; */
        overflow: hidden;
    }

    .site-intro-placeholder {
        position: absolute;
        z-index: -2;
        top: 0;
        left: 0;
        width: calc(100% + 300px);
        height: 100%;
        background: repeating-linear-gradient(-45deg, #444 0, #444 80px, #333 80px, #333 160px);
        background-position: center center;
        transform: translate3d(-226px, 0, 0);
        animation: gradient-move 2.5s ease-out 0s infinite;
    }

    @keyframes gradient-move {
        0% {
            transform: translate3d(-226px, 0, 0);
        }
        100% {
            transform: translate3d(0, 0, 0);
        }
    }

</style>

    <link rel="preload" href= "/css/style.css?v=20180824" as="style" onload="this.onload=null;this.rel='stylesheet'" />
    <link rel="stylesheet" href= "/css/mobile.css?v=20180824" media="(max-width: 980px)">
    
    <link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'" />
    
    <!-- /*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
/* This file is meant as a standalone workflow for
- testing support for link[rel=preload]
- enabling async CSS loading in browsers that do not support rel=preload
- applying rel preload css once loaded, whether supported or not.
*/ -->
<script>
(function( w ){
	"use strict";
	// rel=preload support test
	if( !w.loadCSS ){
		w.loadCSS = function(){};
	}
	// define on the loadCSS obj
	var rp = loadCSS.relpreload = {};
	// rel=preload feature support test
	// runs once and returns a function for compat purposes
	rp.support = (function(){
		var ret;
		try {
			ret = w.document.createElement( "link" ).relList.supports( "preload" );
		} catch (e) {
			ret = false;
		}
		return function(){
			return ret;
		};
	})();

	// if preload isn't supported, get an asynchronous load by using a non-matching media attribute
	// then change that media back to its intended value on load
	rp.bindMediaToggle = function( link ){
		// remember existing media attr for ultimate state, or default to 'all'
		var finalMedia = link.media || "all";

		function enableStylesheet(){
			link.media = finalMedia;
		}

		// bind load handlers to enable media
		if( link.addEventListener ){
			link.addEventListener( "load", enableStylesheet );
		} else if( link.attachEvent ){
			link.attachEvent( "onload", enableStylesheet );
		}

		// Set rel and non-applicable media type to start an async request
		// note: timeout allows this to happen async to let rendering continue in IE
		setTimeout(function(){
			link.rel = "stylesheet";
			link.media = "only x";
		});
		// also enable media after 3 seconds,
		// which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
		setTimeout( enableStylesheet, 3000 );
	};

	// loop through link elements in DOM
	rp.poly = function(){
		// double check this to prevent external calls from running
		if( rp.support() ){
			return;
		}
		var links = w.document.getElementsByTagName( "link" );
		for( var i = 0; i < links.length; i++ ){
			var link = links[ i ];
			// qualify links to those with rel=preload and as=style attrs
			if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
				// prevent rerunning on link
				link.setAttribute( "data-loadcss", true );
				// bind listeners to toggle media back
				rp.bindMediaToggle( link );
			}
		}
	};

	// if unsupported, run the polyfill
	if( !rp.support() ){
		// run once at least
		rp.poly();

		// rerun poly on an interval until onload
		var run = w.setInterval( rp.poly, 500 );
		if( w.addEventListener ){
			w.addEventListener( "load", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		} else if( w.attachEvent ){
			w.attachEvent( "onload", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		}
	}


	// commonjs
	if( typeof exports !== "undefined" ){
		exports.loadCSS = loadCSS;
	}
	else {
		w.loadCSS = loadCSS;
	}
}( typeof global !== "undefined" ? global : this ) );
</script>

    <link rel="icon" href= "/images/logo.png" />
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js" as="script" />
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" as="script" />
    <link rel="preload" href="/scripts/main.js" as="script" />
    <link rel="preload" as="font" href="/font/Oswald-Regular.ttf" crossorigin>
    <link rel="preload" as="font" href="https://at.alicdn.com/t/font_327081_1dta1rlogw17zaor.woff" crossorigin>
    
    <!-- fancybox -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script>
    <!-- 百度统计  -->
    
    <!-- 谷歌统计  -->
    
</head>

    
        <body class="post-body">
    
    
<header class="header">

    <div class="read-progress"></div>
    <div class="header-sidebar-menu">&#xe775;</div>
    <!-- post页的toggle banner  -->
    
    <div class="banner">
            <div class="blog-title">
                <a href="/" >瘟疫青年</a>
            </div>
            <div class="post-title">
                <a href="#" class="post-name">从驱动角度理解binder</a>
            </div>
    </div>
    
    <a class="home-link" href=/>瘟疫青年</a>
</header>
    <div class="wrapper">
        <div class="site-intro" style="







height:50vh;
">
    
    <!-- 主页  -->
    
    
    <!-- 404页  -->
            
    <div class="site-intro-placeholder"></div>
    <div class="site-intro-img" style="background-image: url(/intro/post-bg.jpg)"></div>
    <div class="site-intro-meta">
        <!-- 标题  -->
        <h1 class="intro-title">
            <!-- 主页  -->
            
            从驱动角度理解binder
            <!-- 404 -->
            
        </h1>
        <!-- 副标题 -->
        <p class="intro-subtitle">
            <!-- 主页副标题  -->
            
            
            <!-- 404 -->
            
        </p>
        <!-- 文章页meta -->
        
            <div class="post-intros">
                <!-- 文章页标签  -->
                
                    <div class= post-intro-tags >
    
        <a class="post-tag" href="javascript:void(0);" data-tags = "android">android</a>
    
        <a class="post-tag" href="javascript:void(0);" data-tags = "Binder">Binder</a>
    
</div>
                
                
                    <div class="post-intro-read">
                        <span>Word count: <span class="post-count word-count">5.2k</span>Reading time: <span class="post-count reading-time">19 min</span></span>
                    </div>
                
                <div class="post-intro-meta">
                    <span class="post-intro-calander iconfont-archer">&#xe676;</span>
                    <span class="post-intro-time">2018/06/02</span>
                    
                    <span id="busuanzi_container_page_pv" class="busuanzi-pv">
                        <span class="iconfont-archer">&#xe602;</span>
                        <span id="busuanzi_value_page_pv"></span>
                    </span>
                    
                    <span class="shareWrapper">
                        <span class="iconfont-archer shareIcon">&#xe71d;</span>
                        <span class="shareText">Share</span>
                        <ul class="shareList">
                            <li class="iconfont-archer share-qr" data-type="qr">&#xe75b;
                                <div class="share-qrcode"></div>
                            </li>
                            <li class="iconfont-archer" data-type="weibo">&#xe619;</li>
                            <li class="iconfont-archer" data-type="qzone">&#xe62e;</li>
                            <li class="iconfont-archer" data-type="twitter">&#xe634;</li>
                            <li class="iconfont-archer" data-type="facebook">&#xe67a;</li>
                        </ul>
                    </span>
                </div>
            </div>
        
    </div>
</div>
        <script>
 
  // get user agent
  var browser = {
    versions: function () {
      var u = window.navigator.userAgent;
      return {
        userAgent: u,
        trident: u.indexOf('Trident') > -1, //IE内核
        presto: u.indexOf('Presto') > -1, //opera内核
        webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核
        gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1, //火狐内核
        mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端
        ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
        android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或者uc浏览器
        iPhone: u.indexOf('iPhone') > -1 || u.indexOf('Mac') > -1, //是否为iPhone或者安卓QQ浏览器
        iPad: u.indexOf('iPad') > -1, //是否为iPad
        webApp: u.indexOf('Safari') == -1, //是否为web应用程序，没有头部与底部
        weixin: u.indexOf('MicroMessenger') == -1, //是否为微信浏览器
        uc: u.indexOf('UCBrowser') > -1 //是否为android下的UC浏览器
      };
    }()
  }
  console.log("userAgent:" + browser.versions.userAgent);

  // callback
  function fontLoaded() {
    console.log('font loaded');
    if (document.getElementsByClassName('site-intro-meta')) {
      document.getElementsByClassName('intro-title')[0].classList.add('intro-fade-in');
      document.getElementsByClassName('intro-subtitle')[0].classList.add('intro-fade-in');
      var postIntros = document.getElementsByClassName('post-intros')[0]
      if (postIntros) {
        postIntros.classList.add('post-fade-in');
      }
    }
  }

  // UC不支持跨域，所以直接显示
  function asyncCb(){
    if (browser.versions.uc) {
      console.log("UCBrowser");
      fontLoaded();
    } else {
      WebFont.load({
        custom: {
          families: ['Oswald-Regular']
        },
        loading: function () {  //所有字体开始加载
          // console.log('loading');
        },
        active: function () {  //所有字体已渲染
          fontLoaded();
        },
        inactive: function () { //字体预加载失败，无效字体或浏览器不支持加载
          console.log('inactive: timeout');
          fontLoaded();
        },
        timeout: 5000 // Set the timeout to two seconds
      });
    }
  }

  function asyncErr(){
    console.warn('script load from CDN failed, will load local script')
  }

  // load webfont-loader async, and add callback function
  function async(u, cb, err) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (cb) { o.addEventListener('load', function (e) { cb(null, e); }, false); }
    if (err) { o.addEventListener('error', function (e) { err(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }

  var asyncLoadWithFallBack = function(arr, success, reject) {
      var currReject = function(){
        reject()
        arr.shift()
        if(arr.length)
          async(arr[0], success, currReject)
        }

      async(arr[0], success, currReject)
  }

  asyncLoadWithFallBack([
    "https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js", 
    "https://cdn.bootcss.com/webfont/1.6.28/webfontloader.js",
    "/lib/webfontloader.min.js"
  ], asyncCb, asyncErr)
</script>        
        <img class="loading" src="/assets/loading.svg" style="display: block; margin: 6rem auto 0 auto; width: 6rem; height: 6rem;" />
        <div class="container container-unloaded">
            <main class="main post-page">
    <article class="article-entry">
        <p>一次binder通讯建立的大致流程我们已经了解了，首先是要注册一个serviceManager，server端创建实名binder，向smg注册自己可以提供的服务，以及该实名binder的标签，smg会在svcinfo 链表中缓存该server提供的binder信息，当client需要使用该服务时，只需要向smg中查询服务，获取server端binder的引用就可以了，这其中所有的通讯细节，全部需要binder驱动来实现。<br><img src="/media/15280074117127.jpg" alt=""></p>
<p>本文主要总结一下对binder驱动的理解，了解驱动设计的细节，以及binder通讯过程中驱动主要做了哪些事情。</p>
<h1 id="Binder驱动的定义"><a href="#Binder驱动的定义" class="headerlink" title="Binder驱动的定义"></a>Binder驱动的定义</h1><p>Binder驱动其实是一种特殊的字符型驱动，实现方式类似硬件驱动，工作在内核态。<br>如果了解过linux驱动相关知识，应该知道<code>file_operations</code> 结构体的重要性，linux 使用该结构体访问驱动程序的函数，这个结构体的每一个成员的名字都对应一个内核调用。<br>当用户进程利用设备文件（binder对应的设备文件为/dev/test）对文件进行类似<code>read()/write()</code> 操作的时候，系统调用通过设备文件的主设备号找到对应的设备驱动程序，每一个驱动程序在内核中是由一个<code>cdev</code>结构体描述，<code>cdev</code>结构体中又包括一个成员<code>fops</code>结构体，fops便是<code>file_operations</code>类型的，然后读取<code>file_operations</code> 结构体相应的函数指针，接着把控制权交给该函数的linux 设备驱动程序工作。</p>
<p>下面以binder驱动在内核中的注册流程来分析binder驱动为用户空间定义了哪些可用来调用的函数。</p>
<h2 id="注册Binder"><a href="#注册Binder" class="headerlink" title="注册Binder"></a>注册Binder</h2><p> 在binder驱动源码中（<a href="https://elixir.bootlin.com/linux/v3.11.4/source/drivers/staging/android/binder.c" target="_blank" rel="noopener">kernel/drivers/staging/android/binder.c</a>），通过调用 <code>ret = misc_register(&amp;binder_msicdev)</code>函数完成向内核注册<code>binder</code>驱动，主设备号为10，次设备号动态分配， 其中传入的参数便是一个<code>miscdev</code>的结构体，<br> 它的定义如下</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">miscdevice</span> <span class="title">binder_miscdev</span> = &#123;</span></span><br><span class="line">	.minor = MISC_DYNAMIC_MINOR,</span><br><span class="line">	.name = <span class="string">"binder"</span>,</span><br><span class="line">	.fops = &amp;binder_fops</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到<code>cdev</code>文件中标注了<code>binder</code>设备的设备名”binder”，以及<code>fops</code>结构体，<code>fops</code>结构体如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">binder_fops</span> = &#123;</span></span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .poll = binder_poll,</span><br><span class="line">    .unlocked_ioctl = binder_ioctl,</span><br><span class="line">    .mmap = binder_mmap,</span><br><span class="line">    .open = binder_open,</span><br><span class="line">    .flush = binder_flush,</span><br><span class="line">    .release = binder_release,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到binder驱动为应用层提供了<code>open()</code>,<code>mmap()</code>,<code>poll()</code>,<code>ioctl()</code>等标准的文件操作【注1】，<code>open()</code>负责打开驱动，<code>mmap()</code>负责对<code>binder</code>做内核空间向用户空间的地址映射，<code>ioctl()</code>负责binder协议的通信。</p>
<p>我们知道，用户态的引用程序调用<code>kernel</code>驱动程序是会陷入内核态的，进行系统调用，比如我使用 <code>fd = open(&quot;dev/binder&quot;,O_RDWR)</code>，开打开<code>binder</code>驱动时，它会先通过通过系统调用<code>_open()</code>【注1】，通过主次设备号来找到对应的binder驱动程序，即在 <code>cdev</code> 链表中找到binder驱动对应的<br><code>binder_miscdev</code>，找到 <code>binder_fops</code>结构体，找到<code>open()</code>方法对应的 <code>binder_open()</code>函数，实际执行到的便是<code>binder_open（）</code>函数。那么其他的 比如 mmap(),ioctl()方法，他们的执行流程也是类似的。 参考下图<br><img src="/media/15280103450907.jpg" alt=""></p>
<blockquote>
<p>注释1： open()为用户空间的方法，_open()为系统调用中对应的处理方法。</p>
</blockquote>
<p>打开一次binder通讯，大致分为以下流程：</p>
<ul>
<li>1 调用<code>open()</code>方法打开<code>binder</code>驱动 </li>
<li>2 调用 <code>mmap()</code>方法申请一块内存用来接受通信中的数据，并进行内存映射（binder机制为什么只进行一次拷贝，这里有文章），</li>
<li>3 调用 <code>ioctl()</code>方法 开启binder通讯。<br>这里每一步中具体都做了些什么，下文会有详细描述，但为了更好理解，需要先要搞清楚binder驱动中的几个关键的数据结构和binder的通讯协议。</li>
</ul>
<h2 id="Binder驱动中的结构体"><a href="#Binder驱动中的结构体" class="headerlink" title="Binder驱动中的结构体"></a>Binder驱动中的结构体</h2><p>驱动中的结构体分为两部分，一部分与用户空间共用，这些结构体在Binder通信协议中会用到，被定义在binder.h 头文件中。<br>具体内容见下表：</p>
<table>
<thead>
<tr>
<th>结构体名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>flat_binder_object</td>
<td>binder通讯过程中在client-binderDriver-server之间传递的实际内容，所谓跨进程传递的binder对象，其实传递的就是这个</td>
</tr>
<tr>
<td>binder_wirte_read</td>
<td>存储对binder驱动进行读写操作的数据，当为写的时候，结构体中的write_size非空，当为读的时候，read_size不为空</td>
</tr>
<tr>
<td>binder_version</td>
<td>存储binder的版本号</td>
</tr>
<tr>
<td>transaction_flags</td>
<td>描述一次binder事务的flag，比如是同步还是异步请求</td>
</tr>
<tr>
<td>binder_transcation_data</td>
<td>存储一次事务的数据</td>
</tr>
<tr>
<td>binder_handle_cookie</td>
<td>包含一个句柄和一个cookie</td>
</tr>
<tr>
<td>binder_ptr_cookie</td>
<td>包含一个指针和一个cookie </td>
</tr>
<tr>
<td>binder_pri_dest</td>
<td>暂未用到 </td>
</tr>
<tr>
<td>binder_pri_ptr_cookie</td>
<td>暂未用到</td>
</tr>
</tbody>
</table>
<p>另一部分定义在binder驱动中，是驱动特有的结构体</p>
<table>
<thead>
<tr>
<th>结构体名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>binder_node</td>
<td>描述binder的实体节点，对应一个server，当server通过binder驱动向smg注册时，binder驱动便会在内核中为其创建一个binder实体节点，该实体节点即为binder_node，同时驱动会为server与该节点创建引用关系</td>
</tr>
<tr>
<td>binder_ref</td>
<td>描述对binder实体节点的引用</td>
</tr>
<tr>
<td>binder_buffer</td>
<td>描述binder通讯过程中存储数据的buffer</td>
</tr>
<tr>
<td>binder_proc</td>
<td>描述使用binder的进程</td>
</tr>
<tr>
<td>binder_thread</td>
<td>描述使用binder的线程</td>
</tr>
<tr>
<td>binder_work</td>
<td>描述通信过程中的一项任务</td>
</tr>
<tr>
<td>binder_transcation</td>
<td>描述一次事务的相关信息</td>
</tr>
<tr>
<td>binder_deferred_state</td>
<td>藐视延迟任务</td>
</tr>
<tr>
<td>binder_ref_death</td>
<td>描述binder实体的死亡信息</td>
</tr>
<tr>
<td>binder_transcation_log</td>
<td>debugfs 日志</td>
</tr>
<tr>
<td>binder_transcation_log_entry</td>
<td>debugfs 日志条目</td>
</tr>
</tbody>
</table>
<h2 id="binder协议"><a href="#binder协议" class="headerlink" title="binder协议"></a>binder协议</h2><p>Binder协议 可以分为 <strong>控制协议</strong>和<strong>驱动协议</strong>两部分。</p>
<h3 id="1-控制协议"><a href="#1-控制协议" class="headerlink" title="1.控制协议"></a>1.控制协议</h3><p><strong>控制协议</strong>是进程(client 或server端)通过系统调用（syscall）直接操作binder设备文件，使用<code>ioctl(&#39;dev/binder&#39;)</code>控制binder驱动的协议，该协议包含以下几种命令</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>含义</th>
<th>参数</th>
</tr>
</thead>
<tbody>
<tr>
<td>BINDER_WRITE_READ</td>
<td>该命令想binder写入或者读出数据，参数分为两段，写和度部分，如果write_size不为零，就先将write_buffer中的数据写入binder； 如果read_size不为零，就先从binder中取出数据，写入read_buffer中。 write_consumed和read_consumed 表示操作完成时驱动实际写入和读出的数据个数。</td>
<td>struct binder_wirte_read{ Singned long write_size;Signed long write_consumed;unsigend long write_buffer;signed long read_size;signed long read_consumed;Unsigned long read_buffer}</td>
</tr>
<tr>
<td>BINDER_SET_MAX_THREADS</td>
<td>告知binder驱动接收方(server端)，线程池中最大的线程数。（详见下文 驱动线程管理）</td>
<td>int max_threads</td>
</tr>
<tr>
<td>BINDER_SET_CONEXT_MGR</td>
<td>将当前进程注册为smg，系统同时只可以出现一个smg，只要当前smg没有调用close关闭binder驱动，就不可能有别的进程可以成为smg</td>
<td></td>
</tr>
<tr>
<td>BINDER_THREAD_EXIT</td>
<td>通知binder驱动当前线程退出了，binder会为所有参与binder通信的线程（包括server端线程池中的线程以及client端发出请求的线程）建立相应的数据结构，这些线程在退出时必须显示通知binder释放相应的数据。详见下文 binder驱动的线程控制</td>
</tr>
</tbody>
</table>
<h3 id="2-驱动协议"><a href="#2-驱动协议" class="headerlink" title="2. 驱动协议"></a>2. 驱动协议</h3><p>驱动协议根据具体使用过程，又分为<strong>发送</strong>和<strong>返回</strong>协议。<br><strong>发送协议</strong> 定义在<code>binder.c</code> 中的<br> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> binder_driver_command_protocol</span><br></pre></td></tr></table></figure></p>
<p>，<strong>返回协议 </strong> 定义在<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> binder_driver_return_protocol</span><br></pre></td></tr></table></figure></p>
<p> 根据协议不同，存放的位置也不相同。<br>驱动协议都是封装在控制协议   <code>BINDER_WRITE_READ</code> 命令参数 <code>binder_wirte_read</code> 结构体中，根据发送和返回类型，分别存放在 <code>write_buffer</code>和 <code>read_buffer</code>域所指向的内存空间中。<br><code>binder_write_read</code>结构体的数据结构见下图：<br><img src="/media/15280146752888.jpg" alt=""></p>
<p>它们的数据格式都是命令 + 数据 的格式，多条命令可以连续存放。数据紧接着放在命令的后面，根据命令不同，执行的操作也不同。</p>
<h4 id="发送协议："><a href="#发送协议：" class="headerlink" title="发送协议："></a>发送协议：</h4><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
<th>参数</th>
</tr>
</thead>
<tbody>
<tr>
<td>BC_TRANSCATION</td>
<td>binder事务，client对server的请求</td>
<td>binder_transction_data</td>
</tr>
<tr>
<td>BC_REPLAY</td>
<td>事务的回答，server对client的回复</td>
<td>Binder_transctin_data</td>
</tr>
<tr>
<td>BC_FREE_BUFFER</td>
<td>通知驱动释放buffer</td>
<td>Binder_uinptr_t</td>
</tr>
<tr>
<td>BC_ACQUIRE</td>
<td>强引用计数+1</td>
<td>_u32</td>
</tr>
<tr>
<td>BC_RELEASE</td>
<td>强引用计数-1</td>
<td>_u32</td>
</tr>
<tr>
<td>BC_INCREFS</td>
<td>弱引用计数+1</td>
<td>_u32</td>
</tr>
<tr>
<td>BC_DECREFS</td>
<td>弱引用计数-1</td>
<td>_u32</td>
</tr>
<tr>
<td>BC_ACQUIRE_DODE</td>
<td>acquire指令的回复</td>
<td>Binder_ptr_cookie</td>
</tr>
<tr>
<td>BC_INCREFS_DONE</td>
<td>increfs指令的回复</td>
<td>Binder_prt_cookie</td>
</tr>
<tr>
<td>BC_ENTER_LOOPER</td>
<td>通知驱动主线程ready</td>
<td>Void</td>
</tr>
<tr>
<td>BC_REGISTER_LOOPER</td>
<td>通知驱动子线程ready</td>
<td>Void</td>
</tr>
<tr>
<td>BC_EXIT_LOOPER</td>
<td>通知驱动线程已退出</td>
<td>Void</td>
</tr>
<tr>
<td>BC_REQUEST_DEATH_NOTIFICATION</td>
<td>请求接受死亡通知</td>
<td>Binder_handle_cookie</td>
</tr>
<tr>
<td>BC_CLEAR_DEATH_NOTIFICATION</td>
<td>去除接受死亡通知</td>
<td>Binder_handle_cookie</td>
</tr>
<tr>
<td>BC_DEAD_BINDER_DONE</td>
<td>已经处理完死亡通知</td>
<td>Binder_uinptr_t</td>
</tr>
<tr>
<td>BC_ATTEMPT_ACQUIRE</td>
<td>暂未实现</td>
<td>-</td>
</tr>
<tr>
<td>BC_ACQUIRE_RESULT</td>
<td>暂为实现</td>
<td>-</td>
</tr>
</tbody>
</table>
<h4 id="返回协议："><a href="#返回协议：" class="headerlink" title="返回协议："></a>返回协议：</h4><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
<th>参数</th>
</tr>
</thead>
<tbody>
<tr>
<td>BR_OK</td>
<td>操作完成</td>
<td>void</td>
</tr>
<tr>
<td>BR_NOOP</td>
<td>操作完成</td>
<td>void</td>
</tr>
<tr>
<td>BR_ERROR</td>
<td>发生错误</td>
<td>_s32</td>
</tr>
<tr>
<td>BR_TRANSCATION</td>
<td>进程收到一次binder请求 （server端）</td>
<td>binder_transcation_data</td>
</tr>
<tr>
<td>BR_REPLAY</td>
<td>进程收到binder请求的回复（client）</td>
<td>binder_transtaction_data</td>
</tr>
<tr>
<td>BR_TRANSCATION_COMPLETED</td>
<td>驱动对于接收请求的确认回复</td>
<td>void</td>
</tr>
<tr>
<td>BR_FAILED_REPLAY</td>
<td>告知发送方 通信目标不存在</td>
<td>void</td>
</tr>
<tr>
<td>BR_SPAWN_LOOPER</td>
<td>通server端创建一个新的进程</td>
<td>void</td>
</tr>
<tr>
<td>BR_ACQUIRE</td>
<td>强用用计数+1</td>
<td>Binder_prt_cookie</td>
</tr>
<tr>
<td>BR_RELEASE</td>
<td>强引用计数-1</td>
<td>Binder_prt_cookie</td>
</tr>
<tr>
<td>BR_INCREFS</td>
<td>弱引用计数+1</td>
<td>Binder_prt_cookie</td>
</tr>
<tr>
<td>BR_DECREFS</td>
<td>弱引用计数-1</td>
<td>Binder_prt_cookie</td>
</tr>
<tr>
<td>BR_DEAD_BINDER</td>
<td>发送死亡通知</td>
<td>binder_uintptr_t</td>
</tr>
<tr>
<td>BR_CLEAR_DEATH_NOTIFICATION_DONE</td>
<td>清除死亡通知完成</td>
<td>binder_uintptr_t</td>
</tr>
<tr>
<td>BR_DEAD_REPLAY</td>
<td>改制发送方对方已死亡</td>
<td>void</td>
</tr>
<tr>
<td>BR_ATTEMPT_ACQUIRE</td>
<td>暂未实现</td>
<td>-</td>
</tr>
<tr>
<td>BR_ACQUIRE_RESULT</td>
<td>暂为实现</td>
<td>-</td>
</tr>
<tr>
<td>BR_FINISHED</td>
<td>暂未实现</td>
<td>-</td>
</tr>
</tbody>
</table>
<h4 id="binder-请求的过程"><a href="#binder-请求的过程" class="headerlink" title="binder 请求的过程"></a>binder 请求的过程</h4><p>见下图：</p>
<p><img src="/media/15280173877321.jpg" alt=""></p>
<p>通过上面的Binder协议的说明中我们看到，Binder协议的通信过程中，不仅仅是发送请求和接受数据这些命令。同时包括了对于引用计数的管理和对于死亡通知的管理（告知一方，通讯的另外一方已经死亡）等功能。</p>
<p>这些功能的通信过程和上面这幅图是类似的：一方发送<code>BC_XXX</code>，然后由驱动控制通信过程，接着发送对应的<code>BR_XXX</code>命令给通信的另外一方。因为这种相似性，对于这些内容就不再赘述了。</p>
<h3 id="由驱动角度理解-Binder通讯建立的过程"><a href="#由驱动角度理解-Binder通讯建立的过程" class="headerlink" title="由驱动角度理解 Binder通讯建立的过程"></a>由驱动角度理解 Binder通讯建立的过程</h3><h4 id="1-打开驱动（open-“dev-binder”-）"><a href="#1-打开驱动（open-“dev-binder”-）" class="headerlink" title="1 打开驱动（open(“dev/binder”)）"></a>1 打开驱动（open(“dev/binder”)）</h4><p>任何进程在使用Binder之前，都需要先通过<code>open(&quot;/dev/binder&quot;)</code>打开Binder设备。上文已经提到，用户空间的<code>open</code>系统调用对应了驱动中的<code>binder_open</code>函数。在这个函数，Binder驱动会为调用的进程做一些初始化工作。<code>binder_open</code>函数代码如下所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_open</span><span class="params">(struct inode *nodp, struct file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span>;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 创建进程对应的binder_proc对象 </span></span><br><span class="line">	proc = kzalloc(<span class="keyword">sizeof</span>(*proc), GFP_KERNEL); </span><br><span class="line">	<span class="keyword">if</span> (proc == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	get_task_struct(current);</span><br><span class="line">	proc-&gt;tsk = current;</span><br><span class="line">	<span class="comment">// 初始化binder_proc</span></span><br><span class="line">	INIT_LIST_HEAD(&amp;proc-&gt;todo);</span><br><span class="line">	init_waitqueue_head(&amp;proc-&gt;wait);</span><br><span class="line">	proc-&gt;default_priority = task_nice(current);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 锁保护</span></span><br><span class="line">	binder_lock(__func__);</span><br><span class="line"></span><br><span class="line">	binder_stats_created(BINDER_STAT_PROC);</span><br><span class="line">	<span class="comment">// 添加到全局列表binder_procs中</span></span><br><span class="line">	hlist_add_head(&amp;proc-&gt;proc_node, &amp;binder_procs);</span><br><span class="line">	proc-&gt;pid = current-&gt;group_leader-&gt;pid;</span><br><span class="line">	INIT_LIST_HEAD(&amp;proc-&gt;delivered_death);</span><br><span class="line">	filp-&gt;private_data = proc;</span><br><span class="line"></span><br><span class="line">	binder_unlock(__func__);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在打开binder驱动时，<code>binder_procs</code>会将所有打开binder驱动的进程加入到该列表中，上文中提到binder中的几个主要结构体，其实都是通过<code>binder_procs</code>结构体链接在一起的。</p>
<p><img src="/media/15280179417192.jpg" alt=""></p>
<h4 id="2-创建内存空间并实现用户空间-内核空间的映射（mmap）"><a href="#2-创建内存空间并实现用户空间-内核空间的映射（mmap）" class="headerlink" title="2. 创建内存空间并实现用户空间 内核空间的映射（mmap）"></a>2. 创建内存空间并实现用户空间 内核空间的映射（mmap）</h4><p>打开binder驱动之后，进程会通过<code>mmap()</code>方法进行内存空间的映射。 </p>
<p>上文描述过，<code>mmap()</code>对应的<code>binder_mmap()</code>函数，它会先申请一份物理内存，默认<code>PAGE_SIZE</code> 是4k，然后会<strong>同时在 用户空间和 内核空间</strong>映射该物理内存。当client 发送数据给server的时候，只需要将client端的数据，拷贝到server端所指向的 内核中的地址即可，因为server的用户空间和binder对应的内核空间映射的是同一份物理内存，当server取数据的时候，就无需再从内科中拷贝了，server可以直接使用。</p>
<p><img src="/media/15280184528253.jpg" alt=""></p>
<p>这幅图的说明如下：</p>
<p>Server在启动之后，对<code>/dev/binder</code>设备调用<code>mmap</code><br>内核中的<code>binder_mmap</code>函数进行对应的处理：申请一块物理内存，然后在用户空间和内核空间同时进行映射</p>
<p>Client通过<code>BINDER_WRITE_READ</code>命令发送请求，这个请求将先到驱动中，同时需要将数据从<code>Client</code>进程的用户空间拷贝到内核空间<br>驱动通过<code>BR_TRANSACTION</code>通知Server有人发出请求，Server进行处理。由于这块内存也在用户空间进行了映射，因此Server进程的代码可以直接访问</p>
<h4 id="3-内存管理（非重点）"><a href="#3-内存管理（非重点）" class="headerlink" title="3. 内存管理（非重点）"></a>3. 内存管理（非重点）</h4><p>上文中，我们看到<code>binder_mmap</code>的时候，会申请一个<code>PAGE_SIZE</code>通常是4K的内存。而实际使用过程中，一个<code>PAGE_SIZE</code>的大小通常是不够的。</p>
<p>在驱动中，会根据实际的使用情况进行内存的分配。有内存的分配，当然也需要内存的释放。这里我们就来看看Binder驱动中是如何进行内存的管理的。</p>
<p>首先，我们还是从一次IPC请求说起。</p>
<p>当一个Client想要对Server发出请求时，它首先将请求发送到Binder设备上，由Binder驱动根据请求的信息找到对应的目标节点，然后将请求数据传递过去。</p>
<p>进程通过ioctl系统调用来发出请求：<code>ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr)</code></p>
<p>PS：这行代码来自于Framework层的<code>IPCThreadState</code>类。在后文中，我们将看到，<code>IPCThreadState</code>类专门负责与驱动进行通信。</p>
<p>这里的<code>mProcess-&gt;mDriverFD</code>对应了打开Binder设备时的<code>fd</code>。<code>BINDER_WRITE_READ</code>对应了具体要做的操作码，这个操作码将由Binder驱动解析。<code>bwr</code>存储了请求数据，其类型是<code>binder_write_read</code>。</p>
<p><code>binder_write_read</code>其实是一个相对外层的数据结构，其内部会包含一个<code>binder_transaction_data</code>结构的数据。<code>binder_transaction_data</code>包含了发出请求者的标识，请求的目标对象以及请求所需要的参数。它们的关系如下图所示：</p>
<p><img src="/media/15280191293122.jpg" alt=""></p>
<p><code>binder_ioctl</code>函数对应了<code>ioctl</code>系统调用的处理。这个函数的逻辑比较简单，就是根据<code>ioctl</code>的命令来确定进一步处理的逻辑，具体如下:</p>
<p>如果命令是<code>BINDER_WRITE_READ</code>，并且<br>如果 <code>bwr.write_size &gt; 0</code>，则调用<code>binder_thread_write</code><br>该方法用于处理Binder协议中的请求码。当<code>binder_buffer</code>存在数据，binder线程的写操作循环执行。对于请求码为<code>BC_TRANSACTION</code>或<code>BC_REPLY</code>时，会执行<code>binder_transaction</code>()方法，这是最为频繁的操作。 对于其他命令则不同。</p>
<p>如果 <code>bwr.read_size &gt; 0</code>，则调用<code>binder_thread_read</code>，该方法用以处理响应过程，根据不同的<code>binder_work-&gt;type</code>以及不同状态，生成相应的响应码。</p>
<p>如果命令是<code>BINDER_SET_MAX_THREADS</code>，则设置进程的<code>max_threads</code>，即进程支持的最大线程数<br>如果命令是<code>BINDER_SET_CONTEXT_MGR</code>，则设置当前进程为<code>ServiceManager</code>，见下文<br>如果命令是<code>BINDER_THREAD_EXIT</code>，则调用<code>binder_free_thread</code>，释放<code>binder_thread</code><br>如果命令是<code>BINDER_VERSION</code>，则返回当前的Binder版本号<br>这其中，最关键的就是<code>binder_thread_write</code>方法。当Client请求Server的时候，便会发送一个<code>BINDER_WRITE_READ</code>命令，同时框架会将将实际的数据包装好。此时，<code>binder_transaction_data</code>中的code将是<code>BC_TRANSACTION</code>，由此便会调用到<code>binder_transaction</code>方法，这个方法是对一次Binder事务的处理，这其中会调用<code>binder_alloc_buf</code>函数为此次事务申请一个缓存。<br>调用关系见下图<br><img src="/media/15280210111665.jpg" alt=""></p>
<p><code>binder_update_page_range</code>这个函数在上文中，我们已经看到过了。其作用就是：进行内存分配并且完成内存的映射。而<code>binder_alloc_buf</code>函数，正如其名称那样的：完成缓存的分配。</p>
<p>在驱动中，通过<code>binder_buffer</code>结构体描述缓存。一次Binder事务就会对应一个<code>binder_buffer</code>，<br>进程在mmap时，会设定支持的总缓存大小的上限。而进程每当收到<code>BC_TRANSACTION</code>，就会判断已使用缓存加本次申请的和有没有超过上限。如果没有，就考虑进行内存的分配。</p>
<p>进程的空闲缓存记录在<code>binder_proc</code>的<code>free_buffers</code>中，这是一个以红黑树形式存储的结构。每次尝试分配缓存的时候，会从这里面按大小顺序进行查找，找到最接近需要的一块缓存。找到之后，还要对binder_proc的字段进行更新。</p>
<p><code>BC_FREE_BUFFER</code>命令是通知驱动进行内存的释放，<code>binder_free_buf</code>函数是真正实现的逻辑，这个函数与<code>binder_alloc_buf</code>是刚好对应的。在这个函数中，所做的事情包括：</p>
<ul>
<li>重新计算进程的空闲缓存大小</li>
<li>通过<code>binder_update_page_range</code>释放内存</li>
<li>更新<code>binder_proc</code>的<code>buffers</code>，<code>free_buffers</code>，<code>allocated_buffers</code>字段</li>
</ul>
<h4 id="4-通讯过程"><a href="#4-通讯过程" class="headerlink" title="4 通讯过程"></a>4 通讯过程</h4><p><code>BINDER_COMMAND_PROTOCOL</code>：binder请求码，以”BC_“开头，简称BC码，用于从IPC层传递到Binder Driver层；<br><code>BINDER_RETURN_PROTOCOL</code> ：binder响应码，以”BR_“开头，简称BR码，用于从Binder Driver层传递到IPC层；</p>
<p>一次完整的binder通讯流程：<br><img src="/media/15280207692595.jpg" alt=""><strong>Binder IPC通信至少是两个进程的交互</strong>：</p>
<ul>
<li>client进程执行<code>binder_thread_write</code>，<code>thread_write</code>根据<code>BC_XXX</code>命令，生成相应的<code>binder_work</code>；</li>
<li>server进程执行<code>binder_thread_read</code>，<code>thread_read</code>根据<code>binder_work.type</code>类型，生成<code>BR_XXX</code>，发送到用户空间处理。<br><img src="/media/15280214808773.jpg" alt=""></li>
</ul>
<p><code>binder_work.type</code> ：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BINDER_WORK_TRANSACTION <span class="comment">//最常见类型</span></span><br><span class="line">BINDER_WORK_TRANSACTION_COMPLETE</span><br><span class="line">BINDER_WORK_NODE</span><br><span class="line">BINDER_WORK_DEAD_BINDER</span><br><span class="line">BINDER_WORK_DEAD_BINDER_AND_CLEAR</span><br><span class="line">BINDER_WORK_CLEAR_DEATH_NOTIFICATION</span><br></pre></td></tr></table></figure></p>
<p>可以知道，上述通信流程涉及到三种状态码的转换：<br><code>BR_CODE</code> <code>BC_CODE</code>  <code>BW_CODE</code>,<br>他们之间的转换图如下：</p>
<p><img src="/media/15280221155795.jpg" alt=""></p>
<p><img src="/media/15280221222039.jpg" alt=""></p>
<p>图解：(以<code>BC_TRANSACTION</code>为例)</p>
<p>发起端进程：<code>binder_transaction</code>()过程将<code>BC_TRANSACTION</code>转换为<code>BW_TRANSACTION</code>；<br>接收端进程：<code>binder_thread_read</code>()过程，将<code>BW_TRANSACTION</code>转换为<code>BR_TRANSACTION</code>;<br>接收端进程：<code>IPC.execute()</code>过程，处理<code>BR_TRANSACTION</code>命令</p>
<p>以gityuan的一张图来总结binder通信的全过程</p>
<p><img src="/media/15280227943358.jpg" alt=""></p>
<h4 id="5-通讯过程中-binder实体的传递"><a href="#5-通讯过程中-binder实体的传递" class="headerlink" title="5 通讯过程中 binder实体的传递"></a>5 通讯过程中 binder实体的传递</h4><p>Binder机制淡化了进程的边界，使得跨越进程也能够调用到指定服务的方法，其原因是因为Binder机制在底层处理了在进程间的“对象”传递。</p>
<p>在Binder驱动中，并不是真的将对象在进程间来回序列化，而是通过特定的标识来进行对象的传递。Binder驱动中，通过<code>flat_binder_object</code>来描述需要跨越进程传递的对象。其定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">flat_binder_object</span> &#123;</span></span><br><span class="line">	__u32		type;</span><br><span class="line">	__u32		flags;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="keyword">binder_uintptr_t</span>	binder; <span class="comment">/* local object */</span></span><br><span class="line">		__u32			handle;	<span class="comment">/* remote object */</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">binder_uintptr_t</span>	cookie;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这其中，type有如下5种类型。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">	BINDER_TYPE_BINDER	= B_PACK_CHARS(<span class="string">'s'</span>, <span class="string">'b'</span>, <span class="string">'*'</span>, B_TYPE_LARGE),</span><br><span class="line">	BINDER_TYPE_WEAK_BINDER	= B_PACK_CHARS(<span class="string">'w'</span>, <span class="string">'b'</span>, <span class="string">'*'</span>, B_TYPE_LARGE),</span><br><span class="line">	BINDER_TYPE_HANDLE	= B_PACK_CHARS(<span class="string">'s'</span>, <span class="string">'h'</span>, <span class="string">'*'</span>, B_TYPE_LARGE),</span><br><span class="line">	BINDER_TYPE_WEAK_HANDLE	= B_PACK_CHARS(<span class="string">'w'</span>, <span class="string">'h'</span>, <span class="string">'*'</span>, B_TYPE_LARGE),</span><br><span class="line">	BINDER_TYPE_FD		= B_PACK_CHARS(<span class="string">'f'</span>, <span class="string">'d'</span>, <span class="string">'*'</span>, B_TYPE_LARGE),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>当对象传递到Binder驱动中的时候，由驱动来进行翻译和解释，然后传递到接收的进程。</p>
<p>例如当Server把Binder实体传递给Client时，在发送数据流中，<code>flat_binder_object</code>中的type是<code>BINDER_TYPE_BINDER</code>，同时binder字段指向Server进程用户空间地址。但这个地址对于Client进程是没有意义的（Linux中，每个进程的地址空间是互相隔离的），驱动必须对数据流中的<code>flat_binder_object</code>做相应的翻译：将type该成<code>BINDER_TYPE_HANDLE</code>；为这个Binder在接收进程中创建位于内核中的引用并将引用号填入handle中。对于发生数据流中引用类型的Binder也要做同样转换。经过处理后接收进程从数据流中取得的Binder引用才是有效的，才可以将其填入数据包<code>binder_transaction_data</code>的<code>target.handle</code>域，向Binder实体发送请求。<br><img src="/media/15299006076637.jpg" alt=""><br>图 binder对象索引和映射关系<br><code>flat_binder_object</code>就是进程间传递的<code>Binder</code>对象，每一个<code>flat_binder_object</code>对象内核都有一个唯一的<code>binder_node</code>对象，这个对象挂接在<code>binder_proc</code>的一颗二叉树上。对于一个<code>binder_node</code>对象，内核也会有一个唯一的<code>binder_ref</code>对象，可以这么理解，<code>binder_ref</code>的<code>desc</code>唯一的映射到<code>binder_node</code>的<code>ptr</code>和<code>cookie</code>上，同时也唯一的映射到了<code>flat_binder_object</code>的<code>handler</code>上。而<code>binder_ref</code>又按照<code>node</code>和<code>desc</code>两种方式映射到<code>binder_proc</code>对象上，也就是可以通过<code>binder_node</code>对象或者<code>desc</code>两种方式在<code>binder_proc</code>上查找到<code>binder_ref</code>或<code>binder_node</code>。所以，对于<code>flat_binder_object</code>对象来说，它的<code>binder+cookie</code>和<code>handler</code>指向了同一个<code>binder_node</code>对象上，即同一个<code>binder</code>对象。</p>
<p>由于每个请求和请求的返回都会经历内核的翻译，因此这个过程从进程的角度来看是完全透明的。进程完全不用感知这个过程，就好像对象真的在进程间来回传递一样。</p>
<h4 id="6-驱动层的线程管理"><a href="#6-驱动层的线程管理" class="headerlink" title="6 驱动层的线程管理"></a>6 驱动层的线程管理</h4><p>上文多次提到，Binder本身是C/S架构。由Server提供服务，被Client使用。既然是C/S架构，就可能存在多个Client会同时访问Server的情况。 在这种情况下，如果Server只有一个线程处理响应，就会导致客户端的请求可能需要排队而导致响应过慢的现象发生。解决这个问题的方法就是引入多线程。</p>
<p>Binder机制的设计从最底层–驱动层，就考虑到了对于多线程的支持。具体内容如下：</p>
<ul>
<li>使用Binder的进程在启动之后，通过<code>BINDER_SET_MAX_THREADS</code>告知驱动其支持的最大线程数量</li>
<li>驱动会对线程进行管理。在<code>binder_proc</code>结构中，这些字段记录了进程中线程的信息：<code>max_threads，requested_threads，requested_threads_started，ready_threads</code></li>
<li><code>binder_thread</code>结构对应了Binder进程中的线程</li>
<li>驱动通过<code>BR_SPAWN_LOOPER</code>命令告知进程需要创建一个新的线程</li>
<li>进程通过<code>BC_ENTER_LOOPER</code>命令告知驱动其主线程已经ready</li>
<li>进程通过<code>BC_REGISTER_LOOPER</code>命令告知驱动其子线程（非主线程）已经ready</li>
<li>进程通过<code>BC_EXIT_LOOPER</code>命令告知驱动其线程将要退出</li>
<li>在线程退出之后，通过<code>BINDER_THREAD_EXIT</code>告知Binder驱动。驱动将对应的<code>binder_thread</code>对象销毁</li>
</ul>

    </article>
    <!-- license  -->
    
        <div class="license-wrapper">
            <p>Author：<a href="http://wenyiqingnian.xyz">QuincyJiang</a>
            <p>原文链接：<a href="http://wenyiqingnian.xyz/2018/06/02/从驱动角度理解binder/">http://wenyiqingnian.xyz/2018/06/02/从驱动角度理解binder/</a>
            <p>发表日期：<a href="http://wenyiqingnian.xyz/2018/06/02/从驱动角度理解binder/">June 2nd 2018, 7:00:50 pm</a>
            <p>更新日期：<a href="http://wenyiqingnian.xyz/2018/06/02/从驱动角度理解binder/">June 25th 2018, 12:26:04 pm</a>
            <p>版权声明：本文采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可</p>
        </div>
    
    <!-- paginator  -->
    <ul class="post-paginator">
        <li class="next">
            
                <div class="nextSlogan">Next Post</div>
                <a href= "/2018/06/02/《现代艺术150年》未影印作品1/" title= "《现代艺术150年》未影印作品1">
                    <div class="nextTitle">《现代艺术150年》未影印作品1</div>
                </a>
            
        </li>
        <li class="previous">
            
                <div class="prevSlogan">Previous Post</div>
                <a href= "/2018/06/02/理解Liunx的FD与Inode/" title= "理解Linux的FD与Inode">
                    <div class="prevTitle">理解Linux的FD与Inode</div>
                </a>
            
        </li>
    </ul>
    <!-- 评论插件 -->
    <!-- 来必力City版安装代码 -->

    <div id="lv-container" data-id="city" data-uid= MTAyMC8zNjQwMS8xMjkzNg==>
        <script type="text/javascript">
            (function (d, s) {
                var j, e = d.getElementsByTagName(s)[0];
                if (typeof LivereTower === 'function') { return; }
                j = d.createElement(s);
                j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
                j.async = true;

                e.parentNode.insertBefore(j, e);
            })(document, 'script');
        </script>
        <noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
    </div>

<!-- City版安装代码已完成 -->
    
    
    <!-- partial('_partial/comment/changyan') -->
    <!--PC版-->


    
    

    <!-- 评论 -->
</main>
            <!-- profile -->
            
        </div>
        <footer class="footer footer-unloaded">
    <!-- social  -->
    
    <div class="social">
        
    
        
            
                <a href="mailto:1083873272@qq.com" class="iconfont-archer email" title=email ></a>
            
        
    
        
            
                <a href="//github.com/QuincyJiang" class="iconfont-archer github" target="_blank" title=github></a>
            
        
    
        
            
                <span class="iconfont-archer wechat" title=wechat>
                  
                  <img class="profile-qr" src="/assets/wechat.jpeg" />
                </span>
            
        
    
        
    
        
    
        
            
                <a href="https://weibo.com/2425393311/" class="iconfont-archer weibo" target="_blank" title=weibo></a>
            
        
    
        
    
        
    
        
    
        
    
        
            
                <a href="http://aquencyua11.lofter.com/" class="iconfont-archer instagram" target="_blank" title=instagram></a>
            
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    

    </div>
    
    <!-- powered by Hexo  -->
    <div class="copyright">
        <span id="hexo-power">Powered by <a href="https://hexo.io/" target="_blank">Hexo</a></span><span class="iconfont-archer power">&#xe635;</span><span id="theme-info">theme <a href="https://github.com/fi3ework/hexo-theme-archer" target="_blank">Archer</a></span>
    </div>
    <!-- 不蒜子  -->
    
    <div class="busuanzi-container">
    
     
    <span id="busuanzi_container_site_pv">PV: <span id="busuanzi_value_site_pv"></span> :)</span>
    
    </div>
    
</footer>
    </div>
    <!-- toc -->
    
    <div class="toc-wrapper" style=
    







top:50vh;

    >
        <div class="toc-catalog">
            <span class="iconfont-archer catalog-icon">&#xe613;</span><span>CATALOG</span>
        </div>
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Binder驱动的定义"><span class="toc-number">1.</span> <span class="toc-text">Binder驱动的定义</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#注册Binder"><span class="toc-number">1.1.</span> <span class="toc-text">注册Binder</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Binder驱动中的结构体"><span class="toc-number">1.2.</span> <span class="toc-text">Binder驱动中的结构体</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#binder协议"><span class="toc-number">1.3.</span> <span class="toc-text">binder协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-控制协议"><span class="toc-number">1.3.1.</span> <span class="toc-text">1.控制协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-驱动协议"><span class="toc-number">1.3.2.</span> <span class="toc-text">2. 驱动协议</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#发送协议："><span class="toc-number">1.3.2.1.</span> <span class="toc-text">发送协议：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#返回协议："><span class="toc-number">1.3.2.2.</span> <span class="toc-text">返回协议：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#binder-请求的过程"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">binder 请求的过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#由驱动角度理解-Binder通讯建立的过程"><span class="toc-number">1.3.3.</span> <span class="toc-text">由驱动角度理解 Binder通讯建立的过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-打开驱动（open-“dev-binder”-）"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">1 打开驱动（open(“dev/binder”)）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-创建内存空间并实现用户空间-内核空间的映射（mmap）"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">2. 创建内存空间并实现用户空间 内核空间的映射（mmap）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-内存管理（非重点）"><span class="toc-number">1.3.3.3.</span> <span class="toc-text">3. 内存管理（非重点）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-通讯过程"><span class="toc-number">1.3.3.4.</span> <span class="toc-text">4 通讯过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-通讯过程中-binder实体的传递"><span class="toc-number">1.3.3.5.</span> <span class="toc-text">5 通讯过程中 binder实体的传递</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-驱动层的线程管理"><span class="toc-number">1.3.3.6.</span> <span class="toc-text">6 驱动层的线程管理</span></a></li></ol></li></ol></li></ol></li></ol>
    </div>
    
    <div class="back-top iconfont-archer">&#xe639;</div>
    <div class="sidebar sidebar-hide">
    <ul class="sidebar-tabs sidebar-tabs-active-0">
        <li class="sidebar-tab-archives"><span class="iconfont-archer">&#xe67d;</span><span class="tab-name">Archive</span></li>
        <li class="sidebar-tab-tags"><span class="iconfont-archer">&#xe61b;</span><span class="tab-name">Tag</span></li>
        <li class="sidebar-tab-categories"><span class="iconfont-archer">&#xe666;</span><span class="tab-name">Cate</span></li>
    </ul>
    <div class="sidebar-content sidebar-content-show-archive">
          <div class="sidebar-panel-archives">
    <!-- 在ejs中将archive按照时间排序 -->
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <div class="total-and-search">
        <div class="total-archive">
        Total : 36
        </div>
        <!-- search  -->
        
    </div>
    
    <div class="post-archive">
    
    
    
    
    <div class="archive-year"> 2019 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/21</span><a class="archive-post-title" href= "/2019/10/21/为何fork两次可以避免僵尸进程/" >为何fork两次可以避免僵尸进程</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/14</span><a class="archive-post-title" href= "/2019/01/14/mac 搭建Go开发环境/" >mac 搭建Go开发环境</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/08</span><a class="archive-post-title" href= "/2019/01/08/代码生成插件说明/" >代码生成插件说明</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2018 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/19</span><a class="archive-post-title" href= "/2018/11/19/深度学习课程笔记 第二周 优化算法/" >深度学习课程笔记 第二周 优化算法</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/15</span><a class="archive-post-title" href= "/2018/11/15/深度学习课程笔记 第一周 深度学习的实践层面/" >深度学习课程笔记 第一周 深度学习的实践层面</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/11</span><a class="archive-post-title" href= "/2018/11/11/机器学习算法的演进/" >机器学习算法的演进</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/21</span><a class="archive-post-title" href= "/2018/08/21/八月份学习计划/" >下个阶段的学习计划整理</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/16</span><a class="archive-post-title" href= "/2018/08/16/一些知识点总结/" >一些知识点总结</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/24</span><a class="archive-post-title" href= "/2018/06/24/从一次native端的IPC流程理解binder/" >从一次native端的IPC流程理解binder</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/16</span><a class="archive-post-title" href= "/2018/06/16/《现代艺术150年》未影印作品2/" >《现代艺术150年》未影印作品2</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/08</span><a class="archive-post-title" href= "/2018/06/08/深度学习1-反向传播/" >深度学习1-反向传播</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/02</span><a class="archive-post-title" href= "/2018/06/02/《现代艺术150年》未影印作品1/" >《现代艺术150年》未影印作品1</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/02</span><a class="archive-post-title" href= "/2018/06/02/从驱动角度理解binder/" >从驱动角度理解binder</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/02</span><a class="archive-post-title" href= "/2018/06/02/理解Liunx的FD与Inode/" >理解Linux的FD与Inode</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/30</span><a class="archive-post-title" href= "/2018/05/30/Docker入门/" >Docker入门</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/29</span><a class="archive-post-title" href= "/2018/05/29/Binder的设计架构/" >Binder的设计架构</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/23</span><a class="archive-post-title" href= "/2018/05/23/JAVA的垃圾回收策略（二）/" >JAVA的垃圾回收策略（二）</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/17</span><a class="archive-post-title" href= "/2018/05/17/JAVA的垃圾回收策略/" >JAVA的垃圾回收策略</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/14</span><a class="archive-post-title" href= "/2018/05/14/hexo+icarus/" >hexo+icarus</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/13</span><a class="archive-post-title" href= "/2018/05/13/六大设计模式/" >六大设计模式</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/10</span><a class="archive-post-title" href= "/2018/05/10/AnimatedVectorDrawable 总结/" >AnimatedVectorDrawable总结</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/12</span><a class="archive-post-title" href= "/2018/04/12/Rxjava2操作符/" >Rxjava2操作符</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/16</span><a class="archive-post-title" href= "/2018/03/16/Socket未释放导致的句柄泄露/" >socket未释放导致句柄泄露</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/13</span><a class="archive-post-title" href= "/2018/03/13/线程阻塞和中断的四种方式/" >线程阻塞和中断的四种方式</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2017 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/11</span><a class="archive-post-title" href= "/2017/12/11/MQTT相关/" >MQTT相关总结</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/11</span><a class="archive-post-title" href= "/2017/12/11/mac搭建PyQt5环境/" >mac搭建Pyqt5环境</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/12</span><a class="archive-post-title" href= "/2017/10/12/view 绘制机制/" >view 绘制机制</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/07</span><a class="archive-post-title" href= "/2017/09/07/Linux 用户空间 内核空间/" >linux用户控件、内和空间</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/16</span><a class="archive-post-title" href= "/2017/08/16/webrtc 音频/" >webrtc音频总结</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/18</span><a class="archive-post-title" href= "/2017/06/18/linux的地址映射/" >linux的地址映射</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/07</span><a class="archive-post-title" href= "/2017/05/07/MK语法规范/" >MK语法规范</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/11</span><a class="archive-post-title" href= "/2017/04/11/Binder 进程间通讯机制/" >Binder通讯机制</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/05</span><a class="archive-post-title" href= "/2017/04/05/编译系统环境初始化过程/" >编译系统环境初始化过程</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/15</span><a class="archive-post-title" href= "/2017/03/15/添加SE安全策略/" >添加SE安全策略</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2016 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/03</span><a class="archive-post-title" href= "/2016/08/03/抓包工具 - Fiddler（如何捕获Android数据包）/" >fiddler抓android数据包</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/04</span><a class="archive-post-title" href= "/2016/07/04/Linux vi命令使用方法/" >Linux vi用法</a>
        </li>
    
    </div>
  </div>
        <div class="sidebar-panel-tags">
    <div class="sidebar-tags-name">
    
        <span class="sidebar-tag-name" data-tags="句柄animation"><span class="iconfont-archer">&#xe606;</span>句柄animation</span>
    
        <span class="sidebar-tag-name" data-tags="AnimatedVectorDrawable"><span class="iconfont-archer">&#xe606;</span>AnimatedVectorDrawable</span>
    
        <span class="sidebar-tag-name" data-tags="android"><span class="iconfont-archer">&#xe606;</span>android</span>
    
        <span class="sidebar-tag-name" data-tags="Binder"><span class="iconfont-archer">&#xe606;</span>Binder</span>
    
        <span class="sidebar-tag-name" data-tags="java"><span class="iconfont-archer">&#xe606;</span>java</span>
    
        <span class="sidebar-tag-name" data-tags="垃圾回收"><span class="iconfont-archer">&#xe606;</span>垃圾回收</span>
    
        <span class="sidebar-tag-name" data-tags="docker"><span class="iconfont-archer">&#xe606;</span>docker</span>
    
        <span class="sidebar-tag-name" data-tags="容器"><span class="iconfont-archer">&#xe606;</span>容器</span>
    
        <span class="sidebar-tag-name" data-tags="linux命令"><span class="iconfont-archer">&#xe606;</span>linux命令</span>
    
        <span class="sidebar-tag-name" data-tags="linux"><span class="iconfont-archer">&#xe606;</span>linux</span>
    
        <span class="sidebar-tag-name" data-tags="mqtt"><span class="iconfont-archer">&#xe606;</span>mqtt</span>
    
        <span class="sidebar-tag-name" data-tags="句柄泄露"><span class="iconfont-archer">&#xe606;</span>句柄泄露</span>
    
        <span class="sidebar-tag-name" data-tags="bugs"><span class="iconfont-archer">&#xe606;</span>bugs</span>
    
        <span class="sidebar-tag-name" data-tags="编译"><span class="iconfont-archer">&#xe606;</span>编译</span>
    
        <span class="sidebar-tag-name" data-tags="mk"><span class="iconfont-archer">&#xe606;</span>mk</span>
    
        <span class="sidebar-tag-name" data-tags="后端技术"><span class="iconfont-archer">&#xe606;</span>后端技术</span>
    
        <span class="sidebar-tag-name" data-tags="go"><span class="iconfont-archer">&#xe606;</span>go</span>
    
        <span class="sidebar-tag-name" data-tags="开源框架"><span class="iconfont-archer">&#xe606;</span>开源框架</span>
    
        <span class="sidebar-tag-name" data-tags="rxjava2"><span class="iconfont-archer">&#xe606;</span>rxjava2</span>
    
        <span class="sidebar-tag-name" data-tags="python"><span class="iconfont-archer">&#xe606;</span>python</span>
    
        <span class="sidebar-tag-name" data-tags="qt"><span class="iconfont-archer">&#xe606;</span>qt</span>
    
        <span class="sidebar-tag-name" data-tags="hexo"><span class="iconfont-archer">&#xe606;</span>hexo</span>
    
        <span class="sidebar-tag-name" data-tags="webrtc"><span class="iconfont-archer">&#xe606;</span>webrtc</span>
    
        <span class="sidebar-tag-name" data-tags="现代艺术150年"><span class="iconfont-archer">&#xe606;</span>现代艺术150年</span>
    
        <span class="sidebar-tag-name" data-tags="备忘录"><span class="iconfont-archer">&#xe606;</span>备忘录</span>
    
        <span class="sidebar-tag-name" data-tags="音视频"><span class="iconfont-archer">&#xe606;</span>音视频</span>
    
        <span class="sidebar-tag-name" data-tags="学习计划"><span class="iconfont-archer">&#xe606;</span>学习计划</span>
    
        <span class="sidebar-tag-name" data-tags="抓包"><span class="iconfont-archer">&#xe606;</span>抓包</span>
    
        <span class="sidebar-tag-name" data-tags="设计模式"><span class="iconfont-archer">&#xe606;</span>设计模式</span>
    
        <span class="sidebar-tag-name" data-tags="plugins"><span class="iconfont-archer">&#xe606;</span>plugins</span>
    
        <span class="sidebar-tag-name" data-tags="机器学习"><span class="iconfont-archer">&#xe606;</span>机器学习</span>
    
        <span class="sidebar-tag-name" data-tags="Tensorflow"><span class="iconfont-archer">&#xe606;</span>Tensorflow</span>
    
        <span class="sidebar-tag-name" data-tags="多线程"><span class="iconfont-archer">&#xe606;</span>多线程</span>
    
        <span class="sidebar-tag-name" data-tags="SEAndroid"><span class="iconfont-archer">&#xe606;</span>SEAndroid</span>
    
        <span class="sidebar-tag-name" data-tags="aosp"><span class="iconfont-archer">&#xe606;</span>aosp</span>
    
    </div>
    <div class="iconfont-archer sidebar-tags-empty">&#xe678;</div>
    <div class="tag-load-fail" style="display: none; color: #ccc; font-size: 0.6rem;">
    缺失模块。<br/>
    1、请确保node版本大于6.2<br/>
    2、在博客根目录（注意不是archer根目录）执行以下命令：<br/>
    <span style="color: #f75357; font-size: 1rem; line-height: 2rem;">npm i hexo-generator-json-content --save</span><br/>
    3、在根目录_config.yml里添加配置：
    <pre style="color: #787878; font-size: 0.6rem;">
jsonContent:
  meta: false
  pages: false
  posts:
    title: true
    date: true
    path: true
    text: false
    raw: false
    content: false
    slug: false
    updated: false
    comments: false
    link: false
    permalink: false
    excerpt: false
    categories: true
    tags: true</pre>
    </div> 
    <div class="sidebar-tags-list"></div>
</div>
        <div class="sidebar-panel-categories">
    <div class="sidebar-categories-name">
    
        <span class="sidebar-category-name" data-categories="CoolUI"><span class="iconfont-archer">&#xe60a;</span>CoolUI</span>
    
        <span class="sidebar-category-name" data-categories="Android"><span class="iconfont-archer">&#xe60a;</span>Android</span>
    
        <span class="sidebar-category-name" data-categories="java基础"><span class="iconfont-archer">&#xe60a;</span>java基础</span>
    
        <span class="sidebar-category-name" data-categories="容器技术"><span class="iconfont-archer">&#xe60a;</span>容器技术</span>
    
        <span class="sidebar-category-name" data-categories="Linux"><span class="iconfont-archer">&#xe60a;</span>Linux</span>
    
        <span class="sidebar-category-name" data-categories="MQTT"><span class="iconfont-archer">&#xe60a;</span>MQTT</span>
    
        <span class="sidebar-category-name" data-categories="bug记录"><span class="iconfont-archer">&#xe60a;</span>bug记录</span>
    
        <span class="sidebar-category-name" data-categories="AOSP"><span class="iconfont-archer">&#xe60a;</span>AOSP</span>
    
        <span class="sidebar-category-name" data-categories="后端技术"><span class="iconfont-archer">&#xe60a;</span>后端技术</span>
    
        <span class="sidebar-category-name" data-categories="python"><span class="iconfont-archer">&#xe60a;</span>python</span>
    
        <span class="sidebar-category-name" data-categories="备忘录"><span class="iconfont-archer">&#xe60a;</span>备忘录</span>
    
        <span class="sidebar-category-name" data-categories="webrtc"><span class="iconfont-archer">&#xe60a;</span>webrtc</span>
    
        <span class="sidebar-category-name" data-categories="学习计划"><span class="iconfont-archer">&#xe60a;</span>学习计划</span>
    
        <span class="sidebar-category-name" data-categories="IDEA"><span class="iconfont-archer">&#xe60a;</span>IDEA</span>
    
        <span class="sidebar-category-name" data-categories="机器学习"><span class="iconfont-archer">&#xe60a;</span>机器学习</span>
    
    </div>
    <div class="iconfont-archer sidebar-categories-empty">&#xe678;</div>
    <div class="sidebar-categories-list"></div>
</div>
    </div>
</div> 
    <script>
    var siteMeta = {
        root: "/",
        author: "QuincyJiang"
    }
</script>
    <!-- CDN failover -->
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
    <script type="text/javascript">
        if (typeof window.$ === 'undefined')
        {
            console.warn('jquery load from jsdelivr failed, will load local script')
            document.write('<script src="/lib/jquery.min.js">\x3C/script>')
        }
    </script>
    <script src="/scripts/main.js"></script>
    <!-- algolia -->
    
    <!-- busuanzi  -->
    
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    <!-- CNZZ  -->
    
    </div>
    <!-- async load share.js -->
    
        <script src="/scripts/share.js" async></script>    
     
    </body>
</html>


