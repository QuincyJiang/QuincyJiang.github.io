<!DOCTYPE html>
<html lang="en">
    <!-- title -->




<!-- keywords -->




<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" >
    <meta name="author" content="QuincyJiang">
    <meta name="renderer" content="webkit">
    <meta name="copyright" content="QuincyJiang">
    
    <meta name="keywords" content="binder,android,江夏秋">
    
    <meta name="description" content="">
    <meta http-equiv="Cache-control" content="no-cache">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
    <title>从一次native端的IPC流程理解binder · 瘟疫青年</title>
    <style type="text/css">
    @font-face {
        font-family: 'Oswald-Regular';
        src: url("/font/Oswald-Regular.ttf");
    }

    body {
        margin: 0;
    }

    header,
    footer,
    .back-top,
    .sidebar,
    .container,
    .site-intro-meta,
    .toc-wrapper {
        display: none;
    }

    .site-intro {
        position: relative;
        z-index: 3;
        width: 100%;
        /* height: 50vh; */
        overflow: hidden;
    }

    .site-intro-placeholder {
        position: absolute;
        z-index: -2;
        top: 0;
        left: 0;
        width: calc(100% + 300px);
        height: 100%;
        background: repeating-linear-gradient(-45deg, #444 0, #444 80px, #333 80px, #333 160px);
        background-position: center center;
        transform: translate3d(-226px, 0, 0);
        animation: gradient-move 2.5s ease-out 0s infinite;
    }

    @keyframes gradient-move {
        0% {
            transform: translate3d(-226px, 0, 0);
        }
        100% {
            transform: translate3d(0, 0, 0);
        }
    }

</style>

    <link rel="preload" href= "/css/style.css?v=20180824" as="style" onload="this.onload=null;this.rel='stylesheet'" />
    <link rel="stylesheet" href= "/css/mobile.css?v=20180824" media="(max-width: 980px)">
    
    <link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'" />
    
    <!-- /*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
/* This file is meant as a standalone workflow for
- testing support for link[rel=preload]
- enabling async CSS loading in browsers that do not support rel=preload
- applying rel preload css once loaded, whether supported or not.
*/ -->
<script>
(function( w ){
	"use strict";
	// rel=preload support test
	if( !w.loadCSS ){
		w.loadCSS = function(){};
	}
	// define on the loadCSS obj
	var rp = loadCSS.relpreload = {};
	// rel=preload feature support test
	// runs once and returns a function for compat purposes
	rp.support = (function(){
		var ret;
		try {
			ret = w.document.createElement( "link" ).relList.supports( "preload" );
		} catch (e) {
			ret = false;
		}
		return function(){
			return ret;
		};
	})();

	// if preload isn't supported, get an asynchronous load by using a non-matching media attribute
	// then change that media back to its intended value on load
	rp.bindMediaToggle = function( link ){
		// remember existing media attr for ultimate state, or default to 'all'
		var finalMedia = link.media || "all";

		function enableStylesheet(){
			link.media = finalMedia;
		}

		// bind load handlers to enable media
		if( link.addEventListener ){
			link.addEventListener( "load", enableStylesheet );
		} else if( link.attachEvent ){
			link.attachEvent( "onload", enableStylesheet );
		}

		// Set rel and non-applicable media type to start an async request
		// note: timeout allows this to happen async to let rendering continue in IE
		setTimeout(function(){
			link.rel = "stylesheet";
			link.media = "only x";
		});
		// also enable media after 3 seconds,
		// which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
		setTimeout( enableStylesheet, 3000 );
	};

	// loop through link elements in DOM
	rp.poly = function(){
		// double check this to prevent external calls from running
		if( rp.support() ){
			return;
		}
		var links = w.document.getElementsByTagName( "link" );
		for( var i = 0; i < links.length; i++ ){
			var link = links[ i ];
			// qualify links to those with rel=preload and as=style attrs
			if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
				// prevent rerunning on link
				link.setAttribute( "data-loadcss", true );
				// bind listeners to toggle media back
				rp.bindMediaToggle( link );
			}
		}
	};

	// if unsupported, run the polyfill
	if( !rp.support() ){
		// run once at least
		rp.poly();

		// rerun poly on an interval until onload
		var run = w.setInterval( rp.poly, 500 );
		if( w.addEventListener ){
			w.addEventListener( "load", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		} else if( w.attachEvent ){
			w.attachEvent( "onload", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		}
	}


	// commonjs
	if( typeof exports !== "undefined" ){
		exports.loadCSS = loadCSS;
	}
	else {
		w.loadCSS = loadCSS;
	}
}( typeof global !== "undefined" ? global : this ) );
</script>

    <link rel="icon" href= "/images/logo.png" />
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js" as="script" />
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" as="script" />
    <link rel="preload" href="/scripts/main.js" as="script" />
    <link rel="preload" as="font" href="/font/Oswald-Regular.ttf" crossorigin>
    <link rel="preload" as="font" href="https://at.alicdn.com/t/font_327081_1dta1rlogw17zaor.woff" crossorigin>
    
    <!-- fancybox -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script>
    <!-- 百度统计  -->
    
    <!-- 谷歌统计  -->
    
</head>

    
        <body class="post-body">
    
    
<header class="header">

    <div class="read-progress"></div>
    <div class="header-sidebar-menu">&#xe775;</div>
    <!-- post页的toggle banner  -->
    
    <div class="banner">
            <div class="blog-title">
                <a href="/" >瘟疫青年</a>
            </div>
            <div class="post-title">
                <a href="#" class="post-name">从一次native端的IPC流程理解binder</a>
            </div>
    </div>
    
    <a class="home-link" href=/>瘟疫青年</a>
</header>
    <div class="wrapper">
        <div class="site-intro" style="







height:50vh;
">
    
    <!-- 主页  -->
    
    
    <!-- 404页  -->
            
    <div class="site-intro-placeholder"></div>
    <div class="site-intro-img" style="background-image: url(/intro/post-bg.jpg)"></div>
    <div class="site-intro-meta">
        <!-- 标题  -->
        <h1 class="intro-title">
            <!-- 主页  -->
            
            从一次native端的IPC流程理解binder
            <!-- 404 -->
            
        </h1>
        <!-- 副标题 -->
        <p class="intro-subtitle">
            <!-- 主页副标题  -->
            
            
            <!-- 404 -->
            
        </p>
        <!-- 文章页meta -->
        
            <div class="post-intros">
                <!-- 文章页标签  -->
                
                    <div class= post-intro-tags >
    
        <a class="post-tag" href="javascript:void(0);" data-tags = "android">android</a>
    
        <a class="post-tag" href="javascript:void(0);" data-tags = "Binder">Binder</a>
    
</div>
                
                
                    <div class="post-intro-read">
                        <span>Word count: <span class="post-count word-count">12.3k</span>Reading time: <span class="post-count reading-time">51 min</span></span>
                    </div>
                
                <div class="post-intro-meta">
                    <span class="post-intro-calander iconfont-archer">&#xe676;</span>
                    <span class="post-intro-time">2018/06/24</span>
                    
                    <span id="busuanzi_container_page_pv" class="busuanzi-pv">
                        <span class="iconfont-archer">&#xe602;</span>
                        <span id="busuanzi_value_page_pv"></span>
                    </span>
                    
                    <span class="shareWrapper">
                        <span class="iconfont-archer shareIcon">&#xe71d;</span>
                        <span class="shareText">Share</span>
                        <ul class="shareList">
                            <li class="iconfont-archer share-qr" data-type="qr">&#xe75b;
                                <div class="share-qrcode"></div>
                            </li>
                            <li class="iconfont-archer" data-type="weibo">&#xe619;</li>
                            <li class="iconfont-archer" data-type="qzone">&#xe62e;</li>
                            <li class="iconfont-archer" data-type="twitter">&#xe634;</li>
                            <li class="iconfont-archer" data-type="facebook">&#xe67a;</li>
                        </ul>
                    </span>
                </div>
            </div>
        
    </div>
</div>
        <script>
 
  // get user agent
  var browser = {
    versions: function () {
      var u = window.navigator.userAgent;
      return {
        userAgent: u,
        trident: u.indexOf('Trident') > -1, //IE内核
        presto: u.indexOf('Presto') > -1, //opera内核
        webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核
        gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1, //火狐内核
        mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端
        ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
        android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或者uc浏览器
        iPhone: u.indexOf('iPhone') > -1 || u.indexOf('Mac') > -1, //是否为iPhone或者安卓QQ浏览器
        iPad: u.indexOf('iPad') > -1, //是否为iPad
        webApp: u.indexOf('Safari') == -1, //是否为web应用程序，没有头部与底部
        weixin: u.indexOf('MicroMessenger') == -1, //是否为微信浏览器
        uc: u.indexOf('UCBrowser') > -1 //是否为android下的UC浏览器
      };
    }()
  }
  console.log("userAgent:" + browser.versions.userAgent);

  // callback
  function fontLoaded() {
    console.log('font loaded');
    if (document.getElementsByClassName('site-intro-meta')) {
      document.getElementsByClassName('intro-title')[0].classList.add('intro-fade-in');
      document.getElementsByClassName('intro-subtitle')[0].classList.add('intro-fade-in');
      var postIntros = document.getElementsByClassName('post-intros')[0]
      if (postIntros) {
        postIntros.classList.add('post-fade-in');
      }
    }
  }

  // UC不支持跨域，所以直接显示
  function asyncCb(){
    if (browser.versions.uc) {
      console.log("UCBrowser");
      fontLoaded();
    } else {
      WebFont.load({
        custom: {
          families: ['Oswald-Regular']
        },
        loading: function () {  //所有字体开始加载
          // console.log('loading');
        },
        active: function () {  //所有字体已渲染
          fontLoaded();
        },
        inactive: function () { //字体预加载失败，无效字体或浏览器不支持加载
          console.log('inactive: timeout');
          fontLoaded();
        },
        timeout: 5000 // Set the timeout to two seconds
      });
    }
  }

  function asyncErr(){
    console.warn('script load from CDN failed, will load local script')
  }

  // load webfont-loader async, and add callback function
  function async(u, cb, err) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (cb) { o.addEventListener('load', function (e) { cb(null, e); }, false); }
    if (err) { o.addEventListener('error', function (e) { err(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }

  var asyncLoadWithFallBack = function(arr, success, reject) {
      var currReject = function(){
        reject()
        arr.shift()
        if(arr.length)
          async(arr[0], success, currReject)
        }

      async(arr[0], success, currReject)
  }

  asyncLoadWithFallBack([
    "https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js", 
    "https://cdn.bootcss.com/webfont/1.6.28/webfontloader.js",
    "/lib/webfontloader.min.js"
  ], asyncCb, asyncErr)
</script>        
        <img class="loading" src="/assets/loading.svg" style="display: block; margin: 6rem auto 0 auto; width: 6rem; height: 6rem;" />
        <div class="container container-unloaded">
            <main class="main post-page">
    <article class="article-entry">
        <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>本文是看完邓凡平的《深入理解android卷1》第六章的binder篇后，在此基础上的一些个人理解。<br>上文从驱动角度解释了<code>binder</code>通讯机制的底层运行原理，我们知道android系统中，<code>binder</code>是采用CS架构来设计的，除了<code>binderDriver</code>之外，还需要<code>client</code> <code>server</code> 以及<code>serviceManager</code> 三个角色，才能完整实现一套CS架构的跨进程通讯机制。<br><img src="/media/15298368998935.jpg" alt=""></p>
<p>从上图可以看到，一次完整的IPC 至少需要这么几个步骤</p>
<ol>
<li><code>Server</code> 通过<code>serviceManager</code> 注册服务</li>
<li><code>Client</code> 通过<code>ServiceManager</code> 查询服务</li>
<li><code>Client</code> 获取到<code>Server</code>端的服务后，通过<code>binder</code>驱动，完成跨进程对<code>Server</code>端的引用。<br>下面以native层的一次IPC请求流程为例，通过client对MediaServer的调用，了解一下<code>client</code>、<code>server</code>、<code>serviceManager</code>三者之间的通讯过程。</li>
</ol>
<h1 id="server端：MediaServer"><a href="#server端：MediaServer" class="headerlink" title="server端：MediaServer"></a>server端：MediaServer</h1><p><code>MediaServer</code> 是系统主要<code>server</code>之一，它提供了</p>
<ol>
<li>AudioFlinger</li>
<li>AudioPolicyService</li>
<li>MediaplayerService</li>
<li>CamerService<br>四个重量级服务，查看<code>MediaServer</code>的源码：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//①获得一个ProcessState实例</span></span><br><span class="line"> sp&lt;ProcessState&gt;proc(ProcessState::self());</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//②MS作为ServiceManager的客户端，需要向ServiceManger注册服务</span></span><br><span class="line"> <span class="comment">//调用defaultServiceManager，得到一个IServiceManager。</span></span><br><span class="line"> sp&lt;IServiceManager&gt;sm = defaultServiceManager();</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//初始化音频系统的AudioFlinger服务</span></span><br><span class="line"> AudioFlinger::instantiate();</span><br><span class="line"> <span class="comment">//③多媒体系统的MediaPlayer服务，我们将以它作为主切入点</span></span><br><span class="line"> MediaPlayerService::instantiate();</span><br><span class="line"> <span class="comment">//CameraService服务</span></span><br><span class="line"> CameraService::instantiate();</span><br><span class="line"> <span class="comment">//音频系统的AudioPolicy服务</span></span><br><span class="line"> AudioPolicyService::instantiate();</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//④新建一个用以处理binder请求的线程</span></span><br><span class="line"> ProcessState::self()-&gt;startThreadPool();</span><br><span class="line"> <span class="comment">//⑤将主线程也用来处理binder请求</span></span><br><span class="line"> IPCThreadState::self()-&gt;joinThreadPool();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以代码中标注的1，2，3，4，5为次序，依次讲解每个部分的具体内容。</p>
<h2 id="一、创建ProcessState"><a href="#一、创建ProcessState" class="headerlink" title="一、创建ProcessState"></a>一、创建ProcessState</h2><p>还是先看代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//①获得一个ProcessState实例</span></span><br><span class="line">sp&lt;ProcessState&gt;proc(ProcessState::self());</span><br></pre></td></tr></table></figure>
<p>创建ProcessState实例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;ProcessState&gt; ProcessState::self()</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//gProcess是在Static.cpp中定义的一个全局变量</span></span><br><span class="line">   <span class="comment">//程序刚开始执行，gProcess一定为空</span></span><br><span class="line">    <span class="keyword">if</span>(gProcess != <span class="literal">NULL</span>) <span class="keyword">return</span> gProcess;</span><br><span class="line">        AutoMutex_l(gProcessMutex);</span><br><span class="line">     <span class="comment">//创建一个ProcessState对象，并赋值给gProcess</span></span><br><span class="line">    <span class="keyword">if</span>(gProcess == <span class="literal">NULL</span>) gProcess = <span class="keyword">new</span> ProcessState;</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">return</span> gProcess;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-processState-的构造函数"><a href="#1-processState-的构造函数" class="headerlink" title="1 processState 的构造函数"></a>1 processState 的构造函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">ProcessState::ProcessState()</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    【笔记一：】</span></span><br><span class="line"><span class="comment">    注意 在构造ProcessState时，通过open_driver()函数 打开了binder驱动，并将binder驱动的</span></span><br><span class="line"><span class="comment">    fd赋值给了ProcessState的mDriverFD 成员变量。后面我们可以看到一个与ProcessState对应的</span></span><br><span class="line"><span class="comment">    IPCThreadState对象（它是线程单例），它的构造函数会以ProcessState做参数，ProcessState持</span></span><br><span class="line"><span class="comment">    有Binder驱动的句柄，所以IPCThreadState可以操作Binder驱动，事实上，IPCThread也就是循环</span></span><br><span class="line"><span class="comment">    读写binder驱动，从中拿消息并处理消息的。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    :mDriverFD(open_driver())</span><br><span class="line">    ,mVMStart(MAP_FAILED)<span class="comment">//映射内存的起始地址</span></span><br><span class="line">    ,mManagesContexts(<span class="literal">false</span>)</span><br><span class="line">    ,mBinderContextCheckFunc(<span class="literal">NULL</span>)</span><br><span class="line">    , mBinderContextUserData(<span class="literal">NULL</span>)</span><br><span class="line">    ,mThreadPoolStarted(<span class="literal">false</span>)</span><br><span class="line">    ,mThreadPoolSeq(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(mDriverFD &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    BIDNER_VM_SIZE定义为(1*1024*1024) - (4096 *2) = 1M-8K</span></span><br><span class="line"><span class="comment">    【笔记二：】</span></span><br><span class="line"><span class="comment">    上文驱动篇讲过，用户空间调用驱动的mmap，实际对应驱动层的binder_mmap()方法，</span></span><br><span class="line"><span class="comment">    在该方法里，binder驱动会申请一块用来存储通信数据的内存区域，其实就是binder驱动中一个叫做</span></span><br><span class="line"><span class="comment">    binder_buff的结构体。同时会在server进程的用户空间和内核空间做一次虚拟地址映射。这是为什么 </span></span><br><span class="line"><span class="comment">    binder通讯只进行一次拷贝的原因，上文已讲过这里不再详述。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  mVMStart = mmap(<span class="number">0</span>, BINDER_VM_SIZE, PROT_READ,MAP_PRIVATE | MAP_NORESERVE,</span><br><span class="line">                     mDriverFD, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>processState</code> 是个单例对象，因为它是在程序运行时只初始化一次，所以每个进程只有一个<code>ProcessState</code>对象。在创建<code>ProcessState</code>时，做了这么几件事情</p>
<ol>
<li>打开<code>binder</code>驱动</li>
<li>映射内存起始地址</li>
<li>为<code>binder</code>驱动分配内存用以接受请求数据<h3 id="2-打开binder驱动（open-driver-）"><a href="#2-打开binder驱动（open-driver-）" class="headerlink" title="2 打开binder驱动（open_driver()）"></a>2 打开binder驱动（open_driver()）</h3><strong>ProcessState.cpp</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">open_driver</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd =open(<span class="string">"/dev/binder"</span>, O_RDWR);<span class="comment">//打开/dev/binder设备</span></span><br><span class="line">    <span class="keyword">if</span> (fd&gt;= <span class="number">0</span>) &#123;</span><br><span class="line">         ......</span><br><span class="line">       <span class="keyword">size_t</span> maxThreads = <span class="number">15</span>;</span><br><span class="line">       <span class="comment">//通过ioctl方式告诉binder驱动，这个fd支持的最大线程数是15个</span></span><br><span class="line">       result = ioctl(fd, BINDER_SET_MAX_THREADS, &amp;maxThreads);  </span><br><span class="line">   &#125;</span><br><span class="line"><span class="keyword">return</span> fd;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【笔记三：】<br>上文已经说过，<code>open(&#39;dev/binder&#39;,O_RDWR)</code> 其实对应了内核中<code>binder</code>驱动的<code>binder_open（）</code>方法，<br><code>binder_open()</code>的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_open</span><span class="params">(struct inode *nodp, struct file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span>;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 创建进程对应的binder_proc对象 </span></span><br><span class="line">	proc = kzalloc(<span class="keyword">sizeof</span>(*proc), GFP_KERNEL); </span><br><span class="line">	<span class="keyword">if</span> (proc == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	get_task_struct(current);</span><br><span class="line">	proc-&gt;tsk = current;</span><br><span class="line">	<span class="comment">// 初始化binder_proc</span></span><br><span class="line">	INIT_LIST_HEAD(&amp;proc-&gt;todo);</span><br><span class="line">	init_waitqueue_head(&amp;proc-&gt;wait);</span><br><span class="line">	proc-&gt;default_priority = task_nice(current);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 锁保护</span></span><br><span class="line">	binder_lock(__func__);</span><br><span class="line"></span><br><span class="line">	binder_stats_created(BINDER_STAT_PROC);</span><br><span class="line">	<span class="comment">// 添加到全局列表binder_procs中</span></span><br><span class="line">	hlist_add_head(&amp;proc-&gt;proc_node, &amp;binder_procs);</span><br><span class="line">	proc-&gt;pid = current-&gt;group_leader-&gt;pid;</span><br><span class="line">	INIT_LIST_HEAD(&amp;proc-&gt;delivered_death);</span><br><span class="line">	filp-&gt;private_data = proc;</span><br><span class="line"></span><br><span class="line">	binder_unlock(__func__);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在打开<code>binder</code>驱动时，<code>binder_procs</code>会将所有打开<code>binder</code>驱动的进程加入到该列表中。<br>同时，通过<code>ioctrl</code> 的方式 告诉了<code>binder</code> 驱动 当前<code>server</code>端线程池支持的最大线程数是15.</p>
<p>所以创建<code>processState</code>的过程 其实做了这么几件事：</p>
<ol>
<li>打开<code>binder</code>驱动 同时驱动为该进程创建对应的<code>binder_proc</code> 节点 </li>
<li>对返回的<code>fd</code> 使用<code>mmap</code>方法，操作<code>binder</code>驱动，<code>binder</code>驱动申请了一块内存来接受通讯数据</li>
<li>因为<code>ProcessState</code>是进程单例的，每个进程只会开启<code>binder</code>驱动一次。</li>
</ol>
<h2 id="二、-获取servicManager"><a href="#二、-获取servicManager" class="headerlink" title="二、 获取servicManager"></a>二、 获取servicManager</h2><p><code>defaultServiceManager()</code>方法在<code>IServiceManager.cpp</code>中定义，返回<code>IServiceManager</code>对象，先看一下这个方法的具体实现<br><strong>IServiceManager.cpp</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> sp&lt;IServiceManager&gt; defaultServiceManager()</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 单例实现</span></span><br><span class="line">    <span class="keyword">if</span>(gDefaultServiceManager != <span class="literal">NULL</span>) <span class="keyword">return</span> gDefaultServiceManager;</span><br><span class="line">     &#123;</span><br><span class="line">       AutoMutex _l(gDefaultServiceManagerLock);</span><br><span class="line">        <span class="keyword">if</span>(gDefaultServiceManager == <span class="literal">NULL</span>) &#123;</span><br><span class="line">          <span class="comment">//真正的gDefaultServiceManager是在这里创建的。</span></span><br><span class="line">           gDefaultServiceManager = interface_cast&lt;IServiceManager&gt;(</span><br><span class="line">                                   ProcessState::self()-&gt;getContextObject(<span class="literal">NULL</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   returngDefaultServiceManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到 真正的<code>IServiceManager</code> 是由方法 <code>interface_cast&lt;IServiceManager&gt;（）</code> 传入一个 <code>ProcessState::self()-&gt;getContextObject(NULL)</code>对象实现的。<br>先看一下<code>ProcessState::self()</code>的<code>getContextObject()</code>函数<br><strong>ProcessState.cpp</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;IBinder&gt;ProcessState::getContextObject(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; caller)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    caller的值为0！注意，该函数返回的是IBinder。它是什么？我们后面再说。</span></span><br><span class="line"><span class="comment">    supportsProcesses函数根据openDriver函数打开设备是否成功来判断是否支持process</span></span><br><span class="line"><span class="comment">    真实设备肯定支持process。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span>(supportsProcesses()) &#123;</span><br><span class="line">   <span class="comment">//真实设备上肯定是支持进程的，所以会调用下面这个函数</span></span><br><span class="line">   <span class="comment">//【笔记三：传的参数是null 所以handle号是0】</span></span><br><span class="line">       <span class="keyword">return</span> getStrongProxyForHandle(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> getContextObject(String16(<span class="string">"default"</span>), caller);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续看<code>getStrongProxyForHandle()</code></p>
<p><strong>ProcessState.cpp</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;IBinder&gt;ProcessState::getStrongProxyForHandle(<span class="keyword">int32_t</span> handle)</span><br><span class="line">&#123;</span><br><span class="line">   sp&lt;IBinder&gt; result;</span><br><span class="line"> AutoMutex_l(mLock);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    根据索引查找对应资源。如果lookupHandleLocked发现没有对应的资源项，则会创建一个新的项并返   </span></span><br><span class="line"><span class="comment">    回。</span></span><br><span class="line"><span class="comment">    这个新项的内容需要填充。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   handle_entry* e = lookupHandleLocked(handle);</span><br><span class="line">    <span class="keyword">if</span> (e !=<span class="literal">NULL</span>) &#123;</span><br><span class="line">       IBinder* b = e-&gt;binder;</span><br><span class="line">        <span class="keyword">if</span> (b== <span class="literal">NULL</span> || !e-&gt;refs-&gt;attemptIncWeak(<span class="keyword">this</span>)) &#123;</span><br><span class="line">           <span class="comment">//对于新创建的资源项，它的binder为空，所以走这个分支。注意，handle的值为0</span></span><br><span class="line">            b= <span class="keyword">new</span> BpBinder(handle); <span class="comment">//创建一个BpBinder</span></span><br><span class="line">           e-&gt;binder = b; <span class="comment">//填充entry的内容</span></span><br><span class="line">           <span class="keyword">if</span> (b) e-&gt;refs = b-&gt;getWeakRefs();</span><br><span class="line">           result = b;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           result.force_set(b);</span><br><span class="line">           e-&gt;refs-&gt;decWeak(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    returnresult; <span class="comment">//返回BpBinder(handle)，注意，handle的值为0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到 实际返回的对象是一个<code>BpBinder</code>，<code>BpBinder</code>里持有一个<code>handle</code>成员变量。<br>实际上 <code>BpBinder</code> <code>BBinder</code> 都是继承自<code>IBinder</code>的。<br><img src="/media/15298408964173.jpg" alt=""></p>
<p>从名字也可以看出来，<code>BpBinder</code> ,BProxy（proxy:代理），肯定是与客户端打交道的。如果说<code>Proxy</code>代表客户端，那么<code>BBinder</code>则代表服务端。这里的<code>BpBinder</code>和<code>BBinder</code>是一一对应的，即某个<code>BpBinder</code>只能和对应的<code>BBinder</code>交互。我们当然不希望通过<code>BpBinderA</code>发送的请求，却由<code>BBinderB</code>来处理。<br>刚才我们在<code>defaultServiceManager()</code>函数中创建了这个<code>BpBinder</code>。<br>前面说了，<code>BpBinder</code>和<code>BBinder</code>是一一对应的，那么<code>BpBinder</code>如何标识它所对应的<code>BBinder</code>端呢？<br>答案是<code>Binder</code>系统通过<code>handler</code>来对应<code>BBinder</code>。以后我们会确认这个<code>Handle</code>值的作用。</p>
<blockquote>
<p>注：我们给BpBinder构造函数传的参数handle的值是0。这个0在整个Binder系统中有重要含义—因为0代表的就是ServiceManager所对应的BBinder。</p>
</blockquote>
<p>详细看一下<code>BpBinder</code>的实现</p>
<h3 id="1-BpBinder-cpp"><a href="#1-BpBinder-cpp" class="headerlink" title="1. BpBinder.cpp"></a>1. BpBinder.cpp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">BpBinder::BpBinder(<span class="keyword">int32_t</span> handle)</span><br><span class="line">    :mHandle(handle)<span class="comment">//handle是0</span></span><br><span class="line">    ,mAlive(<span class="number">1</span>)</span><br><span class="line">    ,mObitsSent(<span class="number">0</span>)</span><br><span class="line">    ,mObituaries(<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">   extendObjectLifetime(OBJECT_LIFETIME_WEAK);</span><br><span class="line">   <span class="comment">//另一个重要对象是IPCThreadState，我们稍后会详细讲解。</span></span><br><span class="line">   IPCThreadState::self()-&gt;incWeakHandle(handle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看上面的代码，会觉得<code>BpBinder</code>确实简单，不过再仔细查看，你或许会发现，<code>BpBinder</code>、<code>BBinder</code>这两个类没有任何地方操作<code>ProcessState</code>打开的那个<code>/dev/binder</code>设备，换言之，<strong>这两个Binder类没有和binder设备直接交互</strong>。那为什么说<code>BpBinder</code>会与通信相关呢? 我们接着看<code>interface_cast（）</code>函数</p>
<p>我们是从下面这个函数开始分析的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gDefaultServiceManager =interface_cast&lt;IServiceManager&gt;( ProcessState::self()-&gt;getContextObject(<span class="literal">NULL</span>));</span><br></pre></td></tr></table></figure>
<p>现在这个函数调用将变成如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gDefaultServiceManager =interface_cast&lt;IServiceManager&gt;(<span class="keyword">new</span> BpBinder(<span class="number">0</span>));</span><br></pre></td></tr></table></figure>
<p>这里出现了一个<code>interface_cast</code>。它是什么？其实是一个障眼法！下面就来具体分析它。</p>
<h3 id="2-障眼法——interface-cast"><a href="#2-障眼法——interface-cast" class="headerlink" title="2. 障眼法——interface_cast"></a>2. 障眼法——interface_cast</h3><p>看看<code>interface_cast</code>的具体实现，其代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">IInterface.h</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> INTERFACE&gt;</span><br><span class="line"><span class="keyword">inline</span> sp&lt;INTERFACE&gt; interface_cast(constsp&lt;IBinder&gt;&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">    returnINTERFACE::asInterface(obj);</span><br><span class="line">&#125;</span><br><span class="line">哦，仅仅是一个模板函数，所以interface_cast()等价于：</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> sp&lt;IServiceManager&gt;interface_cast(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> IServiceManager::asInterface(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>又转移到<strong>IServiceManager</strong>对象中去了，还原完模板函数，可以看到<code>interface_cast（）</code>实际调用的是<code>IServiceManager</code>中的<code>asInterface()</code> 方法，该方法传入了上文所说的<code>BpBinder</code>对象。看一下<code>IServiceManager（）</code>中做了什么操作</p>
<h3 id="3-IServiceManager"><a href="#3-IServiceManager" class="headerlink" title="3. IServiceManager"></a>3. IServiceManager</h3><p>刚才提到，<code>IBinder</code>家族的<code>BpBinder</code>和<code>BBinder</code>是与通信业务相关的，那么业务层的逻辑又是如何巧妙地架构在<code>Binder</code>机制上的呢？关于这些问题，可以用一个绝好的例子来解释，它就是<code>IServiceManager</code>。</p>
<blockquote>
<p>【笔记四：】 <code>IServiceManager</code>对象其实可以当做java中的接口函数来理解。它定义在<code>IServiceManager.h</code> 中，描述了<code>ServiceManager</code>可以提供的服务。</p>
</blockquote>
<h4 id="（1）定义业务逻辑"><a href="#（1）定义业务逻辑" class="headerlink" title="（1）定义业务逻辑"></a>（1）定义业务逻辑</h4><p>先回答第一个问题：如何表述应用的业务层逻辑。可以先分析一下<code>IServiceManager</code>是怎么做的。IServiceManager定义了<code>ServiceManager</code>所提供的服务，看它的定义可知，其中有很多有趣的内容。<code>IServiceManager</code>定义在<code>IServiceManager.h</code>中，代码如下所示：<br><strong>IServiceManager.h</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IServiceManager</span> :</span> <span class="keyword">public</span> IInterface</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">   <span class="comment">//关键无比的宏！</span></span><br><span class="line">   DECLARE_META_INTERFACE(ServiceManager);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//下面是ServiceManager所提供的业务函数</span></span><br><span class="line">    virtualsp&lt;IBinder&gt;    getService( constString16&amp; name) <span class="keyword">const</span> = <span class="number">0</span>;</span><br><span class="line">    virtualsp&lt;IBinder&gt;    checkService( constString16&amp; name) <span class="keyword">const</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtualstatus_t</span>        addService( <span class="keyword">const</span> String16&amp; name,</span><br><span class="line">                                               <span class="keyword">const</span> sp&lt;IBinder&gt;&amp;service) = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> Vector&lt;String16&gt;    listServices() = <span class="number">0</span>;</span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="（2）业务与通信的挂钩"><a href="#（2）业务与通信的挂钩" class="headerlink" title="（2）业务与通信的挂钩"></a>（2）业务与通信的挂钩</h4><p>Android巧妙地通过<code>DECLARE_META_INTERFACE</code>和<code>IMPLENT_META_INTERFACE</code>宏，将业务和通信牢牢地钩在了一起。<code>DECLARE_META_INTERFACE</code>和<code>IMPLEMENT_META_INTERFACE</code>这两个宏都定义在刚才的<code>IInterface.h</code>中。先看<code>DECLARE_META_INTERFACE</code>这个宏，如下所示：<br><strong>IInterface.h::DECLARE_META_INTERFACE</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DECLARE_META_INTERFACE(INTERFACE)                               \</span></span><br><span class="line">    staticconst android::String16 descriptor;                          \</span><br><span class="line">    staticandroid::sp&lt;I##INTERFACE&gt; asInterface(                       \</span><br><span class="line">           <span class="keyword">const</span> android::sp&lt;android::IBinder&gt;&amp; obj);                  \</span><br><span class="line">    virtualconst android::<span class="function">String16&amp; <span class="title">getInterfaceDescriptor</span><span class="params">()</span> <span class="keyword">const</span></span>;    \</span><br><span class="line">   I##INTERFACE();                                                    \</span><br><span class="line">    <span class="keyword">virtual</span>~I##INTERFACE();</span><br></pre></td></tr></table></figure>
<p>将IServiceManager的<code>DELCARE</code>宏进行相应的替换后得到的代码如下所示：<br><code>DECLARE_META_INTERFACE(IServiceManager)</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个描述字符串</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> android::String16 descriptor;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//定义一个asInterface函数</span></span><br><span class="line"><span class="keyword">static</span> android::sp&lt; IServiceManager &gt;</span><br><span class="line">asInterface(constandroid::sp&lt;android::IBinder&gt;&amp; obj)</span><br><span class="line"> </span><br><span class="line"><span class="comment">//定义一个getInterfaceDescriptor函数，估计就是返回descriptor字符串</span></span><br><span class="line"><span class="keyword">virtual</span> <span class="keyword">const</span> android::<span class="function">String16&amp;<span class="title">getInterfaceDescriptor</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//定义IServiceManager的构造函数和析构函数</span></span><br><span class="line">IServiceManager ();                                                   </span><br><span class="line"><span class="keyword">virtual</span> ~IServiceManager();</span><br></pre></td></tr></table></figure>
<p><code>DECLARE</code>宏声明了一些函数和一个变量，那么，<code>IMPLEMENT</code>宏的作用肯定就是定义它们了。<code>IMPLEMENT</code>的定义在<code>IInterface.h</code>中，<code>IServiceManager</code>是如何使用了这个宏呢？只有一行代码，在<strong>IServiceManager.cpp</strong>中，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">IMPLEMENT_META_INTERFACE(ServiceManager,<span class="string">"android.os.IServiceManager"</span>);</span><br><span class="line">很简单，可直接将IServiceManager中的IMPLEMENT宏的定义展开，如下所示：</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> android::String16</span><br><span class="line">IServiceManager::descriptor(“android.os.IServiceManager”);</span><br><span class="line"><span class="comment">//实现getInterfaceDescriptor函数</span></span><br><span class="line"><span class="keyword">const</span> android::String16&amp; IServiceManager::getInterfaceDescriptor()<span class="keyword">const</span></span><br><span class="line"> &#123; </span><br><span class="line">    <span class="comment">//返回字符串descriptor，值是“android.os.IServiceManager”</span></span><br><span class="line">      <span class="keyword">return</span> IServiceManager::descriptor;</span><br><span class="line">  &#125;    </span><br><span class="line"><span class="comment">//实现asInterface函数</span></span><br><span class="line"> android::sp&lt;IServiceManager&gt;</span><br><span class="line">             IServiceManager::asInterface(constandroid::sp&lt;android::IBinder&gt;&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">       android::sp&lt;IServiceManager&gt; intr;</span><br><span class="line">        <span class="keyword">if</span>(obj != <span class="literal">NULL</span>) &#123;                                              </span><br><span class="line">           intr = <span class="keyword">static_cast</span>&lt;IServiceManager *&gt;(                         </span><br><span class="line">               obj-&gt;queryLocalInterface(IServiceManager::descriptor).get());  </span><br><span class="line">           <span class="keyword">if</span> (intr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">             <span class="comment">//obj是我们刚才创建的那个BpBinder(0)</span></span><br><span class="line">               intr = <span class="keyword">new</span> BpServiceManager(obj);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">return</span> intr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现构造函数和析构函数</span></span><br><span class="line">IServiceManager::IServiceManager () &#123; &#125;</span><br><span class="line">IServiceManager::~ IServiceManager() &#123; &#125;</span><br></pre></td></tr></table></figure>
<p>我们曾提出过疑问：<code>interface_cast</code>是如何把<code>BpBinder</code>指针转换成一个<code>IServiceManager</code>指针的呢？答案就在asInterface函数的一行代码中，如下所示：</p>
<p><code>intr = new BpServiceManager(obj);</code><br>明白了！<code>interface_cast</code>不是指针的转换，而是利用<code>BpBinder</code>对象作为参数新建了一个<code>BpServiceManager</code>对象。我们已经知道<code>BpBinder</code>和<code>BBinder</code>与通信有关系，这里怎么突然冒出来一个<code>BpServiceManager</code>？它们之间又有什么关系呢？</p>
<h3 id="4-IServiceManager家族"><a href="#4-IServiceManager家族" class="headerlink" title="4 IServiceManager家族"></a>4 IServiceManager家族</h3><p>要搞清这个问题，必须先了解<code>IServiceManager</code>家族之间的关系，先来看图6-3，它展示了<code>IServiceManager</code>的家族图谱。<br><img src="/media/15298420766337.jpg" alt=""></p>
<p>图6-3 <code>IServiceManager</code>的家族图谱</p>
<p>根据图6-3和相关的代码可知，这里有以下几个重要的点值得注意：</p>
<p><code>IServiceManager</code>、<code>BpServiceManager</code>和<code>BnServiceManager</code>都与业务逻辑相关。<br><code>BnServiceManager</code>同时从<code>BBinder</code>派生，表示它可以直接参与<code>Binder</code>通信。<br><code>BpServiceManager</code>虽然从<code>BpInterface</code>中派生，但是这条分支似乎与<code>BpBinder</code>没有关系。<br><code>BnServiceManager</code>是一个虚类，它的业务函数最终需要子类来实现。<br>重要说明：以上这些关系很复杂，但<code>ServiceManager</code>并没有使用错综复杂的派生关系，它直接打开<code>Binder</code>设备并与之交互。后文，还会详细分析它的实现代码。</p>
<p>图6-3中的<code>BpServiceManager</code>，既然不像它的兄弟<code>BnServiceManager</code>那样直接与<code>Binder</code>有血缘关系，那么它又是如何与<code>Binder</code>交互的呢？简言之，<code>BpRefBase</code>中的<code>mRemote</code>的值就是<code>BpBinder</code>。如果你不相信，仔细看<code>BpServiceManager</code>左边的派生分支树上的一系列代码，它们都在<code>IServiceManager.cpp</code>中，如下所示：<br><strong>IServiceManager.cpp::BpServiceManager</strong>类</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过它的参数可得知，impl是IBinder类型，看来与Binder有间接关系,它实际上是BpBinder对象</span></span><br><span class="line">BpServiceManager(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; impl)</span><br><span class="line">   <span class="comment">//调用基类BpInterface的构造函数</span></span><br><span class="line">   : BpInterface&lt;IServiceManager&gt;(impl)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>BpInterface</strong>的实现代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">IInterface.h::BpInterface类</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> INTERFACE&gt;</span><br><span class="line">inlineBpInterface&lt;INTERFACE&gt;::BpInterface(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; remote)</span><br><span class="line">    :BpRefBase(remote)<span class="comment">//基类构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>BpRefBase()</code>的实现代码如下所示：<br><strong>Binder.cpp::BpRefBase</strong>类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">BpRefBase::BpRefBase(const sp&lt;IBinder&gt;&amp;o)</span><br><span class="line">  //mRemote最终等于那个new 出来的BpBinder(0)</span><br><span class="line">    :mRemote(o.get()), mRefs(NULL), mState(0)</span><br><span class="line">&#123;</span><br><span class="line">   extendObjectLifetime(OBJECT_LIFETIME_WEAK);</span><br><span class="line"> </span><br><span class="line">    if(mRemote) &#123;</span><br><span class="line">       mRemote-&gt;incStrong(this);          </span><br><span class="line">        mRefs= mRemote-&gt;createWeak(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原来，<code>BpServiceManager</code>的一个变量<code>mRemote</code>是指向了<code>BpBinder</code>。回想一下<code>defaultServiceManager</code>函数，可以得到以下两个关键对象：</p>
<p>有一个<code>BpBinder</code>对象，它的<code>handle</code>值是0。<br>有一个<code>BpServiceManager</code>对象，它的<code>mRemote</code>值是BpBinder。</p>
<blockquote>
<p>【笔记五：】在获取<code>ServiceManager</code>的时候，通过传入一个<code>BpBinder（0）</code>对象，调用到<code>IServiceManager</code>的<code>asInterface()</code>函数，这个函数创建了一个<code>BpServiceManger</code>对象，该对象也是定义在<code>IServiceManager.cpp</code> 中的，<code>BpServiceManager</code>对象通过构造函数持有了我们传过去的<code>BpBinder</code>，并实现了<code>IServiceManager</code>的业务函数（其实并没有真正实现，只不过<code>BpServiceManager</code>里有一个<code>IServiceManager</code>的同名方法，在同名方法里，会将客户端调用该函数的一些参数数据进行封装，打包成<code>parcel</code>对象，然后交给自己持有的<code>BpBinder</code>，<code>BpBinder</code>并不会直接与<code>binder</code>驱动进行交互，实际上所有的交互操作都是由<code>IPCTthreadState</code>完成的，后文会讲）</p>
</blockquote>
<h2 id="三、-注册MediaPlayerService"><a href="#三、-注册MediaPlayerService" class="headerlink" title="三、 注册MediaPlayerService"></a>三、 注册MediaPlayerService</h2><p>拿到了<code>BpServiceManager</code>，其实就可以通过这个代理，与server 也就是<code>ServiceManager</code>进行通信了。</p>
<p>现在要想<code>serviceManager</code> 注册<code>MediaPlayerService</code>服务。我们看一下 代码③ 具体做了什么</p>
<p><strong>MediaPlayerService.cpp</strong> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MediaPlayerService::instantiate() &#123;</span><br><span class="line">    defaultServiceManager()-&gt;addService(</span><br><span class="line">           String16(<span class="string">"media.player"</span>), <span class="keyword">new</span> MediaPlayerService());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据前面的分析，<code>defaultServiceManager()</code>实际返回的对象是<code>BpServiceManager</code>，它是<code>IServiceManager</code>的后代，代码如下所示：<br><strong>IServiceManager.cpp::BpServiceManager</strong>的<strong>addService()</strong>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> status_t <span class="title">addService</span><span class="params">(<span class="keyword">const</span> String16&amp;name, <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; service)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//Parcel:就把它当作是一个数据包。</span></span><br><span class="line">    Parceldata, reply;</span><br><span class="line">    data.writeInterfaceToken(IServiceManager::getInterfaceDescriptor());</span><br><span class="line">    data.writeString16(name);</span><br><span class="line">    data.writeStrongBinder(service);</span><br><span class="line">    <span class="comment">//remote返回的是mRemote，也就是BpBinder对象</span></span><br><span class="line">    status_terr = remote()-&gt;transact(ADD_SERVICE_TRANSACTION, data, &amp;reply);</span><br><span class="line">    returnerr == NO_ERROR ? reply.readInt32() : err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>别急着往下走，应先思考以下两个问题：</p>
<ul>
<li>调用<code>BpServiceManager</code>的<code>addService</code>是不是一个业务层的函数？</li>
<li><code>addService</code>函数中把请求数据打包成data后，传给了BpBinder的<code>transact</code>函数，这是不是把通信的工作交给了<code>BpBinder</code>？</li>
</ul>
<p>两个问题的答案都是肯定的。至此，业务层的工作原理应该是很清晰了，它的作用就是将请求信息打包后，再交给通信层去处理。<br>通信层的工作<br>下面分析<code>BpBinder</code>的<code>transact</code>函数。前面说过，在<code>BpBinder</code>中确实找不到任何与Binder设备交互的地方吗？那它是如何参与通信的呢？原来，秘密就在这个<code>transact</code>函数中，它的实现代码如下所示：<br><strong>BpBinder.cpp</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> BpBinder::transact(<span class="keyword">uint32_t</span> code, constParcel&amp; data, Parcel* reply,</span><br><span class="line">                                 uint32_tflags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(mAlive) &#123;</span><br><span class="line">     <span class="comment">//BpBinder果然是道具，它把transact工作交给了IPCThreadState</span></span><br><span class="line">       <span class="keyword">status_t</span> status = IPCThreadState::self()-&gt;transact(</span><br><span class="line">                           mHandle,code, data, reply, flags);<span class="comment">//mHandle也是参数</span></span><br><span class="line">        <span class="keyword">if</span>(status == DEAD_OBJECT) mAlive = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    returnDEAD_OBJECT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里又遇见了<code>IPCThreadState</code>，之前也见过一次。看来，它确实与<code>Binder</code>通信有关，所以必须对其进行深入分析！</p>
<h3 id="1-“劳者一份”的IPCThreadState"><a href="#1-“劳者一份”的IPCThreadState" class="headerlink" title="1 “劳者一份”的IPCThreadState"></a>1 “劳者一份”的IPCThreadState</h3><p>谁是“劳者”？线程，是进程中真正干活的伙计，所以它正是劳者。而“劳者一份”，就是每个伙计一份的意思。<code>IPCThreadState</code>的实现代码在<code>IPCThreadState.cpp</code>中，如下所示：<br><strong>IPCThreadState.cpp</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">IPCThreadState* IPCThreadState::self()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(gHaveTLS) &#123;<span class="comment">//第一次进来为false</span></span><br><span class="line">restart:</span><br><span class="line">        <span class="keyword">constpthread_key_t</span> k = gTLS;</span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">   TLS是Thread Local Storage（线程本地存储空间）的简称。</span></span><br><span class="line"><span class="comment">   这里只需知晓：这种空间每个线程都有，而且线程间不共享这些空间。</span></span><br><span class="line"><span class="comment">   通过pthread_getspecific/pthread_setspecific函数可以获取/设置这些空间中的内容。</span></span><br><span class="line"><span class="comment">   从线程本地存储空间中获得保存在其中的IPCThreadState对象。</span></span><br><span class="line"><span class="comment">   有调用pthread_getspecific的地方，肯定也有调用pthread_setspecific的地方</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">       IPCThreadState* st = (IPCThreadState*)pthread_getspecific(k);</span><br><span class="line">        <span class="keyword">if</span>(st) <span class="keyword">return</span> st;</span><br><span class="line"><span class="comment">// new一个对象，构造函数中会调用pthread_setspecific</span></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> IPCThreadState;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span>(gShutdown) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    pthread_mutex_lock(&amp;gTLSMutex);</span><br><span class="line">    <span class="keyword">if</span>(!gHaveTLS) &#123;</span><br><span class="line">        <span class="keyword">if</span>(pthread_key_create(&amp;gTLS, threadDestructor) != <span class="number">0</span>) &#123;</span><br><span class="line">           pthread_mutex_unlock(&amp;gTLSMutex);</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       gHaveTLS = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  pthread_mutex_unlock(&amp;gTLSMutex);</span><br><span class="line"><span class="comment">//其实goto没有我们说的那么不好，汇编代码也有很多跳转语句（没办法，太低级的语言了），关键是要用好</span></span><br><span class="line">  <span class="keyword">goto</span> restart;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，有必要转向分析它的构造函数IPCThreadState()，如下所示：<br><strong>IPCThreadState.cpp</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">IPCThreadState::IPCThreadState()</span><br><span class="line">    :mProcess(ProcessState::self()), mMyThreadId(androidGetTid())</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//在构造函数中，把自己设置到线程本地存储中去。</span></span><br><span class="line">   pthread_setspecific(gTLS, <span class="keyword">this</span>);</span><br><span class="line">    clearCaller();</span><br><span class="line">   <span class="comment">//mIn和mOut是两个Parcel。把它看成是发送和接收命令的缓冲区即可。</span></span><br><span class="line">mIn.setDataCapacity(<span class="number">256</span>);</span><br><span class="line">     mOut.setDataCapacity(<span class="number">256</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个线程都有一个<code>IPCThreadState</code>，每个<code>IPCThreadState</code>中都有一个<code>mIn</code>、一个<code>mOut</code>，其中mIn是用来接收来自<code>Binder</code>设备的数据的，而<code>mOut</code>则是用来存储发往<code>Binder</code>设备的数据的。</p>
<h3 id="2-勤劳的transact"><a href="#2-勤劳的transact" class="headerlink" title="2 勤劳的transact"></a>2 勤劳的transact</h3><p>传输工作是很辛苦的。我们刚才看到<code>BpBinder</code>的<code>transact</code>调用了<code>IPCThreadState</code>的<code>transact</code>函数，这个函数实际完成了与<code>Binder</code>通信的工作，如下面的代码所示：<br><strong>IPCThreadState.cpp</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意，handle的值为0，代表了通信的目的端</span></span><br><span class="line"><span class="keyword">status_t</span> IPCThreadState::transact(<span class="keyword">int32_t</span> handle,</span><br><span class="line">                                  uint32_tcode, <span class="keyword">const</span> Parcel&amp; data,</span><br><span class="line">                                  Parcel* reply, <span class="keyword">uint32_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    status_terr = data.errorCheck();</span><br><span class="line"> </span><br><span class="line">    flags |=TF_ACCEPT_FDS;</span><br><span class="line"> </span><br><span class="line">    ......</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">【笔记六：】</span></span><br><span class="line"><span class="comment"> 注意这里的第一个参数BC_TRANSACTION，它是应用程序向binder设备发送消息的消息码，</span></span><br><span class="line"><span class="comment"> 而binder设备向应用程序回复消息的消息码以BR_开头。消息码的定义在binder_module.h中，</span></span><br><span class="line"><span class="comment"> 请求消息码和回应消息码的对应关系可见上文驱动篇。这里BC_TRANSACTION对应一次binder事务，client </span></span><br><span class="line"><span class="comment"> 对server的请求	，这里client是服务端，server是serviceManager、</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">     err =writeTransactionData(BC_TRANSACTION, flags, handle, code, data, <span class="literal">NULL</span>);</span><br><span class="line">     ......</span><br><span class="line">     err = waitForResponse(reply);</span><br><span class="line">     ......</span><br><span class="line">   </span><br><span class="line">    returnerr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>多熟悉的流程：先发数据，然后等结果。再简单不过了！不过，我们有必要确认一下handle这个参数到底起了什么作用。先来看<strong>writeTransactionData</strong>函数，它的实现如下所示：<br><strong>IPCThreadState.cpp</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">status_tIPCThreadState::writeTransactionData(<span class="keyword">int32_t</span> cmd, <span class="keyword">uint32_t</span> binderFlags,</span><br><span class="line">    int32_thandle, <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, <span class="keyword">status_t</span>* statusBuffer)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//binder_transaction_data 是和binder设备通信的数据结构。   </span></span><br><span class="line">   binder_transaction_data tr;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">//果然，handle的值传递给了target，用来标识目的端，其中0是ServiceManager的标志。</span></span><br><span class="line">   tr.target.handle= handle;</span><br><span class="line">   <span class="comment">//code是消息码，用来switch/case的！</span></span><br><span class="line">    tr.code =code;</span><br><span class="line">    tr.flags= binderFlags;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">conststatus_t</span> err = data.errorCheck();</span><br><span class="line">    <span class="keyword">if</span> (err== NO_ERROR) &#123;</span><br><span class="line">       tr.data_size = data.ipcDataSize();</span><br><span class="line">       tr.data.ptr.buffer = data.ipcData();</span><br><span class="line">       tr.offsets_size = data.ipcObjectsCount()*<span class="keyword">sizeof</span>(<span class="keyword">size_t</span>);</span><br><span class="line">       tr.data.ptr.offsets = data.ipcObjects();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(statusBuffer) &#123;</span><br><span class="line">       tr.flags |= TF_STATUS_CODE;</span><br><span class="line">       *statusBuffer = err;</span><br><span class="line">       tr.data_size = <span class="keyword">sizeof</span>(<span class="keyword">status_t</span>);</span><br><span class="line">       tr.data.ptr.buffer = statusBuffer;</span><br><span class="line">       tr.offsets_size = <span class="number">0</span>;</span><br><span class="line">       tr.data.ptr.offsets = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> (mLastError = err);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//把命令写到mOut中， 而不是直接发出去</span></span><br><span class="line">      mOut.writeInt32(cmd);</span><br><span class="line">   mOut.write(&amp;tr, <span class="keyword">sizeof</span>(tr));</span><br><span class="line">    returnNO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，已经把<code>addService</code>的请求信息写到<code>mOut</code>中了。</p>
<blockquote>
<p>【笔记七：】<br>注意观察传递数据的变化 在<code>BpServiceManager</code>中还是<code>Parcel</code>，然后<code>BpServiceManager</code> 交给了<code>BpBinder</code>，<code>BpBinder</code>又把数据交给了<code>IPCThreadState</code>， <code>IPCThreadState</code>调用<code>writeTransactionData</code>方法，将数据进一步封装为 <code>binder_transaction_data</code>，并将<code>binder_transaction_data</code>和<code>BC_XXX</code>指令写到<code>IPCThreadState</code>中的<code>mOut</code>中。</p>
</blockquote>
<p>·</p>
<blockquote>
<p>【笔记八：】可以看到 真正与<code>binder驱动打</code>驱动打交道的是<code>IPCThreadState</code>。与<code>Binder</code>驱动打交道，意味着要往<code>binder</code>驱动写指令和数据，同时要从<code>binder</code>驱动读取返回的结果。<code>writeTranscationData()</code>方法实际上并没有做 往<code>binder</code>里写数据的操作，而是把数据写到自己的<code>mOut</code>成员变量里，那这个成员变量是怎么传给binder驱动的呢？ 其实是在<code>waitForResponse（）</code>函数里，<code>waitForResponse()</code>中的<code>talkWithDriver()</code>会读取<code>mOut</code>的数据并将数据传递给<code>binder</code>驱动，然后从<code>binder</code>驱动中读取返回数据传递给<code>mIn</code>，这样就完成了一次数据交互。</p>
</blockquote>
<p>接下来再看发送请求和接收回复部分的实现，代码在<code>waitForResponse</code>函数中，如下所示：<br><strong>IPCThreadState.cpp</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> IPCThreadState::waitForResponse(Parcel*reply, <span class="keyword">status_t</span> *acquireResult)</span><br><span class="line">&#123;</span><br><span class="line">    int32_tcmd;</span><br><span class="line">    int32_terr;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//talkWithDriver 在这里才真正开始与驱动打交道</span></span><br><span class="line">        <span class="keyword">if</span>((err=talkWithDriver()) &lt; NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line">        err =mIn.errorCheck();</span><br><span class="line">        <span class="keyword">if</span>(err &lt; NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(mIn.dataAvail() == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">       </span><br><span class="line">        cmd =mIn.readInt32();</span><br><span class="line">       <span class="keyword">switch</span>(cmd) &#123;</span><br><span class="line">        caseBR_TRANSACTION_COMPLETE:</span><br><span class="line">           <span class="keyword">if</span> (!reply &amp;&amp; !acquireResult) <span class="keyword">goto</span> finish;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">           err = executeCommand(cmd);<span class="comment">//看这个！</span></span><br><span class="line">           <span class="keyword">if</span> (err != NO_ERROR) <span class="keyword">goto</span> finish;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">finish:</span><br><span class="line">    <span class="keyword">if</span> (err!= NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">if</span>(acquireResult) *acquireResult = err;</span><br><span class="line">        <span class="keyword">if</span>(reply) reply-&gt;setError(err);</span><br><span class="line">       mLastError = err;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    returnerr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来看看<code>talkWithDriver()</code>函数</p>
<h3 id="3-talkWithDriver（）"><a href="#3-talkWithDriver（）" class="headerlink" title="3 talkWithDriver（）"></a>3 talkWithDriver（）</h3><p>talkwithDriver函数，如下所示：<br><strong>IPCThreadState.cpp</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> IPCThreadState::talkWithDriver(<span class="keyword">bool</span> doReceive)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// binder_write_read是用来与Binder设备交换数据的结构</span></span><br><span class="line">    binder_write_read bwr;</span><br><span class="line">    constbool needRead = mIn.dataPosition() &gt;= mIn.dataSize();</span><br><span class="line">    <span class="keyword">constsize_t</span> outAvail = (!doReceive || needRead) ? mOut.dataSize() : <span class="number">0</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//【笔记9】</span></span><br><span class="line">   bwr.write_size = outAvail;</span><br><span class="line">   bwr.write_buffer = (<span class="keyword">long</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>)mOut.data();</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span>(doReceive &amp;&amp; needRead) &#123;</span><br><span class="line">       <span class="comment">//接收数据缓冲区信息的填充。如果以后收到数据，就直接填在mIn中了。</span></span><br><span class="line">       bwr.read_size = mIn.dataCapacity();</span><br><span class="line">       bwr.read_buffer = (<span class="keyword">long</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>)mIn.data();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       bwr.read_size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span>((bwr.write_size == <span class="number">0</span>) &amp;&amp; (bwr.read_size == <span class="number">0</span>)) <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">   </span><br><span class="line">   bwr.write_consumed = <span class="number">0</span>;</span><br><span class="line">   bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">    status_terr;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="meta">#ifdefined(HAVE_ANDROID_OS)</span></span><br><span class="line">        <span class="comment">//看来不是read/write调用，而是ioctl方式。</span></span><br><span class="line">        <span class="keyword">if</span>(ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= <span class="number">0</span>)</span><br><span class="line">           err = NO_ERROR;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">           err = -errno;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        err =INVALID_OPERATION;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">       &#125;<span class="keyword">while</span> (err == -EINTR);</span><br><span class="line">   </span><br><span class="line">     <span class="keyword">if</span> (err&gt;= NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">if</span>(bwr.write_consumed &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (bwr.write_consumed &lt; (<span class="keyword">ssize_t</span>)mOut.dataSize())</span><br><span class="line">               mOut.remove(<span class="number">0</span>, bwr.write_consumed);</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               mOut.setDataSize(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(bwr.read_consumed &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           mIn.setDataSize(bwr.read_consumed);</span><br><span class="line">           mIn.setDataPosition(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    returnerr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/media/15298933056244.jpg" alt=""><br>图 <code>binder_write_read</code>结构体</p>
<blockquote>
<p>【笔记九：】<code>waitForResponse（）</code>是直接参与与<code>binder</code>驱动交互的地方了，首先 它初始化了<code>binder_read_write</code>结构体，将<code>mIn</code>和<code>mOut</code>中的数据读出来（如果有的话，没有就相当于初始化了），继而调用了<code>binder</code>驱动的ioctrl（）方法（对应驱动层的<code>binder_ioctrl()</code>），将这个封装好的<code>binder_read_write</code>结构发送给<code>binder</code>驱动，还记得上文<code>binder</code>驱动篇中的分析吗，binder驱动的<code>binder_ioctrl</code>()逻辑很简单，只是取出BC码和BR码，然后根据码来做对应的操作。<br><strong>这里综述一下framework到驱动层之间的通讯流程，具体如下</strong><br>1.<strong>ProcessState::self 打开驱动：</strong><code>binder</code>驱动会为每一个<code>flat_binder_object</code>对象在内核中创建一个唯一的<code>BinderNode</code>与之对应。 同时，每一个打开了<code>binder</code>驱动的进程，在内核中都有一个<code>binder_proc</code>结构体与之对应，该结构体被加载在<code>binder_procs</code>的全局链表上，是全局链表，所以这何一个进程（我们这里是<code>MediaServer</code>）都可以访问到任何进程的<code>binder_proc</code>对象了。同时，<code>binder_node</code> 被加载在<code>binder_proc</code>的<code>nodes</code>红黑树中。<br>.<br>.<br>2.<strong>mmap()让binder驱动去申请空间并做地址映射：</strong>还记得我们<code>MediaServer</code>初始化的时候调用了一个<code>ProcessState::self</code> 方法吗，它除了打开驱动，还调用了<code>mmap()</code>为该进程分配一个buffer，默认是4k ，也就是一个页面，这可以从分配函数看出来</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">binder_update_page_range(proc, <span class="number">1</span>, proc-&gt;buffer, proc-&gt;buffer + PAGE_SIZE, vma)；</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>PAGE_SIZE = 4K</code>，分配完成后 以<code>binder_buffer</code> 的形式 保存在<code>proc</code>的<code>buffers</code>红黑数里，同时进行了用户空间和内核空间的物理地址映射，也就是说现在<code>mediaserver</code>和内核空间映射了同一份物理地址，<code>server</code>端可以直接访问该物理地址而不需要将数据从内核空间往<code>server</code>进程所在的用户空间再拷贝一次了！<br>.<br>.</p>
<ol start="3">
<li><strong>通过ProcessState的getStrongProxyForHandle方法，创建了一个客户端“信使”BpBinder（0）</strong>，其中<code>handle = 0</code>，驱动其实正是通过handle值来查找客户端要通信的对端对应的<code>binderNode</code>，这个后面会说。该信使还持有<code>IPCThreadState</code>对象，它才是真正负责与驱动通讯的。<br>.<br>.<br>4.<strong>创建服务端</strong>（这里是<code>serviceManager</code>做特殊的服务端，它提供的服务是注册服务<code>add_service</code>方法）<strong>对应的BpServiceManager对象</strong>（<code>BpServiceManager</code>对象，它是<code>IServiceManager</code>的儿子，<code>IServiceManager</code>定义了业务函数和<code>interface_cast</code>转换函数，同时继承了<code>BpBinderInterface</code>接口,我们创建服务端的<code>BpServiceManager</code>，其实就是调用了<code>IServiceManager.cpp</code>中的<code>asInterface</code>函数，创建了一个<code>BpServiceManager</code>，同时它还持有我们传进去的信使“<code>BpBinder（0）</code>“的引用，对应<code>mRemote</code>）。现在我们有<code>BpServiceManager</code>了，它也有<code>IserviceMaganer</code>的业务函数，当我们调用对应的业务函数，这里是add_service（）要将我们的服务注册上去时，它会把命令交给<code>mRemote</code>，也就是我们的<code>BpBinder().transact()</code>方法，<code>transact（）</code>会调用<code>IPCThreadState</code>的<code>transact（）</code>方法。<br>.<br>.</li>
<li><strong>IPCThreadState.transact(int32_t handle,uint32_t,code, const Parcel&amp; data,Parcel* reply, uint32_t flags)与驱动交流，先写后读。</strong><br>.<br>.</li>
<li><strong>将请求内容写到写缓冲区mOut</strong>，通过<code>IPCThreadState::self.writeTransactionData</code> 吧数据封装成<code>binder_transaction_data</code><br>.<br>.</li>
<li><strong>把请求内容发送给驱动，并等待驱动返回结果，将结果写在mIn缓冲区</strong>，读写是通过<code>IPCThreadState</code>的<code>talkWithDriver()</code>方法，该方法进一步封装了要传递给<code>binder</code>驱动的数据，变为binder_read_write，同时把写的数据填入<code>write_buffer</code>里了。在<code>talkWithDriver</code>中，通过系统调用<code>ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr)</code>将数据发送给驱动。注意，现在<code>bwr</code>中的指令是<code>BC_TRANSACATION</code> ，并且<code>wirte_size&gt;0</code>,且<code>write_buffer</code>不为空。<br>.<br>.</li>
<li><strong>binder_proc对象，再看一下这张图复习一下</strong><br><img src="/media/15298989934622.jpg" alt=""><br><code>binder_proc</code>除了图中所画的几个成员之外，还有两个重要成员，都会在创建binder_proc对象的时候一起初始化。分别是<br><strong>struct list_head todo：</strong>当进程接收到一个进程间通信请求时，Binder驱动就将该请求封装成一个工作项，并且加入到进程的待处理工作向队列中，该队列使用成员变量<code>todo</code>来描述。<br><strong>wait_queue_head_t wait：</strong> 线程池中空闲Binder线程会睡眠在由该成员所描述的等待队列中， 当宿主进程的待处理工作项队列增加新工作项后，驱动会唤醒这些线程，以便处理新的工作项。<br>后面会讲到<code>binder</code>驱动会用他们来构建<code>binder_transaction</code> 结构体。</li>
</ol>
</blockquote>
<blockquote>
<p>以我们的例子为例，<code>MediaServer</code> 调用<code>IPCTtreadState</code>，并将mOut通过<code>waitForResponse()</code>里的<code>ioctrl(BINDER_READ_WRITE,&amp;data)</code>发送给驱动的时候，驱动早已经完成步骤1、2了。也就是<code>MediaServer</code> 已经有了一个对应的<code>binder_proc</code> 结构体，而且其携带的的<code>flat_binder_object</code>的<code>handle</code>指向0.注意，这里面的<code>flat_handle_object</code>中的<code>type</code>是<code>handle</code>，同时<code>handle = 0</code>；【注： 见上文 <a href="http://wenyiqingnian.xyz/2018/06/02/%E4%BB%8E%E9%A9%B1%E5%8A%A8%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3binder/">5.通讯过程中的binder实体的传递</a>】并且做了地址映射。<br>.<br>.<br>9.<strong>调用驱动的ioctrl()方法发送BINDER_WRITE_READ</strong>， 在<code>ioctrl</code>()函数的入口处，会执行 <code>thread = binder_get_thread(proc)</code>，该函数首先获取打开驱动的进程的<code>pid</code>号，根据pid号，检查是否可以在<code>threads</code>的红黑树中找到对应的<code>thread</code>对象，有就直接返回，没有就创建对应的<code>Thread</code>对象，加入<code>binder_proc</code>的<code>threads</code>的红黑树中。<br>.<br>.<br>10.现在binder驱动已经有了线程的<code>Thread</code>对象，并加入到<code>binder_proc</code>中的<code>threads</code>红黑树中。并且知道了请求码是<code>BINDER_WRITE_READ</code>，驱动篇讲过，<code>ioctrl</code>的功能就是根据不同请求码调用不同的处理方法。如果命令是<code>BINDER_WRITE_READ</code>，并且 <code>bwr.write_size &gt; 0</code>，则调用<code>binder_thread_write</code>。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">	<span class="keyword">case</span> BINDER_WRITE_READ: &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">binder_write_read</span> <span class="title">bwr</span>;</span></span><br><span class="line">        ...</span><br><span class="line">		<span class="keyword">if</span> (bwr.write_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			ret = binder_thread_write(proc, thread, (<span class="keyword">void</span> __user *)bwr.write_buffer, bwr.write_size, &amp;bwr.write_consumed);</span><br><span class="line">			trace_binder_write_done(ret);</span><br><span class="line">			<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">				bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr)))</span><br><span class="line">					ret = -EFAULT;</span><br><span class="line">				<span class="keyword">goto</span> err;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (bwr.read_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			ret = binder_thread_read(proc, thread, (<span class="keyword">void</span> __user *)bwr.read_buffer, bwr.read_size, &amp;bwr.read_consumed, filp-&gt;f_flags &amp; O_NONBLOCK);</span><br><span class="line">			trace_binder_read_done(ret);</span><br><span class="line">			<span class="keyword">if</span> (!list_empty(&amp;proc-&gt;todo))</span><br><span class="line">				wake_up_interruptible(&amp;proc-&gt;wait);</span><br><span class="line">			<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr)))</span><br><span class="line">					ret = -EFAULT;</span><br><span class="line">				<span class="keyword">goto</span> err;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当<code>write_buffer</code>存在数据，<code>binder</code>线程的写操作循环执行。这里<code>bwr.write_size&gt;0</code>,故会执行写循环，也就是binder_thread_write()方法。<br>.<br>.<br>11.<strong>进入binder_thread_write()来处理请求码</strong>。首先读取Binder命令，由于buffer里只是指向命令的指针，实际数据还保存在用户空间，因此调用get_user函数从用户空间读取数据（一次拷贝）。取得命令后，先更新命令的状态信息，然后根据不同命令 进行不同的处理。这里的例子中，<code>MediaServer</code>发送的命令是<code>BC_TRANSACTION</code>，对于请求码为<code>BC_TRANSACTION</code>或<code>BC_REPLY</code>时，会执行<code>binder_transaction()</code>方法，这是最为频繁的操作。 </p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binder_thread_write</span><span class="params">(struct binder_proc *proc, struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">void</span> __user *buffer, <span class="keyword">int</span> size, <span class="keyword">signed</span> <span class="keyword">long</span> *consumed)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">uint32_t</span> cmd;</span><br><span class="line">	<span class="keyword">void</span> __user *ptr = buffer + *consumed;</span><br><span class="line">	<span class="keyword">void</span> __user *end = buffer + size;</span><br><span class="line">	...</span><br><span class="line">		<span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">		<span class="keyword">case</span> BC_TRANSACTION:</span><br><span class="line">		<span class="keyword">case</span> BC_REPLY: &#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span> <span class="title">tr</span>;</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (copy_from_user(&amp;tr, ptr, <span class="keyword">sizeof</span>(tr)))</span><br><span class="line">				<span class="keyword">return</span> -EFAULT;</span><br><span class="line">			ptr += <span class="keyword">sizeof</span>(tr);</span><br><span class="line">			<span class="comment">// 【笔记十：】注意看最后一个参数，因为BC_TRANSACTION 还有BC_REPLY 都会</span></span><br><span class="line">			<span class="comment">//调用binder_transaction()，一个函数处理了两个逻辑，所有它用了一个boolean值 </span></span><br><span class="line">		   <span class="comment">//cmd == BC_REPLAY 来决定走哪个流程</span></span><br><span class="line">			binder_transaction(proc, thread, &amp;tr, cmd == BC_REPLY);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>.<br>.<br>12.<strong>binder_transaction内部流程</strong></p>
</blockquote>
<ul>
<li><p>首先梳理下当前传进来的<code>binder_transaction_data</code>到底包含了哪些数据：</p>
<p><img src="/media/15299308632940.png" alt=""></p>
</li>
</ul>
<ul>
<li>1 根据<code>binder_transaction_data</code> 中的<code>handle</code>,通过映射关系<img src="/media/15299136178694.jpg" alt=""><br>找到对应的<code>binder_node</code>，进而找到目标进程<code>binder_proc</code></li>
</ul>
<ul>
<li>2 根据本次<code>binder_transaction</code>是否是异步，如果不是异步，意味着当前的<code>binder</code>传输流程还没走完，还是同一个<code>transaction</code>流程，从<code>from_parent</code>查找，如果是异步，从<code>binder_proc</code> 回溯查找<code>target_thread</code>。 </li>
<li>3 如果找到<code>target_thread</code>，则它就是目标线程，否则<code>binder_proc</code>对应的进程是目标线程。</li>
<li>4 根据用户空间传入的数据和目标，发起事务的线程、进程信息，创建<code>binder_transaction</code>结构体，<code>binder_transaction</code> 其实与一次<code>binder_transaction（）</code>方法对应的，每执行一次，便会在驱动中为其创建一个对应的结构体。这里要解释一下什么是<code>binder_transaction</code>对象。可以这么理解，<code>binder_transaction_data</code>是<code>binder</code>传输对象的外部表示，应用于应用程序的，而<code>binder_transaction</code>是<code>binder</code>传输对象的内部表示，应用于内核binder驱动本身。<code>binder_transaction</code>对象都位于<code>binder_thread</code>的传输栈上，其本身是一个多级链表结构，描述了传输来源和传输目标，也记录了本次传输的信息，如<code>binder_work</code>、<code>binder_buffer</code>、<code>binder</code>命令等。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> debug_id;</span><br><span class="line">    <span class="comment">// 当驱动为目标进程或线程创建一个事务时，就会将该成员的type置为</span></span><br><span class="line">    <span class="comment">// BINDER_WORK_TRANSACTION，并将它添加到目标进程或线程的todo队列，等待处理</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_work</span> <span class="title">work</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">from</span>;</span>         <span class="comment">// 发起事务的线程</span></span><br><span class="line">    <span class="comment">// 事务所依赖的另外一个事务以及目标线程下一个要处理的事务</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">from_parent</span>;</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">to_proc</span>;</span>        <span class="comment">// 负责处理该事务的进程</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">to_thread</span>;</span>    <span class="comment">// 负责处理该事务的线程</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">to_parent</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> need_reply:<span class="number">1</span>;              <span class="comment">// 同步事务为1需要等待对方回复；异步为0</span></span><br><span class="line">    <span class="comment">/* unsigned is_dead:1; */</span>   <span class="comment">/* not used at the moment */</span></span><br><span class="line">    <span class="comment">// 指向驱动为该事务分配的内核缓冲区，保存了进程间通信数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_buffer</span> *<span class="title">buffer</span>;</span>   </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>    code;   <span class="comment">// 直接从进程间通信数据中拷贝过来</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>    flags;  <span class="comment">// 直接从进程间通信数据中拷贝过来</span></span><br><span class="line">    <span class="keyword">long</span>    priority;       <span class="comment">// 源线程优先级</span></span><br><span class="line">    <span class="comment">// 线程在处理事务时，驱动会修改它的优先级以满足源线程和目标Service组建的要求。在修改之</span></span><br><span class="line">    <span class="comment">// 前，会将它原来的线程优先级保存在该成员中，以便线程处理完该事务后可以恢复原来的优先级</span></span><br><span class="line">    <span class="keyword">long</span>    saved_priority; </span><br><span class="line">    <span class="keyword">uid_t</span>   sender_euid;    <span class="comment">// 源线程用户ID</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>4 根据传输的目标设置本次<code>binder</code>传输的目标等待队列(<code>wait_queue</code>)和本次<code>binder_work</code>需要挂载的列表(<code>list</code>)，也就是<code>target_wait</code>和<code>target_list</code>。其中<code>target_wait</code>中存放的就是本次要唤醒的目标进程/线程。 <code>target_list</code> 就是目标进程中的<code>todo</code></li>
<li>5 到目前，<code>target_node</code>，<code>target_thread</code>，<code>target_proc</code>，<code>target_wait</code>和<code>target_list</code>都已经找到了。下面就该为此次传输分配新的<code>binder_transaction</code>对象和<code>binder_work</code>对象了，并根据当前的信息填充内容</li>
<li>6 构造一个新的<code>binder_transaction</code> 对象，并为期分配内存，同时修改<code>flat_binder_object</code>,做好<code>handle</code>到<code>binder</code>地址之间的映射。如果发送端发的是<code>binder</code>，驱动会把<code>type</code> 修改为<code>HANDLE_TYPE</code>，同时找到<code>binder_node-&gt;binder_ref</code> 找到索引id，<code>binder_ref-&gt;desc</code>，将改id赋值给<code>handle</code>.如果是<code>handle</code>，吧流程返过来，<code>handle-&gt;binder_ref-&gt;binder_node</code>，将<code>binder_node</code> 赋值给<code>flat_binder_object</code>中的<code>binder</code>，修改<code>type</code>为<code>BINDER_TYPE</code>；</li>
<li>7 新的<code>binder_flat_object</code>修改好了，在此之前，还要根据是同步传输还是异步传输，设置<code>binder_transaction</code>中的<code>replay</code>值，并将<code>binder_transaction</code>插入到<code>target_list</code>也即<code>traget_tread</code>/<code>target_proc</code>的<code>todo</code>队列中。</li>
</ul>
<p>至此 发送命令算是做完了。可以看到，调用了<code>binder_transcation</code>之后，并没有把数据发送给<code>server</code>，驱动只不过是创建了一个<code>binder_transaction</code>结构，然后把它挂在<code>binder_proc</code>的<code>todo</code>队列中。<br><img src="/media/15299341943387.png" alt=""><br>图：驱动层调用层级</p>
<p><img src="/media/15299348916454.jpg" alt=""></p>
<blockquote>
<p><strong>总结： 客户端的每一次请求，驱动最终都会生成换一个binder_transaction结构体，并把这个结构体挂在目标进程target_proc 也就是Server端 ServerManager服务对应的那个binder_proc 中。</strong></p>
</blockquote>
<ul>
<li>8 唤醒等待线程的目标线程</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (target_wait)  </span><br><span class="line">    wake_up_interruptible(target_wait);</span><br></pre></td></tr></table></figure>
<ul>
<li>9 server端的目标线程开始进入<code>binder_loop</code>状态，从<code>ServiceManager</code>那端来看，它走的其实和client端发起请求的流程是类似的，只不过此时<code>mOut</code>为空，binder驱动执行<code>binder_thread_read</code>()方法。</li>
<li>10 server端通过<code>ioctrl</code>控制驱动执行<code>binder_thread_read</code>,首先读取<code>todo</code>列表的首节点。这是client端发送请求操作完成之后插进来的。</li>
<li>11 根据todo中的<code>binder_work</code> 找到对应的<code>binder_transaction</code>,有了<code>binder_transaction</code>,便从<code>binder_transaction</code> 和<code>binder_buffer</code>中提取出<code>client</code>端发送的数据，重新组装成<code>binder_transaction_data</code>。</li>
<li><p>12 将<code>binder_transaction_data</code>结构体通过<code>copy_to_user</code>拷贝到用户空间，由接收端<code>ServiceManager</code>收到</p>
</li>
<li><p>13 server端收到binder驱动转发的客户端数据 进行处理后，再发送回给binder驱动。一次循环往复。完成客户端往服务端发送数据的过程。</p>
<blockquote>
<p>总结：客户端的请求，都会被binder驱动创建一个对应的binder_transaction。并将这个transaction挂在目标进程binder_proc的todo链表里，binder驱动再唤醒目标进程，目标进程对驱动执行读取命令，驱动执行binder_thread_read，同时将客户端发送的数据，以查找todo链表 -&gt; 查找binder_transaction-&gt; binder_buffer 的方式，重新包装成binder_transaction_data，拷贝到server端对应的用户空间。同时将改todo列表删除。至此完成客户端-&gt;server端的传输。server的返回数据流程和这个基本一致，只不过server和client的角色需要对调一下。</p>
</blockquote>
</li>
</ul>
<p>OK，我们已发送了请求数据，假设马上就收到了回复，后续该怎么处理呢？来看executeCommand函数，如下所示：<br><strong>IPCThreadState.cpp</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> IPCThreadState::executeCommand(int32_tcmd)</span><br><span class="line">&#123;</span><br><span class="line">    BBinder*obj;</span><br><span class="line">   RefBase::weakref_type* refs;</span><br><span class="line">    status_tresult = NO_ERROR;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">switch</span>(cmd) &#123;</span><br><span class="line">    caseBR_ERROR:</span><br><span class="line">       result = mIn.readInt32();</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">        ......</span><br><span class="line">     caseBR_TRANSACTION:</span><br><span class="line">        &#123;</span><br><span class="line">           binder_transaction_data tr;</span><br><span class="line">           result = mIn.read(&amp;tr, <span class="keyword">sizeof</span>(tr));</span><br><span class="line">           <span class="keyword">if</span> (result != NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line">            Parcel buffer;</span><br><span class="line">           Parcel reply;</span><br><span class="line">           <span class="keyword">if</span> (tr.target.ptr) &#123;</span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">             看到了BBinder，想起图6-3了吗？BnServiceXXX从BBinder派生，</span></span><br><span class="line"><span class="comment">             这里的b实际上就是实现BnServiceXXX的那个对象，关于它的作用，后文会详述              </span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">                sp&lt;BBinder&gt; b((BBinder*)tr.cookie);</span><br><span class="line">               <span class="keyword">const</span> <span class="keyword">status_t</span> error = b-&gt;transact(tr.code, buffer, &amp;reply, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (error &lt; NO_ERROR)reply.setError(error);</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">           the_context_object是IPCThreadState.cpp中定义的一个全局变量，</span></span><br><span class="line"><span class="comment">           可通过setTheContextObject函数设置</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">               <span class="keyword">const</span> <span class="keyword">status_t</span> error =</span><br><span class="line">                             the_context_object-&gt;transact(tr.code,buffer, &amp;reply, <span class="number">0</span>);</span><br><span class="line">               <span class="keyword">if</span> (error &lt; NO_ERROR) reply.setError(error);</span><br><span class="line">         &#125;</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">case</span> BR_DEAD_BINDER:</span><br><span class="line">        &#123;</span><br><span class="line">         <span class="comment">/*</span></span><br><span class="line"><span class="comment">           收到binder驱动发来的service死掉的消息，看来只有Bp端能收到了，</span></span><br><span class="line"><span class="comment">           后面，我们将会对此进行分析。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">           BpBinder *proxy = (BpBinder*)mIn.readInt32();</span><br><span class="line">           proxy-&gt;sendObituary();</span><br><span class="line">           mOut.writeInt32(BC_DEAD_BINDER_DONE);</span><br><span class="line">           mOut.writeInt32((<span class="keyword">int32_t</span>)proxy);</span><br><span class="line">        &#125;<span class="keyword">break</span>;</span><br><span class="line">        ......</span><br><span class="line"><span class="keyword">case</span> BR_SPAWN_LOOPER:</span><br><span class="line">  <span class="comment">//特别注意，这里将收到来自驱动的指示以创建一个新线程，用于和Binder通信。</span></span><br><span class="line">       mProcess-&gt;spawnPooledThread(<span class="literal">false</span>);</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        result = UNKNOWN_ERROR;</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   ......</span><br><span class="line">    <span class="keyword">if</span>(result != NO_ERROR) &#123;</span><br><span class="line">       mLastError = result;</span><br><span class="line">    &#125;</span><br><span class="line">    returnresult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-StartThread-Pool和join-Thread-Pool"><a href="#4-StartThread-Pool和join-Thread-Pool" class="headerlink" title="4 StartThread Pool和join Thread Pool"></a>4 StartThread Pool和join Thread Pool</h2><h3 id="1-创造劳动力——startThreadPool"><a href="#1-创造劳动力——startThreadPool" class="headerlink" title="1.创造劳动力——startThreadPool()"></a>1.创造劳动力——startThreadPool()</h3><p><code>startThreadPool()</code>的实现，如下面的代码所示：<br><strong>ProcessState.cpp</strong><br>//太简单，没什么好说的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ProcessState::startThreadPool()</span><br><span class="line">&#123;</span><br><span class="line">AutoMutex _l(mLock);</span><br><span class="line"><span class="comment">//如果要是已经startThreadPool的话，这个函数就没有什么实质作用了</span></span><br><span class="line">    <span class="keyword">if</span>(!mThreadPoolStarted) &#123;</span><br><span class="line">       mThreadPoolStarted = <span class="literal">true</span>;</span><br><span class="line">       spawnPooledThread(<span class="literal">true</span>); <span class="comment">//注意，传进去的参数是true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">上面的spawnPooledThread()函数的实现，如下所示：</span><br><span class="line">ProcessState.cpp</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> ProcessState::spawnPooledThread(<span class="keyword">bool</span> isMain)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//注意，isMain参数是true。</span></span><br><span class="line">    <span class="keyword">if</span>(mThreadPoolStarted) &#123;</span><br><span class="line">       <span class="keyword">int32_t</span> s = android_atomic_add(<span class="number">1</span>, &amp;mThreadPoolSeq);</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">32</span>];</span><br><span class="line">       <span class="built_in">sprintf</span>(buf, <span class="string">"Binder Thread #%d"</span>, s);</span><br><span class="line">        sp&lt;Thread&gt; t = <span class="keyword">new</span> PoolThread(isMain);</span><br><span class="line">       t-&gt;run(buf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PoolThread是在IPCThreadState中定义的一个Thread子类，它的实现，如下所示：<br><strong>IPCThreadState.h::PoolThread</strong>类</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PoolThread</span> :</span> <span class="keyword">public</span> Thread</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   PoolThread(<span class="keyword">bool</span> isMain)</span><br><span class="line">        :mIsMain(isMain)&#123;&#125;</span><br><span class="line">   <span class="keyword">protected</span>:</span><br><span class="line">    <span class="function">virtualbool <span class="title">threadLoop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       <span class="comment">//线程函数如此简单，不过是在这个新线程中又创建了一个IPCThreadState。</span></span><br><span class="line">      <span class="comment">// 你还记得它是每个伙计都有一个的吗？</span></span><br><span class="line">        IPCThreadState::self()-&gt;joinThreadPool(mIsMain);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">const</span> boolmIsMain;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="2万众归一-joinThreadPool"><a href="#2万众归一-joinThreadPool" class="headerlink" title="2万众归一  joinThreadPool"></a>2万众归一  joinThreadPool</h3><p>还需要看看<code>IPCThreadState</code>的<code>joinThreadPool</code>的实现，因为新创建的线程也会调用这个函数，具体代码如下所示：<br><strong>IPCThreadState.cpp</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> IPCThreadState::joinThreadPool(<span class="keyword">bool</span> isMain)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//注意，如果isMain为true，我们需要循环处理。把请求信息写到mOut中，待会儿一起发出去</span></span><br><span class="line">   mOut.writeInt32(isMain ? BC_ENTER_LOOPER : BC_REGISTER_LOOPER);</span><br><span class="line">   </span><br><span class="line">  androidSetThreadSchedulingGroup(mMyThreadId, ANDROID_TGROUP_DEFAULT);</span><br><span class="line">       </span><br><span class="line">    status_tresult;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">       <span class="keyword">int32_t</span> cmd;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">if</span>(mIn.dataPosition() &gt;= mIn.dataSize()) &#123;</span><br><span class="line">           <span class="keyword">size_t</span> numPending = mPendingWeakDerefs.size();</span><br><span class="line">           <span class="keyword">if</span> (numPending &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; numPending; i++) &#123;</span><br><span class="line">                   RefBase::weakref_type* refs = mPendingWeakDerefs[i];</span><br><span class="line">                    refs-&gt;decWeak(mProcess.get());</span><br><span class="line">               &#125;</span><br><span class="line">               mPendingWeakDerefs.clear();</span><br><span class="line">            &#125;</span><br><span class="line">           <span class="comment">//处理已经死亡的BBinder对象</span></span><br><span class="line">           numPending = mPendingStrongDerefs.size();</span><br><span class="line">           <span class="keyword">if</span> (numPending &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; numPending; i++) &#123;</span><br><span class="line">                   BBinder* obj = mPendingStrongDerefs[i];</span><br><span class="line">                   obj-&gt;decStrong(mProcess.get());</span><br><span class="line">               &#125;</span><br><span class="line">               mPendingStrongDerefs.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 发送命令，读取请求</span></span><br><span class="line">       result = talkWithDriver();</span><br><span class="line">        <span class="keyword">if</span>(result &gt;= NO_ERROR) &#123;</span><br><span class="line">           <span class="keyword">size_t</span> IN = mIn.dataAvail();</span><br><span class="line">            <span class="keyword">if</span> (IN &lt; <span class="keyword">sizeof</span>(<span class="keyword">int32_t</span>)) <span class="keyword">continue</span>;</span><br><span class="line">           cmd = mIn.readInt32();</span><br><span class="line">            result= executeCommand(cmd); <span class="comment">//处理消息</span></span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">while</span>(result != -ECONNREFUSED &amp;&amp; result != -EBADF);</span><br><span class="line"> </span><br><span class="line">   mOut.writeInt32(BC_EXIT_LOOPER);</span><br><span class="line">   talkWithDriver(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原来，我们的两个伙计在<code>talkWithDriver</code>，它们希望能从<code>Binder</code>设备那里找到点可做的事情。</p>
<h3 id="3-有几个线程在服务"><a href="#3-有几个线程在服务" class="headerlink" title="3. 有几个线程在服务"></a>3. 有几个线程在服务</h3><p>到底有多少个线程在为Service服务呢？目前看来是两个：</p>
<p><code>startThreadPool</code>中新启动的线程通过<code>joinThreadPool</code>读取Binder设备，查看是否有请求。<br>主线程也调用<code>joinThreadPool</code>读取Binder设备，查看是否有请求。看来，binder设备是支持多线程操作的，其中一定是做了同步方面的工作。<br><code>mediaserver</code>这个进程一共注册了4个服务，繁忙的时候，两个线程会不会显得有点少呢？另外，如果实现的服务负担不是很重，完全可以不调用startThreadPool创建新的线程，使用主线程即可胜任。</p>
<h1 id="特殊的server端，ServiceManager"><a href="#特殊的server端，ServiceManager" class="headerlink" title="特殊的server端，ServiceManager"></a>特殊的server端，ServiceManager</h1><p>刚才分析的<code>MediaServer</code>，在跟<code>servicemanager</code>注册服务的时候，其实扮演的是client的角色。<br><code>serviceManager</code> 是系统所有服务的大管家，提供查询，注册服务等方法。</p>
<h2 id="1-serviceManager-原理"><a href="#1-serviceManager-原理" class="headerlink" title="1. serviceManager 原理"></a>1. serviceManager 原理</h2><p>前面说过，<code>defaultServiceManager</code>返回的是一个<code>BpServiceManager</code>，通过它可以把命令请求发送给handle值为0的目的端。按照图6-3所示的<code>IServiceManager</code>“家谱”，无论如何也应该有一个类从<code>BnServiceManager</code>派生出来并处理这些来自远方的请求吧？<br>很可惜，源码中竟然没有这样的一个类存在！但确实又有这么一个程序完成了<code>BnServiceManager</code>未尽的工作，这个程序就是<code>servicemanager</code>，它的代码在<strong>Service_manager.c</strong>中，如下所示：</p>
<p>注意：通过这件事情是否能感悟到什么？嗯，我们确实可以抛开前面所有的那些封装，直接与Binder设备打交道。</p>
<p>下面来看<code>ServiceManager</code>是怎么放弃华丽的封装去做Manager的。</p>
<h3 id="1-ServiceManager的入口函数"><a href="#1-ServiceManager的入口函数" class="headerlink" title="1 ServiceManager的入口函数"></a>1 ServiceManager的入口函数</h3><p>ServiceManager的入口函数如下所示。<br><strong>ServiceManager.c</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   structbinder_state *bs;</span><br><span class="line">   <span class="comment">//BINDER_SERVICE_MANAGER的值为NULL，是一个magic number。</span></span><br><span class="line">   <span class="keyword">void</span>*svcmgr = BINDER_SERVICE_MANAGER;</span><br><span class="line">   <span class="comment">//①应该是打开binder设备吧？</span></span><br><span class="line">   bs = binder_open(<span class="number">128</span>*<span class="number">1024</span>);</span><br><span class="line">   <span class="comment">//②成为manager，是不是把自己的handle置为0？</span></span><br><span class="line">   binder_become_context_manager(bs)</span><br><span class="line">   svcmgr_handle= svcmgr;</span><br><span class="line">   <span class="comment">//③处理客户端发过来的请求。</span></span><br><span class="line">   binder_loop(bs, svcmgr_handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，一共有三个重要关键点。必须对其逐一地进行分析。</p>
<p>注意：有一些函数是在<strong>Binder.c</strong>中实现的，此<strong>Binder.c</strong>不是前面碰到的那个<strong>Binder.cpp</strong>。</p>
<h3 id="2-打开Binder设备"><a href="#2-打开Binder设备" class="headerlink" title="2 打开Binder设备"></a>2 打开Binder设备</h3><p><code>binder_open</code>函数用于打开Binder设备，它的实现如下所示：<br><strong>Binder.c</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  这里的binder_open应该与我们之前在ProcessState中看到的一样：</span></span><br><span class="line"><span class="comment">  1）打开Binder设备</span></span><br><span class="line"><span class="comment">  2）内存映射</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">struct binder_state *<span class="title">binder_open</span><span class="params">(<span class="keyword">unsigned</span> mapsize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    structbinder_state *bs;</span><br><span class="line">    bs =<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*bs));</span><br><span class="line">    ....</span><br><span class="line">    bs-&gt;fd= open(<span class="string">"/dev/binder"</span>, O_RDWR);</span><br><span class="line">    ....</span><br><span class="line">   bs-&gt;mapsize = mapsize;</span><br><span class="line">   bs-&gt;mapped = mmap(<span class="literal">NULL</span>, mapsize, PROT_READ, MAP_PRIVATE, bs-&gt;fd,<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>果然如此，有了之前所学习掌握的知识，这里真的就不难理解了。</p>
<h3 id="3-成为老大"><a href="#3-成为老大" class="headerlink" title="3. 成为老大"></a>3. 成为老大</h3><p>怎么才成为系统中独一无二的manager了呢？manger的实现，如下面的代码所示：<br><strong>Binder.c</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binder_become_context_manager</span><span class="params">(structbinder_state *bs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">//实现太简单了！这个0是否就是设置自己的handle呢？</span></span><br><span class="line">    returnioctl(bs-&gt;fd, BINDER_SET_CONTEXT_MGR, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-死磕Binder"><a href="#4-死磕Binder" class="headerlink" title="4.死磕Binder"></a>4.死磕Binder</h3><p><code>binder_loop</code>是一个很尽责的函数。为什么这么说呢？因为它老是围绕着Binder设备转悠，实现代码如下所示：<br><strong>Binder.c</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  注意binder_handler参数，它是一个函数指针，binder_loop读取请求后将解析</span></span><br><span class="line"><span class="comment">  这些请求，最后调用binder_handler完成最终的处理。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binder_loop</span><span class="params">(struct binder_state *bs,binder_handler func)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    structbinder_write_read bwr;</span><br><span class="line">   readbuf[<span class="number">0</span>] = BC_ENTER_LOOPER;</span><br><span class="line">   binder_write(bs, readbuf, <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span>));</span><br><span class="line">    <span class="keyword">for</span> (;;)&#123;<span class="comment">//果然是循环</span></span><br><span class="line">       bwr.read_size = <span class="keyword">sizeof</span>(readbuf);</span><br><span class="line">       bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">       bwr.read_buffer = (<span class="keyword">unsigned</span>) readbuf;</span><br><span class="line"> </span><br><span class="line">        res =ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);</span><br><span class="line">        <span class="comment">//接收到请求，交给binder_parse，最终会调用func来处理这些请求。</span></span><br><span class="line">        res = binder_parse(bs, <span class="number">0</span>, readbuf,bwr.read_consumed, func);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-集中处理"><a href="#5-集中处理" class="headerlink" title="5 集中处理"></a>5 集中处理</h3><p>往<code>binder_loop</code>中传的那个函数指针是svcmgr_handler，它的代码如下所示：<br><strong>Service_manager.c</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">svcmgr_handler</span><span class="params">(struct binder_state *bs,structbinder_txn *txn,</span></span></span><br><span class="line"><span class="function"><span class="params">                      struct binder_io *msg,structbinder_io *reply)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    structsvcinfo *si;</span><br><span class="line">    <span class="keyword">uint16_t</span>*s;</span><br><span class="line">    unsignedlen;</span><br><span class="line">    <span class="keyword">void</span>*ptr;</span><br><span class="line">    <span class="comment">// svcmgr_handle就是前面说的那个magic number，值为NULL。</span></span><br><span class="line">   <span class="comment">//这里要比较target是不是自己。</span></span><br><span class="line">    <span class="keyword">if</span>(txn-&gt;target != svcmgr_handle)</span><br><span class="line">       <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    s =bio_get_string16(msg, &amp;len);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> ((len!= (<span class="keyword">sizeof</span>(svcmgr_id) / <span class="number">2</span>)) ||</span><br><span class="line">       <span class="built_in">memcmp</span>(svcmgr_id, s, <span class="keyword">sizeof</span>(svcmgr_id))) &#123;</span><br><span class="line">       <span class="keyword">return</span><span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">switch</span>(txn-&gt;code) &#123;</span><br><span class="line">    caseSVC_MGR_GET_SERVICE:<span class="comment">//得到某个service的信息，service用字符串表示。</span></span><br><span class="line">    caseSVC_MGR_CHECK_SERVICE:</span><br><span class="line">        s = bio_get_string16(msg, &amp;len);<span class="comment">//s是字符串表示的service名称。</span></span><br><span class="line">        ptr =do_find_service(bs, s, len);</span><br><span class="line">        <span class="keyword">if</span>(!ptr)</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">       bio_put_ref(reply, ptr);</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    caseSVC_MGR_ADD_SERVICE:<span class="comment">//对应addService请求</span></span><br><span class="line">        s =bio_get_string16(msg, &amp;len);</span><br><span class="line">        ptr =bio_get_ref(msg);</span><br><span class="line">        <span class="keyword">if</span>(do_add_service(bs, s, len, ptr, txn-&gt;sender_euid))</span><br><span class="line">           <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">//得到当前系统已经注册的所有service的名字。</span></span><br><span class="line">    caseSVC_MGR_LIST_SERVICES: &#123;</span><br><span class="line">       <span class="keyword">unsigned</span> n = bio_get_uint32(msg);</span><br><span class="line">        si =svclist;</span><br><span class="line">        <span class="keyword">while</span>((n-- &gt; <span class="number">0</span>) &amp;&amp; si)</span><br><span class="line">           si = si-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(si) &#123;</span><br><span class="line">           bio_put_string16(reply, si-&gt;name);</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">       <span class="keyword">return</span><span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    bio_put_uint32(reply,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-服务的注册"><a href="#2-服务的注册" class="headerlink" title="2 服务的注册"></a>2 服务的注册</h2><p>上面提到的<code>switch/case</code>语句，将实现<code>IServiceManager</code>中定义的各个业务函数，我们重点看<code>do_add_service</code>这个函数，它最终完成了对<code>addService</code>请求的处理实现，代码如下所示：<br><strong>Service_manager.c</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_add_service</span><span class="params">(struct binder_state *bs,<span class="keyword">uint16_t</span>*s, <span class="keyword">unsigned</span> len,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">void</span>*ptr, <span class="keyword">unsigned</span> uid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    structsvcinfo *si;</span><br><span class="line">    <span class="keyword">if</span> (!ptr|| (len == <span class="number">0</span>) || (len &gt; <span class="number">127</span>))</span><br><span class="line">       <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">     <span class="comment">//svc_can_register函数比较注册进程的uid和名字。</span></span><br><span class="line">    <span class="keyword">if</span>(!svc_can_register(uid, s)) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure>
<p>将上面的函数暂时放一下，先介绍<code>svc_can_register</code>函数。</p>
<h3 id="1不是什么都可以注册的"><a href="#1不是什么都可以注册的" class="headerlink" title="1不是什么都可以注册的"></a>1不是什么都可以注册的</h3><p><code>do_add_service</code>函数中的<code>svc_can_register</code>，是用来判断注册服务的进程是否有权限的，代码如下所示：<br><strong>Service_manager.c</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">svc_can_register</span><span class="params">(<span class="keyword">unsigned</span> uid, <span class="keyword">uint16_t</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    unsignedn;</span><br><span class="line">    <span class="comment">//如果用户组是root用户或者system用户，则权限够高，允许注册</span></span><br><span class="line">    <span class="keyword">if</span> ((uid== <span class="number">0</span>) || (uid == AID_SYSTEM))</span><br><span class="line">       <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (n =<span class="number">0</span>; n &lt; <span class="keyword">sizeof</span>(allowed) / <span class="keyword">sizeof</span>(allowed[<span class="number">0</span>]); n++)</span><br><span class="line">        <span class="keyword">if</span>((uid == allowed[n].uid) &amp;&amp; str16eq(name, allowed[n].name))</span><br><span class="line">           <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>allowed</code>结构数组，控制那些权限达不到root和system的进程，它的定义如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    unsigneduid;</span><br><span class="line">    constchar *name;</span><br><span class="line">&#125; allowed[] = &#123;</span><br><span class="line">#ifdef LVMX</span><br><span class="line">    &#123;AID_MEDIA, <span class="string">"com.lifevibes.mx.ipc"</span> &#125;,</span><br><span class="line">#endif</span><br><span class="line">    &#123;AID_MEDIA, <span class="string">"media.audio_flinger"</span> &#125;,</span><br><span class="line">    &#123;AID_MEDIA, <span class="string">"media.player"</span> &#125;,</span><br><span class="line">    &#123;AID_MEDIA, <span class="string">"media.camera"</span> &#125;,</span><br><span class="line">    &#123;AID_MEDIA, <span class="string">"media.audio_policy"</span> &#125;,</span><br><span class="line">    &#123;AID_RADIO, <span class="string">"radio.phone"</span> &#125;,</span><br><span class="line">    &#123;AID_RADIO, <span class="string">"radio.sms"</span> &#125;,</span><br><span class="line">    &#123;AID_RADIO, <span class="string">"radio.phonesubinfo"</span> &#125;,</span><br><span class="line">    &#123;AID_RADIO, <span class="string">"radio.simphonebook"</span> &#125;,</span><br><span class="line">    &#123;AID_RADIO, <span class="string">"phone"</span> &#125;,</span><br><span class="line">    &#123;AID_RADIO, <span class="string">"isms"</span> &#125;,</span><br><span class="line">    &#123;AID_RADIO, <span class="string">"iphonesubinfo"</span> &#125;,</span><br><span class="line">    &#123;AID_RADIO, <span class="string">"simphonebook"</span> &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>所以，如果Server进程权限不够root和system，那么请记住要在<code>allowed</code>中添加相应的项。</p>
<h3 id="2-添加服务项"><a href="#2-添加服务项" class="headerlink" title="2. 添加服务项"></a>2. 添加服务项</h3><p>再回到我们的<code>do_add_service</code>，如下所示：<br><strong>Service_manager.c</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_add_service</span><span class="params">(struct binder_state *bs,<span class="keyword">uint16_t</span>*s, <span class="keyword">unsigned</span> len,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">void</span> *ptr, <span class="keyword">unsigned</span> uid)</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">...... <span class="comment">//接前面的代码</span></span><br><span class="line">    si =find_svc(s, len);</span><br><span class="line">    <span class="keyword">if</span> (si) &#123;</span><br><span class="line">        <span class="keyword">if</span>(si-&gt;ptr) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       si-&gt;ptr = ptr;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        si =<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*si) + (len + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">uint16_t</span>));</span><br><span class="line">        <span class="keyword">if</span>(!si) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//ptr是关键数据，可惜为void*类型。只有分析驱动的实现才能知道它的真实含义了。</span></span><br><span class="line">       si-&gt;ptr = ptr;</span><br><span class="line">       si-&gt;len = len;</span><br><span class="line">       <span class="built_in">memcpy</span>(si-&gt;name, s, (len + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">uint16_t</span>));</span><br><span class="line">       si-&gt;name[len] = <span class="string">'\0'</span>;</span><br><span class="line">       si-&gt;death.func = svcinfo_death;<span class="comment">//service退出的通知函数</span></span><br><span class="line">       si-&gt;death.ptr = si;</span><br><span class="line">        <span class="comment">//这个svclist是一个list，保存了当前注册到ServiceManager中的信息。</span></span><br><span class="line">       si-&gt;next = svclist;</span><br><span class="line">       svclist = si;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">   binder_acquire(bs,ptr);</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">我们希望当服务进程退出后，ServiceManager能有机会做一些清理工作，例如释放前面malloc出来的si。</span></span><br><span class="line"><span class="comment">binder_link_to_death完成这项工作，每当有服务进程退出时，ServiceManager都会得到来自</span></span><br><span class="line"><span class="comment">Binder设备的通知。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">   binder_link_to_death(bs, ptr, &amp;si-&gt;death);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，服务注册分析完毕。可以知道，<code>ServiceManager</code>不过就是保存了一些服务的信息。那么，这样做又有什么意义呢？</p>
<ul>
<li><code>ServiceManger</code>能集中管理系统内的所有服务，它能施加权限控制，并不是任何进程都能注册服务。</li>
<li><code>ServiceManager</code>支持通过字符串名称来查找对应的Service。这个功能很像DNS。</li>
<li>由于各种原因，Server进程可能生死无常。如果让每个Client都去检测，压力实在太大。现在有了统一的管理机构，Client只需要查询<code>ServiceManager</code>，就能把握动向，得到最新信息。这可能正是<code>ServiceManager</code>存在的最大意义吧。</li>
</ul>
<h1 id="MediaPlayerService和它的Client"><a href="#MediaPlayerService和它的Client" class="headerlink" title="MediaPlayerService和它的Client"></a>MediaPlayerService和它的Client</h1><p>前面，一直在讨论<code>ServiceManager</code>和它的<code>Client</code>，现在我们以<code>MediaPlayerService</code>的<code>Client</code>换换口味吧。由于<code>ServiceManager</code>不是从<code>BnServiceManager</code>中派生的，所以之前没有讲述请求数据是如何从通讯层传递到业务层来处理的过程。本节，我们以<code>MediaPlayerService</code>和它的<code>Client</code>做为分析对象，试解决这些遗留问题。</p>
<h2 id="查询ServiceManager"><a href="#查询ServiceManager" class="headerlink" title="查询ServiceManager"></a>查询ServiceManager</h2><p>前文曾分析过<code>ServiceManager</code>的作用，一个Client想要得到某个Service的信息，就必须先和<code>ServiceManager</code>打交道，通过调用<code>getService</code>函数来获取对应Service的信息。请看来源于<strong>IMediaDeathNotifier.cpp</strong>中的例子<code>getMediaPlayerService()</code>，它的代码如下所示：<br><strong>IMediaDeathNotifier.cpp</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  这个函数通过与ServiceManager通信，获得一个能够与MediaPlayerService通信的BpBinder，</span></span><br><span class="line"><span class="comment">  然后再通过障眼法interface_cast，转换成一个BpMediaPlayerService。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">IMediaDeathNotifier::getMediaPlayerService()</span><br><span class="line">&#123;</span><br><span class="line">       sp&lt;IServiceManager&gt; sm = defaultServiceManager();</span><br><span class="line">       sp&lt;IBinder&gt; binder;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">       <span class="comment">//向ServiceManager查询对应服务的信息，返回BpBinder。</span></span><br><span class="line">               binder = sm-&gt;getService(String16(<span class="string">"media.player"</span>));</span><br><span class="line">                <span class="keyword">if</span>(binder != <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//如果ServiceManager上还没有注册对应的服务，则需要等待，直到对应服务注册</span></span><br><span class="line"><span class="comment">//到ServiceManager中为止。</span></span><br><span class="line">            usleep(<span class="number">500000</span>);</span><br><span class="line">        &#125;<span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     通过interface_cast，将这个binder转化成BpMediaPlayerService，</span></span><br><span class="line"><span class="comment">     binder中的handle标识的一定是目的端MediaPlayerService。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   sMediaPlayerService = interface_cast&lt;IMediaPlayerService&gt;(binder);</span><br><span class="line">    &#125;</span><br><span class="line">    returnsMediaPlayerService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了<code>BpMediaPlayerService</code>，就能够使用任何<code>IMediaPlayerService</code>提供的业务逻辑函数了。例如<code>createMediaRecorder</code>和<code>createMetadataRetriever</code>等。<br>显而易见的是，调用的这些函数都将把请求数据打包发送给Binder驱动，由<code>BpBinder</code>中的<code>handle</code>值找到对应端的处理者来处理。这中间经历过如下的过程：</p>
<ul>
<li>（1）通讯层接收到请求。 </li>
<li>（2）递交给业务层处理。</li>
</ul>
<p>##子承父业<br>根据前面的分析可知，<code>MediaPlayerService</code>驻留在<code>MediaServer</code>进程中，这个进程有两个线程在<code>talkWithDriver</code>。假设其中有一个线程收到了请求，它最终会通过<code>executeCommand</code>调用来处理这个请求，实现代码如下所示：<br><strong>IPCThreadState.cpp</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> IPCThreadState::executeCommand(int32_tcmd)</span><br><span class="line">&#123;</span><br><span class="line">    BBinder*obj;</span><br><span class="line">   RefBase::weakref_type* refs;</span><br><span class="line">    status_tresult = NO_ERROR;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">switch</span>(cmd) &#123;</span><br><span class="line">    <span class="keyword">case</span> BR_ERROR:</span><br><span class="line">       result = mIn.readInt32();</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">        ......</span><br><span class="line">     caseBR_TRANSACTION:</span><br><span class="line">        &#123;</span><br><span class="line">           binder_transaction_data tr;</span><br><span class="line">           result = mIn.read(&amp;tr, <span class="keyword">sizeof</span>(tr));</span><br><span class="line">           <span class="keyword">if</span> (result != NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line">           Parcel buffer;</span><br><span class="line">           Parcel reply;</span><br><span class="line">           <span class="keyword">if</span> (tr.target.ptr) &#123;</span><br><span class="line">              <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 看到BBinder，想起图6-3了吗？ BnServiceXXX从BBinder派生，</span></span><br><span class="line"><span class="comment">                 这里的b实际就是实现BnServiceXXX的那个对象，这样就直接定位到了业务层的对象。</span></span><br><span class="line"><span class="comment">               */</span></span><br><span class="line">               sp&lt;BBinder&gt; b((BBinder*)tr.cookie);</span><br><span class="line">               <span class="keyword">const</span> <span class="keyword">status_t</span> error = b-&gt;transact(tr.code, buffer, &amp;reply, <span class="number">0</span>);</span><br><span class="line">               <span class="keyword">if</span> (error &lt; NO_ERROR) reply.setError(error);</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             the_context_object是IPCThreadState.cpp中定义的一个全局变量。可通过</span></span><br><span class="line"><span class="comment">             setTheContextObject函数设置。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">               <span class="keyword">const</span> <span class="keyword">status_t</span> error =</span><br><span class="line">                             the_context_object-&gt;transact(tr.code,buffer, &amp;reply, <span class="number">0</span>);</span><br><span class="line">               <span class="keyword">if</span> (error &lt; NO_ERROR) reply.setError(error);</span><br><span class="line">         &#125;</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure>
<p><code>BBinder</code>和业务层有什么关系？还记得图6-3吗？我们以<code>MediaPlayerService</code>为例，来梳理一下其派生关系，如图6-5所示：</p>
<p><img src="/media/15299381744168.jpg" alt=""></p>
<p>图6-5 <code>MediaPlayerService</code>家谱</p>
<p><code>BnMediaPlayerService</code>实现了<code>onTransact</code>函数，它将根据消息码调用对应的业务逻辑函数，这些业务逻辑函数由<code>MediaPlayerService</code>来实现。这一路的历程，如下面的代码所示：<br><strong>Binder.cpp</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> BBinder::transact(</span><br><span class="line">    uint32_tcode, <span class="keyword">const</span> Parcel&amp; data, Parcel* reply, <span class="keyword">uint32_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">   data.setDataPosition(<span class="number">0</span>);</span><br><span class="line">    status_terr = NO_ERROR;</span><br><span class="line">    <span class="keyword">switch</span>(code) &#123;</span><br><span class="line">        casePING_TRANSACTION:</span><br><span class="line">           reply-&gt;writeInt32(pingBinder());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">       <span class="keyword">default</span>:</span><br><span class="line">         <span class="comment">//调用子类的onTransact，这是一个虚函数。</span></span><br><span class="line">           err = onTransact(code, data, reply, flags);</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (reply!= <span class="literal">NULL</span>) &#123;</span><br><span class="line">       reply-&gt;setDataPosition(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    returnerr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>IMediaPlayerService.cpp</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> BnMediaPlayerService::onTransact(uint32_tcode, <span class="keyword">const</span> Parcel&amp; data,</span><br><span class="line">                                                  Parcel* reply, <span class="keyword">uint32_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">switch</span>(code) &#123;</span><br><span class="line">        ......</span><br><span class="line">        caseCREATE_MEDIA_RECORDER: &#123;</span><br><span class="line">           CHECK_INTERFACE(IMediaPlayerService, data, reply);</span><br><span class="line">           <span class="comment">//从请求数据中解析对应的参数</span></span><br><span class="line">           <span class="keyword">pid_t</span> pid = data.readInt32();</span><br><span class="line">            <span class="comment">//子类要实现createMediaRecorder函数。</span></span><br><span class="line">           sp&lt;IMediaRecorder&gt; recorder = createMediaRecorder(pid);</span><br><span class="line">           reply-&gt;writeStrongBinder(recorder-&gt;asBinder());</span><br><span class="line">           <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">        &#125;<span class="keyword">break</span>;</span><br><span class="line">        caseCREATE_METADATA_RETRIEVER: &#123;</span><br><span class="line">           CHECK_INTERFACE(IMediaPlayerService, data, reply);</span><br><span class="line">           <span class="keyword">pid_t</span> pid = data.readInt32();</span><br><span class="line">   <span class="comment">//子类要实现createMetadataRetriever函数</span></span><br><span class="line">           sp&lt;IMediaMetadataRetriever&gt; retriever =createMetadataRetriever(pid);</span><br><span class="line">           reply-&gt;writeStrongBinder(retriever-&gt;asBinder());</span><br><span class="line">           <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">        &#125;<span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">           <span class="keyword">return</span> BBinder::onTransact(code, data, reply, flags);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </article>
    <!-- license  -->
    
        <div class="license-wrapper">
            <p>Author：<a href="http://wenyiqingnian.xyz">QuincyJiang</a>
            <p>原文链接：<a href="http://wenyiqingnian.xyz/2018/06/24/从一次native端的IPC流程理解binder/">http://wenyiqingnian.xyz/2018/06/24/从一次native端的IPC流程理解binder/</a>
            <p>发表日期：<a href="http://wenyiqingnian.xyz/2018/06/24/从一次native端的IPC流程理解binder/">June 24th 2018, 7:00:50 pm</a>
            <p>更新日期：<a href="http://wenyiqingnian.xyz/2018/06/24/从一次native端的IPC流程理解binder/">June 25th 2018, 11:12:13 pm</a>
            <p>版权声明：本文采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可</p>
        </div>
    
    <!-- paginator  -->
    <ul class="post-paginator">
        <li class="next">
            
                <div class="nextSlogan">Next Post</div>
                <a href= "/2018/08/16/一些知识点总结/" title= "一些知识点总结">
                    <div class="nextTitle">一些知识点总结</div>
                </a>
            
        </li>
        <li class="previous">
            
                <div class="prevSlogan">Previous Post</div>
                <a href= "/2018/06/16/《现代艺术150年》未影印作品2/" title= "《现代艺术150年》未影印作品2">
                    <div class="prevTitle">《现代艺术150年》未影印作品2</div>
                </a>
            
        </li>
    </ul>
    <!-- 评论插件 -->
    <!-- 来必力City版安装代码 -->

    <div id="lv-container" data-id="city" data-uid= MTAyMC8zNjQwMS8xMjkzNg==>
        <script type="text/javascript">
            (function (d, s) {
                var j, e = d.getElementsByTagName(s)[0];
                if (typeof LivereTower === 'function') { return; }
                j = d.createElement(s);
                j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
                j.async = true;

                e.parentNode.insertBefore(j, e);
            })(document, 'script');
        </script>
        <noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
    </div>

<!-- City版安装代码已完成 -->
    
    
    <!-- partial('_partial/comment/changyan') -->
    <!--PC版-->


    
    

    <!-- 评论 -->
</main>
            <!-- profile -->
            
        </div>
        <footer class="footer footer-unloaded">
    <!-- social  -->
    
    <div class="social">
        
    
        
            
                <a href="mailto:1083873272@qq.com" class="iconfont-archer email" title=email ></a>
            
        
    
        
            
                <a href="//github.com/QuincyJiang" class="iconfont-archer github" target="_blank" title=github></a>
            
        
    
        
            
                <span class="iconfont-archer wechat" title=wechat>
                  
                  <img class="profile-qr" src="/assets/wechat.jpeg" />
                </span>
            
        
    
        
    
        
    
        
            
                <a href="https://weibo.com/2425393311/" class="iconfont-archer weibo" target="_blank" title=weibo></a>
            
        
    
        
    
        
    
        
    
        
    
        
            
                <a href="http://aquencyua11.lofter.com/" class="iconfont-archer instagram" target="_blank" title=instagram></a>
            
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    

    </div>
    
    <!-- powered by Hexo  -->
    <div class="copyright">
        <span id="hexo-power">Powered by <a href="https://hexo.io/" target="_blank">Hexo</a></span><span class="iconfont-archer power">&#xe635;</span><span id="theme-info">theme <a href="https://github.com/fi3ework/hexo-theme-archer" target="_blank">Archer</a></span>
    </div>
    <!-- 不蒜子  -->
    
    <div class="busuanzi-container">
    
     
    <span id="busuanzi_container_site_pv">PV: <span id="busuanzi_value_site_pv"></span> :)</span>
    
    </div>
    
</footer>
    </div>
    <!-- toc -->
    
    <div class="toc-wrapper" style=
    







top:50vh;

    >
        <div class="toc-catalog">
            <span class="iconfont-archer catalog-icon">&#xe613;</span><span>CATALOG</span>
        </div>
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#概述"><span class="toc-number">1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#server端：MediaServer"><span class="toc-number">2.</span> <span class="toc-text">server端：MediaServer</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、创建ProcessState"><span class="toc-number">2.1.</span> <span class="toc-text">一、创建ProcessState</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-processState-的构造函数"><span class="toc-number">2.1.1.</span> <span class="toc-text">1 processState 的构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-打开binder驱动（open-driver-）"><span class="toc-number">2.1.2.</span> <span class="toc-text">2 打开binder驱动（open_driver()）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、-获取servicManager"><span class="toc-number">2.2.</span> <span class="toc-text">二、 获取servicManager</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-BpBinder-cpp"><span class="toc-number">2.2.1.</span> <span class="toc-text">1. BpBinder.cpp</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-障眼法——interface-cast"><span class="toc-number">2.2.2.</span> <span class="toc-text">2. 障眼法——interface_cast</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-IServiceManager"><span class="toc-number">2.2.3.</span> <span class="toc-text">3. IServiceManager</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#（1）定义业务逻辑"><span class="toc-number">2.2.3.1.</span> <span class="toc-text">（1）定义业务逻辑</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#（2）业务与通信的挂钩"><span class="toc-number">2.2.3.2.</span> <span class="toc-text">（2）业务与通信的挂钩</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-IServiceManager家族"><span class="toc-number">2.2.4.</span> <span class="toc-text">4 IServiceManager家族</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、-注册MediaPlayerService"><span class="toc-number">2.3.</span> <span class="toc-text">三、 注册MediaPlayerService</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-“劳者一份”的IPCThreadState"><span class="toc-number">2.3.1.</span> <span class="toc-text">1 “劳者一份”的IPCThreadState</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-勤劳的transact"><span class="toc-number">2.3.2.</span> <span class="toc-text">2 勤劳的transact</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-talkWithDriver（）"><span class="toc-number">2.3.3.</span> <span class="toc-text">3 talkWithDriver（）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-StartThread-Pool和join-Thread-Pool"><span class="toc-number">2.4.</span> <span class="toc-text">4 StartThread Pool和join Thread Pool</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-创造劳动力——startThreadPool"><span class="toc-number">2.4.1.</span> <span class="toc-text">1.创造劳动力——startThreadPool()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2万众归一-joinThreadPool"><span class="toc-number">2.4.2.</span> <span class="toc-text">2万众归一  joinThreadPool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-有几个线程在服务"><span class="toc-number">2.4.3.</span> <span class="toc-text">3. 有几个线程在服务</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#特殊的server端，ServiceManager"><span class="toc-number">3.</span> <span class="toc-text">特殊的server端，ServiceManager</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-serviceManager-原理"><span class="toc-number">3.1.</span> <span class="toc-text">1. serviceManager 原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-ServiceManager的入口函数"><span class="toc-number">3.1.1.</span> <span class="toc-text">1 ServiceManager的入口函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-打开Binder设备"><span class="toc-number">3.1.2.</span> <span class="toc-text">2 打开Binder设备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-成为老大"><span class="toc-number">3.1.3.</span> <span class="toc-text">3. 成为老大</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-死磕Binder"><span class="toc-number">3.1.4.</span> <span class="toc-text">4.死磕Binder</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-集中处理"><span class="toc-number">3.1.5.</span> <span class="toc-text">5 集中处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-服务的注册"><span class="toc-number">3.2.</span> <span class="toc-text">2 服务的注册</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1不是什么都可以注册的"><span class="toc-number">3.2.1.</span> <span class="toc-text">1不是什么都可以注册的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-添加服务项"><span class="toc-number">3.2.2.</span> <span class="toc-text">2. 添加服务项</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MediaPlayerService和它的Client"><span class="toc-number">4.</span> <span class="toc-text">MediaPlayerService和它的Client</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#查询ServiceManager"><span class="toc-number">4.1.</span> <span class="toc-text">查询ServiceManager</span></a></li></ol></li></ol>
    </div>
    
    <div class="back-top iconfont-archer">&#xe639;</div>
    <div class="sidebar sidebar-hide">
    <ul class="sidebar-tabs sidebar-tabs-active-0">
        <li class="sidebar-tab-archives"><span class="iconfont-archer">&#xe67d;</span><span class="tab-name">Archive</span></li>
        <li class="sidebar-tab-tags"><span class="iconfont-archer">&#xe61b;</span><span class="tab-name">Tag</span></li>
        <li class="sidebar-tab-categories"><span class="iconfont-archer">&#xe666;</span><span class="tab-name">Cate</span></li>
    </ul>
    <div class="sidebar-content sidebar-content-show-archive">
          <div class="sidebar-panel-archives">
    <!-- 在ejs中将archive按照时间排序 -->
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <div class="total-and-search">
        <div class="total-archive">
        Total : 36
        </div>
        <!-- search  -->
        
    </div>
    
    <div class="post-archive">
    
    
    
    
    <div class="archive-year"> 2019 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/21</span><a class="archive-post-title" href= "/2019/10/21/为何fork两次可以避免僵尸进程/" >为何fork两次可以避免僵尸进程</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/14</span><a class="archive-post-title" href= "/2019/01/14/mac 搭建Go开发环境/" >mac 搭建Go开发环境</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/08</span><a class="archive-post-title" href= "/2019/01/08/代码生成插件说明/" >代码生成插件说明</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2018 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/19</span><a class="archive-post-title" href= "/2018/11/19/深度学习课程笔记 第二周 优化算法/" >深度学习课程笔记 第二周 优化算法</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/15</span><a class="archive-post-title" href= "/2018/11/15/深度学习课程笔记 第一周 深度学习的实践层面/" >深度学习课程笔记 第一周 深度学习的实践层面</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/11</span><a class="archive-post-title" href= "/2018/11/11/机器学习算法的演进/" >机器学习算法的演进</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/21</span><a class="archive-post-title" href= "/2018/08/21/八月份学习计划/" >下个阶段的学习计划整理</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/16</span><a class="archive-post-title" href= "/2018/08/16/一些知识点总结/" >一些知识点总结</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/24</span><a class="archive-post-title" href= "/2018/06/24/从一次native端的IPC流程理解binder/" >从一次native端的IPC流程理解binder</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/16</span><a class="archive-post-title" href= "/2018/06/16/《现代艺术150年》未影印作品2/" >《现代艺术150年》未影印作品2</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/08</span><a class="archive-post-title" href= "/2018/06/08/深度学习1-反向传播/" >深度学习1-反向传播</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/02</span><a class="archive-post-title" href= "/2018/06/02/《现代艺术150年》未影印作品1/" >《现代艺术150年》未影印作品1</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/02</span><a class="archive-post-title" href= "/2018/06/02/从驱动角度理解binder/" >从驱动角度理解binder</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/02</span><a class="archive-post-title" href= "/2018/06/02/理解Liunx的FD与Inode/" >理解Linux的FD与Inode</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/30</span><a class="archive-post-title" href= "/2018/05/30/Docker入门/" >Docker入门</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/29</span><a class="archive-post-title" href= "/2018/05/29/Binder的设计架构/" >Binder的设计架构</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/23</span><a class="archive-post-title" href= "/2018/05/23/JAVA的垃圾回收策略（二）/" >JAVA的垃圾回收策略（二）</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/17</span><a class="archive-post-title" href= "/2018/05/17/JAVA的垃圾回收策略/" >JAVA的垃圾回收策略</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/14</span><a class="archive-post-title" href= "/2018/05/14/hexo+icarus/" >hexo+icarus</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/13</span><a class="archive-post-title" href= "/2018/05/13/六大设计模式/" >六大设计模式</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/10</span><a class="archive-post-title" href= "/2018/05/10/AnimatedVectorDrawable 总结/" >AnimatedVectorDrawable总结</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/12</span><a class="archive-post-title" href= "/2018/04/12/Rxjava2操作符/" >Rxjava2操作符</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/16</span><a class="archive-post-title" href= "/2018/03/16/Socket未释放导致的句柄泄露/" >socket未释放导致句柄泄露</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/13</span><a class="archive-post-title" href= "/2018/03/13/线程阻塞和中断的四种方式/" >线程阻塞和中断的四种方式</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2017 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/11</span><a class="archive-post-title" href= "/2017/12/11/mac搭建PyQt5环境/" >mac搭建Pyqt5环境</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/11</span><a class="archive-post-title" href= "/2017/12/11/MQTT相关/" >MQTT相关总结</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/12</span><a class="archive-post-title" href= "/2017/10/12/view 绘制机制/" >view 绘制机制</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/07</span><a class="archive-post-title" href= "/2017/09/07/Linux 用户空间 内核空间/" >linux用户控件、内和空间</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/16</span><a class="archive-post-title" href= "/2017/08/16/webrtc 音频/" >webrtc音频总结</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/18</span><a class="archive-post-title" href= "/2017/06/18/linux的地址映射/" >linux的地址映射</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/07</span><a class="archive-post-title" href= "/2017/05/07/MK语法规范/" >MK语法规范</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/11</span><a class="archive-post-title" href= "/2017/04/11/Binder 进程间通讯机制/" >Binder通讯机制</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/05</span><a class="archive-post-title" href= "/2017/04/05/编译系统环境初始化过程/" >编译系统环境初始化过程</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/15</span><a class="archive-post-title" href= "/2017/03/15/添加SE安全策略/" >添加SE安全策略</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2016 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/03</span><a class="archive-post-title" href= "/2016/08/03/抓包工具 - Fiddler（如何捕获Android数据包）/" >fiddler抓android数据包</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/04</span><a class="archive-post-title" href= "/2016/07/04/Linux vi命令使用方法/" >Linux vi用法</a>
        </li>
    
    </div>
  </div>
        <div class="sidebar-panel-tags">
    <div class="sidebar-tags-name">
    
        <span class="sidebar-tag-name" data-tags="句柄animation"><span class="iconfont-archer">&#xe606;</span>句柄animation</span>
    
        <span class="sidebar-tag-name" data-tags="AnimatedVectorDrawable"><span class="iconfont-archer">&#xe606;</span>AnimatedVectorDrawable</span>
    
        <span class="sidebar-tag-name" data-tags="android"><span class="iconfont-archer">&#xe606;</span>android</span>
    
        <span class="sidebar-tag-name" data-tags="Binder"><span class="iconfont-archer">&#xe606;</span>Binder</span>
    
        <span class="sidebar-tag-name" data-tags="java"><span class="iconfont-archer">&#xe606;</span>java</span>
    
        <span class="sidebar-tag-name" data-tags="垃圾回收"><span class="iconfont-archer">&#xe606;</span>垃圾回收</span>
    
        <span class="sidebar-tag-name" data-tags="docker"><span class="iconfont-archer">&#xe606;</span>docker</span>
    
        <span class="sidebar-tag-name" data-tags="容器"><span class="iconfont-archer">&#xe606;</span>容器</span>
    
        <span class="sidebar-tag-name" data-tags="linux命令"><span class="iconfont-archer">&#xe606;</span>linux命令</span>
    
        <span class="sidebar-tag-name" data-tags="linux"><span class="iconfont-archer">&#xe606;</span>linux</span>
    
        <span class="sidebar-tag-name" data-tags="编译"><span class="iconfont-archer">&#xe606;</span>编译</span>
    
        <span class="sidebar-tag-name" data-tags="mk"><span class="iconfont-archer">&#xe606;</span>mk</span>
    
        <span class="sidebar-tag-name" data-tags="mqtt"><span class="iconfont-archer">&#xe606;</span>mqtt</span>
    
        <span class="sidebar-tag-name" data-tags="开源框架"><span class="iconfont-archer">&#xe606;</span>开源框架</span>
    
        <span class="sidebar-tag-name" data-tags="rxjava2"><span class="iconfont-archer">&#xe606;</span>rxjava2</span>
    
        <span class="sidebar-tag-name" data-tags="句柄泄露"><span class="iconfont-archer">&#xe606;</span>句柄泄露</span>
    
        <span class="sidebar-tag-name" data-tags="bugs"><span class="iconfont-archer">&#xe606;</span>bugs</span>
    
        <span class="sidebar-tag-name" data-tags="hexo"><span class="iconfont-archer">&#xe606;</span>hexo</span>
    
        <span class="sidebar-tag-name" data-tags="后端技术"><span class="iconfont-archer">&#xe606;</span>后端技术</span>
    
        <span class="sidebar-tag-name" data-tags="go"><span class="iconfont-archer">&#xe606;</span>go</span>
    
        <span class="sidebar-tag-name" data-tags="webrtc"><span class="iconfont-archer">&#xe606;</span>webrtc</span>
    
        <span class="sidebar-tag-name" data-tags="现代艺术150年"><span class="iconfont-archer">&#xe606;</span>现代艺术150年</span>
    
        <span class="sidebar-tag-name" data-tags="备忘录"><span class="iconfont-archer">&#xe606;</span>备忘录</span>
    
        <span class="sidebar-tag-name" data-tags="python"><span class="iconfont-archer">&#xe606;</span>python</span>
    
        <span class="sidebar-tag-name" data-tags="qt"><span class="iconfont-archer">&#xe606;</span>qt</span>
    
        <span class="sidebar-tag-name" data-tags="plugins"><span class="iconfont-archer">&#xe606;</span>plugins</span>
    
        <span class="sidebar-tag-name" data-tags="音视频"><span class="iconfont-archer">&#xe606;</span>音视频</span>
    
        <span class="sidebar-tag-name" data-tags="学习计划"><span class="iconfont-archer">&#xe606;</span>学习计划</span>
    
        <span class="sidebar-tag-name" data-tags="设计模式"><span class="iconfont-archer">&#xe606;</span>设计模式</span>
    
        <span class="sidebar-tag-name" data-tags="抓包"><span class="iconfont-archer">&#xe606;</span>抓包</span>
    
        <span class="sidebar-tag-name" data-tags="机器学习"><span class="iconfont-archer">&#xe606;</span>机器学习</span>
    
        <span class="sidebar-tag-name" data-tags="Tensorflow"><span class="iconfont-archer">&#xe606;</span>Tensorflow</span>
    
        <span class="sidebar-tag-name" data-tags="SEAndroid"><span class="iconfont-archer">&#xe606;</span>SEAndroid</span>
    
        <span class="sidebar-tag-name" data-tags="多线程"><span class="iconfont-archer">&#xe606;</span>多线程</span>
    
        <span class="sidebar-tag-name" data-tags="aosp"><span class="iconfont-archer">&#xe606;</span>aosp</span>
    
    </div>
    <div class="iconfont-archer sidebar-tags-empty">&#xe678;</div>
    <div class="tag-load-fail" style="display: none; color: #ccc; font-size: 0.6rem;">
    缺失模块。<br/>
    1、请确保node版本大于6.2<br/>
    2、在博客根目录（注意不是archer根目录）执行以下命令：<br/>
    <span style="color: #f75357; font-size: 1rem; line-height: 2rem;">npm i hexo-generator-json-content --save</span><br/>
    3、在根目录_config.yml里添加配置：
    <pre style="color: #787878; font-size: 0.6rem;">
jsonContent:
  meta: false
  pages: false
  posts:
    title: true
    date: true
    path: true
    text: false
    raw: false
    content: false
    slug: false
    updated: false
    comments: false
    link: false
    permalink: false
    excerpt: false
    categories: true
    tags: true</pre>
    </div> 
    <div class="sidebar-tags-list"></div>
</div>
        <div class="sidebar-panel-categories">
    <div class="sidebar-categories-name">
    
        <span class="sidebar-category-name" data-categories="CoolUI"><span class="iconfont-archer">&#xe60a;</span>CoolUI</span>
    
        <span class="sidebar-category-name" data-categories="Android"><span class="iconfont-archer">&#xe60a;</span>Android</span>
    
        <span class="sidebar-category-name" data-categories="java基础"><span class="iconfont-archer">&#xe60a;</span>java基础</span>
    
        <span class="sidebar-category-name" data-categories="容器技术"><span class="iconfont-archer">&#xe60a;</span>容器技术</span>
    
        <span class="sidebar-category-name" data-categories="Linux"><span class="iconfont-archer">&#xe60a;</span>Linux</span>
    
        <span class="sidebar-category-name" data-categories="AOSP"><span class="iconfont-archer">&#xe60a;</span>AOSP</span>
    
        <span class="sidebar-category-name" data-categories="MQTT"><span class="iconfont-archer">&#xe60a;</span>MQTT</span>
    
        <span class="sidebar-category-name" data-categories="bug记录"><span class="iconfont-archer">&#xe60a;</span>bug记录</span>
    
        <span class="sidebar-category-name" data-categories="备忘录"><span class="iconfont-archer">&#xe60a;</span>备忘录</span>
    
        <span class="sidebar-category-name" data-categories="后端技术"><span class="iconfont-archer">&#xe60a;</span>后端技术</span>
    
        <span class="sidebar-category-name" data-categories="webrtc"><span class="iconfont-archer">&#xe60a;</span>webrtc</span>
    
        <span class="sidebar-category-name" data-categories="python"><span class="iconfont-archer">&#xe60a;</span>python</span>
    
        <span class="sidebar-category-name" data-categories="IDEA"><span class="iconfont-archer">&#xe60a;</span>IDEA</span>
    
        <span class="sidebar-category-name" data-categories="学习计划"><span class="iconfont-archer">&#xe60a;</span>学习计划</span>
    
        <span class="sidebar-category-name" data-categories="机器学习"><span class="iconfont-archer">&#xe60a;</span>机器学习</span>
    
    </div>
    <div class="iconfont-archer sidebar-categories-empty">&#xe678;</div>
    <div class="sidebar-categories-list"></div>
</div>
    </div>
</div> 
    <script>
    var siteMeta = {
        root: "/",
        author: "QuincyJiang"
    }
</script>
    <!-- CDN failover -->
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
    <script type="text/javascript">
        if (typeof window.$ === 'undefined')
        {
            console.warn('jquery load from jsdelivr failed, will load local script')
            document.write('<script src="/lib/jquery.min.js">\x3C/script>')
        }
    </script>
    <script src="/scripts/main.js"></script>
    <!-- algolia -->
    
    <!-- busuanzi  -->
    
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    <!-- CNZZ  -->
    
    </div>
    <!-- async load share.js -->
    
        <script src="/scripts/share.js" async></script>    
     
    </body>
</html>


