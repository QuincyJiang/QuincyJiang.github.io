{"meta":{"title":"QuincyJiang","subtitle":null,"description":null,"author":"QuincyJiang","url":"http://yoursite.com"},"pages":[{"title":"About","date":"2018-05-06T06:35:28.393Z","updated":"2018-05-06T06:35:28.382Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"Name： Quincyjiang Male 24 (1993/08/19) Major：ICS（Information and computer science） School：SDU Location：Guangzhou，China Contact： &#x31;&#48;&#x38;&#51;&#x38;&#x37;&#x33;&#50;&#55;&#x32;&#x40;&#x71;&#x71;&#x2e;&#99;&#111;&#x6d; &#x6a;&#105;&#97;&#110;&#103;&#57;&#x33;&#48;&#x36;&#x32;&#x35;&#64;&#x67;&#x6d;&#97;&#105;&#x6c;&#46;&#99;&#111;&#109; Intro：文艺码农，胶片玩家，代码洁癖。 Language Java Android Python C/C++"},{"title":"Categories","date":"2018-05-06T05:42:33.728Z","updated":"2018-05-05T15:10:05.116Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2018-05-06T06:09:35.982Z","updated":"2018-05-05T15:10:05.117Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Rxjava2操作符","slug":"Rxjava2操作符","date":"2018-04-12T12:20:50.000Z","updated":"2018-05-06T13:17:58.015Z","comments":true,"path":"2018/04/12/Rxjava2操作符/","link":"","permalink":"http://yoursite.com/2018/04/12/Rxjava2操作符/","excerpt":"","text":"Rxjava2 操作符 Createcreate操作符，主要用于产生一个 Obserable 被观察者对象，因为Observable主要用于发射事件，Observer主要用于消费时间，所以以后统一把被观察者 Observable 称为发射器（上游事件），观察者 Observer 称为接收器（下游事件）。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; mRxOperatorsText.append(&quot;Observable emit 1&quot; + &quot;\\n&quot;); Log.e(TAG, &quot;Observable emit 1&quot; + &quot;\\n&quot;); e.onNext(1); mRxOperatorsText.append(&quot;Observable emit 2&quot; + &quot;\\n&quot;); Log.e(TAG, &quot;Observable emit 2&quot; + &quot;\\n&quot;); e.onNext(2); mRxOperatorsText.append(&quot;Observable emit 3&quot; + &quot;\\n&quot;); Log.e(TAG, &quot;Observable emit 3&quot; + &quot;\\n&quot;); e.onNext(3); e.onComplete(); mRxOperatorsText.append(&quot;Observable emit 4&quot; + &quot;\\n&quot;); Log.e(TAG, &quot;Observable emit 4&quot; + &quot;\\n&quot; ); e.onNext(4); &#125; &#125;).subscribe(new Observer&lt;Integer&gt;() &#123; private int i; private Disposable mDisposable; @Override public void onSubscribe(@NonNull Disposable d) &#123; mRxOperatorsText.append(&quot;onSubscribe : &quot; + d.isDisposed() + &quot;\\n&quot;); Log.e(TAG, &quot;onSubscribe : &quot; + d.isDisposed() + &quot;\\n&quot; ); mDisposable = d; &#125; @Override public void onNext(@NonNull Integer integer) &#123; mRxOperatorsText.append(&quot;onNext : value : &quot; + integer + &quot;\\n&quot;); Log.e(TAG, &quot;onNext : value : &quot; + integer + &quot;\\n&quot; ); i++; if (i == 2) &#123; // 在RxJava 2.x 中，新增的Disposable可以做到切断的操作，让Observer观察者不再接收上游事件 mDisposable.dispose(); mRxOperatorsText.append(&quot;onNext : isDisposable : &quot; + mDisposable.isDisposed() + &quot;\\n&quot;); Log.e(TAG, &quot;onNext : isDisposable : &quot; + mDisposable.isDisposed() + &quot;\\n&quot;); &#125; &#125; @Override public void onError(@NonNull Throwable e) &#123; mRxOperatorsText.append(&quot;onError : value : &quot; + e.getMessage() + &quot;\\n&quot;); Log.e(TAG, &quot;onError : value : &quot; + e.getMessage() + &quot;\\n&quot; ); &#125; @Override public void onComplete() &#123; mRxOperatorsText.append(&quot;onComplete&quot; + &quot;\\n&quot;); Log.e(TAG, &quot;onComplete&quot; + &quot;\\n&quot; ); &#125; &#125;); MapMap 基本算是 RxJava 中一个最简单的操作符了，熟悉 RxJava 1.x 的知道，它的作用是对发射时间发送的每一个事件应用一个函数，是的每一个事件都按照指定的函数去变化，而在 2.x 中它的作用几乎一致。map 基本作用就是将一个 Observable 通过某种函数关系，转换为另一种 Observable，下面例子中就是把我们的 Integer 数据变成了 String 类型。从Log日志显而易见。 12345678910111213141516171819Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; e.onNext(1); e.onNext(2); e.onNext(3); &#125; &#125;).map(new Function&lt;Integer, String&gt;() &#123; @Override public String apply(@NonNull Integer integer) throws Exception &#123; return &quot;This is result &quot; + integer; &#125; &#125;).subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(@NonNull String s) throws Exception &#123; mRxOperatorsText.append(&quot;accept : &quot; + s +&quot;\\n&quot;); Log.e(TAG, &quot;accept : &quot; + s +&quot;\\n&quot; ); &#125; &#125;); Zip zip 专用于合并事件，该合并不是连接（连接操作符后面会说），而是两两配对，也就意味着，最终配对出的 Observable 发射事件数目只和少的那个相同。 12345678910111213141516Observable.zip(getStringObservable(), getIntegerObservable(), new BiFunction&lt;String, Integer, String&gt;() &#123; @Override public String apply(@NonNull String s, @NonNull Integer integer) throws Exception &#123; return s + integer; &#125; &#125;).subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(@NonNull String s) throws Exception &#123; mRxOperatorsText.append(&quot;zip : accept : &quot; + s + &quot;\\n&quot;); Log.e(TAG, &quot;zip : accept : &quot; + s + &quot;\\n&quot;); &#125; &#125;); /***注： getStringObservable 返回A B C ，getIntegerObservable返回的是1 2 3 4 5 */ 输出结果： zip 组合事件的过程就是分别从发射器 A 和发射器 B 各取出一个事件来组合，并且一个事件只能被使用一次，组合的顺序是严格按照事件发送的顺序来进行的，所以上面截图中，可以看到，1 永远是和 A 结合的，2 永远是和 B 结合的。 最终接收器收到的事件数量是和发送器发送事件最少的那个发送器的发送事件数目相同上面的例子就可以看出 结合后的事件数量是3 Concat 因为zip连接事件有上述两个特点： 121. 分别从两个发射器取一个事件组合成新事件，且事件组合顺序与发射顺序严格相同 2. 最终接受事件数量与原始发射器数量最小的那个相同 对于单一的把两个发射器连接成一个发射器，可以尝试Contact 12345678Observable.concat(Observable.just(1,2,3), Observable.just(4,5,6)) .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(@NonNull Integer integer) throws Exception &#123; mRxOperatorsText.append(&quot;concat : &quot;+ integer + &quot;\\n&quot;); Log.e(TAG, &quot;concat : &quot;+ integer + &quot;\\n&quot; ); &#125; &#125;); **输出结果 123456** FlatMap FlatMap ，它可以把一个发射器 Observable 通过某种方法转换为多个 Observables，然后再把这些分散的 Observables装进一个单一的发射器 Observable。但有个需要注意的是，flatMap ==并不能保证事件的顺序==，如果需要保证，需要用到我们下面要讲的 ConcatMap。 123456789101112131415161718192021222324252627Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; e.onNext(1); e.onNext(2); e.onNext(3); &#125; &#125;).flatMap(new Function&lt;Integer, ObservableSource&lt;String&gt;&gt;() &#123; @Override public ObservableSource&lt;String&gt; apply(@NonNull Integer integer) throws Exception &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 3; i++) &#123; list.add(&quot;I am value &quot; + integer); &#125; int delayTime = (int) (1 + Math.random() * 10); return Observable.fromIterable(list).delay(delayTime, TimeUnit.MILLISECONDS); // 使用delay操作符，做一个小延时操作，而查看 Log 日志也表明，FlatMap是无序的。 &#125; &#125;).subscribeOn(Schedulers.newThread()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(@NonNull String s) throws Exception &#123; Log.e(TAG, &quot;flatMap : accept : &quot; + s + &quot;\\n&quot;); mRxOperatorsText.append(&quot;flatMap : accept : &quot; + s + &quot;\\n&quot;); &#125; &#125;); 输出 12,3,3,3,2,2,1,1 concatMap 上面其实就说了，concatMap 与 FlatMap 的唯一区别就是 concatMap 保证了顺序，所以，我们就直接把 flatMap 替换为 concatMap 验证。 1234567891011121314151617181920212223242526Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; e.onNext(1); e.onNext(2); e.onNext(3); &#125; &#125;).concatMap(new Function&lt;Integer, ObservableSource&lt;String&gt;&gt;() &#123; @Override public ObservableSource&lt;String&gt; apply(@NonNull Integer integer) throws Exception &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 3; i++) &#123; list.add(&quot;I am value &quot; + integer); &#125; int delayTime = (int) (1 + Math.random() * 10); return Observable.fromIterable(list).delay(delayTime, TimeUnit.MILLISECONDS); &#125; &#125;).subscribeOn(Schedulers.newThread()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(@NonNull String s) throws Exception &#123; Log.e(TAG, &quot;flatMap : accept : &quot; + s + &quot;\\n&quot;); mRxOperatorsText.append(&quot;flatMap : accept : &quot; + s + &quot;\\n&quot;); &#125; &#125;); 输出结果： 11 1 1 2 2 2 3 3 3 distinct作用是去重，输入11 1 2 2 3 4 5 输出11 2 3 4 5 12345678910Observable.just(1, 1, 1, 2, 2, 3, 4, 5) .distinct() .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(@NonNull Integer integer) throws Exception &#123; mRxOperatorsText.append(&quot;distinct : &quot; + integer + &quot;\\n&quot;); Log.e(TAG, &quot;distinct : &quot; + integer + &quot;\\n&quot;); &#125; &#125;); FilterFilter 过滤器，可以接受一个参数，让其过滤掉不符合我们条件的值 12345678910111213Observable.just(1, 20, 65, -5, 7, 19) .filter(new Predicate&lt;Integer&gt;() &#123; @Override public boolean test(@NonNull Integer integer) throws Exception &#123; return integer &gt;= 10; &#125; &#125;).subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(@NonNull Integer integer) throws Exception &#123; mRxOperatorsText.append(&quot;filter : &quot; + integer + &quot;\\n&quot;); Log.e(TAG, &quot;filter : &quot; + integer + &quot;\\n&quot;); &#125; &#125;); 输出大于10的事件 120 65 19 buffer buffer 操作符接受两个参数，buffer(count,skip)作用是将 Observable 中的数据按 skip (步长) 分成最大不超过 count 的 buffer ，然后生成一个 Observable 。也就是说 ==按照步长，将原始事件 分成一组一组 重新发射出去== 1234567891011121314151617Observable.just(1, 2, 3, 4, 5) .buffer(3, 2) .subscribe(new Consumer&lt;List&lt;Integer&gt;&gt;() &#123; @Override public void accept(@NonNull List&lt;Integer&gt; integers) throws Exception &#123; mRxOperatorsText.append(&quot;buffer size : &quot; + integers.size() + &quot;\\n&quot;); Log.e(TAG, &quot;buffer size : &quot; + integers.size() + &quot;\\n&quot;); mRxOperatorsText.append(&quot;buffer value : &quot;); Log.e(TAG, &quot;buffer value : &quot; ); for (Integer i : integers) &#123; mRxOperatorsText.append(i + &quot;&quot;); Log.e(TAG, i + &quot;&quot;); &#125; mRxOperatorsText.append(&quot;\\n&quot;); Log.e(TAG, &quot;\\n&quot;); &#125; &#125;); 输出结果 123456size 3value 1 2 3 size 3value 3 4 5 size 1 value 5 timer timer，相当于一个定时任务。在 1.x 中它还可以执行间隔逻辑，但在 2.x 中此功能被交给了 interval。但需要注意的是，timer 和 interval 均==默认在新线程==。==执行timer方法，将使得接受延时== 123456789101112mRxOperatorsText.append(&quot;timer start : &quot; + TimeUtil.getNowStrTime() + &quot;\\n&quot;); Log.e(TAG, &quot;timer start : &quot; + TimeUtil.getNowStrTime() + &quot;\\n&quot;); Observable.timer(2, TimeUnit.SECONDS) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) // timer 默认在新线程，所以需要切换回主线程 .subscribe(new Consumer&lt;Long&gt;() &#123; @Override public void accept(@NonNull Long aLong) throws Exception &#123; mRxOperatorsText.append(&quot;timer :&quot; + aLong + &quot; at &quot; + TimeUtil.getNowStrTime() + &quot;\\n&quot;); Log.e(TAG, &quot;timer :&quot; + aLong + &quot; at &quot; + TimeUtil.getNowStrTime() + &quot;\\n&quot;); &#125; &#125;); 当我们两次点击按钮触发这个事件的时候，接收被延迟了 2 秒。 interval 如同我们上面可说，interval 操作符用于间隔时间执行某个操作，其接受三个参数，分别是第一次发送延迟，间隔时间，时间单位。 123456789101112mRxOperatorsText.append(&quot;interval start : &quot; + TimeUtil.getNowStrTime() + &quot;\\n&quot;); Log.e(TAG, &quot;interval start : &quot; + TimeUtil.getNowStrTime() + &quot;\\n&quot;); Observable.interval(3,2, TimeUnit.SECONDS) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) // 由于interval默认在新线程，所以我们应该切回主线程 .subscribe(new Consumer&lt;Long&gt;() &#123; @Override public void accept(@NonNull Long aLong) throws Exception &#123; mRxOperatorsText.append(&quot;interval :&quot; + aLong + &quot; at &quot; + TimeUtil.getNowStrTime() + &quot;\\n&quot;); Log.e(TAG, &quot;interval :&quot; + aLong + &quot; at &quot; + TimeUtil.getNowStrTime() + &quot;\\n&quot;); &#125; &#125;); 执行结果是第一次延迟了 3 秒后接收到，后面每次间隔了 2 秒。然而，由于我们这个是间隔执行，所以当我们的Activity 都销毁的时候，==实际上这个操作还依然在进行==，查看源码发现，我们1subscribe(Cousumer&lt;? super T&gt; onNext) 返回的是Disposable，Disposable 可以用来解除绑定。 1234567891011121314151617181920212223@Override protected void doSomething() &#123; mRxOperatorsText.append(&quot;interval start : &quot; + TimeUtil.getNowStrTime() + &quot;\\n&quot;); Log.e(TAG, &quot;interval start : &quot; + TimeUtil.getNowStrTime() + &quot;\\n&quot;); mDisposable = Observable.interval(3, 2, TimeUnit.SECONDS) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) // 由于interval默认在新线程，所以我们应该切回主线程 .subscribe(new Consumer&lt;Long&gt;() &#123; @Override public void accept(@NonNull Long aLong) throws Exception &#123; mRxOperatorsText.append(&quot;interval :&quot; + aLong + &quot; at &quot; + TimeUtil.getNowStrTime() + &quot;\\n&quot;); Log.e(TAG, &quot;interval :&quot; + aLong + &quot; at &quot; + TimeUtil.getNowStrTime() + &quot;\\n&quot;); &#125; &#125;); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); if (mDisposable != null &amp;&amp; !mDisposable.isDisposed()) &#123; mDisposable.dispose(); &#125; &#125; doOnNext doOnNext 它的作用是让订阅者在接收到数据之前做一些其他操作。假如我们在获取到数据之前想先保存一下它，无疑我们可以这样实现。 1234567891011121314Observable.just(1, 2, 3, 4) .doOnNext(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(@NonNull Integer integer) throws Exception &#123; mRxOperatorsText.append(&quot;doOnNext 保存 &quot; + integer + &quot;成功&quot; + &quot;\\n&quot;); Log.e(TAG, &quot;doOnNext 保存 &quot; + integer + &quot;成功&quot; + &quot;\\n&quot;); &#125; &#125;).subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(@NonNull Integer integer) throws Exception &#123; mRxOperatorsText.append(&quot;doOnNext :&quot; + integer + &quot;\\n&quot;); Log.e(TAG, &quot;doOnNext :&quot; + integer + &quot;\\n&quot;); &#125; &#125;); skip skip ，接受一个 long 型参数 count ，代表跳过 count 个数目开始接收。 123456789Observable.just(1,2,3,4,5) .skip(2) .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(@NonNull Integer integer) throws Exception &#123; mRxOperatorsText.append(&quot;skip : &quot;+integer + &quot;\\n&quot;); Log.e(TAG, &quot;skip : &quot;+integer + &quot;\\n&quot;); &#125; &#125;); 输出： 13 4 5 take take，接受一个 long 型参数 count ，代表至多接收 count 个数据。 123456789Flowable.fromArray(1,2,3,4,5) .take(2) .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(@NonNull Integer integer) throws Exception &#123; mRxOperatorsText.append(&quot;take : &quot;+integer + &quot;\\n&quot;); Log.e(TAG, &quot;accept: take : &quot;+integer + &quot;\\n&quot; ); &#125; &#125;); 输出： 11 2 just just一个简单的发射器依次调用 onNext() 方法。 12345678910Observable.just(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(@NonNull String s) throws Exception &#123; mRxOperatorsText.append(&quot;accept : onNext : &quot; + s + &quot;\\n&quot;); Log.e(TAG,&quot;accept : onNext : &quot; + s + &quot;\\n&quot; ); &#125; &#125;); 输出： 11 2 3 Single 顾名思义，Single 只会接收一个参数，也就是只发射一次事件，他的而 SingleObserver 只会调用 onError() 或者 onSuccess()。 12345678910111213141516171819Single.just(new Random().nextInt()) .subscribe(new SingleObserver&lt;Integer&gt;() &#123; @Override public void onSubscribe(@NonNull Disposable d) &#123; &#125; @Override public void onSuccess(@NonNull Integer integer) &#123; mRxOperatorsText.append(&quot;single : onSuccess : &quot;+integer+&quot;\\n&quot;); Log.e(TAG, &quot;single : onSuccess : &quot;+integer+&quot;\\n&quot; ); &#125; @Override public void onError(@NonNull Throwable e) &#123; mRxOperatorsText.append(&quot;single : onError : &quot;+e.getMessage()+&quot;\\n&quot;); Log.e(TAG, &quot;single : onError : &quot;+e.getMessage()+&quot;\\n&quot;); &#125; &#125;); 输出： 1onSuccess distinct 去重操作符，简单的作用就是去重。 123456789Observable.just(1, 1, 1, 2, 2, 3, 4, 5) .distinct() .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(@NonNull Integer integer) throws Exception &#123; mRxOperatorsText.append(&quot;distinct : &quot; + integer + &quot;\\n&quot;); Log.e(TAG, &quot;distinct : &quot; + integer + &quot;\\n&quot;); &#125; &#125;); 输出： 11 2 3 4 5 发射器发送的事件，在接收的时候被去重了。 debounce 去除发送频率过快的项，可以用来过滤点击过快的点击事件 1234567891011121314151617181920212223242526Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; // send events with simulated time wait emitter.onNext(1); // skip Thread.sleep(400); emitter.onNext(2); // deliver Thread.sleep(505); emitter.onNext(3); // skip Thread.sleep(100); emitter.onNext(4); // deliver Thread.sleep(605); emitter.onNext(5); // deliver Thread.sleep(510); emitter.onComplete(); &#125; &#125;).debounce(500, TimeUnit.MILLISECONDS) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(@NonNull Integer integer) throws Exception &#123; mRxOperatorsText.append(&quot;debounce :&quot; + integer + &quot;\\n&quot;); Log.e(TAG,&quot;debounce :&quot; + integer + &quot;\\n&quot;); &#125; &#125;); 输出： 12 4 5 代码很清晰，去除发送间隔时间小于 500 毫秒的发射事件，所以 1 和 3 被去掉了。 defer ==直到有订阅，才会创建Observable==具有延时的效果。 代码对比如下： 12345678910a = 10;Observable&lt;String&gt; o1 = Observable.just(&quot;just result: &quot; + a);a = 12;o1.subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String t) &#123; System.out.println(t); &#125;&#125;); 输出： 1just result: 10 可见：在使用just的时候，便创建了Observable对象，随后改变a的值，并不会改变Observable对象中的值。 使用defer 123456789101112131415161718a = 12;Observable&lt;String&gt; o2 = Observable.defer(new Func0&lt;Observable&lt;String&gt;&gt;() &#123; @Override public Observable&lt;String&gt; call() &#123; return Observable.just(&quot;defer result: &quot; + a); &#125;&#125;);a = 20;o2.subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String t) &#123; System.out.println(t); &#125; &#125;); 输出： 1defer result: 20 可见：在a=12时，虽然定义了一个Observable，但是并没有创建这个示例，当a=20时，这时候订阅这个Observable，则开始创建，所以对象中的a为20. last last 操作符仅取出可观察到的最后一个值，或者是满足某些条件的最后一项。 123456789Observable.just(1, 2, 3) .last() .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(@NonNull Integer integer) throws Exception &#123; mRxOperatorsText.append(&quot;last : &quot; + integer + &quot;\\n&quot;); Log.e(TAG, &quot;last : &quot; + integer + &quot;\\n&quot;); &#125; &#125;); 输出：13 merge merge 顾名思义 在 Rx 操作符中，merge 的作用是把多个 Observable 结合起来，接受可变参数，也支持迭代器集合。注意它和 concat 的区别在于，==不用等到 发射器 A 发送完所有的事件再进行发射器 B 的发送==。 12345678Observable.merge(Observable.just(1, 2), Observable.just(3, 4, 5)) .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(@NonNull Integer integer) throws Exception &#123; mRxOperatorsText.append(&quot;merge :&quot; + integer + &quot;\\n&quot;); Log.e(TAG, &quot;accept: merge :&quot; + integer + &quot;\\n&quot; ); &#125; &#125;); 输出： 11 2 3 4 5 reduce reduce 操作符每次用一个方法处理一个值，可以有一个 seed 作为初始值。 12345678910111213Observable.just(1, 2, 3) .reduce(new BiFunction&lt;Integer, Integer, Integer&gt;() &#123; @Override public Integer apply(@NonNull Integer integer, @NonNull Integer integer2) throws Exception &#123; return integer + integer2; &#125; &#125;).subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(@NonNull Integer integer) throws Exception &#123; mRxOperatorsText.append(&quot;reduce : &quot; + integer + &quot;\\n&quot;); Log.e(TAG, &quot;accept: reduce : &quot; + integer + &quot;\\n&quot;); &#125; &#125;); 输出：16 可以看到，代码中，我们中间采用 reduce ，支持一个 function 为两数值相加，所以应该最后的值是：1 + 2 = 3 + 3 = 6 ， scan scan 操作符作用和上面的 reduce 一致，唯一区别是 reduce 是个只追求结果的坏人，而 scan 会始终如一地把每一个步骤都输出。 12345678910111213Observable.just(1, 2, 3) .scan(new BiFunction&lt;Integer, Integer, Integer&gt;() &#123; @Override public Integer apply(@NonNull Integer integer, @NonNull Integer integer2) throws Exception &#123; return integer + integer2; &#125; &#125;).subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(@NonNull Integer integer) throws Exception &#123; mRxOperatorsText.append(&quot;scan &quot; + integer + &quot;\\n&quot;); Log.e(TAG, &quot;accept: scan &quot; + integer + &quot;\\n&quot;); &#125; &#125;); 输出： 11 3 6 window 按照实际划分窗口，将数据发送给不同的 Observable 1234567891011121314151617181920212223mRxOperatorsText.append(&quot;window\\n&quot;); Log.e(TAG, &quot;window\\n&quot;); Observable.interval(1, TimeUnit.SECONDS) // 间隔一秒发一次 .take(15) // 最多接收15个 .window(3, TimeUnit.SECONDS) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;Observable&lt;Long&gt;&gt;() &#123; @Override public void accept(@NonNull Observable&lt;Long&gt; longObservable) throws Exception &#123; mRxOperatorsText.append(&quot;Sub Divide begin...\\n&quot;); Log.e(TAG, &quot;Sub Divide begin...\\n&quot;); longObservable.subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;Long&gt;() &#123; @Override public void accept(@NonNull Long aLong) throws Exception &#123; mRxOperatorsText.append(&quot;Next:&quot; + aLong + &quot;\\n&quot;); Log.e(TAG, &quot;Next:&quot; + aLong + &quot;\\n&quot;); &#125; &#125;); &#125; &#125;); 输出：","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://yoursite.com/tags/android/"},{"name":"开源框架","slug":"开源框架","permalink":"http://yoursite.com/tags/开源框架/"},{"name":"rxjava2","slug":"rxjava2","permalink":"http://yoursite.com/tags/rxjava2/"}]},{"title":"socket未释放导致句柄泄露","slug":"Socket未释放导致的句柄泄露","date":"2018-03-16T11:40:50.000Z","updated":"2018-05-06T13:28:37.592Z","comments":true,"path":"2018/03/16/Socket未释放导致的句柄泄露/","link":"","permalink":"http://yoursite.com/2018/03/16/Socket未释放导致的句柄泄露/","excerpt":"","text":"问题描述客户反馈话机的voipsdk demo在运行起来之后 放置不动，几小时过后，应用进行任何操作都会崩溃。通过logcat 报错信息 发现出现了句柄泄露。通过ls -l /proc//fd可以查看到在demo进程下，持有的socket数量会规律性上升。 12345lrwx------ system system 2018-03-08 14:11 60 -&gt; socket:[4027431]lrwx------ system system 2018-03-08 14:11 61 -&gt; socket:[4025517]lrwx------ system system 2018-03-08 14:11 62 -&gt; socket:[4028038]lrwx------ system system 2018-03-08 14:11 63 -&gt; socket:[4028322]lrwx------ system system 2018-03-08 14:11 64 -&gt; socket:[4026799] 大概十秒增加一个，一直到超出安卓规定的数量，此时由于已无可用fd句柄，在进行任何操作都会因无可用句柄直接导致崩溃。 可以看到新增socket的inode号码之后，通过查找/proc/net/tcp(udp对应/proc/net/udp)文件，其中也列出了相应socket的inode号，通过比对此字段，我在/proc/net/tcp下获得此套接口的其他信息，对应的&lt;本地地址：端口号，远端地址：端口号&gt;对，窗口大小，状态等信息。具体字段含义详见net/ipv4/tcp_ipv4.c 中的 tcp4_seq_show 函数。cat /proc/net/tcp 如下： 12345678root@TOS_IP:/proc/net # cat tcp6 sl local_address remote_address st tx_queue rx_queue tr tm-&gt;when retrnsmt uid timeout inode 0: 0000000000000000FFFF00007665A8C0:D483 0000000000000000FFFF00009F173379:0050 08 00000000:00000001 00:00000000 00000000 10077 0 3660979 1 00000000 25 4 30 10 -1 1: 0000000000000000FFFF00007665A8C0:E595 0000000000000000FFFF0000DCD5B276:0050 08 00000000:00000001 00:00000000 00000000 10077 0 3661419 1 00000000 24 4 28 10 -1 2: 0000000000000000FFFF00007665A8C0:81EC 0000000000000000FFFF00009F173379:0050 08 00000000:00000001 00:00000000 00000000 1000 0 4019721 1 00000000 23 4 30 10 -1 3: 0000000000000000FFFF00007665A8C0:B885 0000000000000000FFFF0000F28D0D6F:0050 08 00000000:00000001 00:00000000 00000000 1000 0 3659952 1 00000000 26 4 30 10 -1 4: 0000000000000000FFFF00007665A8C0:8AD0 0000000000000000FFFF00009F173379:0050 08 00000000:00000001 00:00000000 00000000 1000 0 4018811 1 00000000 24 4 30 10 -1 5: 0000000000000000FFFF00007665A8C0:E83C 0000000000000000FFFF00009F173379:0050 08 00000000:00000001 00:00000000 00000000 1000 0 4018828 1 00000000 23 4 30 10 -1 将本端16进制端口号转化为10进制可以看到是一个与8080端口在通信的socket。 目前初步猜测是端口争夺导致demo没有获取到端口，就会隔段时间重试去申请该端口。 首先去java端排除，全局搜索发现并没有找到对应的8080端口申请情况 那就只有可能是linphone库里或者webrtc库里做了8080相关的操作了。 请linphone端的李工排查，发现在一段前离职同事的代码里，有一段申请8080端口的相关操作。查看了一下，发现和猜测的一致，因为要和底层通讯，同事使用了socket并通过8080端口，但是在申请资源后并未释放改socket，当系统自带的拨号服务起来之后，因为系统自带拨号和sdk的demo使用的linphone库是相同的，导致两个进程都在抢占8080，那个进程服务先拿到，另一个进程就拿不到该端口，会隔10s重新发起申请，但是之前创建的socket又没有释放，就会导致句柄泄露。 我将系统自带的拨号进程彻底杀死，同事运行起demo，然后再将系统拨号运行起来，发现这时候 系统自带拨号也出现了句柄泄露。而demo就没有出现过了。 应征我之前的猜测。解决这个问题就很简单了，在linphone的代码里将改socket释放。","categories":[{"name":"bug记录","slug":"bug记录","permalink":"http://yoursite.com/categories/bug记录/"}],"tags":[{"name":"句柄泄露","slug":"句柄泄露","permalink":"http://yoursite.com/tags/句柄泄露/"},{"name":"bugs","slug":"bugs","permalink":"http://yoursite.com/tags/bugs/"}]},{"title":"线程阻塞和中断的四种方式","slug":"线程阻塞和中断的四种方式","date":"2018-03-13T12:46:25.000Z","updated":"2018-05-06T13:08:08.223Z","comments":true,"path":"2018/03/13/线程阻塞和中断的四种方式/","link":"","permalink":"http://yoursite.com/2018/03/13/线程阻塞和中断的四种方式/","excerpt":"","text":"1、线程阻塞一个线程进入阻塞状态可能的原因： 通过调用sleep(millseconds)使任务进入休眠状态；123456789101112class Demo1 implements Runnable throws InterruptedException&#123; public void run()&#123; Thread.sleep(1000); &#125;&#125;②通过调用wait（）使线程挂起，直到线程获取notify（）/notifyAll（）消息，（或者在Java SE5中java.util.concurrent类库中等价的signal（）/signalAll（）消息），线程才会进入就绪状态；class Demo2 implements Runnable&#123; public void run()&#123; Thread.await(); Thread.notify(); &#125;&#125; 任务在等待某个输入 / 输出流的完成；123456class Demo3 implements Runnable throws InterruptedException&#123; private InputStream in; public void run()&#123; in.read(); &#125;&#125; 任务试图在某个对象上调用其同步控制方法，但是对象锁不可用，因为另一个任务已经获取了该锁；1234567class Demo4 implements Runnable&#123; public synchronized void method1()&#123; &#125; public synchronized void method2()&#123; &#125; public void run()&#123; method1(); &#125;&#125; 2、线程中断的方法Thread类包含interrupt（）方法，用于终止阻塞任务； 1）中断①②类线程休眠，挂起阻塞的方法1.直接使用Thread.interrupt();1234main()&#123; Thread t = new Thread(new Demo1()); t.interrupt();&#125; 2.使用Executor线程池，中断线程池中的所有线程；123456main()&#123; ExecutorService exec = Executors.newCachedThreadPool(); for(int i=0;i&lt;5;i++) exec.execute(new Demo1()) exec.shutdownNow();&#125; 3.使用Executor线程池，中断线程池中单个阻塞的线程；12345main()&#123; ExecutorService exec = Executors.newCachedThreadPool(); Futrue&lt;?&gt; f = exec.submit(new Demo1()); f.interrupt();&#125; //中断后的清除代码放置在InterruptedException异常的catch捕获的代码块中 2）中断③类I/O阻塞的方法使用Thread.iterrupt方法无法中断I/O阻塞，这对于基于Web的程序是很不利的； 有一种解决方法：关闭任务在其上发生阻塞的底层资源；123456789101112main()&#123; ExecutorService exec = Executors.newCachedThreadPool(); ServerSocket server = new ServerSocket(8080); InputStream socketInput = new Socket(&quot;localhost&quot;,8080) exec.execute(socketInput); exec.execute(Sytsem.in); //exec.shutdownNow(); 无法中断2个线程； socketInput.close(); in.close(); exec.shutdownNow();&#125; java.nio类库提供了更加人性化的I/O中断，被阻塞的nio通道会自动地响应中断；12345678910111213141516171819202122232425262728class Demo impelenets Runnable&#123; private final SocketChannel sc; public Demo(SocketChannel sc)&#123; this.sc = sc;&#125; public void run()&#123; try&#123; sc.read(ByteBuffer.allocate(1)); &#125;catch(CloseByInteruptedException e1)&#123; &#125;catch(AsyncronousCloseException e2)&#123; &#125;catch(IOException e3)&#123; &#125; &#125;&#125;public Test &#123; public static void main()&#123; ExecutorService exec = Executors.newCachedThreadPool(); ServerSocket server = new ServerSocket(8080); InetSocketAddress isa = new InetSocketAddress(&quot;localhost&quot;,8080); SocketChannel sc1 = new SocketChannel.open(isa); SocketChannel sc2 = new SocketChannel.open(isa); exec.execute(new Demo(sc1)); Future&lt;?&gt; f = exec.submit(new Demo(sc2)); f.cancel(true); //可以终止sc1通道所在的线程； exec.shutdownNow(); //可以终止exec线程池内所有的线程； sc1.close(); sc2.close(); &#125;&#125; 3）中断④类被互斥阻塞的线程使用Thread.iterrupt方法无法中断互斥类线程， 解决方式1：可以使用ReentrantLock显式加锁，在JavaSE5中引入的新特性，ReentrantLock上阻塞的任务可以被中断；123456789101112131415161718class Task imlements Runnable&#123; private Lock lock = new ReentrantLock(); public void run()&#123; lock.lock(); try&#123; while(true) &#125;catch(InterruptedExcpetion e)&#123; System.out.println(&quot;The Task is interrupted!&quot;); &#125;finally&#123; lock.unlock(); &#125; &#125; public void main()&#123; Thread t = new Thread(new Task()); t.start(); t.interrupt(); &#125;&#125; 解决方式2：使用一个while（！Thread.interrupted（））包裹同步的代码块123456789101112131415161718class Task impelments Runnable&#123; private synchronized void method1()&#123; &#125; public void run()&#123; try&#123; whlie(!Thread.interrupted()) method1(); &#125;catch(InteruptedException e)&#123; &#125; &#125; public static void main()&#123; ExecutorService exec = Executors.newCachedThreadPool(); exec.execute(new Task()); exec.shutdownNow(); //线程被打断 /*或 Thread t = new Thread(new Task()); t.start(); t.interrupt(); */ &#125;&#125;","categories":[{"name":"java基础","slug":"java基础","permalink":"http://yoursite.com/categories/java基础/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"多线程","slug":"多线程","permalink":"http://yoursite.com/tags/多线程/"}]},{"title":"mac搭建Pyqt5环境","slug":"mac搭建PyQt5环境","date":"2017-12-11T12:30:50.000Z","updated":"2018-05-06T13:25:36.596Z","comments":true,"path":"2017/12/11/mac搭建PyQt5环境/","link":"","permalink":"http://yoursite.com/2017/12/11/mac搭建PyQt5环境/","excerpt":"","text":"1.首先基于virtualenv 搭建一个python3的运行环境virtualenv是一个十分好用的python工具，可以为不同的软件创建独立的“隔离”的Python运行环境。 1. 首先，我们用pip安装virtualenv：1$ pip3 install virtualenv 2.创建一个pyhton3的运行环境1jiangxqdeMBP:~ jiangxq$ virtualenv py3 --python=python3 可以通过python=python3来指定要安装的python版本，python3是mac的写法，其他linux系统需要制定为python2.7 或者python3.6 3. 激活该运行环境执行 12jiangxqdeMBP:~ jiangxq$ source ~/py3/bin/activate(py3) jiangxqdeMBP:~ jiangxq$ 当用户名前出现该运行环境的名称时，表示环境已经激活了 2. 检查pip工具的版本 目前最新的为9.0.2 需要更新请 执行1pip3 install --upgrade pip 这里有个窍门是如果mac的默认python运行环境为python2.7，但是不想修改注册文件，可以直接打pip3，pip3是是python3的pip工具，pip是python2的pip工具。 3. 使用pip工具安装PyQt51pip3 install PyQt5 当PyQt5安装完成之后，其实Qt的组件此时已经可用了，如果要测试是否安装成功，可以新建一个Python项目，然后倒入PyQt5的包看看。 4.在pycharm上安装QtDesign工具包QtDesign是Pycharm上的可视化uI设计工具，可以拖动控件来达到实现设计界面的功能安装Qtdesign 需要先安装QT 1. 下载QT安装包下载地址：http://iso.mirrors.ustc.edu.cn/qtproject/archive/qt/5.10/5.10.1/qt-opensource-mac-x64-5.10.1.dmg下载完成后直接安装 2.打开pycharm 点击preference 点击Tools 新建一个插件 注意插件地址不要写错了，是qt5的安装路径 3. 创建PyUIC 插件（将pydesigner的布局自动转化为python代码）","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"qt","slug":"qt","permalink":"http://yoursite.com/tags/qt/"}]},{"title":"mac搭建Pyqt5环境","slug":"MQTT相关","date":"2017-12-11T12:30:50.000Z","updated":"2018-05-06T13:27:09.801Z","comments":true,"path":"2017/12/11/MQTT相关/","link":"","permalink":"http://yoursite.com/2017/12/11/MQTT相关/","excerpt":"","text":"MQTT相关MQTT官网：http://mqtt.org/ MQTT介绍：http://www.ibm.com MQTT Android github：https://github.com/eclipse/paho.mqtt.android MQTT API：http://www.eclipse.org/paho/files/javadoc/index.html MQTT Android API： http://www.eclipse.org/paho/files/android-javadoc/index.html MQTT服务器搭建 环境：windows7 64位 JAVA环境:jdk 1.8.0 下载：Apollo服务器 以下为步骤： 下载Apollo服务器后，解压安装； 用命令行进入到安装目录bin目录下 输入 apollo create xxx (xxx为服务器实例名，eg.apollo create xmaihh) 执行之后会在bin目录下创建名称为xxx的文件夹，比如我生成的文件夹是 xmaihhxxx文件夹下etc\\apollo.xml文件是 配置服务器文件信息etc\\users.properties文件包含连接MQTT服务器时用到的用户名和密码，默认为admin=password，即账号为admin，密码为password，可自行更改。 用命令行进入到刚创建的xxx\\bin目录下，输入apollo-broker.cmd run开启服务器 在浏览器输入http://127.0.0.1:61680/，查看是否安装成功MQTT Android客户端 环境：AndroidStudio 3.0.1 topic：中文意思是“话题”。在MQTT中订阅了(subscribe)同一话题（topic）的客户端会同时收到消息推送。 clientId：客户身份唯一标识。 qos：服务质量。 retained：要保留最后的断开连接信息。 MqttAndroidClient#subscribe()：订阅某个话题。 MqttAndroidClient#publish()： 向某个话题发送消息，之后服务器会推送给所有订阅了此话题的客户。 userName：连接到MQTT服务器的用户名。 passWord ：连接到MQTT服务器的密码 以下为步骤： 添加依赖 123456789repositories &#123; maven &#123; url &quot;https://repo.eclipse.org/content/repositories/paho-snapshots/&quot; &#125;&#125;dependencies &#123; compile &apos;org.eclipse.paho:org.eclipse.paho.client.mqttv3:1.1.0&apos; compile &apos;org.eclipse.paho:org.eclipse.paho.android.service:1.1.1&apos;&#125; 添加权限 123&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.WAKE_LOCK&quot; /&gt; 注册Service 12&lt;!-- Mqtt Service --&gt;&lt;service android:name=&quot;org.eclipse.paho.android.service.MqttService&quot; /&gt; 具体实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157/** * MQTT长连接服务 */public class MQTTService extends Service &#123; public static final String TAG = MQTTService.class.getSimpleName(); public static MqttAndroidClient client; private MqttConnectOptions connectOptions; private String host = &quot;tcp://192.168.102.216:61613&quot;;// private String host = &quot;tcp://192.168.8.241:61613&quot;;// private String host = &quot;tcp://10.0.2.2:61613&quot;;// private String host = &quot;tcp://192.168.26.144:1883&quot;; private String username = &quot;admin&quot;; private String password = &quot;password&quot;; private static String myTopic = &quot;topic&quot;; private String clientId = &quot;test123&quot;; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; init(); return super.onStartCommand(intent, flags, startId); &#125; @Nullable @Override public IBinder onBind(Intent intent) &#123; return null; &#125; public static void publish(String msg) &#123; String topic = myTopic; Integer qos = 0; Boolean retained = false; try &#123; client.publish(topic, msg.getBytes(), qos.intValue(), retained.booleanValue()); &#125; catch (MqttException e) &#123; e.printStackTrace(); &#125; &#125; /** * 初始化方法 */ private void init() &#123; // 服务器地址 (协议+地址+端口号) String url = host; client = new MqttAndroidClient(this, url, clientId); client.setCallback(mqttCallback); connectOptions = new MqttConnectOptions(); // 清除缓存 connectOptions.setCleanSession(true); // 设置超时时间,单位:秒 connectOptions.setConnectionTimeout(10); // 心跳包发送时间间隔,单位:秒 connectOptions.setKeepAliveInterval(20); // 用户名 connectOptions.setUserName(username); // 密码 connectOptions.setPassword(password.toCharArray()); // last will message boolean doConnect = true; String message = &quot;&#123;\\&quot;terminal_uid\\&quot;:\\&quot;&quot; + clientId + &quot;\\&quot;&#125;&quot;; String topic = myTopic; Integer qos = 0; Boolean retained = false; if ((!message.equals(&quot;&quot;)) || (!topic.equals(&quot;&quot;))) &#123; //最后的遗嘱 try &#123; connectOptions.setWill(topic, message.getBytes(), qos.intValue(), retained.booleanValue()); &#125; catch (Exception ex) &#123; Log.d(TAG, &quot;Exception Occured&quot;, ex); doConnect = false; iMqttActionListener.onFailure(null, ex); &#125; &#125; if (doConnect) &#123; //连接MQTT服务器 doClientConnection(); &#125; &#125; /** * 连接MQTT服务器 */ private void doClientConnection() &#123; if (!client.isConnected() &amp;&amp; isConnectIsNomarl()) &#123; try &#123; client.connect(connectOptions, null, iMqttActionListener); &#125; catch (MqttException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /** * 判断网络是否连接 * * @return */ private boolean isConnectIsNomarl() &#123; ConnectivityManager connectivityManager = (ConnectivityManager) this.getApplicationContext().getSystemService(Context.CONNECTIVITY_SERVICE); NetworkInfo info = connectivityManager.getActiveNetworkInfo(); if (info != null &amp;&amp; info.isAvailable()) &#123; String name = info.getTypeName(); Log.i(TAG, &quot;MQTT当前网络名称：&quot; + name); return true; &#125; else &#123; Log.i(TAG, &quot;MQTT 没有可用网络&quot;); return false; &#125; &#125; /** * MQTT监听并且接收消息 */ private MqttCallback mqttCallback = new MqttCallback() &#123; @Override public void connectionLost(Throwable cause) &#123; //失去连接，重连 &#125; @Override public void messageArrived(String topic, MqttMessage message) throws Exception &#123; EventBus.getDefault().post(message); String str2 = topic + &quot;;qos :&quot; + message.getQos() + &quot;;retained:&quot; + message.isRetained(); Log.d(TAG, &quot;messageArrived: str2&quot; + str2); &#125; @Override public void deliveryComplete(IMqttDeliveryToken token) &#123; &#125; &#125;; /** * MQTT是否连接成功 */ private IMqttActionListener iMqttActionListener = new IMqttActionListener() &#123; @Override public void onSuccess(IMqttToken asyncActionToken) &#123; Log.d(TAG, &quot;onSuccess: MQTT连接成功&quot;); try &#123; //订阅myTopic话题 client.subscribe(myTopic, 1); &#125; catch (MqttException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void onFailure(IMqttToken asyncActionToken, Throwable exception) &#123; exception.printStackTrace(); //连接失败，重连 &#125; &#125;;&#125; 初始化各个参数，之后连接服务器。连接成功之后在http://127.0.0.1:61680/ 看到自动创建了名称为”topic”的topic。这里我使用两台真机。http://127.0.0.1:61680/ 服务端看到的是这个样子 模拟器运行的时候host = “tcp://10.0.2.2:61613”，因为10.0.2.2 是模拟器设置的特定ip，是你电脑的别名。真机运行的时候host = “tcp://192.168.102.216:61613”。192.168.102.216是我主机的IPv4地址，查看本机IP的cmd命令为ipconfig/all。 两次运行时的clientId不能一样（为了保证客户标识的唯一性） 访问管理界面要修改前面创建的xxx文件夹下etc\\apollo.xml文件，添加你的host就可以通过host访问管理界面，否则只能通过 http://127.0.0.1:61680 和 https://127.0.0.1:61681 访问123456789101112131415161718192021222324252627282930313233343536373839... ... &lt;virtual_host id=&quot;xmaihh&quot;&gt; &lt;!-- You should add all the host names that this virtual host is known as to properly support the STOMP 1.1 virtual host feature. --&gt; &lt;host_name&gt;xmaihh&lt;/host_name&gt; &lt;host_name&gt;localhost&lt;/host_name&gt; &lt;host_name&gt;127.0.0.1&lt;/host_name&gt; &lt;!--以下为添加内容--&gt; &lt;host_name&gt;192.168.102.216&lt;/host_name&gt; &lt;!--以上为添加内容--&gt; &lt;!-- Uncomment to disable security for the virtual host --&gt; &lt;!-- &lt;authentication enabled=&quot;false&quot;/&gt; --&gt; &lt;!-- Uncomment to disable security for the virtual host --&gt; &lt;!-- &lt;authentication enabled=&quot;false&quot;/&gt; --&gt; &lt;access_rule allow=&quot;users&quot; action=&quot;connect create destroy send receive consume&quot;/&gt; &lt;!-- You can delete this element if you want to disable persistence for this virtual host --&gt; &lt;leveldb_store directory=&quot;$&#123;apollo.base&#125;/data&quot;/&gt; &lt;/virtual_host&gt; &lt;web_admin bind=&quot;http://127.0.0.1:61680&quot;/&gt; &lt;web_admin bind=&quot;https://127.0.0.1:61681&quot;/&gt; &lt;!--以下为添加内容--&gt; &lt;web_admin bind=&quot;http://192.168.102.216:61680&quot;/&gt; &lt;web_admin bind=&quot;https://192.168.102.216:61681&quot;/&gt; &lt;!--以上为添加内容--&gt; &lt;connector id=&quot;tcp&quot; bind=&quot;tcp://0.0.0.0:61613&quot; connection_limit=&quot;2000&quot;/&gt; &lt;connector id=&quot;tls&quot; bind=&quot;tls://0.0.0.0:61614&quot; connection_limit=&quot;2000&quot;/&gt; &lt;connector id=&quot;ws&quot; bind=&quot;ws://0.0.0.0:61623&quot; connection_limit=&quot;2000&quot;/&gt; &lt;connector id=&quot;wss&quot; bind=&quot;wss://0.0.0.0:61624&quot; connection_limit=&quot;2000&quot;/&gt; &lt;key_storage file=&quot;$&#123;apollo.base&#125;/etc/keystore&quot; password=&quot;password&quot; key_password=&quot;password&quot;/&gt;","categories":[{"name":"MQTT","slug":"MQTT","permalink":"http://yoursite.com/categories/MQTT/"}],"tags":[{"name":"mqtt","slug":"mqtt","permalink":"http://yoursite.com/tags/mqtt/"}]},{"title":"view 绘制机制","slug":"view 绘制机制","date":"2017-10-12T11:30:50.000Z","updated":"2018-05-06T13:19:37.758Z","comments":true,"path":"2017/10/12/view 绘制机制/","link":"","permalink":"http://yoursite.com/2017/10/12/view 绘制机制/","excerpt":"","text":"View的绘制和事件处理是两个重要的主题，上一篇《图解 Android事件分发机制》已经把事件的分发机制讲得比较详细了，这一篇是针对View的绘制，View的绘制如果你有所了解，基本分为measure、layout、draw 过程，其中比较难理解就是measure过程，所以本篇文章大幅笔地分析measure过程，相对讲得比较详细，文章也比较长，如果你对View的绘制还不是很懂，对measure过程掌握得不是很深刻，那么耐心点，看完这篇文章，相信你会有所收获的。 Measure过程对于测量我们来说几个知识点,了解这几个知识点，之后的实例分析你才看得懂。 1、MeasureSpec 的理解对于View的测量，肯定会和MeasureSpec接触，MeasureSpec是两个单词组成，翻译过来“测量规格”或者“测量参数”，很多博客包括官方文档对他的说明基本都是“一个MeasureSpec封装了从父容器传递给子容器的布局要求”,这个MeasureSpec 封装的是父容器传递给子容器的布局要求，而不是父容器对子容器的布局要求，“传递” 两个字很重要，更精确的说法应该这个MeasureSpec是由父View的MeasureSpec和子View的LayoutParams通过简单的计算得出一个针对子View的测量要求，这个测量要求就是MeasureSpec。 大家都知道一个MeasureSpec是一个大小跟模式的组合值,MeasureSpec中的值是一个整型（32位）将size和mode打包成一个Int型，其中高两位是mode，后面30位存的是size，是为了减少对象的分配开支。MeasureSpec 类似于下图，只不过这边用的是十进制的数，而MeasureSpec 是二进制存储的。 注：-1 代表的是EXACTLY，-2 是AT_MOSTMeasureSpec一共有三种模式 123UPSPECIFIED : 父容器对于子容器没有任何限制,子容器想要多大就多大EXACTLY: 父容器已经为子容器设置了尺寸,子容器应当服从这些边界,不论子容器想要多大的空间。AT_MOST：子容器可以是声明大小内的任意大小 很多文章都会把这三个模式说成这样，当然其实包括官方文档也是这样表达的，但是这样并不好理解。特别是如果把这三种模式又和MATCH_PARENT和WRAP_CONTENT 联系到一起，很多人就懵逼了。如果从代码上来看1view.measure(int widthMeasureSpec, int heightMeasureSpec) 12 的两个MeasureSpec是父类传递过来的，但并不是完全是父View的要求，而是父View的MeasureSpec和子View自己的LayoutParams共同决定的，而子View的LayoutParams其实就是我们在xml写的时候设置的layout_width和layout_height 转化而来的。我们先来看代码会清晰一些： 父View的measure的过程会先测量子View，等子View测量结果出来后，再来测量自己，上面的measureChildWithMargins就是用来测量某个子View的，我们来分析是怎样测量的，具体看注释： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112protected void measureChildWithMargins(View child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed) &#123; // 子View的LayoutParams，你在xml的layout_width和layout_height,// layout_xxx的值最后都会封装到这个个LayoutParams。final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams(); //根据父View的测量规格和父View自己的Padding，//还有子View的Margin和已经用掉的空间大小（widthUsed），就能算出子View的MeasureSpec,具体计算过程看getChildMeasureSpec方法。final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin + widthUsed, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin + heightUsed, lp.height); //通过父View的MeasureSpec和子View的自己LayoutParams的计算，算出子View的MeasureSpec，然后父容器传递给子容器的// 然后让子View用这个MeasureSpec（一个测量要求，比如不能超过多大）去测量自己，如果子View是ViewGroup 那还会递归往下测量。child.measure(childWidthMeasureSpec, childHeightMeasureSpec);&#125;// spec参数 表示父View的MeasureSpec // padding参数 父View的Padding+子View的Margin，父View的大小减去这些边距，才能精确算出// 子View的MeasureSpec的size// childDimension参数 表示该子View内部LayoutParams属性的值（lp.width或者lp.height）// 可以是wrap_content、match_parent、一个精确指(an exactly size), public static int getChildMeasureSpec(int spec, int padding, int childDimension) &#123; int specMode = MeasureSpec.getMode(spec); //获得父View的mode int specSize = MeasureSpec.getSize(spec); //获得父View的大小 //父View的大小-自己的Padding+子View的Margin，得到值才是子View的大小。 int size = Math.max(0, specSize - padding); int resultSize = 0; //初始化值，最后通过这个两个值生成子View的MeasureSpec int resultMode = 0; //初始化值，最后通过这个两个值生成子View的MeasureSpec switch (specMode) &#123; // Parent has imposed an exact size on us //1、父View是EXACTLY的 ！ case MeasureSpec.EXACTLY: //1.1、子View的width或height是个精确值 (an exactly size) if (childDimension &gt;= 0) &#123; resultSize = childDimension; //size为精确值 resultMode = MeasureSpec.EXACTLY; //mode为 EXACTLY 。 &#125; //1.2、子View的width或height为 MATCH_PARENT/FILL_PARENT else if (childDimension == LayoutParams.MATCH_PARENT) &#123; // Child wants to be our size. So be it. resultSize = size; //size为父视图大小 resultMode = MeasureSpec.EXACTLY; //mode为 EXACTLY 。 &#125; //1.3、子View的width或height为 WRAP_CONTENT else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // Child wants to determine its own size. It can&apos;t be // bigger than us. resultSize = size; //size为父视图大小 resultMode = MeasureSpec.AT_MOST; //mode为AT_MOST 。 &#125; break; // Parent has imposed a maximum size on us //2、父View是AT_MOST的 ！ case MeasureSpec.AT_MOST: //2.1、子View的width或height是个精确值 (an exactly size) if (childDimension &gt;= 0) &#123; // Child wants a specific size... so be it resultSize = childDimension; //size为精确值 resultMode = MeasureSpec.EXACTLY; //mode为 EXACTLY 。 &#125; //2.2、子View的width或height为 MATCH_PARENT/FILL_PARENT else if (childDimension == LayoutParams.MATCH_PARENT) &#123; // Child wants to be our size, but our size is not fixed. // Constrain child to not be bigger than us. resultSize = size; //size为父视图大小 resultMode = MeasureSpec.AT_MOST; //mode为AT_MOST &#125; //2.3、子View的width或height为 WRAP_CONTENT else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // Child wants to determine its own size. It can&apos;t be // bigger than us. resultSize = size; //size为父视图大小 resultMode = MeasureSpec.AT_MOST; //mode为AT_MOST &#125; break; // Parent asked to see how big we want to be //3、父View是UNSPECIFIED的 ！ case MeasureSpec.UNSPECIFIED: //3.1、子View的width或height是个精确值 (an exactly size) if (childDimension &gt;= 0) &#123; // Child wants a specific size... let him have it resultSize = childDimension; //size为精确值 resultMode = MeasureSpec.EXACTLY; //mode为 EXACTLY &#125; //3.2、子View的width或height为 MATCH_PARENT/FILL_PARENT else if (childDimension == LayoutParams.MATCH_PARENT) &#123; // Child wants to be our size... find out how big it should // be resultSize = 0; //size为0！ ,其值未定 resultMode = MeasureSpec.UNSPECIFIED; //mode为 UNSPECIFIED &#125; //3.3、子View的width或height为 WRAP_CONTENT else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // Child wants to determine its own size.... find out how // big it should be resultSize = 0; //size为0! ，其值未定 resultMode = MeasureSpec.UNSPECIFIED; //mode为 UNSPECIFIED &#125; break; &#125; //根据上面逻辑条件获取的mode和size构建MeasureSpec对象。 return MeasureSpec.makeMeasureSpec(resultSize, resultMode); &#125; 上面的代码有点多，希望你仔细看一些注释，代码写得很多，其实计算原理很简单： 如果我们在xml 的layout_width或者layout_height 把值都写死，那么上述的测量完全就不需要了，之所以要上面的这步测量，是因为 match_parent 就是充满父容器，wrap_content 就是自己多大就多大， 我们写代码的时候特别爽，我们编码方便的时候，google就要帮我们计算你match_parent的时候是多大，wrap_content的是多大，这个计算过程，就是计算出来的父View的MeasureSpec不断往子View传递，结合子View的LayoutParams 一起再算出子View的MeasureSpec，然后继续传给子View，不断计算每个View的MeasureSpec，子View有了MeasureSpec才能更测量自己和自己的子View。 上述代码如果这么来理解就简单了 如果父View的MeasureSpec 是EXACTLY，说明父View的大小是确切的，（确切的意思很好理解，如果一个View的MeasureSpec 是EXACTLY，那么它的size 是多大，最后展示到屏幕就一定是那么大）。 1.如果子View 的layout_xxxx是MATCH_PARENT，父View的大小是确切，子View的大小又MATCH_PARENT（充满整个父View），那么子View的大小肯定是确切的，而且大小值就是父View的size。所以子View的size=父View的size，mode=EXACTLY 2.如果子View 的layout_xxxx是WRAP_CONTENT，也就是子View的大小是根据自己的content 来决定的，但是子View的毕竟是子View，大小不能超过父View的大小，但是子View的是WRAP_CONTENT，我们还不知道具体子View的大小是多少，要等到child.measure(childWidthMeasureSpec, childHeightMeasureSpec) 调用的时候才去真正测量子View 自己content的大小（比如TextView wrap_content 的时候你要测量TextView content 的大小，也就是字符占用的大小，这个测量就是在child.measure(childWidthMeasureSpec, childHeightMeasureSpec)的时候，才能测出字符的大小，MeasureSpec 的意思就是假设你字符100px，但是MeasureSpec 要求最大的只能50px，这时候就要截掉了）。通过上述描述，子View MeasureSpec mode的应该是AT_MOST，而size 暂定父View的 size，表示的意思就是子View的大小没有不确切的值，子View的大小最大为父View的大小，不能超过父View的大小（这就是AT_MOST 的意思），然后这个MeasureSpec 做为子View measure方法 的参数，做为子View的大小的约束或者说是要求，有了这个MeasureSpec子View再实现自己的测量。 3、如果如果子View 的layout_xxxx是确定的值（200dp），那么就更简单了，不管你父View的mode和size是什么，我都写死了就是200dp，那么控件最后展示就是就是200dp，不管我的父View有多大，也不管我自己的content 有多大，反正我就是这么大，所以这种情况MeasureSpec 的mode = EXACTLY 大小size=你在layout_xxxx 填的那个值。 如果父View的MeasureSpec 是AT_MOST，说明父View的大小是不确定，最大的大小是MeasureSpec 的size值，不能超过这个值。 1、如果子View 的layout_xxxx是MATCH_PARENT，父View的大小是不确定（只知道最大只能多大），子View的大小MATCH_PARENT（充满整个父View），那么子View你即使充满父容器，你的大小也是不确定的，父View自己都确定不了自己的大小，你MATCH_PARENT你的大小肯定也不能确定的，所以子View的mode=AT_MOST，size=父View的size，也就是你在布局虽然写的是MATCH_PARENT，但是由于你的父容器自己的大小不确定，导致子View的大小也不确定，只知道最大就是父View的大小。 2、如果子View 的layout_xxxx是WRAP_CONTENT，父View的大小是不确定（只知道最大只能多大），子View又是WRAP_CONTENT，那么在子View的Content没算出大小之前，子View的大小最大就是父View的大小，所以子View MeasureSpec mode的就是AT_MOST，而size 暂定父View的 size。 3、如果如果子View 的layout_xxxx是确定的值（200dp），同上，写多少就是多少，改变不了的。 如果父View的MeasureSpec 是UNSPECIFIED(未指定),表示没有任何束缚和约束，不像AT_MOST表示最大只能多大，不也像EXACTLY表示父View确定的大小，子View可以得到任意想要的大小，不受约束 1、如果子View 的layout_xxxx是MATCH_PARENT，因为父View的MeasureSpec是UNSPECIFIED，父View自己的大小并没有任何约束和要求，那么对于子View来说无论是WRAP_CONTENT还是MATCH_PARENT，子View也是没有任何束缚的，想多大就多大，没有不能超过多少的要求，一旦没有任何要求和约束，size的值就没有任何意义了，所以一般都直接设置成0 2、同上… 3、如果如果子View 的layout_xxxx是确定的值（200dp），同上，写多少就是多少，改变不了的（记住，只有设置的确切的值，那么无论怎么测量，大小都是不变的，都是你写的那个值） 到此为止，你是否对MeasureSpec 和三种模式、还有WRAP_CONTENT和MATCH_PARENT有一定的了解了，如果还有任何问题，欢迎在我简书（用户名：Kelin）评论里留言。 2、View的测量过程主要是在onMeasure()方法打开View的源码，找到measure方法，这个方法代码不少，但是测量工作都是在onMeasure()做的，measure方法是final的所以这个方法也不可重写，如果想自定义View的测量，你应该去重写onMeasure()方法 12345public final void measure(int widthMeasureSpec, int heightMeasureSpec) &#123; ...... onMeasure(widthMeasureSpec,heightMeasureSpec); .....&#125; 3、View的onMeasure 的默认实现打开View.java 的源码来看下onMeasure的实现 12345protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasuredDimension( getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));&#125; View的onMeasure方法默认实现很简单，就是调用setMeasuredDimension()，setMeasuredDimension()可以简单理解就是给mMeasuredWidth和mMeasuredHeight设值，如果这两个值一旦设置了，那么意味着对于这个View的测量结束了，这个View的宽高已经有测量的结果出来了。如果我们想设定某个View的高宽，完全可以直接通过setMeasuredDimension（100，200）来设置死它的高宽（不建议），但是setMeasuredDimension方法必须在onMeasure方法中调用，不然会抛异常。我们来看下对于View来说它的默认高宽是怎么获取的。 1234567891011121314151617181920//获取的是android:minHeight属性的值或者View背景图片的大小值protected int getSuggestedMinimumWidth() &#123; return (mBackground == null) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth()); &#125; //@param size参数一般表示设置了android:minHeight属性或者该View背景图片的大小值 public static int getDefaultSize(int size, int measureSpec) &#123; int result = size; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); switch (specMode) &#123; case MeasureSpec.UNSPECIFIED: //表示该View的大小父视图未定，设置为默认值 result = size; break; case MeasureSpec.AT_MOST: case MeasureSpec.EXACTLY: result = specSize; break; &#125; return result;&#125; getDefaultSize的第一个参数size等于getSuggestedMinimumXXXX返回的的值（建议的最小宽度和高度），而建议的最小宽度和高度都是由View的Background尺寸与通过设置View的minXXX属性共同决定的，这个size可以理解为View的默认长度，而第二个参数measureSpec，是父View传给自己的MeasureSpec,这个measureSpec是通过测量计算出来的，具体的计算测量过程前面在讲解MeasureSpec已经讲得比较清楚了（是有父View的MeasureSpec和子View自己的LayoutParams 共同决定的）只要这个测试的mode不是UNSPECIFIED（未确定的），那么默认的就会用这个测量的数值当做View的高度。 对于View默认是测量很简单，大部分情况就是拿计算出来的MeasureSpec的size 当做最终测量的大小。而对于其他的一些View的派生类，如TextView、Button、ImageView等，它们的onMeasure方法系统了都做了重写，不会这么简单直接拿 MeasureSpec 的size来当大小，而去会先去测量字符或者图片的高度等，然后拿到View本身content这个高度（字符高度等），如果MeasureSpec是AT_MOST，而且View本身content的高度不超出MeasureSpec的size，那么可以直接用View本身content的高度（字符高度等），而不是像View.java 直接用MeasureSpec的size做为View的大小。 4、ViewGroup的Measure过程ViewGroup 类并没有实现onMeasure，我们知道测量过程其实都是在onMeasure方法里面做的，我们来看下FrameLayout 的onMeasure 方法,具体分析看注释哦。 1234567891011121314151617181920212223//FrameLayout 的测量protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; ....int maxHeight = 0;int maxWidth = 0;int childState = 0;for (int i = 0; i &lt; count; i++) &#123; final View child = getChildAt(i); if (mMeasureAllChildren || child.getVisibility() != GONE) &#123; // 遍历自己的子View，只要不是GONE的都会参与测量，measureChildWithMargins方法在最上面 // 的源码已经讲过了，如果忘了回头去看看，基本思想就是父View把自己的MeasureSpec // 传给子View结合子View自己的LayoutParams 算出子View 的MeasureSpec，然后继续往下传， // 传递叶子节点，叶子节点没有子View，根据传下来的这个MeasureSpec测量自己就好了。 measureChildWithMargins(child, widthMeasureSpec, 0, heightMeasureSpec, 0); final LayoutParams lp = (LayoutParams) child.getLayoutParams(); maxWidth = Math.max(maxWidth, child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin); maxHeight = Math.max(maxHeight, child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin); .... .... &#125;&#125;.......... //所有的孩子测量之后，经过一系类的计算之后通过setMeasuredDimension设置自己的宽高，//对于FrameLayout 可能用最大的字View的大小，对于LinearLayout，可能是高度的累加，//具体测量的原理去看看源码。总的来说，父View是等所有的子View测量结束之后，再来测量自己。 1234setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState), resolveSizeAndState(maxHeight, heightMeasureSpec, childState &lt;&lt; MEASURED_HEIGHT_STATE_SHIFT));....&#125; 到目前为止，基本把Measure 主要原理都过了一遍，接下来我们会结合实例来讲解整个match的过程，首先看下面的代码： 1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:id=&quot;@+id/linear&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;50dp&quot; android:background=&quot;@android:color/holo_blue_dark&quot; android:paddingBottom=&quot;70dp&quot; android:orientation=&quot;vertical&quot;&gt; &lt;TextView android:id=&quot;@+id/text&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;@color/material_blue_grey_800&quot; android:text=&quot;TextView&quot; android:textColor=&quot;@android:color/white&quot; android:textSize=&quot;20sp&quot; /&gt; &lt;View android:id=&quot;@+id/view&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;150dp&quot; android:background=&quot;@android:color/holo_green_dark&quot; /&gt;&lt;/LinearLayout&gt; 上面的代码对于出来的布局是下面的一张图 对于上面图可能有些不懂，这边做下说明: 整个图是一个DecorView,DecorView可以理解成整个页面的根View,DecorView是一个FrameLayout,包含两个子View，一个id=statusBarBackground的View和一个是LineaLayout，id=statusBarBackground的View，我们可以先不管（我也不是特别懂这个View,应该就是statusBar的设置背景的一个控件，方便设置statusBar的背景)，而这个LinearLayout比较重要，它包含一个title和一个content，title很好理解其实就是TitleBar或者ActionBar,content 就更简单了，setContentView()方法你应该用过吧，android.R.id.content 你应该听过吧，没错就是它,content是一个FrameLayout，你写的页面布局通过setContentView加进来就成了content的直接子View。 整个View的布局图如下： 这张图在下面分析measure，会经常用到，主要用于了解递归的时候view 的measure顺序 注:1、 header的是个ViewStub,用来惰性加载ActionBar，为了便于分析整个测量过程，我把Theme设成NoActionBar，避免ActionBar 相关的measure干扰整个过程，这样可以忽略掉ActionBar 的测量，在调试代码更清晰。2、包含Header(ActionBar）和id/content 的那个父View，我不知道叫什么名字好，我们姑且叫它ViewRoot（看上图）,它是垂直的LinearLayout，放着整个页面除statusBar 的之外所有的东西，叫它ViewRoot 应该还ok，一个代号而已。 既然我们知道整个View的Root是DecorView，那么View的绘制是从哪里开始的呢，我们知道每个Activity 均会创建一个 PhoneWindow对象，是Activity和整个View系统交互的接口，每个Window都对应着一个View和一个ViewRootImpl，Window和View通过ViewRootImpl来建立联系,对于Activity来说，ViewRootImpl是连接WindowManager和DecorView的纽带,绘制的入口是由ViewRootImpl的performTraversals方法来发起Measure，Layout，Draw等流程的。 我们来看下ViewRootImpl的performTraversals 方法： 123456789101112131415161718192021222324private void performTraversals() &#123; ...... int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width); int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height); ...... mView.measure(childWidthMeasureSpec, childHeightMeasureSpec); ......mView.layout(0, 0, mView.getMeasuredWidth(), mView.getMeasuredHeight());...... mView.draw(canvas); ......&#125;private static int getRootMeasureSpec(int windowSize, int rootDimension) &#123; int measureSpec; switch (rootDimension) &#123; case ViewGroup.LayoutParams.MATCH_PARENT: // Window can&apos;t resize. Force root view to be windowSize. measureSpec = MeasureSpec.makeMeasureSpec(windowSize,MeasureSpec.EXACTLY); break; ...... &#125; return measureSpec; &#125; performTraversals 中我们看到的mView其实就是DecorView,View的绘制从DecorView开始， 在mView.measure()的时候调用getRootMeasureSpec获得两个MeasureSpec做为参数，getRootMeasureSpec的两个参数（mWidth, lp.width）mWith和mHeight 是屏幕的宽度和高度， lp是WindowManager.LayoutParams，它的lp.width和lp.height的默认值是MATCH_PARENT,所以通过getRootMeasureSpec 生成的测量规格MeasureSpec 的mode是MATCH_PARENT ，size是屏幕的高宽。因为DecorView 是一个FrameLayout 那么接下来会进入FrameLayout 的measure方法，measure的两个参数就是刚才getRootMeasureSpec的生成的两个MeasureSpec，DecorView的测量开始了。首先是DecorView 的 MeasureSpec ，根据上面的分析DecorView 的 MeasureSpec是Windows传过来的，我们画出DecorView 的MeasureSpec 图： 注：1、-1 代表的是EXACTLY，-2 是AT_MOST2、由于屏幕的像素是1440x2560,所以DecorView 的MeasureSpec的size 对应于这两个值 那么接下来在FrameLayout 的onMeasure()方法DecorView开始for循环测量自己的子View,测量完所有的子View再来测量自己，由下图可知，接下来要测量ViewRoot的大小 1234567891011121314151617181920//FrameLayout 的测量protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; ....int maxHeight = 0;int maxWidth = 0;int childState = 0;for (int i = 0; i &lt; count; i++) &#123; final View child = getChildAt(i); if (mMeasureAllChildren || child.getVisibility() != GONE) &#123; // 遍历自己的子View，只要不是GONE的都会参与测量，measureChildWithMargins方法在最上面 // 的源码已经讲过了，如果忘了回头去看看，基本思想就是父View把自己当MeasureSpec // 传给子View结合子View自己的LayoutParams 算出子View 的MeasureSpec，然后继续往下穿， // 传递叶子节点，叶子节点没有子View，只要负责测量自己就好了。 measureChildWithMargins(child, widthMeasureSpec, 0, heightMeasureSpec, 0); .... .... &#125;&#125;....&#125; DecorView 测量ViewRoot 的时候把自己的widthMeasureSpec和heightMeasureSpec传进去了，接下来你就要去看measureChildWithMargins的源码了 123456789101112protected void measureChildWithMargins(View child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed) &#123; final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams(); final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin + widthUsed, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin + heightUsed, lp.height); child.measure(childWidthMeasureSpec, childHeightMeasureSpec);&#125; ViewRoot 是系统的View，它的LayoutParams默认都是match_parent,根据我们文章最开始MeasureSpec 的计算规则，ViewRoot 的MeasureSpec mode应该等于EXACTLY（DecorView MeasureSpec 的mode是EXACTLY，ViewRoot的layoutparams 是match_parent），size 也等于DecorView的size，所以ViewRoot的MeasureSpec图如下： 算出ViewRoot的MeasureSpec 之后，开始调用ViewRoot.measure 方法去测量ViewRoot的大小，然而ViewRoot是一个LinearLayout ，ViewRoot.measure最终会执行的LinearLayout 的onMeasure 方法，LinearLayout 的onMeasure 方法又开始逐个测量它的子View，上面的measureChildWithMargins方法又会被调用，那么根据View的层级图，接下来测量的是header（ViewStub）,由于header的Gone，所以直接跳过不做测量工作，所以接下来轮到ViewRoot的第二个child content（android.R.id.content）,我们要算出这个content 的MeasureSpec，所以又要拿ViewRoot 的MeasureSpec 和 android.R.id.content的LayoutParams 做计算了，计算过程就是调用getChildMeasureSpec的方法， 1234567891011121314protected void measureChildWithMargins(View child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed) &#123; ..... final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin + heightUsed, lp.height); ....&#125;public static int getChildMeasureSpec(int spec, int padding, int childDimension) &#123; int specMode = MeasureSpec.getMode(spec); //获得父View的mode int specSize = MeasureSpec.getSize(spec); //获得父View的大小 int size = Math.max(0, specSize - padding); //父View的大小-自己的Padding+子View的Margin，得到值才是子View可能的最大值。 .....&#125; 由上面的代码 1int size = Math.max(0, specSize - padding); 而1padding=mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin + heightUsed 算出android.R.id.content 的MeasureSpec 的size由于ViewRoot 的mPaddingBottom=100px(这个可能和状态栏的高度有关，我们测量的最后会发现id/statusBarBackground的View的高度刚好等于100px，ViewRoot 是系统的View的它的Padding 我们没法改变，所以计算出来Content（android.R.id.content） 的MeasureSpec 的高度少了100px ，它的宽高的mode 根据算出来也是EXACTLY（ViewRoot 是EXACTLY和android.R.id.content 是match_parent）。所以Content（android.R.id.content）的MeasureSpec 如下（高度少了100px）：Paste_Image.pngContent（android.R.id.content） 是FrameLayout，递归调用开始准备计算id/linear的MeasureSpec，我们先给出结果： 图中有两个要注意的地方：1、id/linear的heightMeasureSpec 的mode=AT_MOST，因为id/linear 的LayoutParams 的layout_height=”wrap_content”2、id/linear的heightMeasureSpec 的size 少了200px, 由上面的代码padding=mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin + heightUsed;int size = Math.max(0, specSize - padding);由于id/linear 的 android:layout_marginTop=”50dp” 使得lp.topMargin=200px (本设备的density=4，px=4*pd)，在计算后id/linear的heightMeasureSpec 的size 少了200px。（布局代码前面已给出，可自行查看id/linear 控件xml中设置的属性） linear.measure接着往下算linear的子View的的MeasureSpec，看下View 层级图，往下走应该是id/text,接下来是计算id/text的MeasureSpec，直接看图，mode=AT_MOST ,size 少了280，别问我为什么 …specSize - padding. 算出id/text 的MeasureSpec 后，接下来text.measure(childWidthMeasureSpec, childHeightMeasureSpec);准备测量id/text 的高宽，这时候已经到底了，id/text是TextView，已经没有子类了，这时候跳到TextView的onMeasure方法了。TextView 拿着刚才计算出来的heightMeasureSpec（mode=AT_MOST,size=1980）,这个就是对TextView的高度和宽度的约束，进到TextView 的onMeasure(widthMeasureSpec,heightMeasureSpec) 方法，在onMeasure 方法执行调试过程中，我们发现下面的代码： 123456int desired = getDesiredHeight(); desired = 107pxif(heightMode == MeasureSpec.AT_MOST)&#123; height = Math.min(desired,heightSize); height = 1980px &#125; setMeasuredDimension(width,height); TextView字符的高度（也就是TextView的content高度[wrap_content]）测出来=107px，107px 并没有超过1980px(允许的最大高度)，所以实际测量出来TextView的高度是107px。最终算出id/text 的mMeasureWidth=1440px,mMeasureHeight=107px。 贴一下布局代码，免得你忘了具体布局。 1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:id=&quot;@+id/linear&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;50dp&quot; android:background=&quot;@android:color/holo_blue_dark&quot; android:paddingBottom=&quot;70dp&quot; android:orientation=&quot;vertical&quot;&gt; &lt;TextView android:id=&quot;@+id/text&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;@color/material_blue_grey_800&quot; android:text=&quot;TextView&quot; android:textColor=&quot;@android:color/white&quot; android:textSize=&quot;20sp&quot; /&gt; &lt;View android:id=&quot;@+id/view&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;150dp&quot; android:background=&quot;@android:color/holo_green_dark&quot; /&gt;&lt;/LinearLayout&gt; TextView的高度已经测量出来了，接下来测量id/linear的第二个child（id/view），同样的原理测出id/view的MeasureSpec. id/view的MeasureSpec 计算出来后，调用view.measure(childWidthMeasureSpec, childHeightMeasureSpec)的测量id/view的高宽，之前已经说过View measure的默认实现是 12345protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasuredDimension( getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));&#125; 最终算出id/view的mMeasureWidth=1440px,mMeasureHeight=600px。 id/linear 的子View的高度都计算完毕了，接下来id/linear就通过所有子View的测量结果计算自己的高宽，id/linear是LinearLayout，所有它的高度计算简单理解就是子View的高度的累积+自己的Padding. 最终算出id/linear的mMeasureWidth=1440px,mMeasureHeight=987px。 最终算出id/linear出来后，id/content 就要根据它唯一的子View id/linear 的测量结果和自己的之前算出的MeasureSpec一起来测量自己的结果，具体计算的逻辑去看FrameLayout onMeasure 函数的计算过程。以此类推，接下来测量ViewRoot,然后再测量id/statusBarBackground,虽然不知道id/statusBarBackground 是什么，但是调试的过程中，测出的它的高度=100px, 和 id/content 的paddingTop 刚好相等。在最后测量DecorView 的高宽，最终整个测量过程结束。所有的View的大小测量完毕。所有的getMeasureWidth 和 getMeasureWidth 都已经有值了。Measure 分析到此为止，如有不懂，评论留言（简书：kelin） layout过程123mView.measure(childWidthMeasureSpec, childHeightMeasureSpec); ......mView.layout(0, 0, mView.getMeasuredWidth(), mView.getMeasuredHeight()); performTraversals 方法执行完mView.measure 计算出mMeasuredXXX后就开始执行layout 函数来确定View具体放在哪个位置，我们计算出来的View目前只知道view矩阵的大小，具体这个矩阵放在哪里，这就是layout 的工作了。layout的主要作用 ：根据子视图的大小以及布局参数将View树放到合适的位置上。 既然是通过mView.layout(0, 0, mView.getMeasuredWidth(), mView.getMeasuredHeight()); 那我们来看下layout 函数做了什么，mView肯定是个ViewGroup，不会是View,我们直接看下ViewGroup 的layout函数 1234567891011public final void layout(int l, int t, int r, int b) &#123; if (!mSuppressLayout &amp;&amp; (mTransition == null || !mTransition.isChangingLayout())) &#123; if (mTransition != null) &#123; mTransition.layoutChange(this); &#125; super.layout(l, t, r, b); &#125; else &#123; // record the fact that we noop&apos;d it; request layout when transition finishes mLayoutCalledWhileSuppressed = true; &#125;&#125; 代码可以看个大概，LayoutTransition是用于处理ViewGroup增加和删除子视图的动画效果，也就是说如果当前ViewGroup未添加LayoutTransition动画，或者LayoutTransition动画此刻并未运行，那么调用super.layout(l, t, r, b)，继而调用到ViewGroup中的onLayout，否则将mLayoutSuppressed设置为true，等待动画完成时再调用requestLayout()。这个函数是final 不能重写，所以ViewGroup的子类都会调用这个函数，layout 的具体实现是在super.layout(l, t, r, b)里面做的，那么我接下来看一下View类的layout函数 12345678910111213141516public final void layout(int l, int t, int r, int b) &#123; ..... //设置View位于父视图的坐标轴 boolean changed = setFrame(l, t, r, b); //判断View的位置是否发生过变化，看有必要进行重新layout吗 if (changed || (mPrivateFlags &amp; LAYOUT_REQUIRED) == LAYOUT_REQUIRED) &#123; if (ViewDebug.TRACE_HIERARCHY) &#123; ViewDebug.trace(this, ViewDebug.HierarchyTraceType.ON_LAYOUT); &#125; //调用onLayout(changed, l, t, r, b); 函数 onLayout(changed, l, t, r, b); mPrivateFlags &amp;= ~LAYOUT_REQUIRED; &#125; mPrivateFlags &amp;= ~FORCE_LAYOUT; ..... &#125; 1、setFrame(l, t, r, b) 可以理解为给mLeft 、mTop、mRight、mBottom赋值，然后基本就能确定View自己在父视图的位置了，这几个值构成的矩形区域就是该View显示的位置，这里的具体位置都是相对与父视图的位置。 2、回调onLayout，对于View来说，onLayout只是一个空实现，一般情况下我们也不需要重载该函数,： 123protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123; &#125; 对于ViewGroup 来说，唯一的差别就是ViewGroup中多了关键字abstract的修饰，要求其子类必须重载onLayout函数。 123@Override protected abstract void onLayout(boolean changed, int l, int t, int r, int b); 而重载onLayout的目的就是安排其children在父视图的具体位置，那么如何安排子View的具体位置呢？ 123456int childCount = getChildCount() ; for(int i=0 ;i&lt;childCount ;i++)&#123; View child = getChildAt(i) ; //整个layout()过程就是个递归过程 child.layout(l, t, r, b) ; &#125; 代码很简单，就是遍历自己的孩子，然后调用 child.layout(l, t, r, b) ，给子view 通过setFrame(l, t, r, b) 确定位置，而重点是(l, t, r, b) 怎么计算出来的呢。还记得我们之前测量过程，测量出来的MeasuredWidth和MeasuredHeight吗？还记得你在xml 设置的Gravity吗？还有RelativeLayout 的其他参数吗，没错，就是这些参数和MeasuredHeight、MeasuredWidth 一起来确定子View在父视图的具体位置的。具体的计算过程大家可以看下最简单FrameLayout 的onLayout 函数的源码，每个不同的ViewGroup 的实现都不一样，这边不做具体分析了吧。 3、MeasuredWidth和MeasuredHeight这两个参数为layout过程提供了一个很重要的依据（如果不知道View的大小，你怎么固定四个点的位置呢），但是这两个参数也不是必须的，layout过程中的4个参数l, t, r, b完全可以由我们任意指定，而View的最终的布局位置和大小（mRight - mLeft=实际宽或者mBottom-mTop=实际高）完全由这4个参数决定，measure过程得到的mMeasuredWidth和mMeasuredHeight提供了视图大小测量的值，但我们完全可以不使用这两个值，所以measure过程并不是必须的。如果我们不使用这两个值，那么getMeasuredWidth() 和getWidth() 就很有可能不是同一个值，它们的计算是不一样的： 123456public final int getMeasuredWidth() &#123; return mMeasuredWidth &amp; MEASURED_SIZE_MASK; &#125; public final int getWidth() &#123; return mRight - mLeft; &#125; layout 过程相对简单些，分析就到此为止。 draw过程performTraversals 方法的下一步就是mView.draw(canvas); 因为View的draw 方法一般不去重写，官网文档也建议不要去重写draw 方法，所以下一步执行就是View.java的draw 方法，我们来看下源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public void draw(Canvas canvas) &#123; ... /* * Draw traversal performs several drawing steps which must be executed * in the appropriate order: * * 1. Draw the background * 2. If necessary, save the canvas&apos; layers to prepare for fading * 3. Draw view&apos;s content * 4. Draw children * 5. If necessary, draw the fading edges and restore layers * 6. Draw decorations (scrollbars for instance) */ // Step 1, draw the background, if needed ... background.draw(canvas); ... // skip step 2 &amp; 5 if possible (common case) ... // Step 2, save the canvas&apos; layers ... if (solidColor == 0) &#123; final int flags = Canvas.HAS_ALPHA_LAYER_SAVE_FLAG; if (drawTop) &#123; canvas.saveLayer(left, top, right, top + length, null, flags); &#125; ... // Step 3, draw the content if (!dirtyOpaque) onDraw(canvas); // Step 4, draw the children dispatchDraw(canvas); // Step 5, draw the fade effect and restore layers if (drawTop) &#123; matrix.setScale(1, fadeHeight * topFadeStrength); matrix.postTranslate(left, top); fade.setLocalMatrix(matrix); canvas.drawRect(left, top, right, top + length, p); &#125; ... // Step 6, draw decorations (scrollbars) onDrawScrollBars(canvas); &#125; 注释写得比较清楚，一共分成6步，看到注释没有（ // skip step 2 &amp; 5 if possible (common case)）除了2 和 5之外 我们一步一步来看：1、第一步：背景绘制看注释即可，不是重点 12345678910111213private void drawBackground(Canvas canvas) &#123; Drawable final Drawable background = mBackground; ...... //mRight - mLeft, mBottom - mTop layout确定的四个点来设置背景的绘制区域 if (mBackgroundSizeChanged) &#123; background.setBounds(0, 0, mRight - mLeft, mBottom - mTop); mBackgroundSizeChanged = false; rebuildOutline(); &#125; ...... //调用Drawable的draw() 把背景图片画到画布上 background.draw(canvas); ...... &#125; 2、第三步，对View的内容进行绘制。onDraw(canvas) 方法是view用来draw 自己的，具体如何绘制，颜色线条什么样式就需要子View自己去实现，View.java 的onDraw(canvas) 是空实现，ViewGroup 也没有实现，每个View的内容是各不相同的，所以需要由子类去实现具体逻辑。 3、第4步 对当前View的所有子View进行绘制dispatchDraw(canvas) 方法是用来绘制子View的，View.java 的dispatchDraw()方法是一个空方法,因为View没有子View,不需要实现dispatchDraw ()方法，ViewGroup就不一样了，它实现了dispatchDraw ()方法： 1234567891011121314151617181920@Override protected void dispatchDraw(Canvas canvas) &#123; ... if ((flags &amp; FLAG_USE_CHILD_DRAWING_ORDER) == 0) &#123; for (int i = 0; i &lt; count; i++) &#123; final View child = children[i]; if ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) &#123; more |= drawChild(canvas, child, drawingTime); &#125; &#125; &#125; else &#123; for (int i = 0; i &lt; count; i++) &#123; final View child = children[getChildDrawingOrder(count, i)]; if ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) &#123; more |= drawChild(canvas, child, drawingTime); &#125; &#125; &#125; ...... &#125; 代码一眼看出，就是遍历子View然后drawChild(),drawChild()方法实际调用的是子View.draw()方法,ViewGroup类已经为我们实现绘制子View的默认过程，这个实现基本能满足大部分需求，所以ViewGroup类的子类（LinearLayout,FrameLayout）也基本没有去重写dispatchDraw方法，我们在实现自定义控件，除非比较特别，不然一般也不需要去重写它， drawChild()的核心过程就是为子视图分配合适的cavas剪切区，剪切区的大小正是由layout过程决定的，而剪切区的位置取决于滚动值以及子视图当前的动画。设置完剪切区后就会调用子视图的draw()函数进行具体的绘制了。 4、第6步 对View的滚动条进行绘制不是重点，知道有这东西就行，onDrawScrollBars 的一句注释 ：Request the drawing of the horizontal and the vertical scrollbar. The scrollbars are painted only if they have been awakened first. 一张图看下整个draw的递归流程。 到此整个绘制过程基本讲述完毕了。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://yoursite.com/tags/android/"}]},{"title":"linux用户控件、内和空间","slug":"Linux 用户空间 内核空间","date":"2017-09-07T12:30:15.000Z","updated":"2018-05-06T13:11:43.893Z","comments":true,"path":"2017/09/07/Linux 用户空间 内核空间/","link":"","permalink":"http://yoursite.com/2017/09/07/Linux 用户空间 内核空间/","excerpt":"","text":"用户空间就是用户进程所在的内存区域，相对的，系统空间就是操作系统占据的内存区域。 用户进程和系统进程的所有数据都在内存中。 是谁来划分内存空间的呢？ 在电脑开机之前，内存就是一块原始的物理内存。什么也没有。开机加电，系统启动后，就对物理内存进行了划分。当然，这是系统的规定，物理内存条上并没有划分好的地址和空间范围。这些划分都是操作系统在逻辑上的划分。不同版本的操作系统划分的结果都是不一样的。 为什么要划分用户空间和系统空间呢？当然是有必要的。操作系统的数据都是存放于系统空间的，用户进程的数据是存放于用户空间的。这是第一点，不同的身份，数据放置的位置必然不一样，否则大混战就会导致系统的数据和用户的数据混在一起，系统就不能很好的运行了。分开来存放，就让系统的数据和用户的数据互不干扰，保证系统的稳定性。分开存放，管理上很方便，而更重要的是，将用户的数据和系统的数据隔离开，就可以对两部分的数据的访问进行控制。这样就可以确保用户程序不能随便操作系统的数据，这样防止用户程序误操作或者是恶意破坏系统。 处于用户态的程序只能访问用户空间，而处于内核态的程序可以访问用户空间和内核空间。那么用户态和内核态有什么区别呢？ 当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）。此时处理器处于特权级最高的（0级）内核代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。当进程在执行用户自己的代码时，则称其处于用户运行态（用户态）。即此时处理器在特权级最低的（3级）用户代码中运行。 内核态与用户态是操作系统的两种运行级别,Intel x86架构提供Ring0-Ring3四种级别的运行模式，Ring0级别最高，Ring3最低。Linux使用了Ring3级别运行用户态，Ring0作为 内核态，没有使用Ring1和Ring2。Ring3状态不能访问Ring0的地址空间，包括代码和数据。程序特权级别的不同，其所拥有的权力也不同。如下图所示。 用户态切换到内核态的3种方式 a. 系统调用 这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作，比如fork()实际上就是执行了一个创建新进程的系统调用。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断。 b. 异常 当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。 c. 外围设备的中断 当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。 这3种方式是系统在运行时由用户态转到内核态的最主要方式，其中系统调用可以认为是用户进程主动发起的，异常和外围设备中断则是被动的。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"webrtc音频总结","slug":"webrtc 音频","date":"2017-08-16T13:10:30.000Z","updated":"2018-05-06T13:37:22.813Z","comments":true,"path":"2017/08/16/webrtc 音频/","link":"","permalink":"http://yoursite.com/2017/08/16/webrtc 音频/","excerpt":"","text":"webrtc/modules/audio_device/android/audio_record_jni.cc 这个文件，是音频采集jni类文件。 Android Audio Record 和 JNI 通信接口包括： 123// java 调用 c++ 接口nativeCacheDirectBufferAddressnativeDataIsRecorded 123456// c++ 回调 java 接口initRecordingstartRecordingstopRecordingenableBuiltInAECenableBuiltInNS nativeCacheDirectBufferAddress 和 nativeDataIsRecorded 只是为了高效的将 AudioRecord 采集到的音频数据传递给 native。 WebRtcVoiceEngineWebRtcVoiceEngine 初始化 12345678910111213WebRtcVoiceEngine::Init()&#123; send_codecs_ = CollectCodecs(encoder_factory_-&gt;GetSupportedEncoders()); recv_codecs_ = CollectCodecs(decoder_factory_-&gt;GetSupportedDecoders()); adm_ = webrtc::AudioDeviceModule::Create( webrtc::AudioDeviceModule::kPlatformDefaultAudio ); webrtc::adm_helpers::Init(adm()); webrtc::apm_helpers::Init(apm());&#125; 可知，WebRtcVoiceEngine 里面的 adm_ 就是 AudioDeviceModule ，代码在 /modules/audio_device/audio_device_impl.cc 在 webrtcvoiceengine.h123456789101112131415161718192021222324252627// WebRtcVoiceEngine//public void Init();AudioState GetAudioState();VoiceMediaChannel* CreateChannel(Call call, MediaConfig config, AudioOptions options);AudioCodec send_codecs();AudioCodec recv_codecs();RtpCapabilities GetCapabilities();void RegisterChannel(WebRtcVoiceMediaChannel* channel);void UnregisterChannel(WebRtcVoiceMediaChannel* channel);bool StartAecDump();void StopAecDump();//privateAudioDeviceModule adm_;AudioEncoderFactory encoder_factory_;AudioDecoderFactory decoder_factory_;AudioMixer audio_mixer_;AudioProcessing apm_;AudioState audio_state_;AudioCodec send_codecs_;AudioCodec recv_codecs_;WebRtcVoiceMediaChannel channels_; audio_device//webrtc/modules/audio_device/ audio_device_impl.cc 123456789AudioDeviceModule::Create()&#123; audioDevice(new AudioDeviceModuleImpl(audio_layer)); audioDevice-&gt;CheckPlatform(); audioDevice-&gt;CreatePlatformSpecificObjects(); audioDevice-&gt;AttachAudioBuffer(); return audioDevice;&#125; 123456789101112131415161718192021222324252627282930313233343536373839AudioDeviceModuleImpl::CreatePlatformSpecificObjects()&#123; // WEBRTC_DUMMY_AUDIO_BUILD audio_device_.reset(new AudioDeviceDummy()); // WEBRTC_DUMMY_FILE_DEVICES audio_device_.reset(FileAudioFactory::CreateFileAudioDevice()); // WEBRTC_WINDOWS_CORE_AUDIO_BUILD audio_device_.reset(new AudioDeviceWindowsCore()); // WEBRTC_ANDROID audio_manager_android_.reset(new AudioManager()); if(audio_layer == kPlatformDefaultAudio)&#123; audio_layer = kAndroidOpenSLESAudio; &#125; else if(isLowLatencySupported)&#123; audio_layer = kAndroidJavaInputAndroidOpenSLESOutputAudio; &#125; else &#123; audio_layer = kAndroidJavaAudio; &#125; if(kAndroidJavaAudio)&#123; audio_device_.reset(new AudioDeviceTemplate&lt;AudioRecordJni, AudioTrackJni&gt;()) &#125; else if(kAndroidOpenSLESAudio)&#123; audio_device_.reset(new AudioDeviceTemplate&lt;OpenSLESRecorder, OpenSLESPlayer&gt;()); &#125; else if(kAndroidJavaInputAndOpenSLESOutputAudio)&#123; audio_device_.reset(new AudioDeviceTemplate&lt;AudioRecordJni, OpenSLESPlayer&gt;()) &#125; // WEBRTC_LINUX if(kLinuxPulseAudio || kPlatformDefaultAudio)&#123; audio_device_.reset(new AudioDeviceLinuxPulse()) &#125; else if(kLinuxAlsaAudio)&#123; audio_device_.reset(new AudioDeviceLinuxALSA()) &#125; // WEBRTC_IOS audio_device_.reset(new AudioDeviceIOS()) // WEBRTC_MAC audio_device_.reset(new AudioDeviceMac())&#125; 我们以 Android 为例；使用 AudioDeviceTemplate 封装 音频输入（采集）、输出类型（渲染）；目前使用 AudioRecordJni 和 AudioTrackJni。如果直接使用 NDK 的openSLES 开发的化，使用的是 OpenSLESRecorder 和 OpenSLESPlayer。 audio_manager.h12345678910// JavaAudioManagerbool Init()void Close()bool IsCommunicationModeEnabled()bool IsDeviceBlacklistedForOpenSLESUsage()// privateJNICALL CacheAudioParameters()void OnCacheAudioParameters() audio_record_jni.h1234567891011121314151617181920212223242526272829//JavaAudioRecordint InitRecording(int sample_reate, size_t channels);bool StartRecording();bool StopRecording();bool EnableBuiltInAEC(bool enable);bool EnableBuiltInNS(bool enable);// publicint32_t Init();int32_t Terminate();int32_t InitRecording();bool RecordingIsInitialized();int32_t StartRecording();int32_t StopRecording();bool Recording();void AttachAudioBuffer();int32_t EnableBuiltInAEC(bool enable);int32_t EnableBuiltInAGC(bool enable);int32_t EnableBuiltInNS(bool enable);// privateJNICALL CacheDirectBufferAddress()void OnCacheDirectBufferAddress(jobject byte_buffer)JNICALL DataIsRecorded();void OnDataIsRecorded(int length); audio_track_jni.h 12345678910111213141516171819202122232425262728293031// JavaAudioTrackbool InitPlayout(int sample_rate, int channels);bool StartPlayout();bool StopPlayout();bool SetStreamVolume(int volume);int GetStreamMaxVolume();int GetStreamVolume();// publicInit()Terminate()InitPlayout()PlayoutIsInitialized()StartPlayout()StopPlayout()Playing()SpeakerVolumeIsAvailable(bool available);SetSpeakerVolume(volume);SpeakerVolume(volume);MaxSpeakerVolume(max_volume);MinSpeakerVolume(min_volume);AttachAudioBuffer(audioBuffer);// privateJNICALL CacheDirectBufferAddress();void OnCacheDirectBufferAddress(jobject byte_buffer);JNICALL GetPlayoutData();void OnGetPlayoutData(size_t length); AudioRecordJni音频采集初始化AudioRecordJni 初始化时，在构造方法中初始化 JavaAudioRecord。123j_audio-record_.reset( new JavaAudioRecord()) 然后在 webrtcvoiceengine 中 AddSendStream 后，SetSend() 配置媒体通道发送。 12345678910111213//media/engine/webrtcvoiceengine.ccWebRtcVoiceMediaChannel::SetSend(bool send)&#123; ... if(send)&#123; engine()-&gt;ApplyOptions(options_); if(!engine()-&gt;adm()-&gt;RecordingIsInitialized() &amp;&amp; !engine()-&gt;adm()-&gt;Recording())&#123; engine()-&gt;adm()-&gt;InitRecording(); &#125; &#125; ...&#125; 这里面会初始化 AudioRecord。 InitRecording() 方法实现，在 Android 中实在 audio_record_jni.cc 的 JavaAudioRecord::InitRecording() ，最终通过 JNI 回调 Java 层的 InitRecording() 方法。 音频采集初始化完成后，就要开始采集音频数据。 /audio/audio_send_stream.cc音频发送流里面 AudioSendStream::Start() 方法启动音频流发送； 1234AudioSendSstream::Start()&#123; channel_proxy_-&gt;StartSend(); audio_state()-&gt;AddSendingStream(this, encoder_sample_rate_hz_, encoder_num_channels_);&#125; 调用 /audio/audio_state.cc 的 AudioState::AddSendingStream() 方法； 123456AudioState::AddSendingStream()&#123; auto* adm = config_.audio_device_module.get(); ... amd-&gt;StartRecording(); ...&#125; 音频开关另外，PeerConnection 提供了 音频采集开关。 1234//org.webrtc.PeerConnection.javapublic void setAudioRecording(boolean recording)&#123; nativeSetAudioRecording();&#125; 对应的JNI方法1234//JNI/pc/peerconnection.ccvoid JNI_PeerConnection_SetAudioRecording()&#123; ExtractNativePC(jni,j_pc)-&gt;SetAudioRecording(recording);&#125; 其实JNI方法也是调用 webrtc 的 peerconnection 1234567//webrtc/pc/peerconnection.ccPeerConnection::SetAudioRecording(bool recording)&#123; auto audio_state = factory_-&gt;channel_manager()-&gt;media_engine()-&gt;GetAudioState(); // AudioState audio_state-&gt;SetRecording(recording);&#125; 由上代码可知， 通过 WebRtcVoiceEngine 的 GetAudioState() 方法获取 audio_state。然后通过 audio_state 设置音频采集开关。 在 AudioState::SetRecording() 方法调用具体设备模块开始或停止音频采集。 123456789//webrtc/audio/audio_state.ccAudioState::SetRecording(bool enabled)&#123; ... if(enabled)&#123; config_.audio_device_module-&gt;StartRecording(); &#125;else&#123; config_.audio_device_module-&gt;StopRecording(); &#125;&#125; 音频采集具体实现这里我们只以Android为例。 如果使用 opensles ndk 采集音频，采集的具体实现在 opensles_recorder.cc 文件的 StartRecording() 方法。 1234// modules/audio_device/android/opensles_recorder.ccint OpenSLESRecorder::StartRecording()&#123; ...&#125; 这种方法的具体实现我们暂时不深入。 我们讨论 java 实现方案。 java 实现的jni类，audio_record_jni.cc123456//modules/audio_device/android/audio_record_jni.ccAudioRecordJni::StartRecording()&#123; ... j_audio_record_-&gt;StartRecording() ...&#125; j_audio_record_-&gt;StartRecording() 调用的就是 AudioRecordJni::JavaAudioRecord::StartRecording() 方法。 123AudioRecordJni::JavaAudioRecord::StartRecording()&#123; return audio_record_-&gt;CallBooleanMethod(start_recording_);&#125; CallBooleanMethod 就是jni回调java 实现的封装，最终实现回调 WebRtcAudioRecord.java 中的 StartRecording() 方法。 123456//org.webrtc.voiceengine.WebRtcAudioRecord.java boolean startRecording()&#123; audioRecord.startRecording(); audioThread = new AudioRecordThread(&quot;AudioRecordJavaThread&quot;); audioThread.start();&#125; 音频采集线程音频采集线 AudioRecordThread；我们只跟踪 run() 方法。 123456789101112131415161718@Overridepublic void run()&#123; ... while(keepAlive)&#123; int bytesRead = audioRecord.read(byteBuffer, byteBuffer.capacity()); // 通知 native 音频数据 nativeDataIsRecorded(bytesRead, nativeAudioRecord); // 应用音频采集回调 byte[] data = Arrays.copyOf(byteBuffer.array(), byteBuffer.capacity()); audioSamplesReadyCallback.onWebRtcAudioRecordSamplesReady( new AudioSamples(audioRecord, data) ); &#125; ...&#125;","categories":[{"name":"webrtc","slug":"webrtc","permalink":"http://yoursite.com/categories/webrtc/"}],"tags":[{"name":"webrtc","slug":"webrtc","permalink":"http://yoursite.com/tags/webrtc/"}]},{"title":"MK语法规范","slug":"MK语法规范","date":"2017-05-07T12:11:15.000Z","updated":"2018-05-06T13:07:44.655Z","comments":true,"path":"2017/05/07/MK语法规范/","link":"","permalink":"http://yoursite.com/2017/05/07/MK语法规范/","excerpt":"","text":"Android.mk文件语法规范及使用模板 Introduction:Android.mk编译文件是用来向Android NDK描述你的C,C++源代码文件的， 这篇文档描述了它的语法。在阅读下面的内容之前，假定你已经阅读了docs/OVERVIEW.TXT文件，了解了它们的用途。 概述:一个 Android.mk file用来向编译系统描述你的源代码。具体来说：-该文件是GNU Makefile的一小部分，会被编译系统解析一次或更多次的build系统。因此，您应尽量减少您声明的变量，不要认为某些变量在解析过程中不会被定义。-这个文件的语法允许把你的源代码组织成模块，一个模块属下列类型之一： 静态库 、共享库 只有共享库将被安装/复制到您的应用软件包。虽然静态库能被用于生成共享库。 你可以在每一个Android.mk file中定义一个或多个模块，你也可以在几个模块中使用同一个源代码文件。 -编译系统为你处理许多细节问题。例如，你不需要在你的Android.mk中列出头文件和依赖文件。NDK编译系统将会为你自动处理这些问题。这也意味着，在升级NDK后，你应该得到新的toolchain/platform支持，而且不需要改变你的Android.mk文件。 注意，这个语法同公开发布的Android平台的开源代码很接近，然而编译系统实现他们的方式却是不同的，这是故意这样设计的，可以让程序开发人员重用外部库的源代码更容易。 简单的例子: 在描述语法细节之前，咱们来看一个简单的”hello world”的例子，比如，下面的文件： 123sources/helloworld/helloworld.csources/helloworld/Android.mk ‘helloworld.c’是一个JNI共享库，实现返回”hello world”字符串的原生方法。 相应的Android.mk文件会象下面这样： 12345678910111213---------- cut here ------------------LOCAL_PATH := $(call my-dir)include $(CLEAR_VARS)LOCAL_MODULE:= helloworldLOCAL_SRC_FILES := helloworld.cinclude $(BUILD_SHARED_LIBRARY)---------- cut here ------------------ 好，我们来解释一下这几行代码： 1LOCAL_PATH := $(call my-dir) 一个Android.mk file首先必须定义好LOCAL_PATH变量。它用于在开发树中查找源文件。在这个例子中，宏函数’my-dir’, 由编译系统提供，用于返回当前路径（即包含Android.mk file文件的目录）。 1include $( CLEAR_VARS) CLEAR_VARS由编译系统提供，指定让GNU MAKEFILE为你清除许多LOCAL_XXX变量（例如 LOCAL_MODULE, LOCAL_SRC_FILES, LOCAL_STATIC_LIBRARIES, 等等…), 除LOCAL_PATH 。这是必要的，因为所有的编译控制文件都在同一个GNU MAKE执行环境中，所有的变量都是全局的。 1LOCAL_MODULE := helloworld LOCAL_MODULE变量必须定义，以标识你在Android.mk文件中描述的每个模块。名称必须是唯一的，而且不包含任何空格。注意编译系统会自动产生合适的前缀和后缀，换句话说，一个被命名为’foo’的共享库模块，将会生成’libfoo.so’文件。 重要注意事项 如果你把库命名为‘libhelloworld’，编译系统将不会添加任何的lib前缀，也会生成libhelloworld.so，这是为了支持来源于Android平台的源代码的Android.mk文件，如果你确实需要这么做的话。 1LOCAL_SRC_FILES := helloworld.c LOCAL_SRC_FILES变量必须包含将要编译打包进模块中的C或C++源代码文件。注意，你不用在这里列出头文件和包含文件，因为编译系统将会自动为你找出依赖型的文件；仅仅列出直接传递给编译器的源代码文件就好。【注意，默认的C++源码文件的扩展名是’.cpp’. 指定一个不同的扩展名也是可能的，只要定义LOCAL_DEFAULT_CPP_EXTENSION变量，不要忘记开始的小圆点（也就是定义为‘.cxx’,而不是‘cxx’）（当然这一步我们一般不会去改它）】 1include $(BUILD_SHARED_LIBRARY) BUILD_SHARED_LIBRARY是编译系统提供的变量，指向一个GNU Makefile脚本（应该就是在build/core目录下的shared_library.mk），负责收集自从上次调用’include $(CLEAR_VARS)’以来，定义在LOCAL_XXX变量中的所有信息，并且决定编译什么，如何正确地去做。并根据其规则生成静态库。同理对于静态库。 在sources/samples目录下有更复杂一点的例子，写有注释的Android.mk文件，你可以看看。 参考: 这是一份你应该在Android.mk中依赖或定义的变量列表，您可以定义其他变量为自己使用， 但是NDK编译系统保留下列变量名： -以LOCAL_开头的名字（例如 LOCAL_MODULE） -以PRIVATE_, NDK_ or APP_开头的名字（内部使用） -小写名字（内部使用，例如’my-dir’） 如果您为了方便在Android.mk中定义自己的变量，我们建议使用MY_前缀，一个小例子： 12345678910111213---------- cut here ------------------MY_SOURCES := foo.cifneq ($(MY_CONFIG_BAR),)MY_SOURCES += bar.cendifLOCAL_SRC_FILES += $(MY_SOURCES)---------- cut here ------------------ 这些GNU Make 变量在你的Android.mk文件解析之前，就由编译系统定义好了。 注意在某些情况下，NDK可能分析Android.mk几次，每一次某些变量的定义会有不同。 1CLEAR_VARS 指向一个编译脚本，几乎所有未定义的LOCAL_XXX变量都在”Module-description”节中列出。 你必须在开始一个新模块之前包含这个脚本。 1include $(CLEAR_VARS) 1BUILD_SHARED_LIBRARY 指向编译脚本，收集所有的你在LOCAL_XXX变量中提供的信息，并且决定如何把你列出的源代码文件编译成一个共享库。注意，你必须至少在包含这个文件之前定义LOCAL_MODULE和LOCAL_SRC_FILES，使用例子： 1include $(BUILD_SHARED_LIBRARY) 注意这将生成一个名为lib$(LOCAL_MODULE).so的文件。 1BUILD_STATIC_LIBRARY 一个BUILD_SHARED_LIBRARY变量用于编译一个静态库。静态库不会复制到你的project/packages中，诞生能够用于编译共享库，（看下面描述的LOCAL_STATIC_LIBRARIES and LOCAL_STATIC_WHOLE_LIBRARIES） 使用例子： 1include $(BUILD_STATIC_LIBRARY) 注意，这将会生成一个名为lib$(LOCAL_MODULE).a的文件。 1TARGET_ARCH 目标CPU平台的名字，如同在android开放源码中指定的那样。如果是’arm’，表示要生成ARM兼容的指令，与CPU架构的修订版无关。 1TARGET_PLATFORM Android.mk解析的时候，目标Android平台的名字.详情可参考/development/ndk/docs/stable-apis.txt. android-3 -&gt; Official Android 1.5 system images android-4 -&gt; Official Android 1.6 system images android-5 -&gt; Official Android 2.0 system images 1TARGET_ARCH_ABI 暂时只支持两个value，armeabi和armeabi-v7a。在现在的版本中一般把这两个值简单的定义为arm，通过android 平台内部对它重定义来获得更好的匹配。 其他的ＡＢＩ将在以后的ＮＤＫ版本中介绍，它们会有不同的名字。注意所有基于ＡＲＭ的ＡＢＩ都会把’TARGET_ARCH’定义成‘ａｒｍ’，但是会有不同的‘TARGET_ARCH_ABI’ 1TARGET_ABI 目标平台和ABI的组合，它事实上被定义成$(TARGET_PLATFORM)-$(TARGET_ARCH_ABI) 在你想要在真实的设备中针对一个特别的目标系统进行测试时，会有用。在默认的情况下，它会是’android-3-arm’。 /*/ 下面是GNU Make ‘功能’宏，必须通过使用’$(call )’来求值，他们返回文本化的信息。 1my-dir 返回当前Android.mk所在的目录路径，相对于ＮＤＫ编译系统的顶层。这是有用的，在Android.mk文件的开头如此定义： 1LOCAL_PATH := $(call my-dir) 1all-subdir-makefiles 返回一个位于当前’my-dir’路径的子目录列表。例如，看下面的目录层次： 12345sources/foo/Android.mksources/foo/lib1/Android.mksources/foo/lib2/Android.mk 如果sources/foo/Android.mk包含一行： 1include $(call all-subdir-makefiles) 那么它就会自动包含sources/foo/lib1/Android.mk 和sources/foo/lib2/Android.mk 这项功能用于向编译系统提供深层次嵌套的代码目录层次。注意，在默认情况下，ＮＤＫ将会只搜索在sources/*/Android.mk中的文件。 1this-makefile 返回当前Makefile的路径（即这个函数调用的地方） 1parent-makefile 返回调用树中父Makefile路径。即包含当前Makefile的Makefile路径。 1grand-parent-makefile 猜猜看… /*/ 模块描述变量:下面的变量用于向编译系统描述你的模块。你应该定义在’include $(CLEAR_VARS)’和’include $(BUILD_XXXXX)’之间定义。正如前面描写的那样，$(CLEAR_VARS是一个脚本，清除所有这些变量，除非在描述中显式注明。 1LOCAL_PATH 这个变量用于给出当前文件的路径。你必须在Android.mk的开头定义，可以这样使用： 1LOCAL_PATH := $(call my-dir) 这个变量不会被$(CLEAR_VARS)清除，因此每个Android.mk只需要定义一次（即使你在一个文件中定义了几个模块的情况下）。 1LOCAL_MODULE 这是你模块的名字，它必须是唯一的，而且不能包含空格。你必须在包含任一的$(BUILD_XXXX)脚本之前定义它。模块的名字决定了生成文件的名字，例如，如果一个一个共享库模块的名字是，那么生成文件的名字就是lib.so。但是，在你的NDK生成文件中（或者Android.mk或者Application.mk），你应该只涉及(引用)有正常名字的其他模块。 1LOCAL_SRC_FILES 这是要编译的源代码文件列表。只要列出要传递给编译器的文件，因为编译系统自动为你计算依赖。 注意源代码文件名称都是相对于LOCAL_PATH的，你可以使用路径部分，例如： 1LOCAL_SRC_FILES := foo.c \\ toto/bar.c注意：在生成文件中都要使用UNIX风格的斜杠(/).windows风格的反斜杠不会被正确的处理。 1LOCAL_CPP_EXTENSION 这是一个可选变量，用来指定C++代码文件的扩展名，默认是’.cpp’,但是你可以改变它，比如： 1LOCAL_CPP_EXTENSION := .cxx 1LOCAL_C_INCLUDES 路径的可选配置，是从根目录开始的， 123456789all sources (C, C++ and Assembly). For example: LOCAL_C_INCLUDES := sources/foo Or even: LOCAL_C_INCLUDES := $(LOCAL_PATH)/../foo 需要在任何包含LOCAL_CFLAGS / LOCAL_CPPFLAGS标志之前。 1LOCAL_CFLAGS 可选的编译器选项，在编译C代码文件的时候使用。 这可能是有用的，指定一个附加的包含路径（相对于NDK的顶层目录），宏定义，或者编译选项。 重要信息：不要在Android.mk中改变optimization/debugging级别，只要在Application.mk中指定合适的信息，就会自动地为你处理这个问题，在调试期间，会让ＮＤＫ自动生成有用的数据文件。 123LOCAL_CXXFLAGSSame as LOCAL_CFLAGS for C++ source files 1LOCAL_CPPFLAGS 与LOCAL_CFLAGS相同，但是对C 和 C++ source files都适用。 1LOCAL_STATIC_LIBRARIES 应该链接到这个模块的静态库列表（使用BUILD_STATIC_LIBRARY生成），这仅仅对共享库模块才有意义。 1LOCAL_SHARED_LIBRARIES 这个模块在运行时要依赖的共享库模块列表，在链接时需要，在生成文件时嵌入的相应的信息。注意：这不会附加列出的模块到编译图，也就是，你仍然需要在Application.mk中把它们添加到程序要求的模块中。 1LOCAL_LDLIBS 编译你的模块要使用的附加的链接器选项。这对于使用”-l”前缀传递指定库的名字是有用的。例如，下面将告诉链接器生成的模块要在加载时刻链接到/system/lib/libz.so 1LOCAL_LDLIBS := -lz 看docs/STABLE-APIS.TXT获取你使用NDK发行版能链接到的开放的系统库列表。 1LOCAL_ALLOW_UNDEFINED_SYMBOLS 默认情况下，在试图编译一个共享库时，任何未定义的引用将导致一个“未定义的符号”错误。这对于在你的源代码文件中捕捉错误会有很大的帮助。 然而，如果你因为某些原因，需要不启动这项检查，把这个变量设为‘ｔｒｕｅ’。注意相应的共享库可能在运行时加载失败。（这个一般尽量不要去设为true） 1LOCAL_ARM_MODE 默认情况下，arm目标二进制会以thumb的形式生成（16位），你可以通过设置这个变量为arm如果你希望你的module是以32位指令的形式。 &apos;arm&apos; (32-bit instructions) mode. E.g.: LOCAL_ARM_MODE := arm 注意你同样可以在编译的时候告诉系统编译特定的类型，比如 LOCAL_SRC_FILES := foo.c bar.c.arm 这样就告诉系统总是将bar.c以arm的模式编译， Android.mk使用模板在一个Android.mk中可以生成多个可执行程序、动态库和静态库。 1，编译应用程序的模板：#Test Exe LOCAL_PATH := $(call my-dir) #include $(CLEAR_VARS) LOCAL_SRC_FILES:= main.c LOCAL_MODULE:= test_exe #LOCAL_C_INCLUDES := #LOCAL_STATIC_LIBRARIES := #LOCAL_SHARED_LIBRARIES := include $(BUILD_EXECUTABLE) （菜鸟级别解释：:=是赋值的意思，$是引用某变量的值）LOCAL_SRC_FILES中加入源文件路径，LOCAL_C_INCLUDES 中加入所需要包含的头文件路径，LOCAL_STATIC_LIBRARIES加入所需要链接的静态库（.a）的名称，LOCAL_SHARED_LIBRARIES中加入所需要链接的动态库（.so）的名称，LOCAL_MODULE表示模块最终的名称，BUILD_EXECUTABLE表示以一个可执行程序的方式进行编译。 2，编译静态库的模板：#Test Static Lib LOCAL_PATH := $(call my-dir) include $(CLEAR_VARS) LOCAL_SRC_FILES:= \\ helloworld.c LOCAL_MODULE:= libtest_static #LOCAL_C_INCLUDES := #LOCAL_STATIC_LIBRARIES := #LOCAL_SHARED_LIBRARIES := include $(BUILD_STATIC_LIBRARY) 一般的和上面相似，BUILD_STATIC_LIBRARY表示编译一个静态库。 3，编译动态库的模板：#Test Shared Lib LOCAL_PATH := $(call my-dir) include $(CLEAR_VARS) LOCAL_SRC_FILES:= \\ helloworld.c LOCAL_MODULE:= libtest_shared TARGET_PRELINK_MODULES := false #LOCAL_C_INCLUDES := #LOCAL_STATIC_LIBRARIES := #LOCAL_SHARED_LIBRARIES := include $(BUILD_SHARED_LIBRARY) 一般的和上面相似，BUILD_SHARED_LIBRARY表示编译一个共享库。 以上三者的生成结果分别在如下，generic依具体target会变： 12345out/target/product/generic/obj/EXECUTABLEout/target/product/generic/obj/STATIC_LIBRARYout/target/product/generic/obj/SHARED_LIBRARY 每个模块的目标文件夹分别为： 12345可执行程序：XXX_intermediates静态库： XXX_static_intermediates动态库： XXX_shared_intermediates 另外，在Android.mk文件中，还可以指定最后的目标安装路径，用LOCAL_MODULE_PATH和LOCAL_UNSTRIPPED_PATH来指定。不同的文件系统路径用以下的宏进行选择： 12345TARGET_ROOT_OUT：表示根文件系统。TARGET_OUT：表示system文件系统。TARGET_OUT_DATA：表示data文件系统。 用法如： 1LOCAL_MODULE_PATH:=$(TARGET_ROOT_OUT)","categories":[{"name":"AOSP","slug":"AOSP","permalink":"http://yoursite.com/categories/AOSP/"}],"tags":[{"name":"编译","slug":"编译","permalink":"http://yoursite.com/tags/编译/"},{"name":"mk","slug":"mk","permalink":"http://yoursite.com/tags/mk/"}]},{"title":"Binder通讯机制","slug":"Binder 进程间通讯机制","date":"2017-04-11T11:20:50.000Z","updated":"2018-05-06T13:18:34.649Z","comments":true,"path":"2017/04/11/Binder 进程间通讯机制/","link":"","permalink":"http://yoursite.com/2017/04/11/Binder 进程间通讯机制/","excerpt":"","text":"什么是Binder？Binder是Android系统中进程间通讯（IPC）的一种方式，也是Android系统中最重要的特性之一。Android中的四大组件Activity，Service，Broadcast，ContentProvider，不同的App等都运行在不同的进程中，它是这些进程间通讯的桥梁。正如其名“粘合剂”一样，它把系统中各个组件粘合到了一起，是各个组件的桥梁。 理解Binder对于理解整个Android系统有着非常重要的作用，如果对Binder不了解，就很难对Android系统机制有更深入的理解。 1. Binder架构 Binder 通信采用 C/S 架构，从组件视角来说，包含 Client、 Server、 ServiceManager 以及 Binder 驱动，其中 ServiceManager 用于管理系统中的各种服务。 Binder 在 framework 层进行了封装，通过 JNI 技术调用 Native（C/C++）层的 Binder 架构。 Binder 在 Native 层以 ioctl 的方式与 Binder 驱动通讯。 2.Binder机制 首先需要注册服务端，只有注册了服务端，客户端才有通讯的目标，服务端通过 ServiceManager 注册服务，注册的过程就是向 Binder 驱动的全局链表 binder_procs 中插入服务端的信息（binder_proc 结构体，每个 binder_proc 结构体中都有 todo 任务队列），然后向 ServiceManager 的 svcinfo 列表中缓存一下注册的服务。 有了服务端，客户端就可以跟服务端通讯了，通讯之前需要先获取到服务，拿到服务的代理，也可以理解为引用。比如下面的代码： 121//获取WindowManager服务引用2 WindowManager wm = (WindowManager)getSystemService(getApplication().WINDOW_SERVICE); 获取服务端的方式就是通过 ServiceManager 向 svcinfo 列表中查询一下返回服务端的代理，svcinfo 列表就是所有已注册服务的通讯录，保存了所有注册的服务信息。 有了服务端的引用我们就可以向服务端发送请求了，通过 BinderProxy 将我们的请求参数发送给 ServiceManager，通过共享内存的方式使用内核方法 copy_from_user() 将我们的参数先拷贝到内核空间，这时我们的客户端进入等待状态，然后 Binder 驱动向服务端的 todo 队列里面插入一条事务，执行完之后把执行结果通过 copy_to_user() 将内核的结果拷贝到用户空间（这里只是执行了拷贝命令，并没有拷贝数据，binder只进行一次拷贝），唤醒等待的客户端并把结果响应回来，这样就完成了一次通讯。 怎么样是不是很简单，以上就是 Binder 机制的主要通讯方式，下面我们来看看具体实现。 3.Binder驱动我们先来了解下用户空间与内核空间是怎么交互的。 先了解一些概念 用户空间/内核空间详细解释可以参考 Kernel Space Definition； 简单理解如下： Kernel space 是 Linux 内核的运行空间，User space 是用户程序的运行空间。 为了安全，它们是隔离的，即使用户的程序崩溃了，内核也不受影响。 Kernel space 可以执行任意命令，调用系统的一切资源； User space 只能执行简单的运算，不能直接调用系统资源，必须通过系统接口（又称 system call），才能向内核发出指令。 系统调用/内核态/用户态虽然从逻辑上抽离出用户空间和内核空间；但是不可避免的的是，总有那么一些用户空间需要访问内核的资源；比如应用程序访问文件，网络是很常见的事情，怎么办呢？ Kernel space can be accessed by user processes only through the use of system calls. 用户空间访问内核空间的唯一方式就是系统调用；通过这个统一入口接口，所有的资源访问都是在内核的控制下执行，以免导致对用户程序对系统资源的越权访问，从而保障了系统的安全和稳定。用户软件良莠不齐，要是它们乱搞把系统玩坏了怎么办？因此对于某些特权操作必须交给安全可靠的内核来执行。 当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）此时处理器处于特权级最高的（0级）内核代码中执行。当进程在执行用户自己的代码时，则称其处于用户运行态（用户态）。即此时处理器在特权级最低的（3级）用户代码中运行。处理器在特权等级高的时候才能执行那些特权CPU指令。 内核模块/驱动通过系统调用，用户空间可以访问内核空间，那么如果一个用户空间想与另外一个用户空间进行通信怎么办呢？很自然想到的是让操作系统内核添加支持；传统的 Linux 通信机制，比如 Socket，管道等都是内核支持的；但是 Binder 并不是 Linux 内核的一部分，它是怎么做到访问内核空间的呢？ Linux 的动态可加载内核模块（Loadable Kernel Module，LKM）机制解决了这个问题；模块是具有独立功能的程序，它可以被单独编译，但不能独立运行。它在运行时被链接到内核作为内核的一部分在内核空间运行。这样，Android系统可以通过添加一个内核模块运行在内核空间，用户进程之间的通过这个模块作为桥梁，就可以完成通信了。 在 Android 系统中，这个运行在内核空间的，负责各个用户进程通过 Binder 通信的内核模块叫做 Binder 驱动; 驱动程序一般指的是设备驱动程序（Device Driver），是一种可以使计算机和设备通信的特殊程序。相当于硬件的接口，操作系统只有通过这个接口，才能控制硬件设备的工作； 驱动就是操作硬件的接口，为了支持Binder通信过程，Binder 使用了一种“硬件”，因此这个模块被称之为驱动。 熟悉了上面这些概念，我们再来看下上面的图，用户空间中 binder_open(), binder_mmap(), binder_ioctl() 这些方法通过 system call 来调用内核空间 Binder 驱动中的方法。内核空间与用户空间共享内存通过 copy_from_user(), copy_to_user() 内核方法来完成用户空间与内核空间内存的数据传输。 Binder驱动中有一个全局的 binder_procs 链表保存了服务端的进程信息。 4. Binder 进程与线程 对于底层Binder驱动，通过 binder_procs 链表记录所有创建的 binder_proc 结构体，binder 驱动层的每一个 binder_proc 结构体都与用户空间的一个用于 binder 通信的进程一一对应，且每个进程有且只有一个 ProcessState 对象，这是通过单例模式来保证的。在每个进程中可以有很多个线程，每个线程对应一个 IPCThreadState 对象，IPCThreadState 对象也是单例模式，即一个线程对应一个 IPCThreadState 对象，在 Binder 驱动层也有与之相对应的结构，那就是 Binder_thread 结构体。在 binder_proc 结构体中通过成员变量 rb_root threads，来记录当前进程内所有的 binder_thread。 Binder 线程池：每个 Server 进程在启动时创建一个 binder 线程池，并向其中注册一个 Binder 线程；之后 Server 进程也可以向 binder 线程池注册新的线程，或者 Binder 驱动在探测到没有空闲 binder 线程时主动向 Server 进程注册新的的 binder 线程。对于一个 Server 进程有一个最大 Binder 线程数限制，默认为16个 binder 线程，例如 Android 的 system_server 进程就存在16个线程。对于所有 Client 端进程的 binder 请求都是交由 Server 端进程的 binder 线程来处理的。 5. ServiceManager 启动了解了 Binder 驱动，怎么与 Binder 驱动进行通讯呢？那就是通过 ServiceManager，好多文章称 ServiceManager 是 Binder 驱动的守护进程，大管家，其实 ServiceManager 的作用很简单就是提供了查询服务和注册服务的功能。下面我们来看一下 ServiceManager 启动的过程。 ServiceManager 分为 framework 层和 native 层，framework 层只是对 native 层进行了封装方便调用，图上展示的是 native 层的 ServiceManager 启动过程。 ServiceManager 的启动是系统在开机时，init 进程解析 init.rc 文件调用 service_manager.c 中的 main() 方法入口启动的。 native 层有一个 binder.c 封装了一些与 Binder 驱动交互的方法。 ServiceManager 的启动分为三步，首先打开驱动创建全局链表 binder_procs，然后将自己当前进程信息保存到 binder_procs 链表，最后开启 loop 不断的处理共享内存中的数据，并处理 BR_xxx 命令（ioctl 的命令，BR 可以理解为 binder reply 驱动处理完的响应）。 6. ServiceManager 注册服务 注册 MediaPlayerService 服务端，我们通过 ServiceManager 的 addService() 方法来注册服务。 首先 ServiceManager 向 Binder 驱动发送 BC_TRANSACTION 命令（ioctl 的命令，BC 可以理解为 binder client 客户端发过来的请求命令）携带 ADD_SERVICE_TRANSACTION 命令，同时注册服务的线程进入等待状态 waitForResponse()。 Binder 驱动收到请求命令向 ServiceManager 的 todo 队列里面添加一条注册服务的事务。事务的任务就是创建服务端进程 binder_node 信息并插入到 binder_procs 链表中。 事务处理完之后发送 BR_TRANSACTION 命令，ServiceManager 收到命令后向 svcinfo 列表中添加已经注册的服务。最后发送 BR_REPLY 命令唤醒等待的线程，通知注册成功。 7. ServiceManager 获取服务 获取服务的过程与注册类似，相反的过程。通过 ServiceManager 的 getService() 方法来注册服务。 首先 ServiceManager 向 Binder 驱动发送 BC_TRANSACTION 命令携带 CHECK_SERVICE_TRANSACTION 命令，同时获取服务的线程进入等待状态 waitForResponse()。 Binder 驱动收到请求命令向 ServiceManager 的发送 BC_TRANSACTION 查询已注册的服务，查询到直接响应 BR_REPLY 唤醒等待的线程。若查询不到将与 binder_procs 链表中的服务进行一次通讯再响应。 8. 进行一次完整通讯 我们在使用 Binder 时基本都是调用 framework 层封装好的方法，AIDL 就是 framework 层提供的傻瓜式是使用方式。假设服务已经注册完，我们来看看客户端怎么执行服务端的方法。 首先我们通过 ServiceManager 获取到服务端的 BinderProxy 代理对象，通过调用 BinderProxy 将参数，方法标识（例如：TRANSACTION_test，AIDL中自动生成）传给 ServiceManager，同时客户端线程进入等待状态。 ServiceManager 将用户空间的参数等请求数据复制到内核空间，并向服务端插入一条执行执行方法的事务。事务执行完通知 ServiceManager 将执行结果从内核空间复制到用户空间，并唤醒等待的线程，响应结果，通讯结束。 总结好了，这里只是从实现逻辑上简单介绍了下 Binder 机制的工作原理，想要深入理解 Binder 机制，还得自己下功夫，看源码，尽管这个过程很痛苦。一遍看不懂就再来一遍，说实话本人理解能力比较差，跟着博客思路看了不下十遍。努力总会有收获，好好欣赏 native 层各方法之间花式跳转的魅力吧。最后你将发现新世界的大门在向你敞开。 网上资料很多，个人觉得比较好的如下： Bander设计与实现 老罗的 Android进程间通信（IPC）机制Binder简要介绍和学习计划 系列 Innost的 深入理解Binder 系列 Gityuan的 Binder系列 (基于 Android 6.0)5. Binder学习指南","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://yoursite.com/tags/android/"},{"name":"Binder","slug":"Binder","permalink":"http://yoursite.com/tags/Binder/"}]},{"title":"编译系统环境初始化过程","slug":"编译系统环境初始化过程","date":"2017-04-05T07:10:25.000Z","updated":"2018-05-06T13:07:02.134Z","comments":true,"path":"2017/04/05/编译系统环境初始化过程/","link":"","permalink":"http://yoursite.com/2017/04/05/编译系统环境初始化过程/","excerpt":"","text":"对Android编译环境进行初始化很简单，分为两步。 第一步是打开一个终端，并且将build/envsetup.sh加载到该终端中：123456789101112131415$ . ./build/envsetup.sh including device/asus/grouper/vendorsetup.sh including device/asus/tilapia/vendorsetup.sh including device/generic/armv7-a-neon/vendorsetup.sh including device/generic/armv7-a/vendorsetup.sh including device/generic/mips/vendorsetup.sh including device/generic/x86/vendorsetup.sh including device/lge/mako/vendorsetup.sh including device/samsung/maguro/vendorsetup.sh including device/samsung/manta/vendorsetup.sh including device/samsung/toroplus/vendorsetup.sh including device/samsung/toro/vendorsetup.sh including device/ti/panda/vendorsetup.sh including sdk/bash_completion/adb.bash 从命令的输出可以知道，文件build/envsetup.sh在加载的过程中，又会在device目录中寻找那些名称为vendorsetup.sh的文件，并且也将它们加载到当前终端来。另外，在sdk/bash_completion目录下的adb.bash文件也会加载到当前终端来，它是用来实现adb命令的bash completion功能的。也就是说，加载了该文件之后，我们在运行adb相关的命令的时候，通过按tab键就可以帮助我们自动完成命令的输入。关于bash completion的知识，可以参考官方文档： http://www.gnu.org/s/bash/manual/bash.html#Programmable-Completion。 第二步是执行命令lunch，如下所示：1234567891011121314151617181920212223$ lunch You&apos;re building on Linux Lunch menu... pick a combo: 1. full-eng 2. full_x86-eng 3. vbox_x86-eng 4. full_mips-eng 5. full_grouper-userdebug 6. full_tilapia-userdebug 7. mini_armv7a_neon-userdebug 8. mini_armv7a-userdebug 9. mini_mips-userdebug 10. mini_x86-userdebug 11. full_mako-userdebug 12. full_maguro-userdebug 13. full_manta-userdebug 14. full_toroplus-userdebug 15. full_toro-userdebug 16. full_panda-userdebug Which would you like? [full-eng] 我们看到lunch命令输出了一个Lunch菜单，该菜单列出了当前Android源码支持的所有设备型号及其编译类型。例如，第一项“full-eng”表示的设备“full”即为模拟器，并且编译类型为“eng”即为工程机。当我们选定了一个Lunch菜单项序号(1-16)之后，按回车键，就可以完成Android编译环境的初始化过程。例如，我们选择1，可以看到以下输出： 12345678910111213141516171819[html] view plain copyWhich would you like? [full-eng] 1 ============================================ PLATFORM_VERSION_CODENAME=REL PLATFORM_VERSION=4.2 TARGET_PRODUCT=full TARGET_BUILD_VARIANT=eng TARGET_BUILD_TYPE=release TARGET_BUILD_APPS= TARGET_ARCH=arm TARGET_ARCH_VARIANT=armv7-a HOST_ARCH=x86 HOST_OS=linux HOST_OS_EXTRA=Linux-3.8.0-31-generic-x86_64-with-Ubuntu-13.04-raring HOST_BUILD_TYPE=release BUILD_ID=JOP40C OUT_DIR=out ============================================ 我们可以看到，lunch命令帮我们设置好了很多环境变量。通过设置这些环境变量，就配置好了Android编译环境。通过图1我们就可以直观地看到Android编译环境初始化完成后，我们所获得的东西： 图1 Android编译环境初始化完成之后 总体来说，Android编译环境初始化完成之后，获得了以下三样东西： 123451. 将vendor和device目录下的vendorsetup.sh文件加载到了当前终端；2. 新增了lunch、m、mm和mmm等命令；3. 通过执行lunch命令设置好了TARGET_PRODUCT、TARGET_BUILD_VARIANT、TARGET_BUILD_TYPE和TARGET_BUILD_APPS等环境变量。 接下来我们就主要分析build/envsetup.sh文件的加载过程以及lunch命令的执行过程。 一. 文件build/envsetup.sh的加载过程文件build/envsetup.sh是一个bash shell脚本，从它里面定义的函数hmm可以知道，它提供了lunch、m、mm和mmm等命令供我们初始化编译环境或者编译Android源码。 函数hmm的实现如下所示： 12345678910111213141516171819202122232425[plain] view plain copyfunction hmm() &#123; cat &lt;&lt;EOF Invoke &quot;. build/envsetup.sh&quot; from your shell to add the following functions to your environment: - lunch: lunch &lt;product_name&gt;-&lt;build_variant&gt; - tapas: tapas [&lt;App1&gt; &lt;App2&gt; ...] [arm|x86|mips] [eng|userdebug|user] - croot: Changes directory to the top of the tree. - m: Makes from the top of the tree. - mm: Builds all of the modules in the current directory. - mmm: Builds all of the modules in the supplied directories. - cgrep: Greps on all local C/C++ files. - jgrep: Greps on all local Java files. - resgrep: Greps on all local res/*.xml files. - godir: Go to the directory containing a file. Look at the source to view more functions. The complete list is: EOF T=$(gettop) local A A=&quot;&quot; for i in `cat $T/build/envsetup.sh | sed -n &quot;/^function /s/function [a−z]∗.*/\\1/p&quot; | sort`; do A=&quot;$A $i&quot; done echo $A &#125; 我们在当前终端中执行hmm命令即可以看到函数hmm的完整输出。函数hmm主要完成三个工作： 12345671. 调用另外一个函数gettop获得Android源码的根目录T。 2. 通过cat命令显示一个Here Document，说明$T/build/envsetup.sh文件加载到当前终端后所提供的主要命令。3. 通过sed命令解析$T/build/envsetup.sh文件，并且获得在里面定义的所有函数的名称，这些函数名称就是$T/build/envsetup.sh文件加载到当前终端后提供的所有命令。 注意，sed命令是一个强大的文本分析工具，它以行为单位为执行文本替换、删除、新增和选取等操作。函数hmm通过执行以下的sed命令来获得在$T/build/envsetup.sh文件定义的函数的名称： [plain] view plain copysed -n “/^function /s/function [a−z]∗.*/\\1/p” 它表示对所有以“function ”开头的行，如果紧接在“function ”后面的字符串仅由字母a-z和下横线(_)组成，那么就将这个字符串提取出来。这正好就对应于shell脚本里面函数的定义。 文件build/envsetup.sh除了定义一堆函数之外，还有一个重要的代码段，如下所示： 12345678[plain] view plain copy# Execute the contents of any vendorsetup.sh files we can find. for f in `/bin/ls vendor/*/vendorsetup.sh vendor/*/*/vendorsetup.sh device/*/*/vendorsetup.sh 2&gt; /dev/null` do echo &quot;including $f&quot; . $f done unset f 这个for循环遍历vendor目录下的一级子目录和二级子目录以及device目录下的二级子目录中的vendorsetup.sh文件，并且通过source命令(.)将它们加载当前终端来。vendor和device相应子目录下的vendorsetup.sh文件的实现很简单，它们主要就是添加相应的设备型号及其编译类型支持到Lunch菜单中去。 例如，device/samsung/maguro目录下的vendorsetup.sh文件的实现如下所示： 12[plain] view plain copyadd_lunch_combo full_maguro-userdebug 它调用函数add_lunch_combo添加一个名称为“full_maguro-userdebug”的菜单项到Lunch菜单去。函数add_lunch_combo定义在build/envsetup.sh文件中，它的实现如下所示： 123456789101112[plain] view plain copyfunction add_lunch_combo() &#123; local new_combo=$1 local c for c in $&#123;LUNCH_MENU_CHOICES[@]&#125; ; do if [ &quot;$new_combo&quot; = &quot;$c&quot; ] ; then return fi done LUNCH_MENU_CHOICES=($&#123;LUNCH_MENU_CHOICES[@]&#125; $new_combo) &#125; 传递给函数add_lunch_combo的参数保存在位置参数$1中，接着又保存在一个本地变量new_combo中，用来表示一个要即将要添加的Lunch菜单项。函数首先是在数组LUNCH_MENU_CHOICES中检查要添加的菜单项是否已经存在。只有在不存在的情况下，才会将它添加到数组LUNCH_MENU_CHOICES中去。注意，${LUNCH_MENU_CHOICES[@]}表示数组LUNCH_MENU_CHOICES的所有元素。数组LUNCH_MENU_CHOICES是定义在文件build/envsetup.sh的一个全局变量，当文件build/envsetup.sh被加载的时候，这个数组会被初始化为化full-eng、full_x86-eng、vbox_x86-eng和full_mips-eng，如下所示： 123456[plain] view plain copy# add the default one here add_lunch_combo full-eng add_lunch_combo full_x86-eng add_lunch_combo vbox_x86-eng add_lunch_combo full_mips-eng 这样当文件build/envsetup.sh加载完成之后，数组LUNCH_MENU_CHOICES就包含了当前源码支持的所有设备型号及其编译类型，于是当接下来我们执行lunch命令的时候，就可以通过数组LUNCH_MENU_CHOICES看到一个完整的Lunch藤蔓。 二. lunch命令的执行过程lunch命令实际上是定义在文件build/envsetup.sh的一个函数，它的实现如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273[plain] view plain copyfunction lunch() &#123; local answer if [ &quot;$1&quot; ] ; then answer=$1 else print_lunch_menu echo -n &quot;Which would you like? [full-eng] &quot; read answer fi local selection= if [ -z &quot;$answer&quot; ] then selection=full-eng elif (echo -n $answer | grep -q -e &quot;^[0-9][0-9]*$&quot;) then if [ $answer -le $&#123;#LUNCH_MENU_CHOICES[@]&#125; ] then selection=$&#123;LUNCH_MENU_CHOICES[$(($answer-1))]&#125; fi elif (echo -n $answer | grep -q -e &quot;^[^\\-][^\\-]*-[^\\-][^\\-]*$&quot;) then selection=$answer fi if [ -z &quot;$selection&quot; ] then echo echo &quot;Invalid lunch combo: $answer&quot; return 1 fi export TARGET_BUILD_APPS= local product=$(echo -n $selection | sed -e &quot;s/-.*$//&quot;) check_product $product if [ $? -ne 0 ] then echo echo &quot;** Don&apos;t have a product spec for: &apos;$product&apos;&quot; echo &quot;** Do you have the right repo manifest?&quot; product= fi local variant=$(echo -n $selection | sed -e &quot;s/^[^\\-]*-//&quot;) check_variant $variant if [ $? -ne 0 ] then echo echo &quot;** Invalid variant: &apos;$variant&apos;&quot; echo &quot;** Must be one of $&#123;VARIANT_CHOICES[@]&#125;&quot; variant= fi if [ -z &quot;$product&quot; -o -z &quot;$variant&quot; ] then echo return 1 fi export TARGET_PRODUCT=$product export TARGET_BUILD_VARIANT=$variant export TARGET_BUILD_TYPE=release echo set_stuff_for_environment printconfig &#125; 函数lunch的执行逻辑如下所示： 12345678910111. 检查是否带有参数，即位置参数$1是否等于空。如果不等于空的话，就表明带有参数，并且该参数是用来指定要编译的设备型号及其编译类型的。如果等于空的话，那么就调用另外一个函数print_lunch_menu来显示Lunch菜单项，并且通过调用read函数来等待用户输入。无论通过何种方式，最终变量answer的值就保存了用户所指定的备型号及其编译类型。 2. 对变量answer的值的合法性进行检查。如果等于空的话，就将它设置为默认值“full-eng”。如果不等于空的话，就分为三种情况考虑。第一种情况是值为数字，那么就需要确保该数字的大小不能超过Lunch菜单项的个数。在这种情况下，会将输入的数字索引到数组LUNCH_MENU_CHOICES中去，以便获得一个用来表示设备型号及其编译类型的文本。第二种情况是非数字文本，那么就需要确保该文本符合&lt;product&gt;-&lt;variant&gt;的形式，其中&lt;product&gt;表示设备型号，而&lt;variant&gt;表示编译类型 。第三种情况是除了前面两种情况之外的所有情况，这是非法的。经过合法性检查后，变量selection代表了用户所指定的备型号及其编译类型，如果它的值是非法的，即它的值等于空，那么函数lunch就不往下执行了。 3. 接下来是解析变量selection的值，也就是通过sed命令将它的&lt;product&gt;和&lt;variant&gt;值提取出来，并且分别保存在变量product和variant中。提取出来的product和variant值有可能是不合法的，因此需要进一步通过调用函数check_product和check_variant来检查。一旦检查失败，也就是函数check_product和check_variant的返回值$?等于非0，那么函数lunch就不往下执行了。 4. 通过以上合法性检查之后，就将变量product和variant的值保存在环境变量TARGET_PRODUCT和TARGET_BUILD_VARIANT中。此外，另外一个环境变量TARGET_BUILD_TYPE的值会被设置为&quot;release&quot;，表示此次编译是一个release版本的编译。另外，前面还有一个环境变量TARGET_BUILD_APPS，它的值被函数lunch设置为空，用来表示此次编译是对整个系统进行编译。如果环境变量TARGET_BUILD_APPS的值不等于空，那么就表示此次编译是只对某些APP模块进行编译，而这些APP模块就是由环境变量TARGET_BUILD_APPS来指定的。 5. 调用函数set_stuff_for_environment来配置环境，例如设置Java SDK路径和交叉编译工具路径等。 6. 调用函数printfconfig来显示已经配置好的编译环境参数。 在上述执行过程中，函数check_product、check_variant和printconfig是比较关键的，因此接下来我们就继续分析它们的实现。 函数check_product定义在文件build/envsetup.sh中，它的实现如下所示： 1234567891011121314151617[plain] view plain copy# check to see if the supplied product is one we can build function check_product() &#123; T=$(gettop) if [ ! &quot;$T&quot; ]; then echo &quot;Couldn&apos;t locate the top of the tree. Try setting TOP.&quot; &gt;&amp;2 return fi CALLED_FROM_SETUP=true BUILD_SYSTEM=build/core \\ TARGET_PRODUCT=$1 \\ TARGET_BUILD_VARIANT= \\ TARGET_BUILD_TYPE= \\ TARGET_BUILD_APPS= \\ get_build_var TARGET_DEVICE &gt; /dev/null # hide successful answers, but allow the errors to show &#125; 函数gettop用来返回Android源代码工程的根目录。函数check_product需要在Android源代码工程根目录或者子目录下调用。否则的话，函数check_product就出错返回。 接下来函数check_product设置几个环境变量，其中最重要的是前面三个CALLED_FROM_SETUP、BUILD_SYSTEM和TARGET_PRODUCT。环境变量CALLED_FROM_SETUP的值等于true表示接下来执行的make命令是用来初始化Android编译环境的。环境变量BUILD_SYSTEM用来指定Android编译系统的核心目录，它的值被设置为build/core。环境变量TARGET_PRODUCT用来表示要检查的产品名称（也就是我们前面说的设备型号），它的值被设置为$1，即函数check_product的调用参数。 最后函数check_product调用函数get_build_var来检查由环境变量TARGET_PRODUCT指定的产品名称是否合法，注意，它的调用参数为TARGET_DEVICE。 函数get_build_var定义在文件build/envsetup.sh中，它的实现如下所示： 123456789101112[plain] view plain copy# Get the exact value of a build variable. function get_build_var() &#123; T=$(gettop) if [ ! &quot;$T&quot; ]; then echo &quot;Couldn&apos;t locate the top of the tree. Try setting TOP.&quot; &gt;&amp;2 return fi CALLED_FROM_SETUP=true BUILD_SYSTEM=build/core \\ make --no-print-directory -C &quot;$T&quot; -f build/core/config.mk dumpvar-$1 &#125; 这里就可以看到，函数get_build_var实际上就是通过make命令在Android源代码工程根目录中执行build/core/config.mk文件，并且将make目标设置为dumpvar-$1，也就是dumpvar-TARGET_DEVICE。 文件build/core/config.mk的内容比较多，这里我们只关注与产品名称合法性检查相关的逻辑，这些逻辑也基本上涵盖了Android编译系统初始化的逻辑，如下所示： 12345678910111213141516171819202122232425262728[plain] view plain copy...... # --------------------------------------------------------------- # Define most of the global variables. These are the ones that # are specific to the user&apos;s build configuration. include $(BUILD_SYSTEM)/envsetup.mk # Boards may be defined under $(SRC_TARGET_DIR)/board/$(TARGET_DEVICE) # or under vendor/*/$(TARGET_DEVICE). Search in both places, but # make sure only one exists. # Real boards should always be associated with an OEM vendor. board_config_mk := \\ $(strip $(wildcard \\ $(SRC_TARGET_DIR)/board/$(TARGET_DEVICE)/BoardConfig.mk \\ device/*/$(TARGET_DEVICE)/BoardConfig.mk \\ vendor/*/$(TARGET_DEVICE)/BoardConfig.mk \\ )) ifeq ($(board_config_mk),) $(error No config file found for TARGET_DEVICE $(TARGET_DEVICE)) endif ifneq ($(words $(board_config_mk)),1) $(error Multiple board config files for TARGET_DEVICE $(TARGET_DEVICE): $(board_config_mk)) endif include $(board_config_mk) ......include $(BUILD_SYSTEM)/dumpvar.mk 上述代码主要就是将envsetup.mk、BoardConfig,mk和dumpvar.mk三个Makefile片段文件加载进来。其中，envsetup.mk文件位于$(BUILD_SYSTEM)目录中，也就是build/core目录中，BoardConfig.mk文件的位置主要就是由环境变量TARGET_DEVICE来确定，它是用来描述目标产品的硬件模块信息的，例如CPU体系结构。环境变量TARGET_DEVICE用来描述目标设备，它的值是在envsetup.mk文件加载的过程中确定的。一旦目标设备确定后，就可以在$(SRC_TARGET_DIR)/board/$(TARGET_DEVICE)、device//$(TARGET_DEVICE)和vendor//$(TARGET_DEVICE)目录中找到对应的BoradConfig.mk文件。注意，变量SRC_TARGET_DIR的值等于build/target。最后，dumpvar.mk文件也是位于build/core目录中，它用来打印已经配置好的编译环境信息。 接下来我们就通过进入到build/core/envsetup.mk文件来分析变量TARGET_DEVICE的值是如何确定的： [plain] view plain copy Read the product specs so we an get TARGET_DEVICE and othervariables that we need in order to locate the output files.include $(BUILD_SYSTEM)/product_config.mk 它通过加载另外一个文件build/core/product_config.mk文件来确定变量TARGET_DEVICE以及其它与目标产品相关的变量的值。 文件build/core/product_config.mk的内容很多，这里我们只关注变量TARGET_DEVICE设置相关的逻辑，如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667[plain] view plain copy...... ifneq ($(strip $(TARGET_BUILD_APPS)),) # An unbundled app build needs only the core product makefiles. all_product_configs := $(call get-product-makefiles,\\ $(SRC_TARGET_DIR)/product/AndroidProducts.mk) else # Read in all of the product definitions specified by the AndroidProducts.mk # files in the tree. all_product_configs := $(get-all-product-makefiles) endif # all_product_configs consists items like: # &lt;product_name&gt;:&lt;path_to_the_product_makefile&gt; # or just &lt;path_to_the_product_makefile&gt; in case the product name is the # same as the base filename of the product config makefile. current_product_makefile := all_product_makefiles := $(foreach f, $(all_product_configs),\\ $(eval _cpm_words := $(subst :,$(space),$(f)))\\ $(eval _cpm_word1 := $(word 1,$(_cpm_words)))\\ $(eval _cpm_word2 := $(word 2,$(_cpm_words)))\\ $(if $(_cpm_word2),\\ $(eval all_product_makefiles += $(_cpm_word2))\\ $(if $(filter $(TARGET_PRODUCT),$(_cpm_word1)),\\ $(eval current_product_makefile += $(_cpm_word2)),),\\ $(eval all_product_makefiles += $(f))\\ $(if $(filter $(TARGET_PRODUCT),$(basename $(notdir $(f)))),\\ $(eval current_product_makefile += $(f)),))) _cpm_words := _cpm_word1 := _cpm_word2 := current_product_makefile := $(strip $(current_product_makefile)) all_product_makefiles := $(strip $(all_product_makefiles)) ifneq (,$(filter product-graph dump-products, $(MAKECMDGOALS))) # Import all product makefiles. $(call import-products, $(all_product_makefiles)) else # Import just the current product. ifndef current_product_makefile $(error Cannot locate config makefile for product &quot;$(TARGET_PRODUCT)&quot;) endif ifneq (1,$(words $(current_product_makefile))) $(error Product &quot;$(TARGET_PRODUCT)&quot; ambiguous: matches $(current_product_makefile)) endif $(call import-products, $(current_product_makefile)) endif # Import all or just the current product makefile ...... # Convert a short name like &quot;sooner&quot; into the path to the product # file defining that product. # INTERNAL_PRODUCT := $(call resolve-short-product-name, $(TARGET_PRODUCT)) ifneq ($(current_product_makefile),$(INTERNAL_PRODUCT)) $(error PRODUCT_NAME inconsistent in $(current_product_makefile) and $(INTERNAL_PRODUCT)) endif current_product_makefile := all_product_makefiles := all_product_configs := # Find the device that this product maps to. TARGET_DEVICE := $(PRODUCTS.$(INTERNAL_PRODUCT).PRODUCT_DEVICE) ...... 上述代码的执行逻辑如下所示： 1234567891. 检查环境变量TARGET_BUILD_APPS的值是否等于空。如果不等于空，那么就说明此次编译不是针对整个系统，因此只要将核心的产品相关的Makefile文件加载进来就行了，否则的话，就要将所有与产品相关的Makefile文件加载进来的。核心产品Makefile文件在$(SRC_TARGET_DIR)/product/AndroidProducts.mk文件中指定，也就是在build/target/product/AndroidProducts.mk文件，通过调用函数get-product-makefiles可以获得。所有与产品相关的Makefile文件可以通过另外一个函数get-all-product-makefiles获得。无论如何，最终获得的产品Makefie文件列表保存在变量all_product_configs中。 2. 遍历变量all_product_configs所描述的产品Makefile列表，并且在这些Makefile文件中，找到名称与环境变量TARGET_PRODUCT的值相同的文件，保存在另外一个变量current_product_makefile中，作为需要为当前指定的产品所加载的Makefile文件列表。在这个过程当中，上一步找到的所有的产品Makefile文件也会保存在变量all_product_makefiles中。注意，环境变量TARGET_PRODUCT的值是在我们执行lunch命令的时候设置并且传递进来的。 3. 如果指定的make目标等于product-graph或者dump-products，那么就将所有的产品相关的Makefile文件加载进来，否则的话，只加载与目标产品相关的Makefile文件。从前面的分析可以知道，此时的make目标为dumpvar-TARGET_DEVICE，因此接下来只会加载与目标产品，即$(TARGET_PRODUCT)，相关的Makefile文件，这是通过调用另外一个函数import-products实现的。 4. 调用函数resolve-short-product-name解析环境变量TARGET_PRODUCT的值，将它变成一个Makefile文件路径。并且保存在变量INTERNAL_PRODUCT中。这里要求变量INTERNAL_PRODUCT和current_product_makefile的值相等，否则的话，就说明用户指定了一个非法的产品名称。 5. 找到一个名称为PRODUCTS.$(INTERNAL_PRODUCT).PRODUCT_DEVICE的变量，并且将它的值保存另外一个变量TARGET_DEVICE中。变量PRODUCTS.$(INTERNAL_PRODUCT).PRODUCT_DEVICE是在加载产品Makefile文件的过程中定义的，用来描述当前指定的产品的名称。 上述过程主要涉及到了get-all-product-makefiles、import-products和resolve-short-product-name三个关键函数，理解它们的执行过程对理解Android编译系统的初始化过程很有帮助，接下来我们分别分析它们的实现。 函数get-all-product-makefiles定义在文件build/core/product.mk中，如下所示： 123456789[plain] view plain copy# # Returns the sorted concatenation of all PRODUCT_MAKEFILES # variables set in all AndroidProducts.mk files. # $(call ) isn&apos;t necessary. # define get-all-product-makefiles $(call get-product-makefiles,$(_find-android-products-files)) endef 它首先是调用函数_find-android-products-files来找到Android源代码目录中定义的所有AndroidProducts.mk文件，然后再调用函数get-product-makefiles获得在这里AndroidProducts.mk文件里面定义的产品Makefile文件。 函数_find-android-products-files也是定义在文件build/core/product.mk中，如下所示： 12345678910111213141516171819202122232425262728293031[plain] view plain copy# # Returns the list of all AndroidProducts.mk files. # $(call ) isn&apos;t necessary. # define _find-android-products-files $(shell test -d device &amp;&amp; find device -maxdepth 6 -name AndroidProducts.mk) \\ $(shell test -d vendor &amp;&amp; find vendor -maxdepth 6 -name AndroidProducts.mk) \\ $(SRC_TARGET_DIR)/product/AndroidProducts.mk endef 从这里就可以看出，Android源代码目录中定义的所有AndroidProducts.mk文件位于device、vendor或者build/target/product目录或者相应的子目录（最深是6层）中。 函数get-product-makefiles也是定义在文件build/core/product.mk中，如下所示：[plain] view plain copy# # Returns the sorted concatenation of PRODUCT_MAKEFILES # variables set in the given AndroidProducts.mk files. # $(1): the list of AndroidProducts.mk files. # define get-product-makefiles $(sort \\ $(foreach f,$(1), \\ $(eval PRODUCT_MAKEFILES :=) \\ $(eval LOCAL_DIR := $(patsubst %/,%,$(dir $(f)))) \\ $(eval include $(f)) \\ $(PRODUCT_MAKEFILES) \\ ) \\ $(eval PRODUCT_MAKEFILES :=) \\ $(eval LOCAL_DIR :=) \\ ) endef 这个函数实际上就是遍历参数$1所描述的AndroidProucts.mk文件列表，并且将定义在这些AndroidProucts.mk文件中的变量PRODUCT_MAKEFILES的值提取出来，形成一个列表返回给调用者。 例如，在build/target/product/AndroidProducts.mk文件中，变量PRODUCT_MAKEFILES的值如下所示： 12345678910111213141516171819202122[plain] view plain copy# Unbundled apps will be built with the most generic product config. ifneq ($(TARGET_BUILD_APPS),) PRODUCT_MAKEFILES := \\ $(LOCAL_DIR)/full.mk \\ $(LOCAL_DIR)/full_x86.mk \\ $(LOCAL_DIR)/full_mips.mk else PRODUCT_MAKEFILES := \\ $(LOCAL_DIR)/core.mk \\ $(LOCAL_DIR)/generic.mk \\ $(LOCAL_DIR)/generic_x86.mk \\ $(LOCAL_DIR)/generic_mips.mk \\ $(LOCAL_DIR)/full.mk \\ $(LOCAL_DIR)/full_x86.mk \\ $(LOCAL_DIR)/full_mips.mk \\ $(LOCAL_DIR)/vbox_x86.mk \\ $(LOCAL_DIR)/sdk.mk \\ $(LOCAL_DIR)/sdk_x86.mk \\ $(LOCAL_DIR)/sdk_mips.mk \\ $(LOCAL_DIR)/large_emu_hw.mk endif 里列出的每一个文件都对应于一个产品。 我们再来看函数import-products的实现，它定义在文件build/core/product.mk中，如下所示： 12345678[plain] view plain copy# # $(1): product makefile list # #TODO: check to make sure that products have all the necessary vars defined define import-products $(call import-nodes,PRODUCTS,$(1),$(_product_var_list)) endef 它调用另外一个函数import-nodes来加载由参数$1所指定的产品Makefile文件，并且指定了另外两个参数PRODUCTS和$(_product_var_list)。其中，变量_product_var_list也是定义在文件build/core/product.mk中，它的值如下所示： 123456789101112131415161718192021222324252627282930313233[plain] view plain copy_product_var_list := \\ PRODUCT_NAME \\ PRODUCT_MODEL \\ PRODUCT_LOCALES \\ PRODUCT_AAPT_CONFIG \\ PRODUCT_AAPT_PREF_CONFIG \\ PRODUCT_PACKAGES \\ PRODUCT_PACKAGES_DEBUG \\ PRODUCT_PACKAGES_ENG \\ PRODUCT_PACKAGES_TESTS \\ PRODUCT_DEVICE \\ PRODUCT_MANUFACTURER \\ PRODUCT_BRAND \\ PRODUCT_PROPERTY_OVERRIDES \\ PRODUCT_DEFAULT_PROPERTY_OVERRIDES \\ PRODUCT_CHARACTERISTICS \\ PRODUCT_COPY_FILES \\ PRODUCT_OTA_PUBLIC_KEYS \\ PRODUCT_EXTRA_RECOVERY_KEYS \\ PRODUCT_PACKAGE_OVERLAYS \\ DEVICE_PACKAGE_OVERLAYS \\ PRODUCT_TAGS \\ PRODUCT_SDK_ADDON_NAME \\ PRODUCT_SDK_ADDON_COPY_FILES \\ PRODUCT_SDK_ADDON_COPY_MODULES \\ PRODUCT_SDK_ADDON_DOC_MODULES \\ PRODUCT_DEFAULT_WIFI_CHANNELS \\ PRODUCT_DEFAULT_DEV_CERTIFICATE \\ PRODUCT_RESTRICT_VENDOR_FILES \\ PRODUCT_VENDOR_KERNEL_HEADERS \\ PRODUCT_FACTORY_RAMDISK_MODULES \\ PRODUCT_FACTORY_BUNDLE_MODULES 它描述的是在产品Makefile文件中定义在各种变量。 函数import-nodes定义在文件build/core/node_fns.mk中，如下所示： 12345678910111213141516171819202122[plain] view plain copy# # $(1): output list variable name, like &quot;PRODUCTS&quot; or &quot;DEVICES&quot; # $(2): list of makefiles representing nodes to import # $(3): list of node variable names # define import-nodes $(if \\ $(foreach _in,$(2), \\ $(eval _node_import_context := _nic.$(1).[[$(_in)]]) \\ $(if $(_include_stack),$(eval $(error ASSERTION FAILED: _include_stack \\ should be empty here: $(_include_stack))),) \\ $(eval _include_stack := ) \\ $(call _import-nodes-inner,$(_node_import_context),$(_in),$(3)) \\ $(call move-var-list,$(_node_import_context).$(_in),$(1).$(_in),$(3)) \\ $(eval _node_import_context :=) \\ $(eval $(1) := $($(1)) $(_in)) \\ $(if $(_include_stack),$(eval $(error ASSERTION FAILED: _include_stack \\ should be empty here: $(_include_stack))),) \\ ) \\ ,) endef 这个函数主要是做了三件事情： 12345671. 调用函数_import-nodes-inner将参数$2描述的每一个产品Makefile文件加载进来。 2. 调用函数move-var-list将定义在前面所加载的产品Makefile文件里面的由参数$3指定的变量的值分别拷贝到另外一组独立的变量中。 3. 将参数$2描述的每一个产品Makefile文件路径以空格分隔保存在参数$1所描述的变量中，也就是保存在变量PRODUCTS中。 上述第二件事情需要进一步解释一下。由于当前加载的每一个文件都会定义相同的变量，为了区分这些变量，我们需要在这些变量前面加一些前缀。例如，假设加载了build/target/product/full.mk这个产品Makefile文件，它里面定义了以下几个变量： 123456789101112[plain] view plain copy# Overrides PRODUCT_NAME := full PRODUCT_DEVICE := generic PRODUCT_BRAND := Android PRODUCT_MODEL := Full Android on Emulator 当调用了函数move-var-list对它进行解析后，就会得到以下的新变量：[plain] view plain copyPRODUCTS.build/target/product/full.mk.PRODUCT_NAME := full PRODUCTS.build/target/product/full.mk.PRODUCT_DEVICE := generic PRODUCTS.build/target/product/full.mk.PRODUCT_BRAND := Android PRODUCTS.build/target/product/full.mk.PRODUCT_MODEL := Full Android on Emulator 正是由于调用了函数move-var-list，我们在build/core/product_config.mk文件中可以通过PRODUCTS.$(INTERNAL_PRODUCT).PRODUCT_DEVICE来设置变量TARGET_DEVICE的值。 回到build/core/config.mk文件中，接下来我们再看BoardConfig.mk文件的加载过程。前面提到，当前要加载的BoardConfig.mk文件由变量TARGET_DEVICE来确定。例如，假设我们在运行lunch命令时，输入的文本为full-eng，那么build/target/product/full.mk就会被加载，并且我们得到TARGET_DEVICE的值就为generic，接下来加载的BoradConfig.mk文件就会在build/target/board/generic目录中找到。 BoardConfig.mk文件定义的信息可以参考build/target/board/generic/BoardConfig.mk文件的内容，如下所示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647[plain] view plain copy# config.mk # # Product-specific compile-time definitions. # # The generic product target doesn&apos;t have any hardware-specific pieces. TARGET_NO_BOOTLOADER := true TARGET_NO_KERNEL := true TARGET_ARCH := arm # Note: we build the platform images for ARMv7-A _without_ NEON. # # Technically, the emulator supports ARMv7-A _and_ NEON instructions, but # emulated NEON code paths typically ends up 2x slower than the normal C code # it is supposed to replace (unlike on real devices where it is 2x to 3x # faster). # # What this means is that the platform image will not use NEON code paths # that are slower to emulate. On the other hand, it is possible to emulate # application code generated with the NDK that uses NEON in the emulator. # TARGET_ARCH_VARIANT := armv7-a TARGET_CPU_ABI := armeabi-v7a TARGET_CPU_ABI2 := armeabi ARCH_ARM_HAVE_TLS_REGISTER := true HAVE_HTC_AUDIO_DRIVER := true BOARD_USES_GENERIC_AUDIO := true # no hardware camera USE_CAMERA_STUB := true # Enable dex-preoptimization to speed up the first boot sequence # of an SDK AVD. Note that this operation only works on Linux for now ifeq ($(HOST_OS),linux) ifeq ($(WITH_DEXPREOPT),) WITH_DEXPREOPT := true endif endif # Build OpenGLES emulation guest and host libraries BUILD_EMULATOR_OPENGL := true # Build and enable the OpenGL ES View renderer. When running on the emulator, # the GLES renderer disables itself if host GL acceleration isn&apos;t available. USE_OPENGL_RENDERER := true 它描述了产品的Boot Loader、Kernel、CPU体系结构、CPU ABI和Opengl加速等信息。 再回到build/core/config.mk文件中，它最后加载build/core/dumpvar.mk文件。加载build/core/dumpvar.mk文件是为了生成make目标，以便可以对这些目标进行操作。例如，在我们这个情景中，我们要执行的make目标是dumpvar-TARGET_DEVICE，因此在加载build/core/dumpvar.mk文件的过程中，就会生成dumpvar-TARGET_DEVICE目标。 文件build/core/dumpvar.mk的内容也比较多，这里我们只关注生成make目标相关的逻辑： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546[plain] view plain copy...... # The &quot;dumpvar&quot; stuff lets you say something like # # CALLED_FROM_SETUP=true \\ # make -f config/envsetup.make dumpvar-TARGET_OUT # or # CALLED_FROM_SETUP=true \\ # make -f config/envsetup.make dumpvar-abs-HOST_OUT_EXECUTABLES # # The plain (non-abs) version just dumps the value of the named variable. # The &quot;abs&quot; version will treat the variable as a path, and dumps an # absolute path to it. # dumpvar_goals := \\ $(strip $(patsubst dumpvar-%,%,$(filter dumpvar-%,$(MAKECMDGOALS)))) ifdef dumpvar_goals ifneq ($(words $(dumpvar_goals)),1) $(error Only one &quot;dumpvar-&quot; goal allowed. Saw &quot;$(MAKECMDGOALS)&quot;) endif # If the goal is of the form &quot;dumpvar-abs-VARNAME&quot;, then # treat VARNAME as a path and return the absolute path to it. absolute_dumpvar := $(strip $(filter abs-%,$(dumpvar_goals))) ifdef absolute_dumpvar dumpvar_goals := $(patsubst abs-%,%,$(dumpvar_goals)) ifneq ($(filter /%,$($(dumpvar_goals))),) DUMPVAR_VALUE := $($(dumpvar_goals)) else DUMPVAR_VALUE := $(PWD)/$($(dumpvar_goals)) endif dumpvar_target := dumpvar-abs-$(dumpvar_goals) else DUMPVAR_VALUE := $($(dumpvar_goals)) dumpvar_target := dumpvar-$(dumpvar_goals) endif .PHONY: $(dumpvar_target) $(dumpvar_target): @echo $(DUMPVAR_VALUE) endif # dumpvar_goals ...... 我们在执行make命令时，指定的目示会经由MAKECMDGOALS变量传递到Makefile中，因此通过变量MAKECMDGOALS可以获得make目标。 上述代码的逻辑很简单，例如，在我们这个情景中，指定的make目标为dumpvar-TARGET_DEVICE，那么就会得到变量DUMPVAR_VALUE的值为$(TARGET_DEVICE)。TARGET_DEVICE的值在前面已经被设置为“generic”，因此变量DUMPVAR_VALUE的值就等于“generic”。此外，变量dumpvar_target的被设置为“dumpvar-TARGET_DEVICE”。最后我们就可以得到以下的make规则： [plain] view plain copy.PHONY dumpvar-TARGET_DEVICEdumpvar-TARGET_DEVICE: @echo generic 至此，在build/envsetup.sh文件中定义的函数check_product就分析完成了。看完了之后，小伙伴们可能会问，前面不是说这个函数是用来检查用户输入的产品名称是否合法的吗？但是这里没看出哪一段代码给出了true或者false的答案啊。实际上，在前面分析的build/core/config.mk和build/core/product_config.mk等文件的加载过程中，如果发现输入的产品名称是非法的，也就是找不到相应的产品Makefile文件，那么就会通过调用error函数来产生一个错误，这时候函数check_product的返回值$?就会等于非0值。 接下来我们还要继续分析在build/envsetup.sh文件中定义的函数check_variant的实现，如下所示： 123456789101112131415[plain] view plain copyVARIANT_CHOICES=(user userdebug eng) # check to see if the supplied variant is valid function check_variant() &#123; for v in $&#123;VARIANT_CHOICES[@]&#125; do if [ &quot;$v&quot; = &quot;$1&quot; ] then return 0 fi done return 1 &#125; 这个函数的实现就简单多了。合法的编译类型定义在数组VARIANT_CHOICES中，并且它只有三个值user、userdebug和eng。其中，user表示发布版本，userdebug表示带调试信息的发布版本，而eng表标工程机版本。 最后，我们再来分析在build/envsetup.sh文件中定义的函数printconfig的实现，如下所示： 12345678910[plain] view plain copyfunction printconfig() &#123; T=$(gettop) if [ ! &quot;$T&quot; ]; then echo &quot;Couldn&apos;t locate the top of the tree. Try setting TOP.&quot; &gt;&amp;2 return fi get_build_var report_config &#125; 对比我们前面对函数check_product的分析，就会发现函数printconfig的实现与这很相似，都是通过调用get_build_var来获得相关的信息，但是这里传递给函数get_build_var的参数为report_config。 我们跳过前面build/core/config.mk和build/core/envsetup.mk等文件对目标产品Makefile文件的加载，直接跳到build/core/dumpvar.mk文件来查看与report_config这个make目标相关的逻辑： 1234567891011121314151617181920212223242526272829303132[plain] view plain copy...... dumpvar_goals := \\ $(strip $(patsubst dumpvar-%,%,$(filter dumpvar-%,$(MAKECMDGOALS)))) ..... ifneq ($(dumpvar_goals),report_config) PRINT_BUILD_CONFIG:= endif ...... ifneq ($(PRINT_BUILD_CONFIG),) HOST_OS_EXTRA:=$(shell python -c &quot;import platform; print(platform.platform())&quot;) $(info ============================================) $(info PLATFORM_VERSION_CODENAME=$(PLATFORM_VERSION_CODENAME)) $(info PLATFORM_VERSION=$(PLATFORM_VERSION)) $(info TARGET_PRODUCT=$(TARGET_PRODUCT)) $(info TARGET_BUILD_VARIANT=$(TARGET_BUILD_VARIANT)) $(info TARGET_BUILD_TYPE=$(TARGET_BUILD_TYPE)) $(info TARGET_BUILD_APPS=$(TARGET_BUILD_APPS)) $(info TARGET_ARCH=$(TARGET_ARCH)) $(info TARGET_ARCH_VARIANT=$(TARGET_ARCH_VARIANT)) $(info HOST_ARCH=$(HOST_ARCH)) $(info HOST_OS=$(HOST_OS)) $(info HOST_OS_EXTRA=$(HOST_OS_EXTRA)) $(info HOST_BUILD_TYPE=$(HOST_BUILD_TYPE)) $(info BUILD_ID=$(BUILD_ID)) $(info OUT_DIR=$(OUT_DIR)) $(info ============================================) endif 变量PRINT_BUILD_CONFIG定义在文件build/core/envsetup.mk中，默认值设置为true。当make目标为report-config的时候，变量PRINT_BUILD_CONFIG的值就会被设置为空。因此，接下来就会打印一系列用来描述编译环境配置的变量的值，也就是我们执行lunch命令后看到的输出。注意，这些环境配置相关的变量量都是在加载build/core/config.mk和build/core/envsetup.mk文件的过程中设置的，就类似于前面我们分析的TARGET_DEVICE变量的值的设置过程。 至此，我们就分析完成Android编译系统环境的初始化过程了。从分析的过程可以知道，Android编译系统环境是由build/core/config.mk、build/core/envsetup.mk、build/core/product_config.mk、AndroidProducts.mk和BoardConfig.mk等文件来完成的。这些mk文件涉及到非常多的细节，而我们这里只提供了一个大体的骨架和脉络，希望能够起到抛砖引玉的作用。","categories":[{"name":"AOSP","slug":"AOSP","permalink":"http://yoursite.com/categories/AOSP/"}],"tags":[{"name":"编译","slug":"编译","permalink":"http://yoursite.com/tags/编译/"},{"name":"aosp","slug":"aosp","permalink":"http://yoursite.com/tags/aosp/"}]},{"title":"添加SE安全策略","slug":"添加SE安全策略","date":"2017-03-15T11:10:10.000Z","updated":"2018-05-06T13:07:29.880Z","comments":true,"path":"2017/03/15/添加SE安全策略/","link":"","permalink":"http://yoursite.com/2017/03/15/添加SE安全策略/","excerpt":"","text":"一、 问题复现12341.service ro_isn /system/bin/isn.sh 2.class late_start3.user root4.oneshot kernel log会打印以下log： 1Warning! Service ro_isn needs a SELinux domain defined; please fix! 这是因为Service ro_isn没有在SELinux的监控之下，这种情况会提示你定义一个SELinux。在这种情况下，你可以：1.无视该条log，Service功能不受影响。各种权限不受限制。但是这样做会有风险。2.为Service ro_isn定义一个SELinux domain，仅添加需要的权限，未允许的权限操作会被拒绝。具体方法请参照下节。 二、解决方法1.1devices/qcom/sepolicy/common/ 目录下新增ro_isn.te文件，内容如下： 12type ro_isn, domain; type ro_isn_exec, exec_type, file_type; 2.在1devices/qcom/sepolicy/Android.mk 中添加ro_isn.te文件，内容如下： 1234BOARD_SEPOLICY_UNION := \\... \\ hostapd.te \\ ro_isn.te 3.在1devices/qcom/sepolicy/common/file_contexts 中增加如下内容： ################################### 1234567# System files#.../system/vendor/bin/slim_ap_daemonu:object_r:location_exec:s0/system/bin/isn.shu:object_r:ro_isn_exec:s0 4.在init.rc中service ro_isn下添加12345678secure context by seclabel service ro_isn /system/bin/isn.sh class late_start user root oneshot seclabel u:r:ro_isn:s0 5.编译并烧录bootimage 6.如果编译不成功，失败原因如下： 123Error while expanding policylibsepol.check_assertion_helper: neverallow on line 233 of external/sepolicy/domain.te (or line 5194 of policy.conf) violated by allow ro_isn system_file:file &#123; entrypoint &#125;;make: *** [out/target/product/msm8226/obj/ETC/sepolicy_intermediates/sepolicy] 错误 1 这是因为系统在domain.te中定义了全局的neverallow策略，与ro_isn.te中allow的策略有冲突： 12allow ro_isn system_file:file &#123; entrypoint &#125;;neverallow domain &#123; file_type -exec_type &#125;:file entrypoint; 请确定自己的service有必要需要这个权限。如无必要，请在自己的code中删除掉相关操作；如必要，可以在1external/sepolicy/domain.te 中冲突的neverallow语句中添加自己为例外： 1234neverallow &#123; domain -ro_isn&#125; &#123; file_type -exec_type &#125;:file entrypoint; 7.在service ro_isn运行时，搜索关于“ro_isn”的1avc: denied log 123&lt;6&gt;[ 13.547188](CPU:0-pid:320:logd.auditd) type=1400 audit(17468992.410:7): avc: denied &#123; entrypoint &#125; for pid=272 comm=&quot;init&quot; path=&quot;/system/bin/isn.sh &quot; dev=&quot;mmcblk0p38&quot; ino=631 scontext=u:r:ro_isn:s0 tcontext=u:object_r:system_file:s0 tclass=file 8.按照如下规则在ro_isn.te添加权限SELinux规则语句一般如下： 1allow A B:C D; 可以从log中分别获取ABCD四个参数。比如这行12345678warning log：avc: denied &#123; entrypoint &#125; for pid=272 comm=&quot;init&quot; path=&quot;/system/bin/isn.sh &quot; dev=&quot;mmcblk0p38&quot; ino=631 scontext=u:r:ro_isn:s0 tcontext=u:object_r:system_file:s0 tclass=fileavc: denied &#123; transition &#125; for pid=320 comm=&quot;init&quot; path=&quot;/system/xbin/fcgiserver.sh &quot; dev=&quot;mmcblk0p21&quot; ino=7873 scontext=u:r:init:s0 tcontext=u:r:fcgiserver:s0 tclass=process permissive=1 那么我们就得出最后的规则是： 1allow qcomsysd block_device:dir &#123; search &#125;; 1allow ro_isn system_file:file &#123; entrypoint &#125;; 重复步骤5-8,直到没有关于ro_isn的avc: denied log","categories":[{"name":"AOSP","slug":"AOSP","permalink":"http://yoursite.com/categories/AOSP/"}],"tags":[{"name":"编译","slug":"编译","permalink":"http://yoursite.com/tags/编译/"},{"name":"SEAndroid","slug":"SEAndroid","permalink":"http://yoursite.com/tags/SEAndroid/"}]},{"title":"fiddler抓android数据包","slug":"抓包工具 - Fiddler（如何捕获Android数据包）","date":"2016-08-03T12:20:17.000Z","updated":"2018-05-06T13:18:26.134Z","comments":true,"path":"2016/08/03/抓包工具 - Fiddler（如何捕获Android数据包）/","link":"","permalink":"http://yoursite.com/2016/08/03/抓包工具 - Fiddler（如何捕获Android数据包）/","excerpt":"","text":"抓包工具 - Fiddler（如何捕获Android数据包）移动设备访问网络原理 先看看移动设备是怎么去访问网络，如图所示，可以看到，移动端的数据包是从wifi出去的。可以看得出，移动端的数据包，都是要走wifi出去，所以我们可以把自己的电脑开启热点，将手机连上电脑，Fiddler开启代理后，让这些数据通过Fiddler，Fiddler就可以抓到这些包，然后发给路由器（如图）： 二、Fiddler抓取android数据包所需条件 1、电脑需要安装Fiddler 2、测试手机需要支持Wifi 3、测试手机与电脑需要同一网络 4、所测APP需支持代理 注：Iphone、Ipad、WinPhone等支持代理手机均适用 打开Wifi热点，让手机连上（我这里用的360wifi，其实随意一个都行） 打开Fidder，点击菜单栏中的 [Tools] –&gt; [Fiddler Options]Connections，设置代理端口：8888， 勾选 Allow remote computers to connect，即允许远程计算机连接Fiddler. 注：8888为默认端口号，可修改，但需注意两点，一是本机空闲端口，二是手机代理设置时要与fiddler的端口一致。 3、设置解密HTTPS的网络数据 Tools –&gt; Options-&gt; Https，勾选”Decrypt HTTPS traffic”、”Ignore server certificate errors”， 4、查看本机的无线网卡IP 设置了上面的步骤后，就可以在 Fiddler看到自己本机无线网卡的IP了（要是没有的话，重启Fiddler，或者可以在cmd中ipconfig找到自己的网卡IP，注：一定要开启本机的wifi热点）， 也可以在CMD中查看本机网卡的IP，输入命令：ipconfig， 5、手机连接本机的Wifi，并设置代理 每个品牌的手机设置wifi的方式可能不一样，这里以华为手机为例，如图8所示，将手机连接至PC的wifi 勾选“显示高级选项”-&gt; 代理 选择“手动” -&gt;输入服务器主机名和服务器端口 -&gt;IP选择“DHCP”-&gt;连接，即完成手机端设置代理操作，如图9所示 注：服务器主机名：Fiddler所在电脑IP（即开启wifi后，在fiddler或cmd中看到的无线网卡IP地址） 服务器端口： Fiddler使用的端口（即Options-Connections中设置的端口号） 6、手机下载安装Fiddler证书 连接上wifi后，手机打开浏览器输入代理IP+端口号（即是本机无线网卡IP，也是手机连接wifi时所设置的服务器主机名，这里的ip+端口号为192.168.191.1：8888），进入fiddler echo service页面，下载Fiddler的证书，如图10所示，点击FiddlerRoot certificate 下载完成后，进行安装证书 【注意】：如果打开浏览器碰到类似下面的报错，请打开Fiddler的证书解密模式（如上面的步骤3所示）：No root certificate was found. Have you enabled HTTPS traffic decryption in Fiddler yet? 设置完上面6个步骤后，即表明已设置完毕，此时用手机访问应用，就可以看到fiddler抓取到的数据包了.","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://yoursite.com/tags/android/"},{"name":"抓包","slug":"抓包","permalink":"http://yoursite.com/tags/抓包/"}]},{"title":"Linux vi用法","slug":"Linux vi命令使用方法","date":"2016-07-04T13:11:15.000Z","updated":"2018-05-06T13:12:58.582Z","comments":true,"path":"2016/07/04/Linux vi命令使用方法/","link":"","permalink":"http://yoursite.com/2016/07/04/Linux vi命令使用方法/","excerpt":"","text":"vi编辑器支持编辑模式和命令模式，编辑模式下可以完成文本的编辑功能，命令模式下可以完成对文件的操作命令，要正确使用vi编辑器就必须熟练掌握着两种模式的切换。默认情况下，打开vi编辑器后自动进入命令模式。从编辑模式切换到命令模式使用“esc”键，从命令模式切换到编辑模式使用“A”、“a”、“O”、“o”、“I”、“i”键。 vi编辑器提供了丰富的内置命令，有些内置命令使用键盘组合键即可完成，有些内置命令则需要以冒号“：”开头输入。常用内置命令如下： 12345678910111213141516171819202122232425262728293031323334Ctrl+u：向文件首翻半屏；Ctrl+d：向文件尾翻半屏；Ctrl+f：向文件尾翻一屏；Ctrl+b：向文件首翻一屏；Esc：从编辑模式切换到命令模式；ZZ：命令模式下保存当前文件所做的修改后退出vi；:行号：光标跳转到指定行的行首；:$：光标跳转到最后一行的行首；x或X：删除一个字符，x删除光标后的，而X删除光标前的；D：删除从当前光标到光标所在行尾的全部字符；dd：删除光标行正行内容；ndd：删除当前行及其后n-1行；nyy：将当前行及其下n行的内容保存到寄存器？中，其中？为一个字母，n为一个数字；p：粘贴文本操作，用于将缓存区的内容粘贴到当前光标所在位置的下方；P：粘贴文本操作，用于将缓存区的内容粘贴到当前光标所在位置的上方；/字符串：文本查找操作，用于从当前光标所在位置开始向文件尾部查找指定字符串的内容，查找的字符串会被加亮显示；？name：文本查找操作，用于从当前光标所在位置开始向文件头部查找指定字符串的内容，查找的字符串会被加亮显示；a，bs/F/T：替换文本操作，用于在第a行到第b行之间，将F字符串换成T字符串。其中，“s/”表示进行替换操作；a：在当前字符后添加文本；A：在行末添加文本；i：在当前字符前插入文本；I：在行首插入文本；o：在当前行后面插入一空行；O：在当前行前面插入一空行；:wq：在命令模式下，执行存盘退出操作；:w：在命令模式下，执行存盘操作；:w！：在命令模式下，执行强制存盘操作；:q：在命令模式下，执行退出vi操作；:q！：在命令模式下，执行强制退出vi操作；:e文件名：在命令模式下，打开并编辑指定名称的文件；:n：在命令模式下，如果同时打开多个文件，则继续编辑下一个文件；:f：在命令模式下，用于显示当前的文件名、光标所在行的行号以及显示比例；:set number：在命令模式下，用于在最左端显示行号；:set nonumber：在命令模式下，用于在最左端不显示行号；","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"linux命令","slug":"linux命令","permalink":"http://yoursite.com/tags/linux命令/"}]}]}