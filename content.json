{"meta":{"title":"QuincyJiang","subtitle":null,"description":null,"author":"QuincyJiang","url":"http://yoursite.com"},"pages":[{"title":"About","date":"2018-05-06T06:35:28.393Z","updated":"2018-05-06T06:35:28.382Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"Name： Quincyjiang Male 24 (1993/08/19) Major：ICS（Information and computer science） School：SDU Location：Guangzhou，China Contact： &#x31;&#x30;&#56;&#51;&#x38;&#x37;&#x33;&#x32;&#x37;&#50;&#x40;&#113;&#x71;&#46;&#99;&#x6f;&#x6d; &#x6a;&#105;&#x61;&#110;&#x67;&#57;&#x33;&#48;&#x36;&#x32;&#53;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d; Intro：文艺码农，胶片玩家，代码洁癖。 Language Java Android Python C/C++"},{"title":"Categories","date":"2018-05-06T05:42:33.728Z","updated":"2018-05-05T15:10:05.116Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2018-05-06T06:09:35.982Z","updated":"2018-05-05T15:10:05.117Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"线程阻塞和中断的四种方式","slug":"线程阻塞和中断的四种方式","date":"2018-03-13T12:46:25.000Z","updated":"2018-05-06T06:41:37.515Z","comments":true,"path":"2018/03/13/线程阻塞和中断的四种方式/","link":"","permalink":"http://yoursite.com/2018/03/13/线程阻塞和中断的四种方式/","excerpt":"","text":"1、线程阻塞一个线程进入阻塞状态可能的原因： 通过调用sleep(millseconds)使任务进入休眠状态；123456789101112class Demo1 implements Runnable throws InterruptedException&#123; public void run()&#123; Thread.sleep(1000); &#125;&#125;②通过调用wait（）使线程挂起，直到线程获取notify（）/notifyAll（）消息，（或者在Java SE5中java.util.concurrent类库中等价的signal（）/signalAll（）消息），线程才会进入就绪状态；class Demo2 implements Runnable&#123; public void run()&#123; Thread.await(); Thread.notify(); &#125;&#125; 任务在等待某个输入 / 输出流的完成；123456class Demo3 implements Runnable throws InterruptedException&#123; private InputStream in; public void run()&#123; in.read(); &#125;&#125; 任务试图在某个对象上调用其同步控制方法，但是对象锁不可用，因为另一个任务已经获取了该锁；1234567class Demo4 implements Runnable&#123; public synchronized void method1()&#123; &#125; public synchronized void method2()&#123; &#125; public void run()&#123; method1(); &#125;&#125; 2、线程中断的方法Thread类包含interrupt（）方法，用于终止阻塞任务； 1）中断①②类线程休眠，挂起阻塞的方法1.直接使用Thread.interrupt();1234main()&#123; Thread t = new Thread(new Demo1()); t.interrupt();&#125; 2.使用Executor线程池，中断线程池中的所有线程；123456main()&#123; ExecutorService exec = Executors.newCachedThreadPool(); for(int i=0;i&lt;5;i++) exec.execute(new Demo1()) exec.shutdownNow();&#125; 3.使用Executor线程池，中断线程池中单个阻塞的线程；12345main()&#123; ExecutorService exec = Executors.newCachedThreadPool(); Futrue&lt;?&gt; f = exec.submit(new Demo1()); f.interrupt();&#125; //中断后的清除代码放置在InterruptedException异常的catch捕获的代码块中 2）中断③类I/O阻塞的方法使用Thread.iterrupt方法无法中断I/O阻塞，这对于基于Web的程序是很不利的； 有一种解决方法：关闭任务在其上发生阻塞的底层资源；123456789101112main()&#123; ExecutorService exec = Executors.newCachedThreadPool(); ServerSocket server = new ServerSocket(8080); InputStream socketInput = new Socket(&quot;localhost&quot;,8080) exec.execute(socketInput); exec.execute(Sytsem.in); //exec.shutdownNow(); 无法中断2个线程； socketInput.close(); in.close(); exec.shutdownNow();&#125; java.nio类库提供了更加人性化的I/O中断，被阻塞的nio通道会自动地响应中断；12345678910111213141516171819202122232425262728class Demo impelenets Runnable&#123; private final SocketChannel sc; public Demo(SocketChannel sc)&#123; this.sc = sc;&#125; public void run()&#123; try&#123; sc.read(ByteBuffer.allocate(1)); &#125;catch(CloseByInteruptedException e1)&#123; &#125;catch(AsyncronousCloseException e2)&#123; &#125;catch(IOException e3)&#123; &#125; &#125;&#125;public Test &#123; public static void main()&#123; ExecutorService exec = Executors.newCachedThreadPool(); ServerSocket server = new ServerSocket(8080); InetSocketAddress isa = new InetSocketAddress(&quot;localhost&quot;,8080); SocketChannel sc1 = new SocketChannel.open(isa); SocketChannel sc2 = new SocketChannel.open(isa); exec.execute(new Demo(sc1)); Future&lt;?&gt; f = exec.submit(new Demo(sc2)); f.cancel(true); //可以终止sc1通道所在的线程； exec.shutdownNow(); //可以终止exec线程池内所有的线程； sc1.close(); sc2.close(); &#125;&#125; 3）中断④类被互斥阻塞的线程使用Thread.iterrupt方法无法中断互斥类线程， 解决方式1：可以使用ReentrantLock显式加锁，在JavaSE5中引入的新特性，ReentrantLock上阻塞的任务可以被中断；123456789101112131415161718class Task imlements Runnable&#123; private Lock lock = new ReentrantLock(); public void run()&#123; lock.lock(); try&#123; while(true) &#125;catch(InterruptedExcpetion e)&#123; System.out.println(&quot;The Task is interrupted!&quot;); &#125;finally&#123; lock.unlock(); &#125; &#125; public void main()&#123; Thread t = new Thread(new Task()); t.start(); t.interrupt(); &#125;&#125; 解决方式2：使用一个while（！Thread.interrupted（））包裹同步的代码块123456789101112131415161718class Task impelments Runnable&#123; private synchronized void method1()&#123; &#125; public void run()&#123; try&#123; whlie(!Thread.interrupted()) method1(); &#125;catch(InteruptedException e)&#123; &#125; &#125; public static void main()&#123; ExecutorService exec = Executors.newCachedThreadPool(); exec.execute(new Task()); exec.shutdownNow(); //线程被打断 /*或 Thread t = new Thread(new Task()); t.start(); t.interrupt(); */ &#125;&#125;","categories":[{"name":"java基础","slug":"java基础","permalink":"http://yoursite.com/categories/java基础/"}],"tags":[]}]}