{"meta":{"title":"瘟疫青年","subtitle":null,"description":null,"author":"QuincyJiang","url":"http://wenyiqingnian.xyz"},"pages":[{"title":"About","date":"2018-06-17T07:09:51.299Z","updated":"2018-06-17T07:09:51.278Z","comments":true,"path":"about/index.html","permalink":"http://wenyiqingnian.xyz/about/index.html","excerpt":"","text":"Name： Quincyjiang Male 24 (1993/08/19) Major：ICS（Information and computer science） Location：Guangzhou，China Contact： &#49;&#48;&#56;&#x33;&#56;&#x37;&#51;&#x32;&#55;&#50;&#x40;&#x71;&#x71;&#x2e;&#99;&#111;&#109; &#x6a;&#105;&#x61;&#110;&#103;&#x39;&#x33;&#x30;&#x36;&#50;&#x35;&#64;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#111;&#x6d; Intro：文艺码农，胶片玩家 skill Java Android Python C/C++ CV(Computer vison)"},{"title":"Categories","date":"2018-05-09T16:50:09.425Z","updated":"2018-05-05T15:10:05.116Z","comments":true,"path":"categories/index.html","permalink":"http://wenyiqingnian.xyz/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2018-05-06T06:09:35.982Z","updated":"2018-05-05T15:10:05.117Z","comments":true,"path":"tags/index.html","permalink":"http://wenyiqingnian.xyz/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"《现代艺术150年》未影印作品2","slug":"《现代艺术150年》未影印作品2","date":"2018-06-16T06:00:50.000Z","updated":"2018-06-17T06:54:19.422Z","comments":true,"path":"2018/06/16/《现代艺术150年》未影印作品2/","link":"","permalink":"http://wenyiqingnian.xyz/2018/06/16/《现代艺术150年》未影印作品2/","excerpt":"","text":"51.The Kiss (French: Le Baiser) 吻 1882（Auguste Rodin, 奥古斯特·罗丹）https://en.wikipedia.org/wiki/The_Kiss_(Rodin_sculpture) 52.The Kiss 吻 1907-1908（Constantin Brâncuși, 康斯坦丁·布朗库西）https://en.wikipedia.org/wiki/The_Kiss_(Br%C3%A2ncu%C8%99i_sculpture) 53.Sleeping Muse, 沉睡的缪斯 1910 （Constantin Brâncuși, 康斯坦丁·布朗库西）http://www.artic.edu/aic/collections/artwork/9024 54.Head 头 1911-1912（Amedeo Modigliani, 阿梅代奥·莫迪利亚尼）https://www.wikiart.org/en/amedeo-modigliani/head 55.Walking Man I 行走的人1 1960（Alberto Giacometti， 阿尔伯托·贾科梅蒂）https://www.artsy.net/artwork/alberto-giacometti-walking-man-i 56.Spoon Woman勺形女人 1927 （Alberto Giacometti， 阿尔伯托·贾科梅蒂）http://www.artic.edu/aic/collections/artwork/37761 57.Pierced Form 穿孔之形 1963-1964（Barbara Hepworth, 芭芭拉·赫普沃斯）http://www.tate.org.uk/art/artworks/hepworth-pierced-form-t00704 58.Pelagos 海洋生物 1946 （Barbara Hepworth, 芭芭拉·赫普沃斯）http://www.tate.org.uk/art/artworks/hepworth-pelagos-t00699 59.Single Form 单一的形式 1961 （Barbara Hepworth, 芭芭拉·赫普沃斯）http://www.tate.org.uk/art/artworks/hepworth-single-form-september-t03143 SEVEN60.Opening of the Fifth Seal 揭开第五印 1608（El Greco, 埃尔·格列柯）https://en.wikipedia.org/wiki/Opening_of_the_Fifth_Seal 61.Houses at l’Estaque 埃斯塔克的房子 1908（Georges Braque, 乔治·布拉克）https://en.wikipedia.org/wiki/Houses_at_l%27Estaque 62.Violin and Palette 小提琴与调色板 1909（Georges Braque, 乔治·布拉克）https://www.wikiart.org/en/georges-braque/violin-and-palette-1909 63.Still Life with Flowers 静物花卉 1912（Juan Gris, 胡安·格里斯）https://www.wikiart.org/en/juan-gris/still-life-with-flowers-1912 64.Ma Jolie 我的美人 1912（Pablo Picasso, 巴勃罗·毕加索）https://www.moma.org/collection/works/79051 65.Still-Life with Chair Caning有藤椅的静物 1912（Pablo Picasso, 巴勃罗·毕加索）http://www.pablo-ruiz-picasso.net/work-88.php 66.Fruit Dish and Glass 水果盘与玻璃杯 1912 （Georges Braque, 乔治·布拉克）https://en.wikipedia.org/wiki/Fruit_Dish_and_Glass 67.The Little Fourteen-Year-Old Dancer (French: La Petite Danseuse de Quatorze Ans) 小舞女 1880-1881 （Edgar Degas 埃德加·德加）https://en.wikipedia.org/wiki/Little_Dancer_of_Fourteen_Years 68.Guitar 吉他 1912（Pablo Picasso, 巴勃罗·毕加索）https://www.wikiart.org/en/pablo-picasso/guitar-1912 EIGHT69.Dynamism of a Dog on a Leash (Italian: Dinamismo di un cane al guinzaglio)拴着皮带的狗的动态 1912（Giacomo Balla, 贾科莫·巴拉）https://en.wikipedia.org/wiki/Dynamism_of_a_Dog_on_a_Leash 70.Unique Forms of Continuity in Space 空间中连续的唯一形体 1913（UmbertoBoccioni, 翁贝托·薄丘尼） https://en.wikipedia.org/wiki/Unique_Forms_of_Continuity_in_Space 71.States of Mind I: The Farewells 心境I 告别 1911 States of Mind II: Those Who Go 心境II 离开的人 1911 States of Mind III: Those Who Stay 心境III 留下的人 1911 （UmbertoBoccioni, 翁贝托·薄丘尼）https://www.wikiart.org/en/umberto-boccioni/states-of-mind-i-the-farewells-1911https://www.wikiart.org/en/umberto-boccioni/states-of-mind-ii-those-who-go-1911https://www.wikiart.org/en/umberto-boccioni/states-of-mind-iii-those-who-stay-1911-1 72.L’Équipe de Cardiff 加迪夫队 1913（Robert Delaunay, 罗伯特·德劳内）https://fr.wikipedia.org/wiki/L%27%C3%89quipe_de_Cardiff 73.Rock Drill 凿岩机 1913（Jacob Epstein, 雅各·爱泼斯坦）https://en.wikipedia.org/wiki/Rock_Drill_(Jacob_Epstein) NINE74.The First Step 第一步 1910（František Kupka, 弗朗齐歇克·库普卡）https://www.moma.org/collection/works/79969 75.Disque simultané（Simultaneous Disc）共时的圆盘 1912（Robert Delaunay, 罗伯特·德劳内）https://fr.wikipedia.org/wiki/Disque_simultan%C3%A9 76.München - Planegg I 慕尼黑-普拉内格 1 1901（Wassily Kandinsky, 瓦西里·康定斯基）https://www.akg-images.de/archive/Munchen-%25E2%2580%2593-Planegg-I-2UMDHUORFRFR.html 77.Murnau, Dorfstrasse (A Village Street) 穆尔瑙，乡村道路 1908 （Wassily Kandinsky, 瓦西里·康定斯基）https://commons.wikimedia.org/wiki/File:Vassily_Kandinsky,_1908,_Murnau,_Dorfstrasse.jpg 78.Kochel - Straight Road 科黑尔，笔直的路 1909（Wassily Kandinsky, 瓦西里·康定斯基）http://www.the-athenaeum.org/art/detail.php?ID=116422 79.Improvisation 4 即兴 4 1909（Wassily Kandinsky, 瓦西里·康定斯基）https://www.wikiart.org/en/wassily-kandinsky/improvisation-4-1909 80.Impression III (Concert) 印象3（音乐会） 1911 （Wassily Kandinsky, 瓦西里·康定斯基）https://www.wikiart.org/en/wassily-kandinsky/impression-iii-concert-1911 81.Picture with a Circle 带圆的画 1911 （Wassily Kandinsky, 瓦西里·康定斯基）http://www.wassilykandinsky.net/work-432.php 82.Composition IV 作曲 4 1911（Wassily Kandinsky, 瓦西里·康定斯基）https://www.wikiart.org/en/wassily-kandinsky/composition-iv-1911 83.Composition VII 作曲 7 1913（Wassily Kandinsky, 瓦西里·康定斯基）http://www.wassilykandinsky.net/work-36.php 84.Hammamet with mosque 哈马马特的清真寺 1914（Paul Klee, 保罗·克利）https://www.wikiart.org/en/paul-klee/hammamet-with-mosque-1914 TEN85.Cow And Violin 奶牛和小提琴 1913（Kazimir Malevich, 卡济米尔·马列维奇）http://russianartgallery.org/famous/malevich_cow.htm 86.Black Square 黑色正方形 1915 （Kazimir Malevich, 卡济米尔·马列维奇）https://en.wikipedia.org/wiki/Black_Square_(painting) 87.Suprematist Painting 至上主义 1915 （Kazimir Malevich, 卡济米尔·马列维奇）http://www.ibiblio.org/eldritch/el/mpix.html 88.Corner Counter-Relief 1914 角落的反浮雕（Vladimir Tatlin, 弗拉基米尔·塔特林）http://rusmuseumvrm.ru/data/collections/sculpture/20/tatlin_ve_uglovoy_kontrrelef_1914/index.php?lang=en 89.Monument to the Third International 第三国际的纪念塔 1919-1920（Vladimir Tatlin, 弗拉基米尔·塔特林） https://en.wikipedia.org/wiki/Tatlin%27s_Tower 90.Pure Red Color, Pure Yellow Color, Pure Blue Color 纯红、纯黄和纯蓝 1921（Alexander Rodchenko, 亚历山大·罗琴科） 91.Beat the Whites with the Red Wedge 以红锲攻打白军 1919（El Lissitzky, 埃尔·利西茨基）https://en.wikipedia.org/wiki/Beat_the_Whites_with_the_Red_Wedge ELEVEN92.Composition C (No.III) with Red, Yellow and Blue构成C（第 3号），红黄蓝 1935（Piet Mondrian, 皮埃特·蒙特里安）https://theartstack.com/artist/piet-mondrian/composition-c-no-iii-with-red-yellow-and-blue# 93.Evening; Red Tree 夜晚，红树 1908 （Piet Mondrian, 皮埃特·蒙特里安）https://en.wikipedia.org/wiki/Evening;_Red_Tree 94.Gray Tree 灰色的树 1912 （Piet Mondrian, 皮埃特·蒙特里安）https://en.wikipedia.org/wiki/Gray_Tree 95.Blossoming Apple Tree 开花的苹果树 1912 （Piet Mondrian, 皮埃特·蒙特里安）https://en.wikipedia.org/wiki/Evening;_Red_Tree#/media/File:Blossoming_apple_tree,_by_Piet_Mondriaan.jpg 96.Tableau No. 2/Composition No. VII 画面 2/构成 7 1913 （Piet Mondrian, 皮埃特·蒙特里安）https://theartstack.com/artist/piet-mondrian/tableau-no-2-compositio 97.Composition No VI 构成 6 1914 （Piet Mondrian, 皮埃特·蒙特里安） 98.Red and Blue Chair 红蓝椅 1923 （Gerrit Rietveld, 赫里特·里特费尔德）http://www.theartstory.org/movement-de-stijl-artworks.htm 99.Rietveld Schröder House 施罗德住宅 1924 （Gerrit Rietveld, 赫里特·里特费尔德）https://en.wikipedia.org/wiki/Rietveld_Schr%C3%B6der_House 100.Composition No.1 构成第一号 1920 （Piet Mondrian, 皮埃特·蒙特里安） TWELVE101.Wainwright Building 温赖特大厦 1891（ Dankmar Adler and Louis Sullivan, 阿德勒和路易斯·沙利文）https://en.wikipedia.org/wiki/Wainwright_Building 102.AEG turbine factory 通用电气涡轮机工厂 1909 （Peter Behrens, 彼特·贝伦斯）https://en.wikipedia.org/wiki/AEG_turbine_factory 103.Fagus Factory (German:Fagus-Werk）法古斯工厂 1911-1913 （ Walter Gropius and Adolf Meyer, 沃尔特·格罗佩斯，阿道夫·梅耶）https://en.wikipedia.org/wiki/Fagus_Factory 104.Self-Portrait as a Soldier 作为一个军人的自画像 1915（Ernst Ludwig Kirchner, 恩斯特·路德维希·凯尔希纳）https://www.wikiart.org/en/ernst-ludwig-kirchner/self-portrait-as-a-soldier-1915 105.Hot-Water Jug 1924（Marianne Brandt, 玛丽安·布兰德）https://www.moma.org/collection/works/2440 106.Table Lamp 华根菲尔德台灯 1924（Wilhelm Wagenfeld &amp; Carl Jakob Jucker, 威尔赫姆·华根菲尔德，卡尔·朱克）https://www.moma.org/collection/works/4056?locale=en 107.EM 1 (Telephone Picture) 电话图 EM1 1923 （László Moholy-Nagy, 莫霍利·纳吉）https://www.moma.org/collection/works/147626 108.NESTING TABLES 嵌套桌组 1927 （Josef Albers, 约瑟夫·亚伯斯）https://blog.timelesswroughtiron.com/2014/09/modern-history-bauhaus-nesting-tables/ 109.Wassily Chair 瓦西里椅 1925（Marcel Lajos Breuer, 马塞尔·布劳耶）https://en.wikipedia.org/wiki/Wassily_Chair 110.Barcelona Pavilion 巴塞罗那世博会德国馆 1929 （Ludwig Mies van der Rohe, 路德维希·密斯·凡德罗）https://en.wikipedia.org/wiki/Barcelona_Pavilion 111.Barcelona Chair 巴塞罗那椅 1929 （Ludwig Mies van der Rohe, 路德维希·密斯·凡德罗）https://www.moma.org/collection/works/4369?locale=en THIRTEEN112.La Nona Ora (The Ninth Hour) 第九时辰 1999（Maurizio Cattelan, 莫瑞吉奥·卡特兰）https://farticulate.wordpress.com/2010/10/21/la-nona-ora-the-ninth-hour-1999/ 113.Collage with Squares Arranged according to the Laws of Chance 根据随机法则排布的正方形的拼贴画 1916-1917 （Jean （Hans）Arp, 让·阿尔普（汉斯·阿尔普））https://www.moma.org/collection/works/37013?locale=en 114.Revolving 旋转 1919 （Kurt Schwitters, 库尔特·施维特斯）https://www.moma.org/collection/works/79211?locale=en 115.Merzbau 梅尔兹堡 1933 （Kurt Schwitters, 库尔特·施维特斯）https://www.moma.org/explore/inside_out/2012/07/09/in-search-of-lost-art-kurt-schwitterss-merzbau/ 116.3 Standard Stoppages 三个标准的终止 1913-1914（Marcel Duchamp, 马塞尔·杜尚）https://www.moma.org/collection/works/78990?locale=en 117.L.H.O.O.Q. 1919 （Marcel Duchamp, 马塞尔·杜尚）https://en.wikipedia.org/wiki/L.H.O.O.Q. 118.Beautiful Breath: Veil Water 美丽气息 1921 （Marcel Duchamp, 马塞尔·杜尚）http://www.toutfait.com/unmaking_the_museum/Belle%20Haleine.html","categories":[{"name":"备忘录","slug":"备忘录","permalink":"http://wenyiqingnian.xyz/categories/备忘录/"}],"tags":[{"name":"现代艺术150年","slug":"现代艺术150年","permalink":"http://wenyiqingnian.xyz/tags/现代艺术150年/"},{"name":"备忘录","slug":"备忘录","permalink":"http://wenyiqingnian.xyz/tags/备忘录/"}]},{"title":"深度学习1-反向传播","slug":"深度学习1-反向传播","date":"2018-06-08T09:33:50.000Z","updated":"2018-06-10T10:09:02.531Z","comments":true,"path":"2018/06/08/深度学习1-反向传播/","link":"","permalink":"http://wenyiqingnian.xyz/2018/06/08/深度学习1-反向传播/","excerpt":"","text":"机器学习算法中的数学思想一、 机器学习的过程是在学习什么以MNIST手写数字识别为例 MNIST是一个手写数字数据库，它是以一个28*28像素的图片以及一个对应的数字标签作为键值对的数据库。 为了更好的将这个识别过程数学化，先将输入的图形像素化，每一个数字图形可以按照各像素的明度值 转化为一个784个参数的列向量。[0.1,0.3,0.4 ...... 0.0,0.8] 其中每个向量值代表一个像素对应的明度值。假设学习模型为一个有两个隐藏层的全连接层。 可以看到 每个神经元与神经元之间都由一根线连接着，这根线其实指代的是两个神经元之间的关系，用数学方式来说，可以称之为 权重值。 我们希望找到每根线所代表的权重，当输入一个手写数字图片的时候，通过第一层的权重值，点亮部分第一个隐藏层的神经元【注1】 注释1： 可以假设 最后一层隐藏的神经元所代表的是类似人类识别数字那样，指代组成数字的一些笔画，比如说圆圈或者竖线，那么第一层隐藏的神经元可能指代的是 组成哪些笔画的更细微一些的笔画，比如一个左上角的圆弧，一个左下角的圆弧之类，但其实机器学习的过程并非我们想象的那样，每一层代表的可能是一些我们人类都看不懂的信息，我们称之为features，或者说是特征。为了更好理解机器学习的数学原理，我们暂且这么认为。 那么 拿最后输出层的一个神经元 a2 来说，它就等于上一层神经元与权重值的求和$sum = \\sum_j W_{i,j}x_j$但只求和是不行的，因为对于输出端 a2来说，它的值必须在[0,1]范围内，这里就要用到sigmoid() 压缩函数。【注2】 注2： sigmoid 函数 是一个压缩函数 $ S(x) = \\frac{1}{1+e_{-x}}$，sigmoid函数连续，光滑，严格单调，以(0,0.5)中心对称，是一个非常良好的阈值函数。当x趋近负无穷时，y趋近于0；趋近于正无穷时，y趋近于1；x=0时，y=0.5。当然，在x超出[-6,6]的范围后，函数值基本上没有变化，值非常接近，在应用中一般不考虑。 在机器学习中，常常使用sigmoid函数 将相似率控制在0-1 范围内。 当然，神经元的触发难易程度也不应该是一样的，我们在求和函数$sum = \\sum_j W_{i,j}x_j$中增加一个偏置值$ b_i$，用来控制神经元激活的难易程度。$sum = \\sum_j W_{i,j}x_j+b_i$那么 输出结果ai 就可以用公式表示为$ a_i = sigmoid（\\sum{w^{i-1}_j a_j^{l-1}+b_i}）$所谓机器学习，就是找到上述有着无比复杂参数（偏置b和权重w）的函数funa（），求出其正确的偏置和权重值,使得我们每次输入一个手写图片向量，该函数都能在最后点亮输出向量中的某个神经节点。所以： 机器学习的核心，就是使用合适的方法 去找到学习的数学模型里，所有的 偏置和 权重 反向传播这是机器学习的核心，就是找到一个合适的方法，去调整偏置和权重，使输出层的结果尽可能的与我们期望的结果一致。就以前面说到的识别mnist手写数字识别算法为例。当输入一个手写数字 2 的时候 当模型还未完全训练完毕，输入的结果和输出的结果看起来应该是没有什么关联的。 可以看到，尚未完成训练的模型，它的识别结果是很混乱的，同时点亮了好几个数字。 我们的期望： 是让数字2 对应的节点 值变得更大，让其他的节点 对应的结果值变得更小。同时 该变化应该和节点当前对应的值与期望值的差距成正比。 比如说 节点2 当前激活的值为0.2 我们期望的值是1，那么节点2变大 对于我们预测模型来说就比让节点8变为0要来的更重要，因为节点8 当前的数值0.2 已经和我们期望的0 差距不大了，而2对应的0.2 与我们当前期望的1差距显然要更大。 见下图： 我们知道，数字2 对应的值0.2 是将输入的748列向量的值，与对应的偏置和权重相乘之后求和，再通过sigmoid()函数 将其结果约束在[0,1]之间的 注： w0 w1 w2…. 为上一层（该例子中为第二个隐藏层）对应的每个神经元的权重，b为偏置向量。如果要让0.2（即节点2对应的输出）变大，有三个途径 增大权重wi 增大偏置b 修改ai的值 我们目前只关注如何修改权重 使得输出节点2 对应的结果变大。 可以看到上一个链接层对应的激活情况如图。如果我们要更改权重值， 那么1，6，7，9对应的神经节点的参数更改会更有意义，因为预测结果是上层神经元与权重乘积求和的，因为1678 对应的节点更亮，那么增大他们之间的权重值会更有意义。同样，如果如果我们更改节点的值，那么1，6，7，9对应的节点更应该增大，但现在我们无法更改节点值，只能通过更改权重和偏置的值来修改最终的计算结果。 这只是当只有一个输入的时候，输出结果告诉我们它对上个节点权重值变化的诉求，以这个例子为例，就代表当输入一个手写数字2 的时候，为了使输出结果更接近为2，结果神经元要求上一个隐藏层中 第 1，6，7，9对应的节点的权重应该更大，那么当吧全部训练数据输入进来的时候，所有的输出结果对上一个神经元 权重的诉求就都可以获取到了，那么将全部的诉求求和求均，就得到整个样本对该模型 第二个隐藏层 权重变化的诉求。 损失函数当学习模型尚未训练好，它给出的结果可以说是相当随机的，那么有必要告诉模型，当前的输出结果与预期结果偏差有多大。 这里便引申出损失函数的概念。 损失函数（loss function）是用来估量模型的预测值f(x)与真实值Y不一致的程度，它是一个非负实数值函数，通常使用L(Y,f(x))来表示，损失函数越小，模型稳健性越好。 在机器学习里 我们的损失函数一般是 预测结果和期望结果的平方差之和。我们训练模型，就是为了是损失函数最小。机器学习的损失函数可以表示为【注3】 参数解释：$a^j$：机器学习预测出的结果值$b^j$： 目标期望值$C_0$： 表示输入一个样本的损失值 其中 $a^j$ 又可以表示 上一层神经元与权重和偏置的加权和，我们记为z，对z进行sigmoid压缩得到的结果。 用公式可以表述如下： 那么 可以看到 最终的损失值$C_0$ 可以表示为 反向传播算法正向传播过程当我们输入随机的一组权重和偏置，以及一张手写数字数组之后，将其按照求和公式求和，可得到一组预测值。这叫正向传播 正向传播： 根据输入的一组数据，计算出输出值 反向传播 概念： 当计算出预测值之后，因为它必定跟我们的期望结果有偏差，所以就需要将偏差值计算出来，将偏差反向传播，计算每个权重的偏导值，然后以一定的步长更新权重，减小误差，这叫反向传播。 上面说过，我们判断上个神经元层与输出结果的神经元之间的权重变化，他们不仅与当前计算结果和预期结果的偏差相关（表现在数学上，就是输出向量与预期向量$y = [0,0,1,0,0,0,0,0,0]$ 之间的求和平均数），还与当前神经元的数值相关。 对于上文中 我们说过的损失函数C，机器学习的目的就是通过改变对应的偏置b和权重w 使该函数最小，那么我们只需要求出 损失函数对每一个偏置和每一个权重的偏导数即可，知道了偏导数，我们就知道权重应该以什么样的方式，以多大的数量，增加还是减少，来影响最终的预测结果从而是损失函数降低到最小。一般的处理是，算出权重的梯度值之后，如果梯度为正，就意味着这里涉及到梯度下降算法的一些知识，可以详细的看一下梯度下降的维基百科，讲的很好 剩下的就是求偏导数的知识了，$C_0$ 对$ w_{l}^j$ 的敏感度，也就是偏导数，根据链式法则，可以求得为： 其中 每一项，抛去数学含义，它都是代表了一定意义的 $C_0$ 对$a_j^{L}$ 的偏导数： 因为平方差函数（损失函数c0）的偏导数斜率一般为正，所以该函数意味着 目标函数与预测函数之间的差距越大，偏置w的改变对该偏差值的影响就越大，与上文所讲的吻合，就是预测值和期望值之间的差距，也会对权重的改变产生影响。偏差越大的，他们的权重改变对偏差值的影响会更大。（就是改变这些偏差大的神经元他们链接的权重会更有性价比一些） a对z求导：就是你所选的非线性激活函数对z的偏导数 $z^{L}j$对$w{jk}^{L}$ 的偏导数： 偏导结果其实是$f(a^{L-1})$ ，意味着 L层的权重$w^{L}_{jk}$ 对偏差值的影响 受到它上一层的神经元的影响。也就是一同激活的神经元联系在一起这句话的由来 说到这里，我们有必要看一下 $C_0$ 对$a_j^{L-1}$（L1层的神经元）的敏偏导数。这是理解反向传播算法的核心虽然上文说过 我们无法改变$a_{L-1}$层神经元的值，只能改变他们的权重和偏置，但是看一下 $a^(L-1)$ 与$z^{L-1}$ 、$w^{L-1}$、$a^{L-2}$ 、$b^{L-1}$是直接相关联的，那么如果知道$C_0$ 对$a_j^{L-1}$的偏导数，那么反过来用求导公式 （将公式中的L 替换为L-1，同时左边的移动到右边，也就知道了代价函数对之前偏置和权重的偏导数了。对上一层神经元的的偏导数： 这里也可以看出，上一层神经元对代价函数的影响是同时通过下一层神经元的共同作用而影响的（因为偏导数是下一层神经元的偏导数乘积之和 ） 将上式展开，可得偏差函数对L层每一个权重的偏导数为： 当求出$w_jk^{(L)}$的偏导数，下一步只需要采用合适的最优化方法，更新该偏导数的值，就可以使误差逐步减小。 关于反向传播算法的具体例子，可以参考这篇博客，以具体的例子展示了反向传播的过程中 权重值是如何变化的。","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://wenyiqingnian.xyz/categories/机器学习/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://wenyiqingnian.xyz/tags/机器学习/"},{"name":"Tensorflow","slug":"Tensorflow","permalink":"http://wenyiqingnian.xyz/tags/Tensorflow/"}]},{"title":"《现代艺术150年》未影印作品1","slug":"《现代艺术150年》未影印作品1","date":"2018-06-02T14:00:50.000Z","updated":"2018-06-17T06:35:07.324Z","comments":true,"path":"2018/06/02/《现代艺术150年》未影印作品1/","link":"","permalink":"http://wenyiqingnian.xyz/2018/06/02/《现代艺术150年》未影印作品1/","excerpt":"","text":"以书中提到的艺术品先后为时序，罗列出书中未影印出的作品。 ZERO1.Equivalent VIII 等价物 8 1966 （ Carl Andre 卡尔·安德烈） http://www.tate.org.uk/art/artworks/andre-equivalent-viii-t01534 2.Puppy 小狗 1992 （Jeff Koons，杰夫·昆斯） https://www.guggenheim.org/artwork/48 ONE3.Fountain 泉 1917 （Marcel Duchamp, 马塞尔·杜尚）https://en.wikipedia.org/wiki/Fountain_(Duchamp) TWO4.睡莲 Reflections of Clouds on the Water-Lily Pond，1920 （Claude Monet 克劳德·莫奈）https://en.wikipedia.org/wiki/Water_Lilies_(Monet_series) 5.The Dance Class (La Classe de Danse) 舞蹈课 1874（Edgar Degas 埃德加·德加）https://en.wikipedia.org/wiki/The_Ballet_Class_(Degas,_Mus%C3%A9e_d%27Orsay) 6.Hoar Frost, the Old Road to Ennery 白霜，通往埃纳里的老路 1873（Camille Pissarro , 米耶·毕沙罗）https://artbookannex.com/tag/ennery/ 7.The Raft of the Medusa 美杜莎之筏 1818-1819（Théodore Géricault, 泰奥多尔·席里柯）https://en.wikipedia.org/wiki/The_Raft_of_the_Medusa 8.Liberty Leading the People 自由引导人民 1830 （Eugène Delacroix, 欧仁·德拉克罗瓦）https://en.wikipedia.org/wiki/Liberty_Leading_the_People 9.L’Origine du monde (“The Origin of the World”) 世界的起源 1866 （Gustave Courbet, 古斯塔夫·库尔贝 ）https://en.wikipedia.org/wiki/L%27Origine_du_monde 10.The Absinthe Drinker (French: Le Buveur d’absinthe) 喝苦艾酒的人 1859 （Édouard Manet, 爱德华·马奈）https://en.wikipedia.org/wiki/The_Absinthe_Drinker_(Manet_painting) 11.Le Déjeuner sur l’herbe (English: The Luncheon on the Grass) 草地上的午餐 1863 （Édouard Manet, 爱德华·马奈）https://en.wikipedia.org/wiki/Le_D%C3%A9jeuner_sur_l%E2%80%99herbe 12.Olympia 奥林匹亚 1863 （Édouard Manet, 爱德华·马奈）https://en.wikipedia.org/wiki/Olympia_(Manet) THREE13.Impression, Sunrise (French: Impression, soleil levant) 1872（Claude Monet 克劳德·莫奈） https://en.wikipedia.org/wiki/Impression,_Sunrise 14.A Modern Olympia 现代奥林匹亚 1870（Paul Cézanne, 保罗·塞尚）http://www.paulcezanne.org/a-modern-olympia.jsp#prettyPhoto 15.Bain à la Grenouillère 青蛙塘 1869 （Claude Monet 克劳德·莫奈）https://en.wikipedia.org/wiki/Bain_%C3%A0_la_Grenouill%C3%A8re 16.La Grenouillère 青蛙塘 1869 （Pierre-Auguste Renoir, 皮埃尔-奥古斯特·雷诺阿）https://en.wikipedia.org/wiki/Pierre-Auguste_Renoir 17.Rain, Steam and Speed – The Great Western Railway 雨、蒸汽和速度 1844 （ J. M. W. Turner, J.M.W 特纳）https://en.wikipedia.org/wiki/Rain,_Steam_and_Speed_%E2%80%93_The_Great_Western_Railway 18.The Thames below Westminster 威斯敏斯特下的泰晤士河 1871 （Claude Monet 克劳德·莫奈）https://artuk.org/discover/artworks/the-thames-below-westminster-115865 19.神奈川沖浪裏 The Great Wave off Kanagawa 神奈川巨浪 1829-1833 （葛飾北斎，Katsushika Hokusai, 葛饰北斋）https://en.wikipedia.org/wiki/The_Great_Wave_off_Kanagawa 20.大津駅 Station of Otsu 大津站 1840（安藤 広重, Ando Hiroshige, 安藤广重（后改名 歌川 広重, Utagawa Hiroshige, 歌川广重））https://www.metmuseum.org/toah/works-of-art/JP804/ 21.A Carriage at The Races 赛马场上的马车 1870 （Edgar Degas 埃德加·德加）https://www.wikiart.org/en/edgar-degas/a-carriage-at-the-races-1872 FOUR22.The Potato Eaters 吃土豆的人 1885（Vincent Willem van Gogh, 文森特·梵高）https://en.wikipedia.org/wiki/The_Potato_Eaters 23.The Yellow House 黄房子 1888 （Vincent Willem van Gogh, 文森特·梵高）https://en.wikipedia.org/wiki/The_Yellow_House 24.Still Life With a Plate of Onions 静物：一盘洋葱 1889 （Vincent Willem van Gogh, 文森特·梵高）https://commons.wikimedia.org/wiki/File:Still_life_with_a_plate_of_onions.jpg 25.The Sower 播种者 1888（Vincent Willem van Gogh, 文森特·梵高）https://en.wikipedia.org/wiki/Vincent_van_Gogh#/media/File:The_Sower.jpg 26.The Night Café 夜间咖啡馆 1888（Vincent Willem van Gogh, 文森特·梵高）https://en.wikipedia.org/wiki/The_Night_Caf%C3%A9 27.Sunflowers 向日葵 1888（Vincent Willem van Gogh, 文森特·梵高）https://en.wikipedia.org/wiki/Sunflowers_(Van_Gogh_series) 28.Starry Night Over the Rhône 满天星斗下的罗纳河 1888 （Vincent Willem van Gogh, 文森特·梵高）https://en.wikipedia.org/wiki/Starry_Night_Over_the_Rh%C3%B4ne 29.Bedroom in Arles 寝室 1888（Vincent Willem van Gogh, 文森特·梵高）https://en.wikipedia.org/wiki/Bedroom_in_Arles 30.The Scream 呐喊 1893 （Edvard Munch, 爱德华·蒙克）https://en.wikipedia.org/wiki/The_Scream 31.Study after Velázquez’s Portrait of Pope Innocent X 临摹委拉斯开兹的《教皇英诺森十世肖像》1953（Francis Bacon, 弗朗西斯·培根）https://en.wikipedia.org/wiki/Study_after_Vel%C3%A1zquez%27s_Portrait_of_Pope_Innocent_X 32.Homage to Van Gogh 向梵高致敬 1960 （Francis Bacon, 弗朗西斯·培根）https://www.artimage.org.uk/3087/francis-bacon/homage-to-van-gogh--1960 33.Painter on the Road to Tarascon, August 1888 (destroyed by fire in the Second World War) 去往塔拉斯孔路上的画家 1888 （Vincent Willem van Gogh, 文森特·梵高）https://en.wikipedia.org/wiki/Vincent_van_Gogh#/media/File:Vincent_Van_Gogh_0013.jpg 34.Vision after the Sermon (Jacob Wrestling with the Angel) 布道后的幻象（雅各与天使搏斗） 1888（Paul Gauguin, 保罗·高更）https://en.wikipedia.org/wiki/Vision_After_the_Sermon 35.No te aha oe riri (Why Are You Angry?), 你为何生气 1896（Paul Gauguin, 保罗·高更）http://www.artic.edu/aic/collections/artwork/16496 36.Bathers at Asnières (French: Une Baignade, Asnières) 阿尼埃尔的浴场 1884（Georges Seurat, 乔治·修拉）https://en.wikipedia.org/wiki/Bathers_at_Asni%C3%A8res 37.A Sunday Afternoon on the Island of La Grande Jatte 大碗岛的星期天下午 1884-1886（Georges Seurat, 乔治·修拉）https://en.wikipedia.org/wiki/A_Sunday_Afternoon_on_the_Island_of_La_Grande_Jatte FIVE38.Still Life with Apples and Peaches 有苹果和桃子的静物 1905（Paul Cézanne, 保罗·塞尚）https://www.nga.gov/Collection/art-object-page.45986.html 39.Mont Sainte-Victoire with Large Pine 圣维克多山 1887 （Paul Cézanne, 保罗·塞尚）https://en.wikipedia.org/wiki/Mont_Sainte-Victoire_with_Large_Pine SIX40.The Kiss 吻 1907-1908 （Gustav Klimt, 古斯塔夫·克里姆特）https://en.wikipedia.org/wiki/The_Kiss_(Klimt) 41.Boats in the Harbour at Collioure 科利乌尔港的船 1905 （André Derain, 安德烈·德兰） 42.Restaurant de la Machine at Bougival 布吉瓦尔的餐馆 1905（Maurice de Vlaminck, 莫里斯·德·弗拉芒克） 43.Woman with a Hat 戴帽子的妇人 1905 （Henri Matisse, 亨利·马蒂斯）https://en.wikipedia.org/wiki/Woman_with_a_Hat 44.Le bonheur de vivre (The Joy of Life) 生之欢乐 1905-1906 （Henri Matisse, 亨利·马蒂斯）https://en.wikipedia.org/wiki/Le_bonheur_de_vivre 45.Reciproco Amore 互爱 1589-1595（Agostino Carracci, 阿戈斯蒂诺·卡拉奇） 46.Portrait of Gertrude Stein 格特鲁德·斯泰因肖像 1905-1906 （Pablo Picasso, 巴勃罗·毕加索）https://en.wikipedia.org/wiki/Portrait_of_Gertrude_Stein 47.Les Demoiselles d’Avignon (The Young Ladies of Avignon, and originally titled The Brothel of Avignon) 亚维农少女 1907 （Pablo Picasso, 巴勃罗·毕加索）https://en.wikipedia.org/wiki/Les_Demoiselles_d%27Avignon 48.A Carnival Evening 狂欢节之夜 1886（Henri Rousseau, 亨利·卢梭） 49.The Hungry Lion Throws Itself on the Antelope (Le lion ayant faim se jette sur l’antilope) 饿狮猛扑羚羊 1905（Henri Rousseau, 亨利·卢梭）https://en.wikipedia.org/wiki/The_Hungry_Lion_Throws_Itself_on_the_Antelope Portrait of a Woman 一个女人的肖像 1895 （Henri Rousseau, 亨利·卢梭）https://commons.wikimedia.org/wiki/File:Henri_Rousseau__Portrait_of_a_Woman_(1895).jpg","categories":[{"name":"备忘录","slug":"备忘录","permalink":"http://wenyiqingnian.xyz/categories/备忘录/"}],"tags":[{"name":"现代艺术150年","slug":"现代艺术150年","permalink":"http://wenyiqingnian.xyz/tags/现代艺术150年/"},{"name":"备忘录","slug":"备忘录","permalink":"http://wenyiqingnian.xyz/tags/备忘录/"}]},{"title":"从驱动角度理解binder","slug":"从驱动角度理解binder","date":"2018-06-02T11:00:50.000Z","updated":"2018-06-03T14:05:09.390Z","comments":true,"path":"2018/06/02/从驱动角度理解binder/","link":"","permalink":"http://wenyiqingnian.xyz/2018/06/02/从驱动角度理解binder/","excerpt":"","text":"一次binder通讯建立的大致流程我们已经了解了，首先是要注册一个serviceManager，server端创建实名binder，向smg注册自己可以提供的服务，以及该实名binder的标签，smg会在svcinfo 链表中缓存该server提供的binder信息，当client需要使用该服务时，只需要向smg中查询服务，获取server端binder的引用就可以了，这其中所有的通讯细节，全部需要binder驱动来实现。 本文主要总结一下对binder驱动的理解，了解驱动设计的细节，以及binder通讯过程中驱动主要做了哪些事情。 Binder驱动的定义Binder驱动其实是一种特殊的字符型驱动，实现方式类似硬件驱动，工作在内核态。如果了解过linux驱动相关知识，应该知道file_operations 结构体的重要性，linux 使用该结构体访问驱动程序的函数，这个结构体的每一个成员的名字都对应一个内核调用。当用户进程利用设备文件（binder对应的设备文件为/dev/test）对文件进行类似read()/write() 操作的时候，系统调用通过设备文件的主设备号找到对应的设备驱动程序，每一个驱动程序在内核中是由一个cdev结构体描述，cdev结构体中又包括一个成员fops结构体，fops便是file_operations类型的，然后读取file_operations 结构体相应的函数指针，接着把控制权交给该函数的linux 设备驱动程序工作。 下面以binder驱动在内核中的注册流程来分析binder驱动为用户空间定义了哪些可用来调用的函数。 注册Binder 在binder驱动源码中（kernel/drivers/staging/android/binder.c），通过调用 ret = misc_register(&amp;binder_msicdev)函数完成向内核注册binder驱动，主设备号为10，次设备号动态分配， 其中传入的参数便是一个miscdev的结构体， 它的定义如下 12345static struct miscdevice binder_miscdev = &#123; .minor = MISC_DYNAMIC_MINOR, .name = \"binder\", .fops = &amp;binder_fops&#125;; 可以看到cdev文件中标注了binder设备的设备名”binder”，以及fops结构体，fops结构体如下： 123456789static const struct file_operations binder_fops = &#123; .owner = THIS_MODULE, .poll = binder_poll, .unlocked_ioctl = binder_ioctl, .mmap = binder_mmap, .open = binder_open, .flush = binder_flush, .release = binder_release,&#125;; 可以看到binder驱动为应用层提供了open(),mmap(),poll(),ioctl()等标准的文件操作【注1】，open()负责打开驱动，mmap()负责对binder做内核空间向用户空间的地址映射，ioctl()负责binder协议的通信。 我们知道，用户态的引用程序调用kernel驱动程序是会陷入内核态的，进行系统调用，比如我使用 fd = open(&quot;dev/binder&quot;,O_RDWR)，开打开binder驱动时，它会先通过通过系统调用_open()【注1】，通过主次设备号来找到对应的binder驱动程序，即在 cdev 链表中找到binder驱动对应的binder_miscdev，找到 binder_fops结构体，找到open()方法对应的 binder_open()函数，实际执行到的便是binder_open（）函数。那么其他的 比如 mmap(),ioctl()方法，他们的执行流程也是类似的。 参考下图 注释1： open()为用户空间的方法，_open()为系统调用中对应的处理方法。 打开一次binder通讯，大致分为以下流程： 1 调用open()方法打开binder驱动 2 调用 mmap()方法申请一块内存用来接受通信中的数据，并进行内存映射（binder机制为什么只进行一次拷贝，这里有文章）， 3 调用 ioctl()方法 开启binder通讯。这里每一步中具体都做了些什么，下文会有详细描述，但为了更好理解，需要先要搞清楚binder驱动中的几个关键的数据结构和binder的通讯协议。 Binder驱动中的结构体驱动中的结构体分为两部分，一部分与用户空间共用，这些结构体在Binder通信协议中会用到，被定义在binder.h 头文件中。具体内容见下表： 结构体名 说明 flat_binder_object binder通讯过程中在client-binderDriver-server之间传递的实际内容，所谓跨进程传递的binder对象，其实传递的就是这个 binder_wirte_read 存储对binder驱动进行读写操作的数据，当为写的时候，结构体中的write_size非空，当为读的时候，read_size不为空 binder_version 存储binder的版本号 transaction_flags 描述一次binder事务的flag，比如是同步还是异步请求 binder_transcation_data 存储一次事务的数据 binder_handle_cookie 包含一个句柄和一个cookie binder_ptr_cookie 包含一个指针和一个cookie binder_pri_dest 暂未用到 binder_pri_ptr_cookie 暂未用到 另一部分定义在binder驱动中，是驱动特有的结构体 结构体名 描述 binder_node 描述binder的实体节点，对应一个server，当server通过binder驱动向smg注册时，binder驱动便会在内核中为其创建一个binder实体节点，该实体节点即为binder_node，同时驱动会为server与该节点创建引用关系 binder_ref 描述对binder实体节点的引用 binder_buffer 描述binder通讯过程中存储数据的buffer binder_proc 描述使用binder的进程 binder_thread 描述使用binder的线程 binder_work 描述通信过程中的一项任务 binder_transcation 描述一次事务的相关信息 binder_deferred_state 藐视延迟任务 binder_ref_death 描述binder实体的死亡信息 binder_transcation_log debugfs 日志 binder_transcation_log_entry debugfs 日志条目 binder协议Binder协议 可以分为 控制协议和驱动协议两部分。 1.控制协议控制协议是进程(client 或server端)通过系统调用（syscall）直接操作binder设备文件，使用ioctl(&#39;dev/binder&#39;)控制binder驱动的协议，该协议包含以下几种命令 命令 含义 参数 BINDER_WRITE_READ 该命令想binder写入或者读出数据，参数分为两段，写和度部分，如果write_size不为零，就先将write_buffer中的数据写入binder； 如果read_size不为零，就先从binder中取出数据，写入read_buffer中。 write_consumed和read_consumed 表示操作完成时驱动实际写入和读出的数据个数。 struct binder_wirte_read{ Singned long write_size;Signed long write_consumed;unsigend long write_buffer;signed long read_size;signed long read_consumed;Unsigned long read_buffer} BINDER_SET_MAX_THREADS 告知binder驱动接收方(server端)，线程池中最大的线程数。（详见下文 驱动线程管理） int max_threads BINDER_SET_CONEXT_MGR 将当前进程注册为smg，系统同时只可以出现一个smg，只要当前smg没有调用close关闭binder驱动，就不可能有别的进程可以成为smg BINDER_THREAD_EXIT 通知binder驱动当前线程退出了，binder会为所有参与binder通信的线程（包括server端线程池中的线程以及client端发出请求的线程）建立相应的数据结构，这些线程在退出时必须显示通知binder释放相应的数据。详见下文 binder驱动的线程控制 2. 驱动协议驱动协议根据具体使用过程，又分为发送和返回协议。发送协议 定义在binder.c 中的 1enum binder_driver_command_protocol ，返回协议 定义在1enum binder_driver_return_protocol 根据协议不同，存放的位置也不相同。驱动协议都是封装在控制协议 BINDER_WRITE_READ 命令参数 binder_wirte_read 结构体中，根据发送和返回类型，分别存放在 write_buffer和 read_buffer域所指向的内存空间中。binder_write_read结构体的数据结构见下图： 它们的数据格式都是命令 + 数据 的格式，多条命令可以连续存放。数据紧接着放在命令的后面，根据命令不同，执行的操作也不同。 发送协议： 命令 说明 参数 BC_TRANSCATION binder事务，client对server的请求 binder_transction_data BC_REPLAY 事务的回答，server对client的回复 Binder_transctin_data BC_FREE_BUFFER 通知驱动释放buffer Binder_uinptr_t BC_ACQUIRE 强引用计数+1 _u32 BC_RELEASE 强引用计数-1 _u32 BC_INCREFS 弱引用计数+1 _u32 BC_DECREFS 弱引用计数-1 _u32 BC_ACQUIRE_DODE acquire指令的回复 Binder_ptr_cookie BC_INCREFS_DONE increfs指令的回复 Binder_prt_cookie BC_ENTER_LOOPER 通知驱动主线程ready Void BC_REGISTER_LOOPER 通知驱动子线程ready Void BC_EXIT_LOOPER 通知驱动线程已退出 Void BC_REQUEST_DEATH_NOTIFICATION 请求接受死亡通知 Binder_handle_cookie BC_CLEAR_DEATH_NOTIFICATION 去除接受死亡通知 Binder_handle_cookie BC_DEAD_BINDER_DONE 已经处理完死亡通知 Binder_uinptr_t BC_ATTEMPT_ACQUIRE 暂未实现 - BC_ACQUIRE_RESULT 暂为实现 - 返回协议： 命令 说明 参数 BR_OK 操作完成 void BR_NOOP 操作完成 void BR_ERROR 发生错误 _s32 BR_TRANSCATION 进程收到一次binder请求 （server端） binder_transcation_data BR_REPLAY 进程收到binder请求的回复（client） binder_transtaction_data BR_TRANSCATION_COMPLETED 驱动对于接收请求的确认回复 void BR_FAILED_REPLAY 告知发送方 通信目标不存在 void BR_SPAWN_LOOPER 通server端创建一个新的进程 void BR_ACQUIRE 强用用计数+1 Binder_prt_cookie BR_RELEASE 强引用计数-1 Binder_prt_cookie BR_INCREFS 弱引用计数+1 Binder_prt_cookie BR_DECREFS 弱引用计数-1 Binder_prt_cookie BR_DEAD_BINDER 发送死亡通知 binder_uintptr_t BR_CLEAR_DEATH_NOTIFICATION_DONE 清除死亡通知完成 binder_uintptr_t BR_DEAD_REPLAY 改制发送方对方已死亡 void BR_ATTEMPT_ACQUIRE 暂未实现 - BR_ACQUIRE_RESULT 暂为实现 - BR_FINISHED 暂未实现 - binder 请求的过程见下图： 通过上面的Binder协议的说明中我们看到，Binder协议的通信过程中，不仅仅是发送请求和接受数据这些命令。同时包括了对于引用计数的管理和对于死亡通知的管理（告知一方，通讯的另外一方已经死亡）等功能。 这些功能的通信过程和上面这幅图是类似的：一方发送BC_XXX，然后由驱动控制通信过程，接着发送对应的BR_XXX命令给通信的另外一方。因为这种相似性，对于这些内容就不再赘述了。 由驱动角度理解 Binder通讯建立的过程1 打开驱动（open(“dev/binder”)）任何进程在使用Binder之前，都需要先通过open(&quot;/dev/binder&quot;)打开Binder设备。上文已经提到，用户空间的open系统调用对应了驱动中的binder_open函数。在这个函数，Binder驱动会为调用的进程做一些初始化工作。binder_open函数代码如下所示 1234567891011121314151617181920212223242526272829static int binder_open(struct inode *nodp, struct file *filp)&#123; struct binder_proc *proc; // 创建进程对应的binder_proc对象 proc = kzalloc(sizeof(*proc), GFP_KERNEL); if (proc == NULL) return -ENOMEM; get_task_struct(current); proc-&gt;tsk = current; // 初始化binder_proc INIT_LIST_HEAD(&amp;proc-&gt;todo); init_waitqueue_head(&amp;proc-&gt;wait); proc-&gt;default_priority = task_nice(current); // 锁保护 binder_lock(__func__); binder_stats_created(BINDER_STAT_PROC); // 添加到全局列表binder_procs中 hlist_add_head(&amp;proc-&gt;proc_node, &amp;binder_procs); proc-&gt;pid = current-&gt;group_leader-&gt;pid; INIT_LIST_HEAD(&amp;proc-&gt;delivered_death); filp-&gt;private_data = proc; binder_unlock(__func__); return 0;&#125; 可以看到，在打开binder驱动时，binder_procs会将所有打开binder驱动的进程加入到该列表中，上文中提到binder中的几个主要结构体，其实都是通过binder_procs结构体链接在一起的。 2. 创建内存空间并实现用户空间 内核空间的映射（mmap）打开binder驱动之后，进程会通过mmap()方法进行内存空间的映射。 上文描述过，mmap()对应的binder_mmap()函数，它会先申请一份物理内存，默认PAGE_SIZE 是4k，然后会同时在 用户空间和 内核空间映射该物理内存。当client 发送数据给server的时候，只需要将client端的数据，拷贝到server端所指向的 内核中的地址即可，因为server的用户空间和binder对应的内核空间映射的是同一份物理内存，当server取数据的时候，就无需再从内科中拷贝了，server可以直接使用。 这幅图的说明如下： Server在启动之后，对/dev/binder设备调用mmap内核中的binder_mmap函数进行对应的处理：申请一块物理内存，然后在用户空间和内核空间同时进行映射 Client通过BINDER_WRITE_READ命令发送请求，这个请求将先到驱动中，同时需要将数据从Client进程的用户空间拷贝到内核空间驱动通过BR_TRANSACTION通知Server有人发出请求，Server进行处理。由于这块内存也在用户空间进行了映射，因此Server进程的代码可以直接访问 3. 内存管理（非重点）上文中，我们看到binder_mmap的时候，会申请一个PAGE_SIZE通常是4K的内存。而实际使用过程中，一个PAGE_SIZE的大小通常是不够的。 在驱动中，会根据实际的使用情况进行内存的分配。有内存的分配，当然也需要内存的释放。这里我们就来看看Binder驱动中是如何进行内存的管理的。 首先，我们还是从一次IPC请求说起。 当一个Client想要对Server发出请求时，它首先将请求发送到Binder设备上，由Binder驱动根据请求的信息找到对应的目标节点，然后将请求数据传递过去。 进程通过ioctl系统调用来发出请求：ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) PS：这行代码来自于Framework层的IPCThreadState类。在后文中，我们将看到，IPCThreadState类专门负责与驱动进行通信。 这里的mProcess-&gt;mDriverFD对应了打开Binder设备时的fd。BINDER_WRITE_READ对应了具体要做的操作码，这个操作码将由Binder驱动解析。bwr存储了请求数据，其类型是binder_write_read。 binder_write_read其实是一个相对外层的数据结构，其内部会包含一个binder_transaction_data结构的数据。binder_transaction_data包含了发出请求者的标识，请求的目标对象以及请求所需要的参数。它们的关系如下图所示： binder_ioctl函数对应了ioctl系统调用的处理。这个函数的逻辑比较简单，就是根据ioctl的命令来确定进一步处理的逻辑，具体如下: 如果命令是BINDER_WRITE_READ，并且如果 bwr.write_size &gt; 0，则调用binder_thread_write该方法用于处理Binder协议中的请求码。当binder_buffer存在数据，binder线程的写操作循环执行。对于请求码为BC_TRANSACTION或BC_REPLY时，会执行binder_transaction()方法，这是最为频繁的操作。 对于其他命令则不同。 如果 bwr.read_size &gt; 0，则调用binder_thread_read，该方法用以处理响应过程，根据不同的binder_work-&gt;type以及不同状态，生成相应的响应码。 如果命令是BINDER_SET_MAX_THREADS，则设置进程的max_threads，即进程支持的最大线程数如果命令是BINDER_SET_CONTEXT_MGR，则设置当前进程为ServiceManager，见下文如果命令是BINDER_THREAD_EXIT，则调用binder_free_thread，释放binder_thread如果命令是BINDER_VERSION，则返回当前的Binder版本号这其中，最关键的就是binder_thread_write方法。当Client请求Server的时候，便会发送一个BINDER_WRITE_READ命令，同时框架会将将实际的数据包装好。此时，binder_transaction_data中的code将是BC_TRANSACTION，由此便会调用到binder_transaction方法，这个方法是对一次Binder事务的处理，这其中会调用binder_alloc_buf函数为此次事务申请一个缓存。调用关系见下图 binder_update_page_range这个函数在上文中，我们已经看到过了。其作用就是：进行内存分配并且完成内存的映射。而binder_alloc_buf函数，正如其名称那样的：完成缓存的分配。 在驱动中，通过binder_buffer结构体描述缓存。一次Binder事务就会对应一个binder_buffer，进程在mmap时，会设定支持的总缓存大小的上限。而进程每当收到BC_TRANSACTION，就会判断已使用缓存加本次申请的和有没有超过上限。如果没有，就考虑进行内存的分配。 进程的空闲缓存记录在binder_proc的free_buffers中，这是一个以红黑树形式存储的结构。每次尝试分配缓存的时候，会从这里面按大小顺序进行查找，找到最接近需要的一块缓存。找到之后，还要对binder_proc的字段进行更新。 BC_FREE_BUFFER命令是通知驱动进行内存的释放，binder_free_buf函数是真正实现的逻辑，这个函数与binder_alloc_buf是刚好对应的。在这个函数中，所做的事情包括： 重新计算进程的空闲缓存大小 通过binder_update_page_range释放内存 更新binder_proc的buffers，free_buffers，allocated_buffers字段 4 通讯过程BINDER_COMMAND_PROTOCOL：binder请求码，以”BC_“开头，简称BC码，用于从IPC层传递到Binder Driver层；BINDER_RETURN_PROTOCOL ：binder响应码，以”BR_“开头，简称BR码，用于从Binder Driver层传递到IPC层； 一次完整的binder通讯流程：Binder IPC通信至少是两个进程的交互： client进程执行binder_thread_write，thread_write根据BC_XXX命令，生成相应的binder_work； server进程执行binder_thread_read，thread_read根据binder_work.type类型，生成BR_XXX，发送到用户空间处理。 binder_work.type ：123456BINDER_WORK_TRANSACTION //最常见类型BINDER_WORK_TRANSACTION_COMPLETEBINDER_WORK_NODEBINDER_WORK_DEAD_BINDERBINDER_WORK_DEAD_BINDER_AND_CLEARBINDER_WORK_CLEAR_DEATH_NOTIFICATION 可以知道，上述通信流程涉及到三种状态码的转换：BR_CODE BC_CODE BW_CODE,他们之间的转换图如下： 图解：(以BC_TRANSACTION为例) 发起端进程：binder_transaction()过程将BC_TRANSACTION转换为BW_TRANSACTION；接收端进程：binder_thread_read()过程，将BW_TRANSACTION转换为BR_TRANSACTION;接收端进程：IPC.execute()过程，处理BR_TRANSACTION命令 以gityuan的一张图来总结binder通信的全过程 5 通讯过程中 binder实体的传递Binder机制淡化了进程的边界，使得跨越进程也能够调用到指定服务的方法，其原因是因为Binder机制在底层处理了在进程间的“对象”传递。 在Binder驱动中，并不是真的将对象在进程间来回序列化，而是通过特定的标识来进行对象的传递。Binder驱动中，通过flat_binder_object来描述需要跨越进程传递的对象。其定义如下：12345678910struct flat_binder_object &#123; __u32 type; __u32 flags; union &#123; binder_uintptr_t binder; /* local object */ __u32 handle; /* remote object */ &#125;; binder_uintptr_t cookie;&#125;; 这其中，type有如下5种类型。1234567enum &#123; BINDER_TYPE_BINDER = B_PACK_CHARS('s', 'b', '*', B_TYPE_LARGE), BINDER_TYPE_WEAK_BINDER = B_PACK_CHARS('w', 'b', '*', B_TYPE_LARGE), BINDER_TYPE_HANDLE = B_PACK_CHARS('s', 'h', '*', B_TYPE_LARGE), BINDER_TYPE_WEAK_HANDLE = B_PACK_CHARS('w', 'h', '*', B_TYPE_LARGE), BINDER_TYPE_FD = B_PACK_CHARS('f', 'd', '*', B_TYPE_LARGE),&#125;; 当对象传递到Binder驱动中的时候，由驱动来进行翻译和解释，然后传递到接收的进程。 例如当Server把Binder实体传递给Client时，在发送数据流中，flat_binder_object中的type是BINDER_TYPE_BINDER，同时binder字段指向Server进程用户空间地址。但这个地址对于Client进程是没有意义的（Linux中，每个进程的地址空间是互相隔离的），驱动必须对数据流中的flat_binder_object做相应的翻译：将type该成BINDER_TYPE_HANDLE；为这个Binder在接收进程中创建位于内核中的引用并将引用号填入handle中。对于发生数据流中引用类型的Binder也要做同样转换。经过处理后接收进程从数据流中取得的Binder引用才是有效的，才可以将其填入数据包binder_transaction_data的target.handle域，向Binder实体发送请求。 由于每个请求和请求的返回都会经历内核的翻译，因此这个过程从进程的角度来看是完全透明的。进程完全不用感知这个过程，就好像对象真的在进程间来回传递一样。 6 驱动层的线程管理上文多次提到，Binder本身是C/S架构。由Server提供服务，被Client使用。既然是C/S架构，就可能存在多个Client会同时访问Server的情况。 在这种情况下，如果Server只有一个线程处理响应，就会导致客户端的请求可能需要排队而导致响应过慢的现象发生。解决这个问题的方法就是引入多线程。 Binder机制的设计从最底层–驱动层，就考虑到了对于多线程的支持。具体内容如下： 使用Binder的进程在启动之后，通过BINDER_SET_MAX_THREADS告知驱动其支持的最大线程数量 驱动会对线程进行管理。在binder_proc结构中，这些字段记录了进程中线程的信息：max_threads，requested_threads，requested_threads_started，ready_threads binder_thread结构对应了Binder进程中的线程 驱动通过BR_SPAWN_LOOPER命令告知进程需要创建一个新的线程 进程通过BC_ENTER_LOOPER命令告知驱动其主线程已经ready 进程通过BC_REGISTER_LOOPER命令告知驱动其子线程（非主线程）已经ready 进程通过BC_EXIT_LOOPER命令告知驱动其线程将要退出 在线程退出之后，通过BINDER_THREAD_EXIT告知Binder驱动。驱动将对应的binder_thread对象销毁","categories":[{"name":"Android","slug":"Android","permalink":"http://wenyiqingnian.xyz/categories/Android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://wenyiqingnian.xyz/tags/android/"},{"name":"Binder","slug":"Binder","permalink":"http://wenyiqingnian.xyz/tags/Binder/"}]},{"title":"理解Linux的FD与Inode","slug":"理解Liunx的FD与Inode","date":"2018-06-02T08:30:15.000Z","updated":"2018-06-02T08:22:05.871Z","comments":true,"path":"2018/06/02/理解Liunx的FD与Inode/","link":"","permalink":"http://wenyiqingnian.xyz/2018/06/02/理解Liunx的FD与Inode/","excerpt":"","text":"FD 文件描述符一、概念 Linux 系统中，把一切都看做是文件，当进程打开现有文件或创建新文件时，内核向进程返回一个文件描述符，文件描述符就是内核为了高效管理已被打开的文件所创建的索引，用来指向被打开的文件，所有执行I/O操作的系统调用都会通过文件描述符。 二、文件描述符、文件、进程间的关系1.描述：我们可以通过linux的几个基本的I/O操作函数来理解什么是文件操作符。 123456fd = open(pathname, flags, mode)// 返回了该文件的fdrlen = read(fd, buf, count)// IO操作均需要传入该文件的fd值wlen = write(fd, buf, count)status = close(fd) 每当进程用open（）函数打开一个文件，内核便会返回该文件的文件操作符（一个非负的整形值），此后所有对该文件的操作，都会以返回的fd文件操作符为参数。【注1】 注1： 文件描述符可以理解为进程文件描述表这个表的索引，或者把文件描述表看做一个数组的话，文件描述符可以看做是数组的下标。当需要进行I/O操作的时候，会传入fd作为参数，先从进程文件描述符表查找该fd对应的那个条目，取出对应的那个已经打开的文件的句柄，根据文件句柄指向，去系统fd表中查找到该文件指向的inode，从而定位到该文件的真正位置，从而进行I/O操作。 每个文件描述符会与一个打开的文件相对应 不同的文件描述符也可能指向同一个文件 相同的文件可以被不同的进程打开，也可以在同一个进程被多次打开 2.系统为维护文件描述符，建立了三个表 进程级的文件描述符表 系统级的文件描述符表 文件系统的i-node表 (inode 见下文) 进程级别的文件描述表：linux内核会为每一个进程创建一个task_truct结构体来维护进程信息，称之为 进程描述符，该结构体中 指针 1struct files_struct *files 指向一个名称为file_struct的结构体，该结构体即 进程级别的文件描述表。 它的每一个条目记录的是单个文件描述符的相关信息 fd控制标志，前内核仅定义了一个，即close-on-exec 文件描述符所打开的文件句柄的引用【注2】 [注释2]：文件句柄这里可以理解为文件名，或者文件的全路径名，因为linux文件系统文件名和文件是独立的，以此与inode区分 系统级别的文件描述符表内核对系统中所有打开的文件维护了一个描述符表，也被称之为 【打开文件表】，表格中的每一项被称之为 【打开文件句柄】，一个【打开文件句柄】 描述了一个打开文件的全部信息。主要包括： 当前文件偏移量（调用read()和write()时更新，或使用lseek()直接修改） 打开文件时所使用的状态标识（即，open()的flags参数） 文件访问模式（如调用open()时所设置的只读模式、只写模式或读写模式） 与信号驱动相关的设置 对该文件i-node对象的引用 文件类型（例如：常规文件、套接字或FIFO）和访问权限 一个指针，指向该文件所持有的锁列表 文件的各种属性，包括文件大小以及与不同类型操作相关的时间戳 Inode表 每个文件系统会为存储于其上的所有文件(包括目录)维护一个i-node表，单个i-node包含以下信息： 文件类型(file type)，可以是常规文件、目录、套接字或FIFO 访问权限 文件锁列表(file locks) 文件大小等等i-node存储在磁盘设备上，内核在内存中维护了一个副本，这里的i-node表为后者。副本除了原有信息，还包括：引用计数(从打开文件描述体)、所在设备号以及一些临时属性，例如文件锁。 注：进程A的fd表中，左边fd0，fd1，fd2… 就是各个文件描述符，它是fd表的索引，fd不是表里那个fd flags！这里不要搞混淆了，fd flags 目前只有一个取值。 在进程A中，文件描述符1和30都指向了同一个打开的文件句柄（标号23）。这可能是通过调用dup()、dup2()、fcntl()或者对同一个文件多次调用了open()函数而形成的。dup（），也称之为文件描述符复制函数，在某些场景下非常有用，比如：标准输入/输出重定向。在shell下，完成这个操作非常简单，大部分人都会，但是极少人思考过背后的原理。 大概描述一下需要的几个步骤，以标准输出(文件描述符为1)重定向为例： 打开目标文件，返回文件描述符n； 关闭文件描述符1； 调用dup将文件描述符n复制到1； 关闭文件描述符n； 进程A的文件描述符2和进程B的文件描述符2都指向了同一个打开的文件句柄（标号73）。这种情形可能是在调用fork()后出现的（即，进程A、B是父子进程关系）【注3】，或者当某进程通过UNIX域套接字将一个打开的文件描述符传递给另一个进程时，也会发生。再者是不同的进程独自去调用open函数打开了同一个文件，此时进程内部的描述符正好分配到与其他进程打开该文件的描述符一样。 注3： 子进程会继承父进程的文件描述符表，也就是子进程继承父进程打开的文件 这句话的由来。 此外，进程A的描述符0和进程B的描述符3分别指向不同的打开文件句柄，但这些句柄均指向i-node表的相同条目（1976），换言之，指向同一个文件。发生这种情况是因为每个进程各自对同一个文件发起了open()调用。同一个进程两次打开同一个文件，也会发生类似情况。 三、文件描述符限制 有资源的地方就有战争，“文件描述符”也是一种资源，系统中的每个进程都需要有“文件描述符”才能进行改变世界的宏图霸业。世界需要秩序，于是就有了“文件描述符限制”的规定。 如下表： 永久修改用户级限制时有三种设置类型： soft 指的是当前系统生效的设置值 hard 指的是系统中所能设定的最大值 “-” 指的是同时设置了 soft 和 hard 的值 Inode 文件节点一、inode是什么？理解inode，要从文件储存说起。 文件储存在硬盘上，硬盘的最小存储单位叫做”扇区”（Sector）。每个扇区储存512字节（相当于0.5KB）。 操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个”块”（block）。这种由多个扇区组成的”块”，是文件存取的最小单位。”块”的大小，最常见的是4KB，即连续八个 sector组成一个 block。 文件数据都储存在”块”中，那么很显然，我们还必须找到一个地方储存文件的元信息，比如文件的创建者、文件的创建日期、文件的大小等等。这种储存文件元信息的区域就叫做inode，中文译名为”索引节点”。 每一个文件都有对应的inode，里面包含了与该文件有关的一些信息。 二、inode的内容inode包含文件的元信息，具体来说有以下内容： 文件的字节数 文件拥有者的User ID 文件的Group ID 文件的读、写、执行权限 文件的时间戳，共有三个：ctime指inode上一次变动的时间，mtime指文件内容上一次变动的时间，atime指文件上一次打开的时间。 链接数，即有多少文件名指向这个inode 文件数据block的位置 可以用stat命令，查看某个文件的inode信息： stat 233.txt 总之，除了文件名以外的所有文件信息，都存在inode之中。至于为什么没有文件名，下文会有详细解释。 三、inode的大小inode也会消耗硬盘空间，所以硬盘格式化的时候，操作系统自动将硬盘分成两个区域。一个是数据区，存放文件数据；另一个是inode区（inode table），存放inode所包含的信息。 每个inode节点的大小，一般是128字节或256字节。inode节点的总数，在格式化时就给定，一般是每1KB或每2KB就设置一个inode。假定在一块1GB的硬盘中，每个inode节点的大小为128字节，每1KB就设置一个inode，那么inode table的大小就会达到128MB，占整块硬盘的12.8%。 查看每个硬盘分区的inode总数和已经使用的数量，可以使用df命令。 df -i 查看每个inode节点的大小，可以用如下命令： sudo dumpe2fs -h /dev/hda | grep &quot;Inode size&quot; 由于每个文件都必须有一个inode，因此有可能发生inode已经用光，但是硬盘还未存满的情况。这时，就无法在硬盘上创建新文件。 四、inode号码每个inode都有一个号码，操作系统用inode号码来识别不同的文件。 这里值得重复一遍，Unix/Linux系统内部不使用文件名，而使用inode号码来识别文件。对于系统来说，文件名只是inode号码便于识别的别称或者绰号。 表面上，用户通过文件名，打开文件。实际上，系统内部这个过程分成三步：首先，系统找到这个文件名对应的inode号码；其次，通过inode号码，获取inode信息；最后，根据inode信息，找到文件数据所在的block，读出数据。 使用ls -i命令，可以看到文件名对应的inode号码： ls -i 233.txt 五、目录文件 Unix/Linux系统中，目录（directory）也是一种文件。打开目录，实际上就是打开目录文件。 目录文件的结构非常简单，就是一系列目录项（dirent）的列表。每个目录项，由两部分组成：所包含文件的文件名，以及该文件名对应的inode号码。 ls命令只列出目录文件中的所有文件名： ls /etc ls -i命令列出整个目录文件，即文件名和inode号码： ls -i /etc 如果要查看文件的详细信息，就必须根据inode号码，访问inode节点，读取信息。ls -l命令列出文件的详细信息。 ls -l /etc 理解了上面这些知识，就能理解目录的权限。目录文件的读权限（r）和写权限（w），都是针对目录文件本身。由于目录文件内只有文件名和inode号码，所以如果只有读权限，只能获取文件名，无法获取其他信息，因为其他信息都储存在inode节点中，而读取inode节点内的信息需要目录文件的执行权限（x）。 六、硬链接一般情况下，文件名和inode号码是”一一对应”关系，每个inode号码对应一个文件名。但是，Unix/Linux系统允许，多个文件名指向同一个inode号码。 这意味着，可以用不同的文件名访问同样的内容；对文件内容进行修改，会影响到所有文件名；但是，删除一个文件名，不影响另一个文件名的访问。这种情况就被称为”硬链接”（hard link）。 ln命令可以创建硬链接： ln 源文件 目标文件 运行上面这条命令以后，源文件与目标文件的inode号码相同，都指向同一个inode。inode信息中有一项叫做”链接数”，记录指向该inode的文件名总数，这时就会增加1。 反过来，删除一个文件名，就会使得inode节点中的”链接数”减1。当这个值减到0，表明没有文件名指向这个inode，系统就会回收这个inode号码，以及其所对应block区域。 这里顺便说一下目录文件的”链接数”。创建目录时，默认会生成两个目录项：”.”和”..”。前者的inode号码就是当前目录的inode号码，等同于当前目录的”硬链接”；后者的inode号码就是当前目录的父目录的inode号码，等同于父目录的”硬链接”。所以，任何一个目录的”硬链接”总数，总是等于2加上它的子目录总数（含隐藏目录）。 七、软链接除了硬链接以外，还有一种特殊情况。 文件A和文件B的inode号码虽然不一样，但是文件A的内容是文件B的路径。读取文件A时，系统会自动将访问者导向文件B。因此，无论打开哪一个文件，最终读取的都是文件B。这时，文件A就称为文件B的”软链接”（soft link）或者”符号链接（symbolic link）。 这意味着，文件A依赖于文件B而存在，如果删除了文件B，打开文件A就会报错：”No such file or directory”。这是软链接与硬链接最大的不同：文件A指向文件B的文件名，而不是文件B的inode号码，文件B的inode”链接数”不会因此发生变化。 ln -s命令可以创建软链接。 ln -s 源文文件或目录 目标文件或目录 八、inode的特殊作用由于inode号码与文件名分离，这种机制导致了一些Unix/Linux系统特有的现象。 有时，文件名包含特殊字符，无法正常删除。这时，直接删除inode节点，就能起到删除文件的作用。 移动文件或重命名文件，只是改变文件名，不影响inode号码。 打开一个文件以后，系统就以inode号码来识别这个文件，不再考虑文件名。因此，通常来说，系统无法从inode号码得知文件名。 第3点使得软件更新变得简单，可以在不关闭软件的情况下进行更新，不需要重启。因为系统通过inode号码，识别运行中的文件，不通过文件名。更新的时候，新版文件以同样的文件名，生成一个新的inode，不会影响到运行中的文件。等到下一次运行这个软件的时候，文件名就自动指向新版文件，旧版文件的inode则被回收。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://wenyiqingnian.xyz/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://wenyiqingnian.xyz/tags/linux/"}]},{"title":"Docker入门","slug":"Docker入门","date":"2018-05-30T07:56:50.000Z","updated":"2018-06-02T08:22:02.760Z","comments":true,"path":"2018/05/30/Docker入门/","link":"","permalink":"http://wenyiqingnian.xyz/2018/05/30/Docker入门/","excerpt":"","text":"Docker是目前最火的Linux容器解决方案，真正做到一劳永逸的解决环境配置和依赖问题，而且可以方便的修改、分享，版本管理，本篇文章摘选自 阮一峰的博客：Docker 入门教程 一、环境配置的难题软件开发最大的麻烦事之一，就是环境配置。用户计算机的环境都不相同，你怎么知道自家的软件，能在那些机器跑起来？ 用户必须保证两件事：操作系统的设置，各种库和组件的安装。只有它们都正确，软件才能运行。举例来说，安装一个 Python 应用，计算机必须有 Python 引擎，还必须有各种依赖，可能还要配置环境变量。 如果某些老旧的模块与当前环境不兼容，那就麻烦了。开发者常常会说：”它在我的机器可以跑了”（It works on my machine），言下之意就是，其他机器很可能跑不了。 环境配置如此麻烦，换一台机器，就要重来一次，旷日费时。很多人想到，能不能从根本上解决问题，软件可以带环境安装？也就是说，安装的时候，把原始环境一模一样地复制过来。 二、虚拟机虚拟机（virtual machine）就是带环境安装的一种解决方案。它可以在一种操作系统里面运行另一种操作系统，比如在 Windows 系统里面运行 Linux 系统。应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。 虽然用户可以通过虚拟机还原软件的原始环境。但是，这个方案有几个缺点。 （1）资源占用多 虚拟机会独占一部分内存和硬盘空间。它运行的时候，其他程序就不能使用这些资源了。哪怕虚拟机里面的应用程序，真正使用的内存只有 1MB，虚拟机依然需要几百 MB 的内存才能运行。 （2）冗余步骤多 虚拟机是完整的操作系统，一些系统级别的操作步骤，往往无法跳过，比如用户登录。 （3）启动慢 启动操作系统需要多久，启动虚拟机就需要多久。可能要等几分钟，应用程序才能真正运行。 三、Linux 容器由于虚拟机存在这些缺点，Linux 发展出了另一种虚拟化技术：Linux 容器（Linux Containers，缩写为 LXC）。 Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离。或者说，在正常进程的外面套了一个保护层。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。 由于容器是进程级别的，相比虚拟机有很多优势。 （1）启动快 容器里面的应用，直接就是底层系统的一个进程，而不是虚拟机内部的进程。所以，启动容器相当于启动本机的一个进程，而不是启动一个操作系统，速度就快很多。 （2）资源占用少 容器只占用需要的资源，不占用那些没有用到的资源；虚拟机由于是完整的操作系统，不可避免要占用所有资源。另外，多个容器可以共享资源，虚拟机都是独享资源。 （3）体积小 容器只要包含用到的组件即可，而虚拟机是整个操作系统的打包，所以容器文件比虚拟机文件要小很多。 总之，容器有点像轻量级的虚拟机，能够提供虚拟化的环境，但是成本开销小得多。 四、Docker 是什么？Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。它是目前最流行的 Linux 容器解决方案。 Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。 总体来说，Docker 的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。 五、Docker 的用途Docker 的主要用途，目前有三大类。 （1）提供一次性的环境。比如，本地测试他人的软件、持续集成的时候提供单元测试和构建的环境。 （2）提供弹性的云服务。因为 Docker 容器可以随开随关，很适合动态扩容和缩容。 （3）组建微服务架构。通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构。 六、Docker 的安装Docker 是一个开源的商业产品，有两个版本：社区版（Community Edition，缩写为 CE）和企业版（Enterprise Edition，缩写为 EE）。企业版包含了一些收费服务，个人开发者一般用不到。下面的介绍都针对社区版。 Docker CE 的安装请参考官方文档。 MacWindowsUbuntu其他 Linux 发行版安装完成后，运行下面的命令，验证是否安装成功。 123$ docker version# 或者$ docker info Docker 需要用户具有 sudo 权限，为了避免每次命令都输入sudo，可以把用户加入 Docker 用户组（官方文档）。 1$ sudo usermod -aG docker $USER Docker 是服务器—-客户端架构。命令行运行docker命令的时候，需要本机有 Docker 服务。如果这项服务没有启动，可以用下面的命令启动（官方文档）。 12345# service 命令的用法$ sudo service docker start# systemctl 命令的用法$ sudo systemctl start docker 六、image 文件Docker 把应用程序及其依赖，打包在 image 文件里面。只有通过这个文件，才能生成 Docker 容器。image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。 image 是二进制文件。实际开发中，一个 image 文件往往通过继承另一个 image 文件，加上一些个性化设置而生成。举例来说，你可以在 Ubuntu 的 image 基础上，往里面加入 Apache 服务器，形成你的 image。 12345# 列出本机的所有 image 文件。$ docker image ls# 删除 image 文件$ docker image rm [imageName] image 文件是通用的，一台机器的 image 文件拷贝到另一台机器，照样可以使用。一般来说，为了节省时间，我们应该尽量使用别人制作好的 image 文件，而不是自己制作。即使要定制，也应该基于别人的 image 文件进行加工，而不是从零开始制作。 为了方便共享，image 文件制作完成后，可以上传到网上的仓库。Docker 的官方仓库 Docker Hub 是最重要、最常用的 image 仓库。此外，出售自己制作的 image 文件也是可以的。 七、实例：hello world下面，我们通过最简单的 image 文件”hello world”，感受一下 Docker。 需要说明的是，国内连接 Docker 的官方仓库很慢，还会断线，需要将默认仓库改成国内的镜像网站，具体的修改方法在下一篇文章的第一节。有需要的朋友，可以先看一下。 首先，运行下面的命令，将 image 文件从仓库抓取到本地。 $ docker image pull library/hello-world上面代码中，docker image pull是抓取 image 文件的命令。library/hello-world是 image 文件在仓库里面的位置，其中library是 image 文件所在的组，hello-world是 image 文件的名字。 由于 Docker 官方提供的 image 文件，都放在library组里面，所以它的是默认组，可以省略。因此，上面的命令可以写成下面这样。 $ docker image pull hello-world抓取成功以后，就可以在本机看到这个 image 文件了。 $ docker image ls现在，运行这个 image 文件。 $ docker container run hello-worlddocker container run命令会从 image 文件，生成一个正在运行的容器实例。 注意，docker container run命令具有自动抓取 image 文件的功能。如果发现本地没有指定的 image 文件，就会从仓库自动抓取。因此，前面的docker image pull命令并不是必需的步骤。 如果运行成功，你会在屏幕上读到下面的输出。 123456$ docker container run hello-worldHello from Docker!This message shows that your installation appears to be working correctly.... ... 输出这段提示以后，hello world就会停止运行，容器自动终止。 有些容器不会自动终止，因为提供的是服务。比如，安装运行 Ubuntu 的 image，就可以在命令行体验 Ubuntu 系统。 $ docker container run -it ubuntu bash对于那些不会自动终止的容器，必须使用docker container kill 命令手动终止。 $ docker container kill [containID] 八、容器文件image 文件生成的容器实例，本身也是一个文件，称为容器文件。也就是说，一旦容器生成，就会同时存在两个文件： image 文件和容器文件。而且关闭容器并不会删除容器文件，只是容器停止运行而已。 12345# 列出本机正在运行的容器$ docker container ls# 列出本机所有容器，包括终止运行的容器$ docker container ls --all 上面命令的输出结果之中，包括容器的 ID。很多地方都需要提供这个 ID，比如上一节终止容器运行的docker container kill命令。 终止运行的容器文件，依然会占据硬盘空间，可以使用docker container rm命令删除。 $ docker container rm [containerID]运行上面的命令之后，再使用docker container ls --all命令，就会发现被删除的容器文件已经消失了。 九、Dockerfile 文件学会使用 image 文件以后，接下来的问题就是，如何可以生成 image 文件？如果你要推广自己的软件，势必要自己制作 image 文件。 这就需要用到 Dockerfile 文件。它是一个文本文件，用来配置 image。Docker 根据 该文件生成二进制的 image 文件。 下面通过一个实例，演示如何编写 Dockerfile 文件。 十、实例：制作自己的 Docker 容器下面我以 koa-demos 项目为例，介绍怎么写 Dockerfile 文件，实现让用户在 Docker 容器里面运行 Koa 框架。 作为准备工作，请先下载源码。 12$ git clone https://github.com/ruanyf/koa-demos.git$ cd koa-demos 10.1 编写 Dockerfile 文件首先，在项目的根目录下，新建一个文本文件.dockerignore，写入下面的内容。 123.gitnode_modulesnpm-debug.log 上面代码表示，这三个路径要排除，不要打包进入 image 文件。如果你没有路径要排除，这个文件可以不新建。 然后，在项目的根目录下，新建一个文本文件 Dockerfile，写入下面的内容。 12345FROM node:8.4COPY . /appWORKDIR /appRUN npm install --registry=https://registry.npm.taobao.orgEXPOSE 3000 上面代码一共五行，含义如下。 FROM node:8.4:该 image 文件继承官方的 node image，冒号表示标签，这里标签是8.4，即8.4版本的 node。 COPY . /app：将当前目录下的所有文件（除了.dockerignore排除的路径），都拷贝进入 image 文件的/app目录。 WORKDIR /app：指定接下来的工作路径为/app。 RUN npm install：在/app目录下，运行npm install命令安装依赖。注意，安装后所有的依赖，都将打包进入 image 文件。EXPOSE 3000：将容器 3000 端口暴露出来， 允许外部连接这个端口。 10.2 创建 image 文件有了 Dockerfile 文件以后，就可以使用docker image build命令创建 image 文件了。 123$ docker image build -t koa-demo # 或者$ docker image build -t koa-demo:0.0.1 . 上面代码中，-t参数用来指定 image 文件的名字，后面还可以用冒号指定标签。如果不指定，默认的标签就是latest。最后的那个点表示 Dockerfile 文件所在的路径，上例是当前路径，所以是一个点。 如果运行成功，就可以看到新生成的 image 文件koa-demo了。 $ docker image ls 10.3 生成容器docker container run命令会从 image 文件生成容器。 123$ docker container run -p 8000:3000 -it koa-demo /bin/bash# 或者$ docker container run -p 8000:3000 -it koa-demo:0.0.1 /bin/bash 上面命令的各个参数含义如下： -p参数：容器的 3000 端口映射到本机的 8000 端口。 -it参数：容器的 Shell 映射到当前的 Shell，然后你在本机窗口输入的命令，就会传入容器。 koa-demo:0.0.1：image 文件的名字（如果有标签，还需要提供标签，默认是 latest 标签）。 /bin/bash：容器启动以后，内部第一个执行的命令。这里是启动 Bash，保证用户可以使用 Shell。如果一切正常，运行上面的命令以后，就会返回一个命令行提示符。 root@66d80f4aaf1e:/app#这表示你已经在容器里面了，返回的提示符就是容器内部的 Shell 提示符。执行下面的命令。 root@66d80f4aaf1e:/app# node demos/01.js这时，Koa 框架已经运行起来了。打开本机的浏览器，访问 http://127.0.0.1:8000，网页显示&quot;Not Found”，这是因为这个 demo 没有写路由。 这个例子中，Node 进程运行在 Docker 容器的虚拟环境里面，进程接触到的文件系统和网络接口都是虚拟的，与本机的文件系统和网络接口是隔离的，因此需要定义容器与物理机的端口映射（map）。 现在，在容器的命令行，按下 Ctrl + c 停止 Node 进程，然后按下 Ctrl + d （或者输入 exit）退出容器。此外，也可以用docker container kill终止容器运行。 12345678910111213# 在本机的另一个终端窗口，查出容器的 ID$ docker container ls# 停止指定的容器运行$ docker container kill [containerID]容器停止运行之后，并不会消失，用下面的命令删除容器文件。# 查出容器的 ID$ docker container ls --all# 删除指定的容器文件$ docker container rm [containerID] 也可以使用docker container run命令的--rm参数，在容器终止运行后自动删除容器文件。 1$ docker container run --rm -p 8000:3000 -it koa-demo /bin/bash 10.4 CMD 命令上一节的例子里面，容器启动以后，需要手动输入命令node demos/01.js。我们可以把这个命令写在 Dockerfile 里面，这样容器启动以后，这个命令就已经执行了，不用再手动输入了。 123456FROM node:8.4COPY . /appWORKDIR /appRUN npm install --registry=https://registry.npm.taobao.orgEXPOSE 3000CMD node demos/01.js 上面的 Dockerfile 里面，多了最后一行CMD node demos/01.js，它表示容器启动后自动执行node demos/01.js。 你可能会问，RUN命令与CMD命令的区别在哪里？简单说，RUN命令在 image 文件的构建阶段执行，执行结果都会打包进入 image 文件；CMD命令则是在容器启动后执行。另外，一个 Dockerfile 可以包含多个RUN命令，但是只能有一个CMD命令。 注意，指定了CMD命令以后，docker container run命令就不能附加命令了（比如前面的/bin/bash），否则它会覆盖CMD命令。现在，启动容器可以使用下面的命令。 1$ docker container run --rm -p 8000:3000 -it koa-demo:0.0.1 10.5 发布 image 文件容器运行成功后，就确认了 image 文件的有效性。这时，我们就可以考虑把 image 文件分享到网上，让其他人使用。 首先，去 cloud.docker.com 或 cloud.docker.com 注册一个账户。然后，用下面的命令登录。 $ docker login接着，为本地的 image 标注用户名和版本。 123$ docker image tag [imageName] [username]/[repository]:[tag]# 实例$ docker image tag koa-demos:0.0.1 ruanyf/koa-demos:0.0.1 也可以不标注用户名，重新构建一下 image 文件。 1$ docker image build -t [username]/[repository]:[tag] . 最后，发布 image 文件。 1$ docker image push [username]/[repository]:[tag] 发布成功以后，登录 hub.docker.com，就可以看到已经发布的 image 文件。 十一、其他有用的命令docker 的主要用法就是上面这些，此外还有几个命令，也非常有用。 （1）docker container start 前面的docker container run命令是新建容器，每运行一次，就会新建一个容器。同样的命令运行两次，就会生成两个一模一样的容器文件。如果希望重复使用容器，就要使用docker container start命令，它用来启动已经生成、已经停止运行的容器文件。 $ docker container start [containerID] （2）docker container stop 前面的docker container kill命令终止容器运行，相当于向容器里面的主进程发出 SIGKILL 信号。而docker container stop命令也是用来终止容器运行，相当于向容器里面的主进程发出 SIGTERM 信号，然后过一段时间再发出 SIGKILL 信号。 $ bash container stop [containerID]这两个信号的差别是，应用程序收到 SIGTERM 信号以后，可以自行进行收尾清理工作，但也可以不理会这个信号。如果收到 SIGKILL 信号，就会强行立即终止，那些正在进行中的操作会全部丢失。 （3）docker container logs docker container logs命令用来查看 docker 容器的输出，即容器里面 Shell 的标准输出。如果docker run命令运行容器的时候，没有使用-it参数，就要用这个命令查看输出。 $ docker container logs [containerID] （4）docker container exec docker container exec命令用于进入一个正在运行的 docker 容器。如果docker run命令运行容器的时候，没有使用-it参数，就要用这个命令进入容器。一旦进入了容器，就可以在容器的 Shell 执行命令了。 1$ docker container exec -it [containerID] /bin/bash （5）docker container cp docker container cp命令用于从正在运行的 Docker 容器里面，将文件拷贝到本机。下面是拷贝到当前目录的写法。 1$ docker container cp [containID]:[/path/to/file] .","categories":[{"name":"容器技术","slug":"容器技术","permalink":"http://wenyiqingnian.xyz/categories/容器技术/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://wenyiqingnian.xyz/tags/docker/"},{"name":"容器","slug":"容器","permalink":"http://wenyiqingnian.xyz/tags/容器/"}]},{"title":"Binder的设计架构","slug":"Binder的设计架构","date":"2018-05-29T11:20:50.000Z","updated":"2018-06-03T04:49:58.141Z","comments":true,"path":"2018/05/29/Binder的设计架构/","link":"","permalink":"http://wenyiqingnian.xyz/2018/05/29/Binder的设计架构/","excerpt":"","text":"一、为什么选择Binderandroid 是基于Linux开发的移动端操作系统，而传统的Linux已有的IPC机制，包括管道，消息队列、共享内存、信号量、socket为什么不适合安卓，而非要采用Binder？ 1.拷贝次数SocketLinux中除了Binder之外唯一一个C/S架构的IPC，为了兼容本地操作系统中的进程间通讯和互联网中的远程主机之间的通讯，Socket采用的是更加通用型的架构，一般的socket通讯流程如下 客户端通过 int socket(int domain, int type, int protocol); 函数创建了一个socket，返回了该套接字的文件描述符 通过bind函数 绑定了该socket的端口号，监听该端口 循环检查该端口是否有消息，如果有消息则fork出子进程去处理 使用read（）读取客户端发送的消息数据，通过write（）处理消息并发送给客户端 客户端也要创建socket 客户端连接到制定IP和端口的服务端socket 使用write向服务端写数据，用read 从服务端度数据可以看到，一次标准的socket通讯步骤繁琐，计算机内的进程间通讯，如果采用socket，不可避免的会先write()将文件写到内核缓冲区，再read() 将文件读取到用户缓冲区，涉及两次拷贝。如果是网络传输，一次通讯过程可能会涉及三到四次拷贝，多次切换上下文。匿名管道 半双工，数据流动方向是单向的，读写端都是固定的 只能用于父子进程间的通讯 属于一种特殊的文件，只存在内存中 数据传递方式仍然采用read 和 write ，先从发送方缓冲区拷贝到内核，再从内核缓冲区拷贝到接收方 拷贝次数 两次 命名管道可以在无关进程之间交流数据，它有些类似用文件的方式在进城之间传递数据，但该文件又同时具有管道的特点，它允许所有知道其FIFO接口的进程参与读写，遵循先入先出的原则。 拷贝次数 2次拷贝 消息队列 面向记录，消息队列中的消息具有特定格式和优先级 独立于进程，就算进程被杀死，队列中的消息也不会被清除 可以实现消息的独立查询 消息队列同样需要两次拷贝，进程A 拷贝消息到消息队列，消息队列从队列中取消息 将其拷贝到进程B共享内存指的是两个或以上进程共享的一块内存区域 速度最快 因为是直接读取，不涉及拷贝 多个进程需要同时读取，所以需要同步机制，一般配合信号量使用 BinderBinder是Android系统中广泛采用的C/S架构IPC通讯方式，它只需要一次内存拷贝。Binder的一次通讯过程：通过 BinderProxy 将我们的请求参数发送给 ServiceManager，通过共享内存的方式使用内核方法 copy_from_user() 将我们的参数先拷贝到内核空间，这时我们的客户端进入等待状态，然后 Binder 驱动向服务端的 todo 队列里面插入一条事务，执行完之后把执行结果通过 copy_to_user()将内核的结果拷贝到用户空间（这里只是执行了拷贝命令，并没有拷贝数据，binder只进行一次拷贝），唤醒等待的客户端并把结果响应回来，这样就完成了一次通讯。 关于消息传递效率 参考下表 IPC 特征 拷贝次数 特点 共享内存 速度快，但是控制复杂，要解决同步问题 0 极少用 Binder 简单 通用 安全 1 Android常用、性能高 Socket A缓冲区-&gt;内核缓冲区-&gt;B缓冲区 2 Socket作为通用接口，开销大，传输性能低，一般用作跨网络或者进程间的低速IPC 2.安全性Android作为一个开放式，拥有众多开发者的的平台，应用程序的来源广泛，确保智能终端的安全是非常重要的。终端用户不希望从网上下载的程序在不知情的情况下偷窥隐私数据，连接无线网络，长期操作底层设备导致电池很快耗尽等等。传统IPC没有任何安全措施，完全依赖上层协议来确保。 传统IPC的接收方无法获得对方进程可靠的UID/PID（用户ID/进程ID），从而无法鉴别对方身份。Android为每个安装好的应用程序分配了自己的UID，故进程的UID是鉴别进程身份的重要标志。 使用传统IPC只能由用户在数据包里填入UID/PID，但这样不可靠，容易被恶意程序利用。可靠的身份标记只有由IPC机制本身在内核中添加。其次传统IPC访问接入点是开放的，无法建立私有通道。比如命名管道的名称，system V的键值，socket的ip地址或文件名都是开放的，只要知道这些接入点的程序都可以和对端建立连接，不管怎样都无法阻止恶意程序通过猜测接收方地址获得连接。 基于以上原因，Android需要建立一套新的IPC机制来满足系统对通信方式，传输性能和安全性的要求，这就是Binder。Binder基于Client-Server通信模式，传输过程只需一次拷贝，为发送发添加UID/PID身份，既支持实名Binder也支持匿名Binder，安全性高。 二、 Binder 的面向对象思想Binder可以看做是server端提供某个功能的访问接入点，client通过访问该接入点获得server的服务，但和其他ipc不同的是，binder采用一种面向对象的思想来设计该入口。 Binder的实体是位于server中的对象，它实现了一系列方法用以访问server的服务，有点类似于类中的成员函数，而client中拿到的其实是该binder对象的引用 client —&gt; binder引用—-&gt;Binder—-&gt;server 面向对象思想的引入将进程间通信转化为通过对某个Binder对象的引用调用该对象的方法，而其独特之处在于Binder对象是一个可以跨进程引用的对象，它的实体位于一个进程中，而它的引用却遍布于系统的各个进程之中。这个引用和java里引用一样既可以是强类型，也可以是弱类型，而且可以从一个进程传给其它进程，让大家都能访问同一Server，就象将一个对象或引用赋值给另一个引用一样。Binder模糊了进程边界，淡化了进程间通信过程，整个系统仿佛运行于同一个面向对象的程序之中。形形色色的Binder对象以及星罗棋布的引用仿佛粘接各个应用程序的胶水，这也是Binder在英文里的原意。 当然面向对象只是针对应用程序而言，对于Binder驱动和内核其它模块一样使用C语言实现，没有类和对象的概念。Binder驱动为面向对象的进程间通信提供底层支持。 三、Binder的通讯模型一个完整的Binder驱动包含四个角色 Server、Client、ServiceManager、Binder驱动。 server client smg 运行在用户空间，Binder驱动运行在内和空间。 1.Binder驱动实现方式类似硬件驱动，工作在内核态123456789static const struct file_operations binder_fops = &#123; .owner = THIS_MODULE, .poll = binder_poll, .unlocked_ioctl = binder_ioctl, .mmap = binder_mmap, .open = binder_open, .flush = binder_flush, .release = binder_release,&#125;; 这是binder驱动的file_operation结构体，可以看到binder驱动为应用层提供了open(),mmap(),poll(),ioctl()等标准的文件操作【注1】，open()负责打开驱动，mmap()负责对binder做内核空间向用户空间的地址映射，ioctl()负责binder协议的通信。Binder驱动负责在内核中创建对应的Binder实体节点，为client或者server进程创建对该实体节点的引用，负责进程之间Binder通信的建立，Binder在进程之间传递，Binder引用计数管理，数据包在进程之间的传递等一系列操作的底层支持，驱动和应用程序之间定义了一套标准的接口协议，主要功能由ioctl()【注2】来实现，不提供read（），write接口。（因为ioctl是更为高灵活的操作文件的接口，自动遵循先写后读的顺序，可以满足同步请求） 注释1：设备驱动程序是操作系统内核和机器硬件之间的接口。设备驱动程序为应用程序屏蔽了硬件的细节，这样在应用程序看来，硬件设备只是一个设备文件，应用程序可以象操作普通文件一样对硬件设备进行操作。设备驱动程序是内核的一部分，它完成以下的功能:1、对设备初始化和释放；2、把数据从内核传送到硬件和从硬件读取数据；3、读取应用程序传送给设备文件的数据和回送应用程序请求的数据；4、检测和处理设备出现的错误。 注释2： ioctl()函数是驱动中对设备的I/O通道进行管理的函数，ioctl函数里面都实现了多个的对硬件的操作步骤，将他们综合起来完成一个任务，而不是单一的某个write/read操作，通过应用层传入的命令来调用相应的操作。 ServiceManagerServiceManger有点类似于路由器，使得client端可以通过字符串形式的binder名来获取server端binder的引用，它提供注册和查询服务。server端像smg注册服务，client从smg获取服务。 server创建了一个binder实体，为其取一个容易记住的名字，然后将这个binder实体 连同名字通过binder驱动发送给smg，通知smg注册一个服务，以及该服务的名字，binder驱动会为这个穿过进程边际的binder创建一个位于内核的实体节点，以及smg对该实体节点的引用，然后将名字以及新建的引用打包发送给serviceManager，smg会在它的svcinfo表中添加该信息。该svcinfo便是服务查询表。","categories":[{"name":"Android","slug":"Android","permalink":"http://wenyiqingnian.xyz/categories/Android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://wenyiqingnian.xyz/tags/android/"},{"name":"Binder","slug":"Binder","permalink":"http://wenyiqingnian.xyz/tags/Binder/"}]},{"title":"JAVA的垃圾回收策略（二）","slug":"JAVA的垃圾回收策略（二）","date":"2018-05-23T08:56:50.000Z","updated":"2018-06-02T08:11:08.499Z","comments":true,"path":"2018/05/23/JAVA的垃圾回收策略（二）/","link":"","permalink":"http://wenyiqingnian.xyz/2018/05/23/JAVA的垃圾回收策略（二）/","excerpt":"","text":"上文说到了一个java对象的生命周期以及生存位置本文主要讲 jvm虚拟机如何判定一个对象是否是垃圾，以及以何种算法回收垃圾。 GC的工作流程1. 判定那些对象已成为垃圾jvm一般有两种方法判断对象是否成为垃圾 1. 引用标记算法1.流程 给每一个对象都增加一个引用计数器 每次对象新增一个引用的时候，该计数器+1 当该引用对象失效（比如超出了作用域）==【注1】==，该引用计数器-1 当该对象的引用计数器为1时，表明该对象不可用，可作为垃圾回收了。 注1：作用域的概念，上文其实已经说过了，见JAVA垃圾回收机制。当在方法内创建了一个引用变量并指向它引用的对象的时候，引用的对象会在方法执行完后仍然存活在堆内存上，只是引用变量会随方法一起出栈销毁而已，见下面的例子。 123456789void fun()&#123;...Persion p = new Person();&#125;/***方法之外，引用变量P就消失了，因为引用变量是存放在*方法栈中的，所以方法执行完毕，p便随着方法栈一起出*栈，但是因为这中间调用了new 关键字,其创建的person对象会一直存放在堆内存中等待**被GC，此时person对象，就是超出了作用域的对象。*/ 123graph LRCLASS_A--&gt;CLASS_BCLASS_B--&gt;CLASS_A 2. 引用标记算法的优缺点 优点：算法简单，执行速度快，不需要长时间中断应用程序的执行 缺陷：无法解决循环引用问题（A引用B，B引用A，此时引用计数器永远无法置0）。2. GC_ROOT 可达性算法1. 原理 以GC root作为根节点 ==（gcroot具体包含那些对象下面会详细解释）==,向下搜寻所有对象 如果可以走到该对象，就建立一个该对象和GCTROOT之间的引用链。 从根节点开始，生成对象引用树，不可达的对象，会被判断为垃圾由GC判断是否回收 123456789101112graph LRGCROOT--&gt;CLASS_AGCROOT--&gt;CLASS_BGCROOT--&gt;CLASS_CGCROOT--&gt;CLASS_ECLASS_A--&gt;CLASS_DCLASS_A--&gt;CLASS_FCLASS_B--&gt;CLASS_FCLASS_B--&gt;CLASS_GCLASS_H--&gt;CLASS_JCLASS_J--&gt;CLASS_HCLASS_E--&gt;CLASS_K 上图的对象h和对象j 就是不可达的引用，但是彼此持有对方的引用，如果用引用计数算法，该对象是无法被回收的，gcroot算法，他们是不可达的，会随时被gc回收。 3.关于回收的一些其他问题当对象被标记为不可达的时候，gc并不会立刻启动回收程序，而是再使用两次标记算法来区分何时回收。在GC启动回收程序的时候，为了保证引用状态不变，系统会暂停所有应用进程（stopt the world ），这个时间很短，反应在UI上就是UI卡顿了一下，所以安卓应用要十分注意合理控制好内存回收，不要频繁处罚GC，不然体验会十分糟糕。 二次标记算法:1.如果对象与GC Root没有连接的引用链，就会被第一次标记，随后判定该对象是否有必要执行finalize()方法 2.如果有必要执行finalize()方法，则这个对象就会被放到F-Queue的队列中，稍后由虚拟机建立低优先级的Finalizer线程去执行，但并不承诺等待它运行结束（对象类中能够重写finalize()方法进行自救，但系统最多只能执行一次） 3.如果没必要执行finalize()方法，则第二次标记 2. 通过特定算法回收垃圾主要包括以下四种算法 12341、标记清除算法2、算法算法3、标记整理算法4、分代回收算法 1. 标记清除算法两步走 标记 标记出无用的对象 清除 清除掉对象的空间 可以看到 优缺点很明显 123缺点：容易造成内存碎片，当下次申请大内存的时候，可能找不到连续的内存给其使用，会频繁出发gc，优点：是算法比较简单。 因为标记无用对象耗时，可以看出 标记清除算法比较适合于 垃圾少，存活对象多的情况，可以减少标记次数。在分代回收算法中，它一般应用在老年代（对象存活率高，需要回收的少） 2. 复制算法（也被成为拷贝回收算法）此方法将内存按容量分为两块，例如A、B两块，每次只使用其中的一块，当要进行回收操作时，将A中还存活的对象复制到B块中（假设上次使用A），然后对A中所有对象清空就又构成一个完整的内存块。这种方法就避免了标记清除的内存碎片问题。 123优点：不会产生内存碎片缺点： 会浪费内存，因为不管A块中有多少存活对象，都只能使用内存的一半，AB块中始终有一块为空，属于用空间换时间。 分代回收法中新生代的部分，使用的是该算法。 适合存活对象少 回收对象多的情况，因为存活对象多复制的过程就长一些，算法效率会受影响。 3. 标记整理算法解决了上述两种算法的缺点，但也带来了新的缺点，就是算法效率不够高。 1231. 标记存活对象2. 移动对象到左上角3. 将其他空间全部回收 123优点： 不会产生内存碎片 不会造成空间使用浪费缺点：标记的过程导致其效率不如复制算法，移动的过程，导致其效率不如标记算法。 适合存活对象多 4. 分代回收算法该算法其实是上述三种算法的组合，因为上述三种算法都有其适用的适用情景，不可能适用所有情况，分代回收算法就是根据jvm里不同对象的存活特性来组合使用上述三种算法。 jvm按照对象生命周期将内存划分为两个区域。 新生代 新生代会产生大量的临时对象。这些对象 朝生夕死。存活时间短，经常需要回收，所以采用拷贝回收算法。在新生代的gc，称之为minor gc。 老年代 一般是生命周期长的对象，回收频率很低，只有当老年代内存占满了之后，才会触发一次full gc，或称之为（major gc）。 内存的具体划分 可以看到 新生代又被分为Eden 区 和 s1，s2区。s1 s2是为了拷贝算法划分的乒乓区域。他们大小是相同的。 2. 分代回收算法的具体回收过程 新生对象全部在Eden区域活动，当Eden区域满了之后，会触发一次minor gc 将Eden区域中还能用的的对象拷贝到From区域。 此时 Eden区域的空间被清空，存活对象在From区。 当From区域满了之后，会再次触发monor gc，将Eden和From区域中还可用的对象拷贝到To区域中。 此时 Eden 和From区的空间被清空。 当To的空间满了之后，会再次触发minor gc，此时会将Eden 和To 空间中还存活的对象拷贝到From区。Eden 和To space被清空。 在多次minor gc之后，有些对象会一直在from和to 区域之间来回拷贝，此时会被算法标注为老年代对象，gc会将该对象从新生代直接拷贝到老年代。JVM虚拟机默认的反复拷贝次数为==15次==。如果对象在From 到 to区域中反复拷贝了15次，就会被划分为老年代。 对象进入老年代之后，当老年代内存区域也满了，便会触发一次Full gc， 此时使用的算法是标记算法和标记整理算法。 为什么老年代的gc 不使用拷贝算法，因为老年代中的对象大多是存活率高的对象，使用拷贝算法要创建一个很大的新内存空间来做拷贝，这样很浪费资源。为什么不只使用标记算法，因为这样会导致内存碎片。使用标记清除算法，会将存活对象做地址移动，都集中在一块连续地址空间中，防止产生内存碎片。 所monor gc的时候，是用空间换时间，因为该gc发生频繁，效率是首要考虑的问题。 而full gc的时候，腾出空间更重要，所以选择用时间（使用标注整理算法）换空间。 3. 新生代老年代的内存划分比新生代：老年代 2：1 新生代中 Eden : s1 : s2 = 8 : 1 : 1 3. GC_ROOT要记住一个概念，选gcroot，就是要以这些当前活跃的gcroot对象为根去遍历所有引用关系，能遍历到的就是存活的，遍历不到的认为死去，所以选gcroot，本质是找到==所有存活的对象==，把其他空间认定为无用去清除掉。所以gcroot必须具备两个性质 必须存活 必须有其他引用（因为要以它自己去遍历引用关系） jvm 运行时内存 所以“GC roots”，或者说tracing GC的“根集合”，就是一组必须==活跃==的==引用==。具体包括以下几种： 1234567891. Class 由System Class Loader/Boot Class Loader加载的类，类似于java.util.*包下的类，因为它一定是贯穿于整个生命周期的，可以以此为根遍历出去找到其他引用的类。被引用到的就一定是存活的。2. Thread 对象，已激活但是未结束的线程对象；3. Stack Local 栈中的对象。每个线程都会分配一个栈，栈中的局部变量或者参数的引用都是GC root，因为仍在栈中，表明方法还没执行完，对象仍存活，（执行后的方法会出栈，就不满足存活条件了），同时是引用对象。4.JNI Local JNI中的局部变量和参数引用的对象；可能在JNI中定义的，也可能在虚拟机中定义5. JNI Global JNI中的全局变量引用的对象；同上6. Monitor Used 用于保证同步的对象，例如wait()，notify()中使用的对象、锁等。7. Held by JVM JVM持有的对象。JVM为了特殊用途保留的对象，它与JVM的具体实现有关。比如有System Class Loader, 一些Exceptions对象，和一些其它的ClassLoader。对于这些类，JVM也没有过多的信息。8. 静态数据结构指向对象堆的引用。 关于1 2 我举几个具体例子来说明一下： 123456789101112131415161718192021222324252627//1.由系统类加载器加载的类public class ServiceManager extends Service &#123; public Person p = new Person();&#125;这里不确切，但是大致可以表明意思，安卓ServiceManager贯穿整个应用生命周期，它里面持有Persion对象的引用，这个ServiceManager对象就是gcroot 它持有的person对象永远不会被释放。2. //Thred Localpublic class A&#123; void main()&#123; Thread t = new Thread(new Runnable() &#123; @Override public void run() &#123; B b = new B(); &#125; &#125;); t.start(); &#125; &#125;t 属于gcroot 如果不停止thread t永远不会被回收，它持有的b 也不会被回收。3. ==注意，是一组必须活跃的引用，不是对象==Tracing GC的根本思路就是：给定一个集合的引用作为根出发，通过引用关系遍历对象图，能被遍历到的（可到达的）对象就被判定为存活，其余对象（也就是没有被遍历到的）就自然被判定为死亡。注意再注意：tracing GC的本质是==通过找出所有活对象来把其余空间认定为“无用”==，而不是==找出所有死掉的对象并回收它们占用的空间==。这里非常容易搞混淆！！GC roots这组引用是tracing GC的起点。 4 . 安卓的Dalvik虚拟机与jvm不同的地方1. 堆的结构不同 Dalvik虚拟机用来分配对象的堆划分为两部分，一部分叫做Active Heap，另一部分叫做Zygote Heap。为什么要划分为两个堆，是为了减少内存拷贝的过程。(5.0之后改为ART虚拟机，ART运行时堆划分为四个空间，分别是Image Space、Zygote Space、Allocation Space和Large Object Space) 123graph LRActiveHeapZygoteHeap 我们知道 安卓系统的父进程是Zygote进程，它在开机的过程中就为Android系统准备好了一个Dalvik虚拟机实例。 安卓的每一个应用程序都是一个独立的进程，都有自己独立的内存空间和虚拟机实例，如果在应用启动的时候都重新为其创建虚拟机实例，是十分消耗资源的，为了加快这个速度，dalvik虚拟机采用写时拷贝的方式，将Zygote进程在开机时就创建好的Dalvik虚拟机实例，复制到应用程序的进程中去，从而加快了Android应用程序进程的启动过程。 因为zygote进程作为核心进程，应用的虚拟机实例都是复制于它，在创建虚拟机实例的时候，要预先加载安卓系统的核心方法还有一些核心类，是重量级的进程。主要做了以下四件事情：12341. 创建了一个Dalvik虚拟机实例；2. 加载了Java核心类及其JNI方法；3. 为主线程的设置了一个JNI环境；4. 注册了Android核心类的JNI方法。 这些核心类可以与应用程序共享，所以说 zygote牺牲自己的启动时间，来提高应用的加载速度。 但拷贝仍然是很费时的操作，为了避免拷贝，dalvik将自己的堆分为两部分，事实上，Dalvik虚拟机的堆最初是只有一个的。也就是Zygote进程在启动过程中创建Dalvik虚拟机的时候，只有一个堆。但是当Zygote进程在fork第一个应用程序进程之前，会将已经使用了的那部分堆内存划分为一部分，还没有使用的堆内存划分为另外一部分。前者就称为Zygote堆，后者就称为Active堆。以后无论是Zygote进程，还是应用程序进程，当它们需要分配对象的时候，都在Active堆上进行。 zygote堆 zygote进程启动创建虚拟机的时候已经用了的那部分内存，主要存的是Zygote进程在启动过程中预加载的类、资源和对象 active堆 zygote启动创建虚拟机时尚未使用的堆内存。应用程序还有zygote进程创建对象都在该堆进行 这样就可以使得Zygote堆尽可能少地被执行写操作，因而就可以减少执行写时拷贝的操作，在zygote堆中存放的预加载的类、资源和对象可以在Zygote进程和应用程序进程中做到长期共享。这样既能减少拷贝操作，还能减少对内存的需求。 2.标记机制不同 虽然dalvik虚拟机也是用的标记-清除算法，但为了减少Stop_the_world 造成的停顿，采用的并行垃圾回收算法（Concurrent GC） 标记被分为两部分 第一步 只标记gcroot 引用的对象 第二步 标记被gcroot 引用对象所引用的其他对象例如，一个栈变量引了一个对象，而这个对象又通过成员变量引用了另外一个对象，那该被引用的对象也会同时标记为正在使用。这个标记被根集对象引用的对象的过程就是第二个子阶段。 注意 在Concurrent GC，第一个子阶段是不允许垃圾收集线程之外的线程运行的，但是第二个子阶段是允许的。不过，在第二个子阶段执行的过程中，如果一个线程修改了一个对象，那么该对象必须要记录起来，因为它很有可能引用了新的对象，或者引用了之前未引用过的对象。如果不这样做的话，那么就会导致被引用对象还在使用然而却被回收。这种情况出现在只进行部分垃圾收集的情况，这时候Card Table的作用就是用来记录非垃圾收集堆对象对垃圾收集堆对象的引用。 4. 由垃圾回收机制引申的内存泄漏问题所谓内存泄漏，其实就是该回收的对象无法回收，造成无法回收的原因就是它还被gcroot直接或者间接引用。 可以看几个内存泄漏的例子 静态类123456public class A &#123; public static Context instance; public A(Context context)&#123; this.instance = context; &#125;&#125; 静态成员变量 instance 持有一个context的引用，instance是gcroot，不会被回收，它持有的context对象也不会被回收，导致内存泄漏。 匿名内部类 创建HashMap的时候， 123public class A &#123; public static List&lt;HashMap&lt;String,Object&gt;&gt; list = new ArrayList&lt;&gt;();&#125; 属于匿名创建，list中会持有外部类的引用，list又是一个gcroot，导致类A 无法被回收，另一个常见的例子：123456789101112131415public class MainActivity extends AppCompatActivity &#123; private static MyHandler handler = new MyHandler(); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); &#125; public class MyHandler extends Handler &#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); &#125; &#125;&#125; 静态成员变量handler指向Myhandler()，是GCROOT成员，但MyHandler是内部类，持有外部类MainActivity的引用，会导致MainActivity 无法被回收。 线程未结束12345678910111213141516public class MainActivity extends MainActivity &#123; void foo()&#123; Thread t = new Thread(new Runnable() &#123; @Override public void run() &#123; Activity a = MainActivity.this; ... ... &#125; &#125;); t.start(); &#125; &#125; 如果t不执行完，Activity1就无法被回收。 JNI LOCAL GLOBAL reference这类对象一般发生在参与Jni交互的类中。 比如说很多close()相关的类，InputStream,OutputStream,Cursor,SqliteDatabase等。这些对象不止被Java代码中的引用持有，也会被虚拟机中的底层代码持有。在将持有它们的引用设置为null之前，要先将他们close()掉。还有一个特殊的类是Bitmap。在Android系统3.0之前，它的内存一部分在虚拟机中，一部分在虚拟机外。因此它的一部分内存不参与垃圾回收，需要我们主动调用recycler()才能回收。 动态链接库中的内存是用C/C++语言申请的，这些内存不受虚拟机的管辖。所以，so库中的数组，类等都有可能发生内存泄漏，使用的时候务必小心。","categories":[{"name":"java基础","slug":"java基础","permalink":"http://wenyiqingnian.xyz/categories/java基础/"}],"tags":[{"name":"java","slug":"java","permalink":"http://wenyiqingnian.xyz/tags/java/"},{"name":"垃圾回收","slug":"垃圾回收","permalink":"http://wenyiqingnian.xyz/tags/垃圾回收/"}]},{"title":"JAVA的垃圾回收策略","slug":"JAVA的垃圾回收策略","date":"2018-05-16T16:56:50.000Z","updated":"2018-05-16T16:56:24.408Z","comments":true,"path":"2018/05/17/JAVA的垃圾回收策略/","link":"","permalink":"http://wenyiqingnian.xyz/2018/05/17/JAVA的垃圾回收策略/","excerpt":"","text":"前言创建了一个对象，就意味着或早或晚，该对象都是需要 被释放掉的，只不过这个时间有长有短，对象从被new出来到被垃圾回收器回收，就是一个生命周期的完整过程，java的垃圾回收机制可以做到自动决定哪些对象是无用的从而被回收掉，无需使用者担心，但是不健壮的java代码会影响到回收算法对无效对象的识别，从而影响对象的生命周期，导致无法回收。为了弄清楚java的垃圾回收机制，有必要先搞懂下面这些概念。 java程序的生存空间： 堆与栈 堆：实例变量（成员变量）与对象的生存空间 栈：方法调用与局部变量的生存空间 注1：实例变量生命在对象内部，而不是方法内，塔代表每一个独立对象的“字段”，是存储在对象中的。 注2：局部变量生命在方法中，他们是暂时的，生命周期只限于方法被放入栈上的时间，也就是方法执行到结束的过程。 注3：方法的调用过程，是伴随方法栈入栈出栈的过程的，方法被调用，一个对应的方法堆栈块也就被放置到栈顶，这个堆栈块里除了存放局部变量和方法参数之外，还会存放方法的执行状态，包括方法执行的行数，当方法执行完毕之后，该方法堆栈块便会出栈。 如果是这样 1234567891011public static void main(String[] args)&#123; foo1();&#125;void bar()&#123;&#125;void foo2()&#123;&#125;void foo1()&#123; foo2();&#125; 方法foo1 调用了foo2 执行到调用时，会将foo2放在foo1()的栈顶上，foo1被压下去。 注4：非primitive（注5）的变量都只是对对象的引用而已，所以所有的局部变量，变量本身都是存放在方法栈空间的，当所指向的对象被实例化了，对象存放在堆空间。 注5：java的变量类型分为 primitive数据类型和 引用类型，primitive 主数据类型用来保存基本类型的值，包括整数、布尔和浮点数等，而对象引用保存的是对象的引用。 注6： 不管是实例变量还是局部变量，对象本身都是存放在堆上的 对象的创建 三部曲：声明、创建、赋值123Duck duck // 1.创建出新的引用变量duck给Duck类型= //3. 赋值该对象给引用变量new Duck(); //2. 创建该对象实例 调用new 方法，便创建了一个duck实例，这其中的过程其实是调用了类的构造方法。 注意 对象构造方法会先与对象实例被赋值给引用对象之前就执行。1234567891011public class People&#123; public People()&#123; System.out.println('people'); &#125;&#125;public class Person&#123; public static void main()&#123; People p = new People(); &#125;&#125; 会打印出people的log 对象的声明周期对象的生命周期是看对象的引用。如果还有引用，对象继续存活在堆上，如果没有引用了，对象就会被垃圾回收器回收。所以==对象的声明周期 要看引用变量的声明周期==，而引用变量的声明周期，又要看它是局部变量还是成员变量。 局部变量： 与方法声明周期同步，只活在该方法内，方法执行完毕，对象立即被释放，对其他程序和方法不可见。 成员变量： 与对象声明周期同步。如果对象活着，该成员变量也活着。关于局部变量，这里需要讲两个概念Life对象的堆栈块还在栈内，方法还没执行完，就还活着。活到方法执行完结束。 Scope局部变量的范围，只存在声明它的方法内，如果该方法调用了其他方法，则该变量仍然存活，只不过在执行调用方法的时候，该变量不在它的范围而已。 只要方法还没执行完，对象就不会死，但只有方法在栈顶，对象才是可用的。 变量的生命周期如何影响对象的生命周期？只要有活的引用，对象会一直活着，如果对某个对象的引用不在它的范围内，但该引用变量还是活的，则该对象也会活着，呆在堆内存中。如果对该对象的唯一引用没有了，对象便会回收 三种方法释放对象引用：12345678910// 方法执行完，引用便释放了void go()&#123; People p = new People();&#125;// 引用被赋值到别处People p = new People();p = new People(); //第一个对象会在此时被释放// 直接置空People p = new People();p =null; —待续 5.17 00:51","categories":[{"name":"java基础","slug":"java基础","permalink":"http://wenyiqingnian.xyz/categories/java基础/"}],"tags":[{"name":"java","slug":"java","permalink":"http://wenyiqingnian.xyz/tags/java/"},{"name":"垃圾回收","slug":"垃圾回收","permalink":"http://wenyiqingnian.xyz/tags/垃圾回收/"}]},{"title":"hexo+icarus","slug":"hexo+icarus","date":"2018-05-13T16:15:50.000Z","updated":"2018-05-24T03:40:05.312Z","comments":true,"path":"2018/05/14/hexo+icarus/","link":"","permalink":"http://wenyiqingnian.xyz/2018/05/14/hexo+icarus/","excerpt":"","text":"安装hexo1. 安装node2. 生成ssh公钥秘钥对 并且添加到github上3. 安装hexo1npm install -g hexo 4. 初始化hexo1hexo init hexo 5. 安装部署依赖文件进入hexo目录1npm install 6. 安装hexo-server1npm install hexo-server hexo-server 会创建本地服务器，你可以使用hexo s来在本地预览你的博客效果。 6. 生成hexo的目录结构1hexo generate 7. 配置_config.yml文件需要修改博客根目录的config文件，添加上你的github.io仓库地址，注意，你的ssh公钥此时应该已经添加到github上了 我的配置如下 1234deploy: type: git repository: https://github.com/QuincyJiang/QuincyJiang.github.io.git branch: master 8.目录结构以及写作流程1234567/scaffoldssource/themes.gitignore_config.ymlpackage.jsonpackage-lock.json public文件夹是每次hexo g 自动生成的网页静态代码 source中存放日志的原始md文件，每次写了新的文章，就需要将文章放置在该目录下，然后1hexo g 来生成静态网页代码，生成的代码会创建1/public 文件夹， 如果启用了 about tags categories等界面 也需要在source目录中创建对应的文件夹（about，tags，categories文件夹，内部放index.md文件，文件头以 123title: &quot;About&quot;layout: &quot;about&quot;--- 这种格式编写。 当文章写完并且已使用 1hexo g 生成public文件夹后，使用 123hexo sINFO Start processingINFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 在浏览器输入 1localhost:4000 来本地预览博客效果。 确认无误，使用 1hexo d 部署博客到github.io仓库。 主题配置下载主题克隆你喜欢的主题到/themes文件夹内。我使用的是icarus主题 自定义主题配置 修改根目录config文件，指定主题为icarus 1theme: icarus 进入themes/icarus/目录下,修改config文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101# Menusmenu: # 配置主页上方的分类项 如果需要开启 要在博客根目录的source 文件夹下创建对应的同名文件并防止index.md 上面已经说过了 Home: . Archives: archives Categories: categories Tags: tags About: about# Customizecustomize: logo: # 左上方小logo 将png文件放在主题目录下的css/image目录下 enabled: true width: 40 height: 40 url: images/logo.png profile: enabled: true # Whether to show profile bar fixed: true avatar: css/images/avatar.png gravatar: # Gravatar email address, if you enable Gravatar, your avatar config will be overriden author: QuincyJiang author_title: Coder &amp; FilmPlayer location: Guangzhou, China follow: https://github.com/QuincyJiang highlight: androidstudio # 代码高亮风格，需要md文件格式支持，在代码块外 要显示标注代码语言 比如 ···java public static void main()&#123; ... &#125; ... sidebar: right # sidebar position, options: left, right or leave it empty thumbnail: true # enable posts thumbnail, options: true, false favicon: css/images/avatar.png social_links: github: https://github.com/QuincyJiang weibo: https://weibo.com/2425393311/ photo: http://aquencyua11.lofter.com/ social_link_tooltip: true # enable the social link tooltip, options: true, false# Widgetswidgets: - recent_posts - category - archive - tag - tagcloud - links# Search 是否启用insight搜索search: insight: true # you need to install `hexo-generator-json-content` before using Insight Search swiftype: # enter swiftype install key here baidu: false # you need to disable other search engines to use Baidu search, options: true, false# Comment 是否开启评论功能 需要disqus账号comment: # disqus: https-quincyjiang-github-io duoshuo: # enter duoshuo shortname here youyan: # enter youyan uid here facebook: # enter true to enable isso: # enter the domain name of your own comment isso server eg. comments.example.com changyan: # please fill in `appid` and `conf` to enable appid: conf: gitment: owner: #QuincyJiang repo: #https://github.com/QuincyJiang/comments.git #Register an OAuth application, and you will get a client ID and a client secret. client_id: client_secret: livere: # enter livere uid here valine: # Valine Comment System https://github.com/xCss/Valine on: # enter true to enable appId: # enter the leancloud application appId here appKey: # enter the leancloud application appKey here notify: # enter true to enable &lt;Mail notifier&gt; https://github.com/xCss/Valine/wiki/Valine-%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E9%82%AE%E4%BB%B6%E6%8F%90%E9%86%92%E8%AE%BE%E7%BD%AE verify: # enter true to enable &lt;Validation code&gt; placeholder: Just Do It # enter the comment box placeholder # Shareshare: default # options: jiathis, bdshare, addtoany, default# Pluginsplugins: lightgallery: true # options: true, false justifiedgallery: true # options: true, false google_analytics: # enter the tracking ID for your Google Analytics google_site_verification: # enter Google site verification code baidu_analytics: # enter Baidu Analytics hash key mathjax: false # options: true, false# Miscellaneousmiscellaneous: open_graph: # see http://ogp.me fb_app_id: fb_admins: twitter_id: google_plus: links: github: https://github.com/QuincyJiang 托管hexo博客源码为了保证切换电脑也可以保留原博客的风格，我们需要将博客的配置用git托管起来 1.创建hexo源码仓库去gitub 新建一个 源码仓库 1https://github.com/QuincyJiang/blog.git 2. 将博客代码使用git托管博客根目录在我们创建hexo项目的时候，就已经生成了一个gitignore文件 1234567.DS_StoreThumbs.dbdb.json*.lognode_modules/public/.deploy*/ 因为mode_modules public .deploy 文件夹都是会动态生成的，所以被添加到git忽略文件列表中了。注意，theme目录下我们克隆下来的第三方theme，它的远程仓库还是跟克隆时的目标仓库保持一致的，我们需要解除它远程仓库的关联，这样推送代码的时候才不会吧主题推送到其他地方。 a 清除第三方主题的远程仓库12cd themes/icarus/rm -rf .git b 修改主题目录下的gitignore文件因为主题的config配置文件我们也要托管起来，对博客的自定义配置主要都是在这里修改的。修改很简单 删除忽略文件中的config.yml就好了 c 创建版本库并与远程仓库链接123456cd ../../git initgit add . git remote add origin https://github/com/QuincyJiang/blog.gitgit commit -m &quot;init commit&quot;git push -u origin master 关于博客贴图一般使用md文件写博客的时候，贴图是最痛苦的事情，一般是现将图片上传到图床之后，再获取图片链接。这边安利一个软件 Mweb md文件编辑器，它可以用拖拽的方式来贴图，图片可以直接上传到github上。官网地址了解一下 用法非常简单 下载安装选择外部模式 点击右下角的加号 将hexo 博客的source文件夹添加进去编辑该folders，右键点击folder 选择图片保存路径以及路径类型 切换电脑后重新恢复博客环境克隆博客源码1git clone https://github/com/QuincyJiang/blog.git 配置基础环境123安装node安装git配置公钥到github 安装hexo1234npm install -g hexonpm install hexo --savenpm install hexo-servernpm install 至此hexo安装完成，回到熟悉的source/_post 目录愉快开始写作吧","categories":[{"name":"备忘录","slug":"备忘录","permalink":"http://wenyiqingnian.xyz/categories/备忘录/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://wenyiqingnian.xyz/tags/hexo/"}]},{"title":"六大设计模式","slug":"六大设计模式","date":"2018-05-12T16:51:50.000Z","updated":"2018-05-16T17:01:06.360Z","comments":true,"path":"2018/05/13/六大设计模式/","link":"","permalink":"http://wenyiqingnian.xyz/2018/05/13/六大设计模式/","excerpt":"","text":"设计模式六大原则（1）：单一职责原则 定义：不要存在多于一个导致类变更的原因。通俗的说，即一个类只负责一项职责。 问题由来：类T负责两个不同的职责：职责P1，职责P2。当由于职责P1需求发生改变而需要修改类T时，有可能会导致原本运行正常的职责P2功能发生故障。 解决方案：遵循单一职责原则。分别建立两个类T1、T2，使T1完成职责P1功能，T2完成职责P2功能。这样，当修改类T1时，不会使职责P2发生故障风险；同理，当修改T2时，也不会使职责P1发生故障风险。 说到单一职责原则，很多人都会不屑一顾。因为它太简单了。稍有经验的程序员即使从来没有读过设计模式、从来没有听说过单一职责原则，在设计软件时也会自觉的遵守这一重要原则，因为这是常识。在软件编程中，谁也不希望因为修改了一个功能导致其他的功能发生故障。而避免出现这一问题的方法便是遵循单一职责原则。虽然单一职责原则如此简单，并且被认为是常识，但是即便是经验丰富的程序员写出的程序，也会有违背这一原则的代码存在。为什么会出现这种现象呢？因为有职责扩散。所谓职责扩散，就是因为某种原因，职责P被分化为粒度更细的职责P1和P2。 比如：类T只负责一个职责P，这样设计是符合单一职责原则的。后来由于某种原因，也许是需求变更了，也许是程序的设计者境界提高了，需要将职责P细分为粒度更细的职责P1，P2，这时如果要使程序遵循单一职责原则，需要将类T也分解为两个类T1和T2，分别负责P1、P2两个职责。但是在程序已经写好的情况下，这样做简直太费时间了。所以，简单的修改类T，用它来负责两个职责是一个比较不错的选择，虽然这样做有悖于单一职责原则。（这样做的风险在于职责扩散的不确定性，因为我们不会想到这个职责P，在未来可能会扩散为P1，P2，P3，P4……Pn。所以记住，在职责扩散到我们无法控制的程度之前，立刻对代码进行重构。） 举例说明，用一个类描述动物呼吸这个场景： 12345678910111213class Animal&#123; public void breathe(String animal)&#123; System.out.println(animal+\"呼吸空气\"); &#125;&#125;public class Client&#123; public static void main(String[] args)&#123; Animal animal = new Animal(); animal.breathe(\"牛\"); animal.breathe(\"羊\"); animal.breathe(\"猪\"); &#125;&#125; 1234567运行结果：牛呼吸空气羊呼吸空气猪呼吸空气 程序上线后，发现问题了，并不是所有的动物都呼吸空气的，比如鱼就是呼吸水的。修改时如果遵循单一职责原则，需要将Animal类细分为陆生动物类Terrestrial，水生动物Aquatic，代码如下： 12345678910111213141516171819202122class Terrestrial&#123; public void breathe(String animal)&#123; System.out.println(animal+\"呼吸空气\"); &#125;&#125;class Aquatic&#123; public void breathe(String animal)&#123; System.out.println(animal+\"呼吸水\"); &#125;&#125;public class Client&#123; public static void main(String[] args)&#123; Terrestrial terrestrial = new Terrestrial(); terrestrial.breathe(\"牛\"); terrestrial.breathe(\"羊\"); terrestrial.breathe(\"猪\"); Aquatic aquatic = new Aquatic(); aquatic.breathe(\"鱼\"); &#125;&#125; 123456789运行结果：牛呼吸空气羊呼吸空气猪呼吸空气鱼呼吸水 我们会发现如果这样修改花销是很大的，除了将原来的类分解之外，还需要修改客户端。而直接修改类Animal来达成目的虽然违背了单一职责原则，但花销却小的多，代码如下： 12345678910111213141516171819class Animal&#123; public void breathe(String animal)&#123; if(\"鱼\".equals(animal))&#123; System.out.println(animal+\"呼吸水\"); &#125;else&#123; System.out.println(animal+\"呼吸空气\"); &#125; &#125;&#125;public class Client&#123; public static void main(String[] args)&#123; Animal animal = new Animal(); animal.breathe(\"牛\"); animal.breathe(\"羊\"); animal.breathe(\"猪\"); animal.breathe(\"鱼\"); &#125;&#125; 可以看到，这种修改方式要简单的多。但是却存在着隐患：有一天需要将鱼分为呼吸淡水的鱼和呼吸海水的鱼，则又需要修改Animal类的breathe方法，而对原有代码的修改会对调用“猪”“牛”“羊”等相关功能带来风险，也许某一天你会发现程序运行的结果变为“牛呼吸水”了。这种修改方式直接在代码级别上违背了单一职责原则，虽然修改起来最简单，但隐患却是最大的。还有一种修改方式： 12345678910111213141516171819class Animal&#123; public void breathe(String animal)&#123; System.out.println(animal+\"呼吸空气\"); &#125; public void breathe2(String animal)&#123; System.out.println(animal+\"呼吸水\"); &#125;&#125;public class Client&#123; public static void main(String[] args)&#123; Animal animal = new Animal(); animal.breathe(\"牛\"); animal.breathe(\"羊\"); animal.breathe(\"猪\"); animal.breathe2(\"鱼\"); &#125;&#125; 可以看到，这种修改方式没有改动原来的方法，而是在类中新加了一个方法，这样虽然也违背了单一职责原则，但在方法级别上却是符合单一职责原则的，因为它并没有动原来方法的代码。这三种方式各有优缺点，那么在实际编程中，采用哪一中呢？其实这真的比较难说，需要根据实际情况来确定。我的原则是：只有逻辑足够简单，才可以在代码级别上违反单一职责原则；只有类中方法数量足够少，才可以在方法级别上违反单一职责原则； 例如本文所举的这个例子，它太简单了，它只有一个方法，所以，无论是在代码级别上违反单一职责原则，还是在方法级别上违反，都不会造成太大的影响。实际应用中的类都要复杂的多，一旦发生职责扩散而需要修改类时，除非这个类本身非常简单，否则还是遵循单一职责原则的好。 遵循单一职责原的优点有： 可以降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多； 提高类的可读性，提高系统的可维护性； 变更引起的风险降低，变更是必然的，如果单一职责原则遵守的好，当修改一个功能时，可以显著降低对其他功能的影响。 需要说明的一点是单一职责原则不只是面向对象编程思想所特有的，只要是模块化的程序设计，都适用单一职责原则。 设计模式六大原则（2）：里氏替换原则肯定有不少人跟我刚看到这项原则的时候一样，对这个原则的名字充满疑惑。其实原因就是这项原则最早是在1988年，由麻省理工学院的一位姓里的女士（Barbara Liskov）提出来的。 定义1：如果对每一个类型为 T1的对象 o1，都有类型为 T2 的对象o2，使得以 T1定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。 定义2：所有引用基类的地方必须能透明地使用其子类的对象。 问题由来：有一功能P1，由类A完成。现需要将功能P1进行扩展，扩展后的功能为P，其中P由原有功能P1与新功能P2组成。新功能P由类A的子类B来完成，则子类B在完成新功能P2的同时，有可能会导致原有功能P1发生故障。 解决方案：当使用继承时，遵循里氏替换原则。类B继承类A时，除添加新的方法完成新增功能P2外，尽量不要重写父类A的方法，也尽量不要重载父类A的方法。 继承包含这样一层含义：==父类中凡是已经实现好的方法（相对于抽象方法而言），实际上是在设定一系列的规范和契约，虽然它不强制要求所有的子类必须遵从这些契约，但是如果子类对这些非抽象方法任意修改，就会对整个继承体系造成破坏==。而里氏替换原则就是表达了这一层含义。 继承作为面向对象三大特性之一，在给程序设计带来巨大便利的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低，增加了对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能会产生故障。 举例说明继承的风险，我们需要完成一个两数相减的功能，由类A来负责。 123456789101112131415161718class A&#123; public int func1(int a, int b)&#123; return a-b; &#125;&#125;public class Client&#123; public static void main(String[] args)&#123; A a = new A(); System.out.println(\"100-50=\"+a.func1(100, 50)); System.out.println(\"100-80=\"+a.func1(100, 80)); &#125;&#125; 运行结果：100-50=50100-80=20 后来，我们需要增加一个新的功能：完成两数相加，然后再与100求和，由类B来负责。即类B需要完成两个功能： 两数相减。两数相加，然后再加100。由于类A已经实现了第一个功能，所以类B继承类A后，只需要再完成第二个功能就可以了，代码如下： 12345678910111213141516171819202122232425class B extends A&#123; public int func1(int a, int b)&#123; return a+b; &#125; public int func2(int a, int b)&#123; return func1(a,b)+100; &#125;&#125;public class Client&#123; public static void main(String[] args)&#123; B b = new B(); System.out.println(\"100-50=\"+b.func1(100, 50)); System.out.println(\"100-80=\"+b.func1(100, 80)); System.out.println(\"100+20+100=\"+b.func2(100, 20)); &#125;&#125; 类B完成后，运行结果：100-50=150100-80=180100+20+100=220 我们发现原本运行正常的相减功能发生了错误。原因就是类B在给方法起名时无意中重写了父类的方法，造成所有运行相减功能的代码全部调用了类B重写后的方法，造成原本运行正常的功能出现了错误。在本例中，引用基类A完成的功能，换成子类B之后，发生了异常。在实际编程中，我们常常会通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的几率非常大。==如果非要重写父类的方法，比较通用的做法是：原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉，采用依赖、聚合，组合等关系代替==。 里氏替换原则通俗的来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。它包含以下4层含义： 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。 子类中可以增加自己特有的方法。 当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。* 当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。 看上去很不可思议，因为我们会发现在自己编程中常常会违反里氏替换原则，程序照样跑的好好的。所以大家都会产生这样的疑问，假如我非要不遵循里氏替换原则会有什么后果？ 后果就是：你写的代码出问题的几率将会大大增加。 设计模式六大原则（3）：依赖倒置原则定义： 高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。 问题由来：类A直接依赖类B，假如要将类A改为依赖类C，则必须通过修改类A的代码来达成。这种场景下，类A一般是高层模块，负责复杂的业务逻辑；类B和类C是低层模块，负责基本的原子操作；假如修改类A，会给程序带来不必要的风险。 ### 解决方案：将类A修改为依赖接口I，类B和类C各自实现接口I，类A通过接口I间接与类B或者类C发生联系，则会大大降低修改类A的几率。 依赖倒置原则基于这样一个事实：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建起来的架构比以细节为基础搭建起来的架构要稳定的多。在java中，抽象指的是接口或者抽象类，细节就是具体的实现类，使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成。 依赖倒置原则的核心思想是==面向接口编程==，我们依旧用一个例子来说明面向接口编程比相对于面向实现编程好在什么地方。场景是这样的，母亲给孩子讲故事，只要给她一本书，她就可以照着书给孩子讲故事了。代码如下： 123456789101112131415161718192021222324class Book&#123; public String getContent()&#123; return \"很久很久以前有一个阿拉伯的故事……\"; &#125;&#125;class Mother&#123; public void narrate(Book book)&#123; System.out.println(\"妈妈开始讲故事\"); System.out.println(book.getContent()); &#125;&#125;public class Client&#123; public static void main(String[] args)&#123; Mother mother = new Mother(); mother.narrate(new Book()); &#125;&#125; 运行结果：妈妈开始讲故事很久很久以前有一个阿拉伯的故事…… 运行良好，假如有一天，需求变成这样：不是给书而是给一份报纸，让这位母亲讲一下报纸上的故事，报纸的代码如下： 12345class Newspaper&#123; public String getContent()&#123; return \"林书豪38+7领导尼克斯击败湖人……\"; &#125;&#125; 这位母亲却办不到，因为她居然不会读报纸上的故事，这太荒唐了，只是将书换成报纸，居然必须要修改Mother才能读。假如以后需求换成杂志呢？换成网页呢？还要不断地修改Mother，这显然不是好的设计。原因就是Mother与Book之间的耦合性太高了，必须降低他们之间的耦合度才行。 我们引入一个抽象的接口IReader。读物，只要是带字的都属于读物： 123456789101112131415161718192021222324252627282930313233343536373839interface IReader&#123; public String getContent();&#125; Mother类与接口IReader发生依赖关系，而Book和Newspaper都属于读物的范畴，他们各自都去实现IReader接口，这样就符合依赖倒置原则了，代码修改为：class Newspaper implements IReader &#123; public String getContent()&#123; return \"林书豪17+9助尼克斯击败老鹰……\"; &#125;&#125;class Book implements IReader&#123; public String getContent()&#123; return \"很久很久以前有一个阿拉伯的故事……\"; &#125;&#125;class Mother&#123; public void narrate(IReader reader)&#123; System.out.println(\"妈妈开始讲故事\"); System.out.println(reader.getContent()); &#125;&#125;public class Client&#123; public static void main(String[] args)&#123; Mother mother = new Mother(); mother.narrate(new Book()); mother.narrate(new Newspaper()); &#125;&#125;运行结果：妈妈开始讲故事很久很久以前有一个阿拉伯的故事……妈妈开始讲故事林书豪17+9助尼克斯击败老鹰…… 这样修改后，无论以后怎样扩展Client类，都不需要再修改Mother类了。这只是一个简单的例子，实际情况中，代表高层模块的Mother类将负责完成主要的业务逻辑，一旦需要对它进行修改，引入错误的风险极大。所以遵循依赖倒置原则可以降低类之间的耦合性，提高系统的稳定性，降低修改程序造成的风险。 采用依赖倒置原则给多人并行开发带来了极大的便利，比如上例中，原本Mother类与Book类直接耦合时，Mother类必须等Book类编码完成后才可以进行编码，因为Mother类依赖于Book类。修改后的程序则可以同时开工，互不影响，因为Mother与Book类一点关系也没有。参与协作开发的人越多、项目越庞大，采用依赖导致原则的意义就越重大。现在很流行的TDD开发模式就是依赖倒置原则最成功的应用。 传递依赖关系有三种方式，以上的例子中使用的方法是接口传递，另外还有两种传递方式：构造方法传递和setter方法传递，相信用过Spring框架的，对依赖的传递方式一定不会陌生。 在实际编程中，我们一般需要做到如下3点： 低层模块尽量都要有抽象类或接口，或者两者都有。 变量的声明类型尽量是抽象类或接口。 使用继承时遵循里氏替换原则。 依赖倒置原则的核心就是要我们面向接口编程，理解了面向接口编程，也就理解了依赖倒置。 设计模式六大原则（4）：接口隔离原则定义： 客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。 问题由来：类A通过接口I依赖类B，类C通过接口I依赖类D，如果接口I对于类A和类B来说不是最小接口，则类B和类D必须去实现他们不需要的方法。 解决方案：将臃肿的接口I拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则。举例来说明接口隔离原则： （图1 未遵循接口隔离原则的设计） 这个图的意思是：类A依赖接口I中的方法1、方法2、方法3，类B是对类A依赖的实现。类C依赖接口I中的方法1、方法4、方法5，类D是对类C依赖的实现。对于类B和类D来说，虽然他们都存在着用不到的方法（也就是图中红色字体标记的方法），但由于实现了接口I，所以也必须要实现这些用不到的方法。对类图不熟悉的可以参照程序代码来理解，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778interface I &#123; public void method1(); public void method2(); public void method3(); public void method4(); public void method5();&#125;class A&#123; public void depend1(I i)&#123; i.method1(); &#125; public void depend2(I i)&#123; i.method2(); &#125; public void depend3(I i)&#123; i.method3(); &#125;&#125;class B implements I&#123; public void method1() &#123; System.out.println(\"类B实现接口I的方法1\"); &#125; public void method2() &#123; System.out.println(\"类B实现接口I的方法2\"); &#125; public void method3() &#123; System.out.println(\"类B实现接口I的方法3\"); &#125; //对于类B来说，method4和method5不是必需的，但是由于接口A中有这两个方法， //所以在实现过程中即使这两个方法的方法体为空，也要将这两个没有作用的方法进行实现。 public void method4() &#123;&#125; public void method5() &#123;&#125;&#125;class C&#123; public void depend1(I i)&#123; i.method1(); &#125; public void depend2(I i)&#123; i.method4(); &#125; public void depend3(I i)&#123; i.method5(); &#125;&#125;class D implements I&#123; public void method1() &#123; System.out.println(\"类D实现接口I的方法1\"); &#125; //对于类D来说，method2和method3不是必需的，但是由于接口A中有这两个方法， //所以在实现过程中即使这两个方法的方法体为空，也要将这两个没有作用的方法进行实现。 public void method2() &#123;&#125; public void method3() &#123;&#125; public void method4() &#123; System.out.println(\"类D实现接口I的方法4\"); &#125; public void method5() &#123; System.out.println(\"类D实现接口I的方法5\"); &#125;&#125;public class Client&#123; public static void main(String[] args)&#123; A a = new A(); a.depend1(new B()); a.depend2(new B()); a.depend3(new B()); C c = new C(); c.depend1(new D()); c.depend2(new D()); c.depend3(new D()); &#125;&#125; 可以看到，如果接口过于臃肿，只要接口中出现的方法，不管对依赖于它的类有没有用处，实现类中都必须去实现这些方法，这显然不是好的设计。如果将这个设计修改为符合接口隔离原则，就必须对接口I进行拆分。在这里我们将原有的接口I拆分为三个接口，拆分后的设计如图2所示： （图2 遵循接口隔离原则的设计） 照例贴出程序的代码，供不熟悉类图的朋友参考： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061interface I1 &#123; public void method1();&#125;interface I2 &#123; public void method2(); public void method3();&#125;interface I3 &#123; public void method4(); public void method5();&#125;class A&#123; public void depend1(I1 i)&#123; i.method1(); &#125; public void depend2(I2 i)&#123; i.method2(); &#125; public void depend3(I2 i)&#123; i.method3(); &#125;&#125;class B implements I1, I2&#123; public void method1() &#123; System.out.println(\"类B实现接口I1的方法1\"); &#125; public void method2() &#123; System.out.println(\"类B实现接口I2的方法2\"); &#125; public void method3() &#123; System.out.println(\"类B实现接口I2的方法3\"); &#125;&#125;class C&#123; public void depend1(I1 i)&#123; i.method1(); &#125; public void depend2(I3 i)&#123; i.method4(); &#125; public void depend3(I3 i)&#123; i.method5(); &#125;&#125;class D implements I1, I3&#123; public void method1() &#123; System.out.println(\"类D实现接口I1的方法1\"); &#125; public void method4() &#123; System.out.println(\"类D实现接口I3的方法4\"); &#125; public void method5() &#123; System.out.println(\"类D实现接口I3的方法5\"); &#125;&#125; 接口隔离原则的含义是： 建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。 也就是说，我们要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。本文例子中，将一个庞大的接口变更为3个专用的接口所采用的就是接口隔离原则。在程序设计中，依赖几个专用的接口要比依赖一个综合的接口更灵活。接口是设计时对外部设定的“契约”，通过分散定义多个接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。 说到这里，很多人会觉的接口隔离原则跟之前的单一职责原则很相似，其实不然。其一，单一职责原则原注重的是职责；而接口隔离原则注重对接口依赖的隔离。其二，单一职责原则主要是约束类，其次才是接口和方法，它针对的是程序中的实现和细节；而接口隔离原则主要约束接口接口，主要针对抽象，针对程序整体框架的构建。 采用接口隔离原则对接口进行约束时，要注意以下几点： 接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。 为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。 提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。 运用接口隔离原则，一定要适度，接口设计的过大或过小都不好。设计接口的时候，只有多花些时间去思考和筹划，才能准确地实践这一原则。 设计模式六大原则（5）：迪米特法则定义： 一个对象应该对其他对象保持最少的了解。 问题由来：类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。 解决方案：尽量降低类与类之间的耦合。 自从我们接触编程开始，就知道了软件编程的总的原则：低耦合，高内聚。无论是面向过程编程还是面向对象编程，只有使各个模块之间的耦合尽量的低，才能提高代码的复用率。低耦合的优点不言而喻，但是怎么样编程才能做到低耦合呢？那正是迪米特法则要去完成的。 迪米特法则又叫最少知道原则，最早是在1987年由美国Northeastern University的Ian Holland提出。通俗的来讲，就是一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类来说，无论逻辑多么复杂，都尽量地的将逻辑封装在类的内部，对外除了提供的public方法，不对外泄漏任何信息。迪米特法则还有一个更简单的定义：==只与直接的朋友通信==。首先来解释一下什么是直接的朋友：==每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系==。耦合的方式很多，依赖、关联、组合、聚合等。其中，我们称出现成员变量、方法参数、方法返回值中的类为直接的朋友，而出现在局部变量中的类则不是直接的朋友。也就是说，陌生的类最好不要作为局部变量的形式出现在类的内部。 举一个例子：有一个集团公司，下属单位有分公司和直属部门，现在要求打印出所有下属单位的员工ID。先来看一下违反迪米特法则的设计。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//总公司员工class Employee&#123; private String id; public void setId(String id)&#123; this.id = id; &#125; public String getId()&#123; return id; &#125;&#125;//分公司员工class SubEmployee&#123; private String id; public void setId(String id)&#123; this.id = id; &#125; public String getId()&#123; return id; &#125;&#125;class SubCompanyManager&#123; public List&lt;SubEmployee&gt; getAllEmployee()&#123; List&lt;SubEmployee&gt; list = new ArrayList&lt;SubEmployee&gt;(); for(int i=0; i&lt;100; i++)&#123; SubEmployee emp = new SubEmployee(); //为分公司人员按顺序分配一个ID emp.setId(\"分公司\"+i); list.add(emp); &#125; return list; &#125;&#125;class CompanyManager&#123; public List&lt;Employee&gt; getAllEmployee()&#123; List&lt;Employee&gt; list = new ArrayList&lt;Employee&gt;(); for(int i=0; i&lt;30; i++)&#123; Employee emp = new Employee(); //为总公司人员按顺序分配一个ID emp.setId(\"总公司\"+i); list.add(emp); &#125; return list; &#125; public void printAllEmployee(SubCompanyManager sub)&#123; List&lt;SubEmployee&gt; list1 = sub.getAllEmployee(); for(SubEmployee e:list1)&#123; System.out.println(e.getId()); &#125; List&lt;Employee&gt; list2 = this.getAllEmployee(); for(Employee e:list2)&#123; System.out.println(e.getId()); &#125; &#125;&#125;public class Client&#123; public static void main(String[] args)&#123; CompanyManager e = new CompanyManager(); e.printAllEmployee(new SubCompanyManager()); &#125;&#125; 现在这个设计的主要问题出在CompanyManager中，根据迪米特法则，只与直接的朋友发生通信，而SubEmployee类并不是CompanyManager类的直接朋友（以局部变量出现的耦合不属于直接朋友），从逻辑上讲总公司只与他的分公司耦合就行了，与分公司的员工并没有任何联系，这样设计显然是增加了不必要的耦合。按照迪米特法则，应该避免类中出现这样非直接朋友关系的耦合。修改后的代码如下: 123456789101112131415161718192021222324252627282930313233343536373839class SubCompanyManager&#123; public List&lt;SubEmployee&gt; getAllEmployee()&#123; List&lt;SubEmployee&gt; list = new ArrayList&lt;SubEmployee&gt;(); for(int i=0; i&lt;100; i++)&#123; SubEmployee emp = new SubEmployee(); //为分公司人员按顺序分配一个ID emp.setId(\"分公司\"+i); list.add(emp); &#125; return list; &#125; public void printEmployee()&#123; List&lt;SubEmployee&gt; list = this.getAllEmployee(); for(SubEmployee e:list)&#123; System.out.println(e.getId()); &#125; &#125;&#125;class CompanyManager&#123; public List&lt;Employee&gt; getAllEmployee()&#123; List&lt;Employee&gt; list = new ArrayList&lt;Employee&gt;(); for(int i=0; i&lt;30; i++)&#123; Employee emp = new Employee(); //为总公司人员按顺序分配一个ID emp.setId(\"总公司\"+i); list.add(emp); &#125; return list; &#125; public void printAllEmployee(SubCompanyManager sub)&#123; sub.printEmployee(); List&lt;Employee&gt; list2 = this.getAllEmployee(); for(Employee e:list2)&#123; System.out.println(e.getId()); &#125; &#125;&#125; 修改后，为分公司增加了打印人员ID的方法，总公司直接调用来打印，从而避免了与分公司的员工发生耦合。 迪米特法则的初衷是降低类之间的耦合，由于每个类都减少了不必要的依赖，因此的确可以降低耦合关系。但是凡事都有度，虽然可以避免与非直接的类通信，但是要通信，必然会通过一个“中介”来发生联系，例如本例中，总公司就是通过分公司这个“中介”来与分公司的员工发生联系的。过分的使用迪米特原则，会产生大量这样的中介和传递类，导致系统复杂度变大。所以在采用迪米特法则时要反复权衡，既做到结构清晰，又要高内聚低耦合。 设计模式六大原则（6）：开闭原则定义： 一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。 问题由来：在软件的生命周期内，因为变化、升级和维护等原因需要对软件原有代码进行修改时，可能会给旧代码中引入错误，也可能会使我们不得不对整个功能进行重构，并且需要原有代码经过重新测试。 解决方案：当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。 开闭原则是面向对象设计中最基础的设计原则，它指导我们如何建立稳定灵活的系统。开闭原则可能是设计模式六项原则中定义最模糊的一个了，它只告诉我们对扩展开放，对修改关闭，可是到底如何才能做到对扩展开放，对修改关闭，并没有明确的告诉我们。以前，如果有人告诉我“你进行设计的时候一定要遵守开闭原则”，我会觉的他什么都没说，但貌似又什么都说了。因为开闭原则真的太虚了。 在仔细思考以及仔细阅读很多设计模式的文章后，终于对开闭原则有了一点认识。其实，我们遵循设计模式前面5大原则，以及使用23种设计模式的目的就是遵循开闭原则。也就是说，只要我们对前面5项原则遵守的好了，设计出的软件自然是符合开闭原则的，这个开闭原则更像是前面五项原则遵守程度的“平均得分”，前面5项原则遵守的好，平均分自然就高，说明软件设计开闭原则遵守的好；如果前面5项原则遵守的不好，则说明开闭原则遵守的不好。 其实笔者认为，开闭原则无非就是想表达这样一层意思：用抽象构建框架，用实现扩展细节。因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节，我们用从抽象派生的实现类来进行扩展，当软件需要发生变化时，我们只需要根据需求重新派生一个实现类来扩展就可以了。当然前提是我们的抽象要合理，要对需求的变更有前瞻性和预见性才行。 说到这里，再回想一下前面说的5项原则，恰恰是告诉我们用抽象构建框架，用实现扩展细节的注意事项而已： 单一职责原则告诉我们实现类要职责单一； 里氏替换原则告诉我们不要破坏继承体系； 依赖倒置原则告诉我们要面向接口编程； 接口隔离原则告诉我们在设计接口的时候要精简单一； 迪米特法则告诉我们要降低耦合。 开闭原则是总纲，他告诉我们要对扩展开放，对修改关闭。 最后说明一下如何去遵守这六个原则。对这六个原则的遵守并不是是和否的问题，而是多和少的问题，也就是说，我们一般不会说有没有遵守，而是说遵守程度的多少。任何事都是过犹不及，设计模式的六个设计原则也是一样，制定这六个原则的目的并不是要我们刻板的遵守他们，而需要根据实际情况灵活运用。对他们的遵守程度只要在一个合理的范围内，就算是良好的设计。我们用一幅图来说明一下。 图中的每一条维度各代表一项原则，我们依据对这项原则的遵守程度在维度上画一个点，则如果对这项原则遵守的合理的话，这个点应该落在红色的同心圆内部；如果遵守的差，点将会在小圆内部；如果过度遵守，点将会落在大圆外部。一个良好的设计体现在图中，应该是六个顶点都在同心圆中的六边形。 在上图中，设计1、设计2属于良好的设计，他们对六项原则的遵守程度都在合理的范围内；设计3、设计4设计虽然有些不足，但也基本可以接受；设计5则严重不足，对各项原则都没有很好的遵守；而设计6则遵守过渡了，设计5和设计6都是迫切需要重构的设计。","categories":[{"name":"java基础","slug":"java基础","permalink":"http://wenyiqingnian.xyz/categories/java基础/"}],"tags":[{"name":"java","slug":"java","permalink":"http://wenyiqingnian.xyz/tags/java/"},{"name":"设计模式","slug":"设计模式","permalink":"http://wenyiqingnian.xyz/tags/设计模式/"}]},{"title":"AnimatedVectorDrawable总结","slug":"AnimatedVectorDrawable 总结","date":"2018-05-09T16:51:50.000Z","updated":"2018-05-24T03:55:08.292Z","comments":true,"path":"2018/05/10/AnimatedVectorDrawable 总结/","link":"","permalink":"http://wenyiqingnian.xyz/2018/05/10/AnimatedVectorDrawable 总结/","excerpt":"","text":"在更新Android N之后 会注意到状态栏上的快捷方式有了新的变化 当我们点击的时候，从开启到关闭状态，会有一个顺滑自然的过渡动画，在学习完AnimatinVectorDrawable的api用法之后，你就会知道该怎么实现这些类似的效果了。 Vector在开始之前，想先说明一下安卓中的矢量图标文件Vector，我们经常会用到矢量图，将一张SVG的图片通过AS自动生成一个以vector为根节点的xml文件，可以直接通过1R.drawable.xx 的格式引用它。矢量图形不管我们如何拉伸都不会模糊，因此广受开发者青睐。看一下一个典型的vector文件结构 12345678910111213&lt;vector android:height=\"24dp\" android:viewportHeight=\"24dp\" android:viewportWidth=\"24\" android:width=\"24\" xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;path android:fillColor=\"#36ab60\" android:pathData=\"M6.4,6.4 L17.6,17.6 M6.4,17.6 L17.6 ,6.4\" android:strokeWidth=\"2\" android:strokeColor=\"#999\" android:trimPathStart=\"0.1\" android:trimPathEnd=\"0.9\"/&gt;&lt;/vector&gt; heigit/width: 图片的宽高 viewportWidth/viewportHeight: 画布宽高，也是必填的，定义Path路径的时候就必须在这个画布大小里去绘制，超出画布就显示不出来了。 path 绘制路径 主要理解几个字母代表的意思 1234M：MOVE 将画笔移动到该点L: LINE 直线连接到该点C: CURVE 曲线连接到该点Z: CLOSE 闭合曲线 strokeWidth: 线的粗细 trimPathStart: 绘制线段起始点偏移的百分比 这么说起来其实有点抽象，用一张图来解释会更加直观一些 12android:trimPathStart=\"0\"android:trimPathEnd=\"1\"/&gt; 12android:trimPathStart=\"0\"android:trimPathEnd=\"0.75\"/&gt; 12android:trimPathStart=\"0.5\"android:trimPathEnd=\"0.75\"/&gt; 123android:trimPathStart=\"0.25\"android:trimPathEnd=\"0.75\"android:trimPathOffset=\"0.25\"/&gt; 123android:trimPathStart=\"0.25\"android:trimPathEnd=\"0.75\"android:trimPathOffset=\"0.375\"/&gt; 其实这几张图片连在一起看，你会发现只要将这几个数值重复循环，这就成了一个进度条动画了。下面正式讲解文章主角 AnimatedVectorDrawable听名字其实可以猜到，它主要是靠两个东西来实现的 ObjectAnimation 属性动画：不用于补间动画，属性动画是直接对view的属性值进行动态、更改，不再只是一种视觉上的动画效果了。它实际上是一种不断地对值进行操作的机制，并将值赋值到指定对象的指定属性上，可以是任意对象的任意属性。关于属性动画的具体介绍不在本文重点，可以参考郭林的博客，属性动画完全解析 VectorDrawable 矢量图型，上文已经介绍过，不再详述 创建一个AnimatedVectorDrawable定义一个vectorDrawable1android:drawable=\"@drawable/foo\" 创建一个animation1234567&lt;ObjectAnimator android:propertyName=\"rotation\" android:valueFrom=\"0\" android:valueTo=\"180\" android:duration=\"200\" android:interpolator=\"@interpolator/...\" android:valueType=\"floatVaule\" valueFrom valueTo propertyName: 要进行变换的属性值该值有以以下几种取值 1234567891011Paths:(support-library 25.3以上 支持变换path数据)Color:Opacity:Trim start /end /offsetPath:Groups:Translate:Scale:Rotate: paths分组下我们可以对颜色 不透明度 起始点偏移量 还有path元数据进行变换 动画1 这是通过动态变换paths分组下的start end的偏移位置，做到x变为对号，同时通过groups分组下的translate 来动态改变位置图像在变化前后还保持中心位置 其实通过trim属性，我们可以做到更多炫酷的动画效果，可以先看下面这个动画 它的完整路径其实是这样的 只是通过变换trim的值，让其部分不可见便实现了上述效果 动画2 本质是将碎裂的心分为两组图片，心的填充颜色默认为白色，点击填充是更改了透明度opacity，裂开的动画是使用groups中的rotation动画 Path Morphing我们还可以直接对path元数据进行变换 1234567&lt;ObjectAnimator android:propertyName=\"pathData\" android:valueFrom=\"M6.4,6.4 L17.6,17.6 M6.4,17.6 L17.6 ,6.4\" android:valueTo=\"M6,10 L4,10 ...\" android:duration=\"200\" android:valueType=\"pathType\" ... 但进行path变换的前提是前后两条path路径 他们的绘制点数量和绘制命令必须是相同的就比如上面代码中 变换前是4个点 变换后也必须是四个点 而且 m l m l 的顺序不可以改变 上面这种 两个正方形 大小变了 形状没变，我们可以选定点的四个点作为变换参考点，只需要改变下四个点的前后坐标就可以了，绘制流程是不变的，符合要求，但如果变换前后是这样的呢？ 圆是没有顶点的，这时候只能变通一下，这样来选择四个点，同时要将连接点与点之间的命令由L （直线）改为C（曲线），这样可以通过控制贝塞尔曲线的控制点坐标，达到绘制圆弧和直线的效果。你可以通过设置更多的控制点 来达到更顺滑的变换效果 进行path变换 因为要操作控制点坐标，也带来了下面几个问题 1.无法精确获取点的坐标我们绘制的矢量图 一般用的是sketch之类的软件，它并不能让我们直接选择变换的点，比如上面的圆，只能得到一个半径和圆心坐标，无法精准的获取四个或者更多控制点的坐标 2.点与点之间无法重叠3.不能直观的看到动画中间状态的样子有时候点选择的不合理，会导致变换中间产生一些非常奇怪的形状，类似sketch之类的设计工具并不能直观看到变化中间态的样子 幸运的是 有个工具可以很好解决上述的三个问题 是一个在线预览工具，shapeshafter 官方的详细介绍 在这里我这边以创建一个-号到+号的变换动画为例，简单介绍下用法 1. 上传两张svg图片分别表示的是变换前，变换后 2.复制第二个涂层的pathdata后，删除该图层 3. 调整第一张图，选择要变换的数据是pathdata，并将变化后 也即第二张图的pathdata 粘贴进去 这时候因为“+”和“-”的节点数不一致，会报错提示，可以点击修改pathdata 按钮去手动删减增加一些节点数据 4.妥善选择好前后的节点位置，就可以点击下方播放按钮直观查看变化效果了，不满意可以修改节点，知道达到预期目标。 待续 —————–18.5.9","categories":[{"name":"CoolUI","slug":"CoolUI","permalink":"http://wenyiqingnian.xyz/categories/CoolUI/"}],"tags":[{"name":"句柄animation","slug":"句柄animation","permalink":"http://wenyiqingnian.xyz/tags/句柄animation/"},{"name":"AnimatedVectorDrawable","slug":"AnimatedVectorDrawable","permalink":"http://wenyiqingnian.xyz/tags/AnimatedVectorDrawable/"}]},{"title":"Rxjava2操作符","slug":"Rxjava2操作符","date":"2018-04-12T12:20:50.000Z","updated":"2018-05-06T14:18:23.807Z","comments":true,"path":"2018/04/12/Rxjava2操作符/","link":"","permalink":"http://wenyiqingnian.xyz/2018/04/12/Rxjava2操作符/","excerpt":"","text":"Rxjava2 操作符 Createcreate操作符，主要用于产生一个 Obserable 被观察者对象，因为Observable主要用于发射事件，Observer主要用于消费时间，所以以后统一把被观察者 Observable 称为发射器（上游事件），观察者 Observer 称为接收器（下游事件）。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; mRxOperatorsText.append(\"Observable emit 1\" + \"\\n\"); Log.e(TAG, \"Observable emit 1\" + \"\\n\"); e.onNext(1); mRxOperatorsText.append(\"Observable emit 2\" + \"\\n\"); Log.e(TAG, \"Observable emit 2\" + \"\\n\"); e.onNext(2); mRxOperatorsText.append(\"Observable emit 3\" + \"\\n\"); Log.e(TAG, \"Observable emit 3\" + \"\\n\"); e.onNext(3); e.onComplete(); mRxOperatorsText.append(\"Observable emit 4\" + \"\\n\"); Log.e(TAG, \"Observable emit 4\" + \"\\n\" ); e.onNext(4); &#125; &#125;).subscribe(new Observer&lt;Integer&gt;() &#123; private int i; private Disposable mDisposable; @Override public void onSubscribe(@NonNull Disposable d) &#123; mRxOperatorsText.append(\"onSubscribe : \" + d.isDisposed() + \"\\n\"); Log.e(TAG, \"onSubscribe : \" + d.isDisposed() + \"\\n\" ); mDisposable = d; &#125; @Override public void onNext(@NonNull Integer integer) &#123; mRxOperatorsText.append(\"onNext : value : \" + integer + \"\\n\"); Log.e(TAG, \"onNext : value : \" + integer + \"\\n\" ); i++; if (i == 2) &#123; // 在RxJava 2.x 中，新增的Disposable可以做到切断的操作，让Observer观察者不再接收上游事件 mDisposable.dispose(); mRxOperatorsText.append(\"onNext : isDisposable : \" + mDisposable.isDisposed() + \"\\n\"); Log.e(TAG, \"onNext : isDisposable : \" + mDisposable.isDisposed() + \"\\n\"); &#125; &#125; @Override public void onError(@NonNull Throwable e) &#123; mRxOperatorsText.append(\"onError : value : \" + e.getMessage() + \"\\n\"); Log.e(TAG, \"onError : value : \" + e.getMessage() + \"\\n\" ); &#125; @Override public void onComplete() &#123; mRxOperatorsText.append(\"onComplete\" + \"\\n\"); Log.e(TAG, \"onComplete\" + \"\\n\" ); &#125; &#125;); MapMap 基本算是 RxJava 中一个最简单的操作符了，熟悉 RxJava 1.x 的知道，它的作用是对发射时间发送的每一个事件应用一个函数，是的每一个事件都按照指定的函数去变化，而在 2.x 中它的作用几乎一致。map 基本作用就是将一个 Observable 通过某种函数关系，转换为另一种 Observable，下面例子中就是把我们的 Integer 数据变成了 String 类型。从Log日志显而易见。 12345678910111213141516171819Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; e.onNext(1); e.onNext(2); e.onNext(3); &#125; &#125;).map(new Function&lt;Integer, String&gt;() &#123; @Override public String apply(@NonNull Integer integer) throws Exception &#123; return \"This is result \" + integer; &#125; &#125;).subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(@NonNull String s) throws Exception &#123; mRxOperatorsText.append(\"accept : \" + s +\"\\n\"); Log.e(TAG, \"accept : \" + s +\"\\n\" ); &#125; &#125;); Zip zip 专用于合并事件，该合并不是连接（连接操作符后面会说），而是两两配对，也就意味着，最终配对出的 Observable 发射事件数目只和少的那个相同。 12345678910111213141516Observable.zip(getStringObservable(), getIntegerObservable(), new BiFunction&lt;String, Integer, String&gt;() &#123; @Override public String apply(@NonNull String s, @NonNull Integer integer) throws Exception &#123; return s + integer; &#125; &#125;).subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(@NonNull String s) throws Exception &#123; mRxOperatorsText.append(\"zip : accept : \" + s + \"\\n\"); Log.e(TAG, \"zip : accept : \" + s + \"\\n\"); &#125; &#125;); /***注： getStringObservable 返回A B C ，getIntegerObservable返回的是1 2 3 4 5 */ 输出结果： zip 组合事件的过程就是分别从发射器 A 和发射器 B 各取出一个事件来组合，并且一个事件只能被使用一次，组合的顺序是严格按照事件发送的顺序来进行的，所以上面截图中，可以看到，1 永远是和 A 结合的，2 永远是和 B 结合的。 最终接收器收到的事件数量是和发送器发送事件最少的那个发送器的发送事件数目相同上面的例子就可以看出 结合后的事件数量是3 Concat 因为zip连接事件有上述两个特点： 121. 分别从两个发射器取一个事件组合成新事件，且事件组合顺序与发射顺序严格相同 2. 最终接受事件数量与原始发射器数量最小的那个相同 对于单一的把两个发射器连接成一个发射器，可以尝试Contact 12345678Observable.concat(Observable.just(1,2,3), Observable.just(4,5,6)) .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(@NonNull Integer integer) throws Exception &#123; mRxOperatorsText.append(\"concat : \"+ integer + \"\\n\"); Log.e(TAG, \"concat : \"+ integer + \"\\n\" ); &#125; &#125;); **输出结果 123456** FlatMap FlatMap ，它可以把一个发射器 Observable 通过某种方法转换为多个 Observables，然后再把这些分散的 Observables装进一个单一的发射器 Observable。但有个需要注意的是，flatMap ==并不能保证事件的顺序==，如果需要保证，需要用到我们下面要讲的 ConcatMap。 123456789101112131415161718192021222324252627Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; e.onNext(1); e.onNext(2); e.onNext(3); &#125; &#125;).flatMap(new Function&lt;Integer, ObservableSource&lt;String&gt;&gt;() &#123; @Override public ObservableSource&lt;String&gt; apply(@NonNull Integer integer) throws Exception &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 3; i++) &#123; list.add(\"I am value \" + integer); &#125; int delayTime = (int) (1 + Math.random() * 10); return Observable.fromIterable(list).delay(delayTime, TimeUnit.MILLISECONDS); // 使用delay操作符，做一个小延时操作，而查看 Log 日志也表明，FlatMap是无序的。 &#125; &#125;).subscribeOn(Schedulers.newThread()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(@NonNull String s) throws Exception &#123; Log.e(TAG, \"flatMap : accept : \" + s + \"\\n\"); mRxOperatorsText.append(\"flatMap : accept : \" + s + \"\\n\"); &#125; &#125;); 输出 12,3,3,3,2,2,1,1 concatMap 上面其实就说了，concatMap 与 FlatMap 的唯一区别就是 concatMap 保证了顺序，所以，我们就直接把 flatMap 替换为 concatMap 验证。 1234567891011121314151617181920212223242526Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; e.onNext(1); e.onNext(2); e.onNext(3); &#125; &#125;).concatMap(new Function&lt;Integer, ObservableSource&lt;String&gt;&gt;() &#123; @Override public ObservableSource&lt;String&gt; apply(@NonNull Integer integer) throws Exception &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 3; i++) &#123; list.add(\"I am value \" + integer); &#125; int delayTime = (int) (1 + Math.random() * 10); return Observable.fromIterable(list).delay(delayTime, TimeUnit.MILLISECONDS); &#125; &#125;).subscribeOn(Schedulers.newThread()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(@NonNull String s) throws Exception &#123; Log.e(TAG, \"flatMap : accept : \" + s + \"\\n\"); mRxOperatorsText.append(\"flatMap : accept : \" + s + \"\\n\"); &#125; &#125;); 输出结果： 11 1 1 2 2 2 3 3 3 distinct作用是去重，输入11 1 2 2 3 4 5 输出11 2 3 4 5 12345678910Observable.just(1, 1, 1, 2, 2, 3, 4, 5) .distinct() .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(@NonNull Integer integer) throws Exception &#123; mRxOperatorsText.append(\"distinct : \" + integer + \"\\n\"); Log.e(TAG, \"distinct : \" + integer + \"\\n\"); &#125; &#125;); FilterFilter 过滤器，可以接受一个参数，让其过滤掉不符合我们条件的值 12345678910111213Observable.just(1, 20, 65, -5, 7, 19) .filter(new Predicate&lt;Integer&gt;() &#123; @Override public boolean test(@NonNull Integer integer) throws Exception &#123; return integer &gt;= 10; &#125; &#125;).subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(@NonNull Integer integer) throws Exception &#123; mRxOperatorsText.append(\"filter : \" + integer + \"\\n\"); Log.e(TAG, \"filter : \" + integer + \"\\n\"); &#125; &#125;); 输出大于10的事件 120 65 19 buffer buffer 操作符接受两个参数，buffer(count,skip)作用是将 Observable 中的数据按 skip (步长) 分成最大不超过 count 的 buffer ，然后生成一个 Observable 。也就是说 ==按照步长，将原始事件 分成一组一组 重新发射出去== 1234567891011121314151617Observable.just(1, 2, 3, 4, 5) .buffer(3, 2) .subscribe(new Consumer&lt;List&lt;Integer&gt;&gt;() &#123; @Override public void accept(@NonNull List&lt;Integer&gt; integers) throws Exception &#123; mRxOperatorsText.append(\"buffer size : \" + integers.size() + \"\\n\"); Log.e(TAG, \"buffer size : \" + integers.size() + \"\\n\"); mRxOperatorsText.append(\"buffer value : \"); Log.e(TAG, \"buffer value : \" ); for (Integer i : integers) &#123; mRxOperatorsText.append(i + \"\"); Log.e(TAG, i + \"\"); &#125; mRxOperatorsText.append(\"\\n\"); Log.e(TAG, \"\\n\"); &#125; &#125;); 输出结果 123456size 3value 1 2 3 size 3value 3 4 5 size 1 value 5 timer timer，相当于一个定时任务。在 1.x 中它还可以执行间隔逻辑，但在 2.x 中此功能被交给了 interval。但需要注意的是，timer 和 interval 均==默认在新线程==。==执行timer方法，将使得接受延时== 123456789101112mRxOperatorsText.append(\"timer start : \" + TimeUtil.getNowStrTime() + \"\\n\"); Log.e(TAG, \"timer start : \" + TimeUtil.getNowStrTime() + \"\\n\"); Observable.timer(2, TimeUnit.SECONDS) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) // timer 默认在新线程，所以需要切换回主线程 .subscribe(new Consumer&lt;Long&gt;() &#123; @Override public void accept(@NonNull Long aLong) throws Exception &#123; mRxOperatorsText.append(\"timer :\" + aLong + \" at \" + TimeUtil.getNowStrTime() + \"\\n\"); Log.e(TAG, \"timer :\" + aLong + \" at \" + TimeUtil.getNowStrTime() + \"\\n\"); &#125; &#125;); 当我们两次点击按钮触发这个事件的时候，接收被延迟了 2 秒。 interval 如同我们上面可说，interval 操作符用于间隔时间执行某个操作，其接受三个参数，分别是第一次发送延迟，间隔时间，时间单位。 123456789101112mRxOperatorsText.append(\"interval start : \" + TimeUtil.getNowStrTime() + \"\\n\"); Log.e(TAG, \"interval start : \" + TimeUtil.getNowStrTime() + \"\\n\"); Observable.interval(3,2, TimeUnit.SECONDS) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) // 由于interval默认在新线程，所以我们应该切回主线程 .subscribe(new Consumer&lt;Long&gt;() &#123; @Override public void accept(@NonNull Long aLong) throws Exception &#123; mRxOperatorsText.append(\"interval :\" + aLong + \" at \" + TimeUtil.getNowStrTime() + \"\\n\"); Log.e(TAG, \"interval :\" + aLong + \" at \" + TimeUtil.getNowStrTime() + \"\\n\"); &#125; &#125;); 执行结果是第一次延迟了 3 秒后接收到，后面每次间隔了 2 秒。然而，由于我们这个是间隔执行，所以当我们的Activity 都销毁的时候，==实际上这个操作还依然在进行==，查看源码发现，我们1subscribe(Cousumer&lt;? super T&gt; onNext) 返回的是Disposable，Disposable 可以用来解除绑定。 1234567891011121314151617181920212223@Override protected void doSomething() &#123; mRxOperatorsText.append(\"interval start : \" + TimeUtil.getNowStrTime() + \"\\n\"); Log.e(TAG, \"interval start : \" + TimeUtil.getNowStrTime() + \"\\n\"); mDisposable = Observable.interval(3, 2, TimeUnit.SECONDS) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) // 由于interval默认在新线程，所以我们应该切回主线程 .subscribe(new Consumer&lt;Long&gt;() &#123; @Override public void accept(@NonNull Long aLong) throws Exception &#123; mRxOperatorsText.append(\"interval :\" + aLong + \" at \" + TimeUtil.getNowStrTime() + \"\\n\"); Log.e(TAG, \"interval :\" + aLong + \" at \" + TimeUtil.getNowStrTime() + \"\\n\"); &#125; &#125;); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); if (mDisposable != null &amp;&amp; !mDisposable.isDisposed()) &#123; mDisposable.dispose(); &#125; &#125; doOnNext doOnNext 它的作用是让订阅者在接收到数据之前做一些其他操作。假如我们在获取到数据之前想先保存一下它，无疑我们可以这样实现。 1234567891011121314Observable.just(1, 2, 3, 4) .doOnNext(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(@NonNull Integer integer) throws Exception &#123; mRxOperatorsText.append(\"doOnNext 保存 \" + integer + \"成功\" + \"\\n\"); Log.e(TAG, \"doOnNext 保存 \" + integer + \"成功\" + \"\\n\"); &#125; &#125;).subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(@NonNull Integer integer) throws Exception &#123; mRxOperatorsText.append(\"doOnNext :\" + integer + \"\\n\"); Log.e(TAG, \"doOnNext :\" + integer + \"\\n\"); &#125; &#125;); skip skip ，接受一个 long 型参数 count ，代表跳过 count 个数目开始接收。 123456789Observable.just(1,2,3,4,5) .skip(2) .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(@NonNull Integer integer) throws Exception &#123; mRxOperatorsText.append(\"skip : \"+integer + \"\\n\"); Log.e(TAG, \"skip : \"+integer + \"\\n\"); &#125; &#125;); 输出： 13 4 5 take take，接受一个 long 型参数 count ，代表至多接收 count 个数据。 123456789Flowable.fromArray(1,2,3,4,5) .take(2) .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(@NonNull Integer integer) throws Exception &#123; mRxOperatorsText.append(\"take : \"+integer + \"\\n\"); Log.e(TAG, \"accept: take : \"+integer + \"\\n\" ); &#125; &#125;); 输出： 11 2 just just一个简单的发射器依次调用 onNext() 方法。 12345678910Observable.just(\"1\", \"2\", \"3\") .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(@NonNull String s) throws Exception &#123; mRxOperatorsText.append(\"accept : onNext : \" + s + \"\\n\"); Log.e(TAG,\"accept : onNext : \" + s + \"\\n\" ); &#125; &#125;); 输出： 11 2 3 Single 顾名思义，Single 只会接收一个参数，也就是只发射一次事件，他的而 SingleObserver 只会调用 onError() 或者 onSuccess()。 12345678910111213141516171819Single.just(new Random().nextInt()) .subscribe(new SingleObserver&lt;Integer&gt;() &#123; @Override public void onSubscribe(@NonNull Disposable d) &#123; &#125; @Override public void onSuccess(@NonNull Integer integer) &#123; mRxOperatorsText.append(\"single : onSuccess : \"+integer+\"\\n\"); Log.e(TAG, \"single : onSuccess : \"+integer+\"\\n\" ); &#125; @Override public void onError(@NonNull Throwable e) &#123; mRxOperatorsText.append(\"single : onError : \"+e.getMessage()+\"\\n\"); Log.e(TAG, \"single : onError : \"+e.getMessage()+\"\\n\"); &#125; &#125;); 输出： 1onSuccess distinct 去重操作符，简单的作用就是去重。 123456789Observable.just(1, 1, 1, 2, 2, 3, 4, 5) .distinct() .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(@NonNull Integer integer) throws Exception &#123; mRxOperatorsText.append(\"distinct : \" + integer + \"\\n\"); Log.e(TAG, \"distinct : \" + integer + \"\\n\"); &#125; &#125;); 输出： 11 2 3 4 5 发射器发送的事件，在接收的时候被去重了。 debounce 去除发送频率过快的项，可以用来过滤点击过快的点击事件 1234567891011121314151617181920212223242526Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; // send events with simulated time wait emitter.onNext(1); // skip Thread.sleep(400); emitter.onNext(2); // deliver Thread.sleep(505); emitter.onNext(3); // skip Thread.sleep(100); emitter.onNext(4); // deliver Thread.sleep(605); emitter.onNext(5); // deliver Thread.sleep(510); emitter.onComplete(); &#125; &#125;).debounce(500, TimeUnit.MILLISECONDS) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(@NonNull Integer integer) throws Exception &#123; mRxOperatorsText.append(\"debounce :\" + integer + \"\\n\"); Log.e(TAG,\"debounce :\" + integer + \"\\n\"); &#125; &#125;); 输出： 12 4 5 代码很清晰，去除发送间隔时间小于 500 毫秒的发射事件，所以 1 和 3 被去掉了。 defer ==直到有订阅，才会创建Observable==具有延时的效果。 代码对比如下： 12345678910a = 10;Observable&lt;String&gt; o1 = Observable.just(\"just result: \" + a);a = 12;o1.subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String t) &#123; System.out.println(t); &#125;&#125;); 输出： 1just result: 10 可见：在使用just的时候，便创建了Observable对象，随后改变a的值，并不会改变Observable对象中的值。 使用defer 123456789101112131415161718a = 12;Observable&lt;String&gt; o2 = Observable.defer(new Func0&lt;Observable&lt;String&gt;&gt;() &#123; @Override public Observable&lt;String&gt; call() &#123; return Observable.just(\"defer result: \" + a); &#125;&#125;);a = 20;o2.subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String t) &#123; System.out.println(t); &#125; &#125;); 输出： 1defer result: 20 可见：在a=12时，虽然定义了一个Observable，但是并没有创建这个示例，当a=20时，这时候订阅这个Observable，则开始创建，所以对象中的a为20. last last 操作符仅取出可观察到的最后一个值，或者是满足某些条件的最后一项。 123456789Observable.just(1, 2, 3) .last() .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(@NonNull Integer integer) throws Exception &#123; mRxOperatorsText.append(\"last : \" + integer + \"\\n\"); Log.e(TAG, \"last : \" + integer + \"\\n\"); &#125; &#125;); 输出：13 merge merge 顾名思义 在 Rx 操作符中，merge 的作用是把多个 Observable 结合起来，接受可变参数，也支持迭代器集合。注意它和 concat 的区别在于，==不用等到 发射器 A 发送完所有的事件再进行发射器 B 的发送==。 12345678Observable.merge(Observable.just(1, 2), Observable.just(3, 4, 5)) .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(@NonNull Integer integer) throws Exception &#123; mRxOperatorsText.append(\"merge :\" + integer + \"\\n\"); Log.e(TAG, \"accept: merge :\" + integer + \"\\n\" ); &#125; &#125;); 输出： 11 2 3 4 5 reduce reduce 操作符每次用一个方法处理一个值，可以有一个 seed 作为初始值。 12345678910111213Observable.just(1, 2, 3) .reduce(new BiFunction&lt;Integer, Integer, Integer&gt;() &#123; @Override public Integer apply(@NonNull Integer integer, @NonNull Integer integer2) throws Exception &#123; return integer + integer2; &#125; &#125;).subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(@NonNull Integer integer) throws Exception &#123; mRxOperatorsText.append(\"reduce : \" + integer + \"\\n\"); Log.e(TAG, \"accept: reduce : \" + integer + \"\\n\"); &#125; &#125;); 输出：16 可以看到，代码中，我们中间采用 reduce ，支持一个 function 为两数值相加，所以应该最后的值是：1 + 2 = 3 + 3 = 6 ， scan scan 操作符作用和上面的 reduce 一致，唯一区别是 reduce 是个只追求结果的坏人，而 scan 会始终如一地把每一个步骤都输出。 12345678910111213Observable.just(1, 2, 3) .scan(new BiFunction&lt;Integer, Integer, Integer&gt;() &#123; @Override public Integer apply(@NonNull Integer integer, @NonNull Integer integer2) throws Exception &#123; return integer + integer2; &#125; &#125;).subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(@NonNull Integer integer) throws Exception &#123; mRxOperatorsText.append(\"scan \" + integer + \"\\n\"); Log.e(TAG, \"accept: scan \" + integer + \"\\n\"); &#125; &#125;); 输出： 11 3 6 window 按照实际划分窗口，将数据发送给不同的 Observable 1234567891011121314151617181920212223mRxOperatorsText.append(\"window\\n\"); Log.e(TAG, \"window\\n\"); Observable.interval(1, TimeUnit.SECONDS) // 间隔一秒发一次 .take(15) // 最多接收15个 .window(3, TimeUnit.SECONDS) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;Observable&lt;Long&gt;&gt;() &#123; @Override public void accept(@NonNull Observable&lt;Long&gt; longObservable) throws Exception &#123; mRxOperatorsText.append(\"Sub Divide begin...\\n\"); Log.e(TAG, \"Sub Divide begin...\\n\"); longObservable.subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;Long&gt;() &#123; @Override public void accept(@NonNull Long aLong) throws Exception &#123; mRxOperatorsText.append(\"Next:\" + aLong + \"\\n\"); Log.e(TAG, \"Next:\" + aLong + \"\\n\"); &#125; &#125;); &#125; &#125;); 输出：","categories":[{"name":"Android","slug":"Android","permalink":"http://wenyiqingnian.xyz/categories/Android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://wenyiqingnian.xyz/tags/android/"},{"name":"开源框架","slug":"开源框架","permalink":"http://wenyiqingnian.xyz/tags/开源框架/"},{"name":"rxjava2","slug":"rxjava2","permalink":"http://wenyiqingnian.xyz/tags/rxjava2/"}]},{"title":"socket未释放导致句柄泄露","slug":"Socket未释放导致的句柄泄露","date":"2018-03-16T11:40:50.000Z","updated":"2018-05-06T13:28:37.592Z","comments":true,"path":"2018/03/16/Socket未释放导致的句柄泄露/","link":"","permalink":"http://wenyiqingnian.xyz/2018/03/16/Socket未释放导致的句柄泄露/","excerpt":"","text":"问题描述客户反馈话机的voipsdk demo在运行起来之后 放置不动，几小时过后，应用进行任何操作都会崩溃。通过logcat 报错信息 发现出现了句柄泄露。通过ls -l /proc//fd可以查看到在demo进程下，持有的socket数量会规律性上升。 12345lrwx------ system system 2018-03-08 14:11 60 -&gt; socket:[4027431]lrwx------ system system 2018-03-08 14:11 61 -&gt; socket:[4025517]lrwx------ system system 2018-03-08 14:11 62 -&gt; socket:[4028038]lrwx------ system system 2018-03-08 14:11 63 -&gt; socket:[4028322]lrwx------ system system 2018-03-08 14:11 64 -&gt; socket:[4026799] 大概十秒增加一个，一直到超出安卓规定的数量，此时由于已无可用fd句柄，在进行任何操作都会因无可用句柄直接导致崩溃。 可以看到新增socket的inode号码之后，通过查找/proc/net/tcp(udp对应/proc/net/udp)文件，其中也列出了相应socket的inode号，通过比对此字段，我在/proc/net/tcp下获得此套接口的其他信息，对应的&lt;本地地址：端口号，远端地址：端口号&gt;对，窗口大小，状态等信息。具体字段含义详见net/ipv4/tcp_ipv4.c 中的 tcp4_seq_show 函数。cat /proc/net/tcp 如下： 12345678root@TOS_IP:/proc/net # cat tcp6 sl local_address remote_address st tx_queue rx_queue tr tm-&gt;when retrnsmt uid timeout inode 0: 0000000000000000FFFF00007665A8C0:D483 0000000000000000FFFF00009F173379:0050 08 00000000:00000001 00:00000000 00000000 10077 0 3660979 1 00000000 25 4 30 10 -1 1: 0000000000000000FFFF00007665A8C0:E595 0000000000000000FFFF0000DCD5B276:0050 08 00000000:00000001 00:00000000 00000000 10077 0 3661419 1 00000000 24 4 28 10 -1 2: 0000000000000000FFFF00007665A8C0:81EC 0000000000000000FFFF00009F173379:0050 08 00000000:00000001 00:00000000 00000000 1000 0 4019721 1 00000000 23 4 30 10 -1 3: 0000000000000000FFFF00007665A8C0:B885 0000000000000000FFFF0000F28D0D6F:0050 08 00000000:00000001 00:00000000 00000000 1000 0 3659952 1 00000000 26 4 30 10 -1 4: 0000000000000000FFFF00007665A8C0:8AD0 0000000000000000FFFF00009F173379:0050 08 00000000:00000001 00:00000000 00000000 1000 0 4018811 1 00000000 24 4 30 10 -1 5: 0000000000000000FFFF00007665A8C0:E83C 0000000000000000FFFF00009F173379:0050 08 00000000:00000001 00:00000000 00000000 1000 0 4018828 1 00000000 23 4 30 10 -1 将本端16进制端口号转化为10进制可以看到是一个与8080端口在通信的socket。 目前初步猜测是端口争夺导致demo没有获取到端口，就会隔段时间重试去申请该端口。 首先去java端排除，全局搜索发现并没有找到对应的8080端口申请情况 那就只有可能是linphone库里或者webrtc库里做了8080相关的操作了。 请linphone端的李工排查，发现在一段前离职同事的代码里，有一段申请8080端口的相关操作。查看了一下，发现和猜测的一致，因为要和底层通讯，同事使用了socket并通过8080端口，但是在申请资源后并未释放改socket，当系统自带的拨号服务起来之后，因为系统自带拨号和sdk的demo使用的linphone库是相同的，导致两个进程都在抢占8080，那个进程服务先拿到，另一个进程就拿不到该端口，会隔10s重新发起申请，但是之前创建的socket又没有释放，就会导致句柄泄露。 我将系统自带的拨号进程彻底杀死，同事运行起demo，然后再将系统拨号运行起来，发现这时候 系统自带拨号也出现了句柄泄露。而demo就没有出现过了。 应征我之前的猜测。解决这个问题就很简单了，在linphone的代码里将改socket释放。","categories":[{"name":"bug记录","slug":"bug记录","permalink":"http://wenyiqingnian.xyz/categories/bug记录/"}],"tags":[{"name":"句柄泄露","slug":"句柄泄露","permalink":"http://wenyiqingnian.xyz/tags/句柄泄露/"},{"name":"bugs","slug":"bugs","permalink":"http://wenyiqingnian.xyz/tags/bugs/"}]},{"title":"线程阻塞和中断的四种方式","slug":"线程阻塞和中断的四种方式","date":"2018-03-13T12:46:25.000Z","updated":"2018-05-06T14:15:08.753Z","comments":true,"path":"2018/03/13/线程阻塞和中断的四种方式/","link":"","permalink":"http://wenyiqingnian.xyz/2018/03/13/线程阻塞和中断的四种方式/","excerpt":"","text":"1、线程阻塞一个线程进入阻塞状态可能的原因： 通过调用sleep(millseconds)使任务进入休眠状态；123456789101112class Demo1 implements Runnable throws InterruptedException&#123; public void run()&#123; Thread.sleep(1000); &#125;&#125;②通过调用wait（）使线程挂起，直到线程获取notify（）/notifyAll（）消息，（或者在Java SE5中java.util.concurrent类库中等价的signal（）/signalAll（）消息），线程才会进入就绪状态；class Demo2 implements Runnable&#123; public void run()&#123; Thread.await(); Thread.notify(); &#125;&#125; 任务在等待某个输入 / 输出流的完成；123456class Demo3 implements Runnable throws InterruptedException&#123; private InputStream in; public void run()&#123; in.read(); &#125;&#125; 任务试图在某个对象上调用其同步控制方法，但是对象锁不可用，因为另一个任务已经获取了该锁；1234567class Demo4 implements Runnable&#123; public synchronized void method1()&#123; &#125; public synchronized void method2()&#123; &#125; public void run()&#123; method1(); &#125;&#125; 2、线程中断的方法Thread类包含interrupt（）方法，用于终止阻塞任务； 1）中断①②类线程休眠，挂起阻塞的方法1.直接使用Thread.interrupt();1234main()&#123; Thread t = new Thread(new Demo1()); t.interrupt();&#125; 2.使用Executor线程池，中断线程池中的所有线程；123456main()&#123; ExecutorService exec = Executors.newCachedThreadPool(); for(int i=0;i&lt;5;i++) exec.execute(new Demo1()) exec.shutdownNow();&#125; 3.使用Executor线程池，中断线程池中单个阻塞的线程；12345main()&#123; ExecutorService exec = Executors.newCachedThreadPool(); Futrue&lt;?&gt; f = exec.submit(new Demo1()); f.interrupt();&#125; //中断后的清除代码放置在InterruptedException异常的catch捕获的代码块中 2）中断③类I/O阻塞的方法使用Thread.iterrupt方法无法中断I/O阻塞，这对于基于Web的程序是很不利的； 有一种解决方法：关闭任务在其上发生阻塞的底层资源；123456789101112main()&#123; ExecutorService exec = Executors.newCachedThreadPool(); ServerSocket server = new ServerSocket(8080); InputStream socketInput = new Socket(\"localhost\",8080) exec.execute(socketInput); exec.execute(Sytsem.in); //exec.shutdownNow(); 无法中断2个线程； socketInput.close(); in.close(); exec.shutdownNow();&#125; java.nio类库提供了更加人性化的I/O中断，被阻塞的nio通道会自动地响应中断；12345678910111213141516171819202122232425262728class Demo impelenets Runnable&#123; private final SocketChannel sc; public Demo(SocketChannel sc)&#123; this.sc = sc;&#125; public void run()&#123; try&#123; sc.read(ByteBuffer.allocate(1)); &#125;catch(CloseByInteruptedException e1)&#123; &#125;catch(AsyncronousCloseException e2)&#123; &#125;catch(IOException e3)&#123; &#125; &#125;&#125;public Test &#123; public static void main()&#123; ExecutorService exec = Executors.newCachedThreadPool(); ServerSocket server = new ServerSocket(8080); InetSocketAddress isa = new InetSocketAddress(\"localhost\",8080); SocketChannel sc1 = new SocketChannel.open(isa); SocketChannel sc2 = new SocketChannel.open(isa); exec.execute(new Demo(sc1)); Future&lt;?&gt; f = exec.submit(new Demo(sc2)); f.cancel(true); //可以终止sc1通道所在的线程； exec.shutdownNow(); //可以终止exec线程池内所有的线程； sc1.close(); sc2.close(); &#125;&#125; 3）中断④类被互斥阻塞的线程使用Thread.iterrupt方法无法中断互斥类线程， 解决方式1：可以使用ReentrantLock显式加锁，在JavaSE5中引入的新特性，ReentrantLock上阻塞的任务可以被中断；123456789101112131415161718class Task imlements Runnable&#123; private Lock lock = new ReentrantLock(); public void run()&#123; lock.lock(); try&#123; while(true) &#125;catch(InterruptedExcpetion e)&#123; System.out.println(\"The Task is interrupted!\"); &#125;finally&#123; lock.unlock(); &#125; &#125; public void main()&#123; Thread t = new Thread(new Task()); t.start(); t.interrupt(); &#125;&#125; 解决方式2：使用一个while（！Thread.interrupted（））包裹同步的代码块123456789101112131415161718class Task impelments Runnable&#123; private synchronized void method1()&#123; &#125; public void run()&#123; try&#123; whlie(!Thread.interrupted()) method1(); &#125;catch(InteruptedException e)&#123; &#125; &#125; public static void main()&#123; ExecutorService exec = Executors.newCachedThreadPool(); exec.execute(new Task()); exec.shutdownNow(); //线程被打断 /*或 Thread t = new Thread(new Task()); t.start(); t.interrupt(); */ &#125;&#125;","categories":[{"name":"java基础","slug":"java基础","permalink":"http://wenyiqingnian.xyz/categories/java基础/"}],"tags":[{"name":"java","slug":"java","permalink":"http://wenyiqingnian.xyz/tags/java/"},{"name":"多线程","slug":"多线程","permalink":"http://wenyiqingnian.xyz/tags/多线程/"}]},{"title":"mac搭建Pyqt5环境","slug":"mac搭建PyQt5环境","date":"2017-12-11T12:30:50.000Z","updated":"2018-05-06T13:25:36.596Z","comments":true,"path":"2017/12/11/mac搭建PyQt5环境/","link":"","permalink":"http://wenyiqingnian.xyz/2017/12/11/mac搭建PyQt5环境/","excerpt":"","text":"1.首先基于virtualenv 搭建一个python3的运行环境virtualenv是一个十分好用的python工具，可以为不同的软件创建独立的“隔离”的Python运行环境。 1. 首先，我们用pip安装virtualenv：1$ pip3 install virtualenv 2.创建一个pyhton3的运行环境1jiangxqdeMBP:~ jiangxq$ virtualenv py3 --python=python3 可以通过python=python3来指定要安装的python版本，python3是mac的写法，其他linux系统需要制定为python2.7 或者python3.6 3. 激活该运行环境执行 12jiangxqdeMBP:~ jiangxq$ source ~/py3/bin/activate(py3) jiangxqdeMBP:~ jiangxq$ 当用户名前出现该运行环境的名称时，表示环境已经激活了 2. 检查pip工具的版本 目前最新的为9.0.2 需要更新请 执行1pip3 install --upgrade pip 这里有个窍门是如果mac的默认python运行环境为python2.7，但是不想修改注册文件，可以直接打pip3，pip3是是python3的pip工具，pip是python2的pip工具。 3. 使用pip工具安装PyQt51pip3 install PyQt5 当PyQt5安装完成之后，其实Qt的组件此时已经可用了，如果要测试是否安装成功，可以新建一个Python项目，然后倒入PyQt5的包看看。 4.在pycharm上安装QtDesign工具包QtDesign是Pycharm上的可视化uI设计工具，可以拖动控件来达到实现设计界面的功能安装Qtdesign 需要先安装QT 1. 下载QT安装包下载地址：http://iso.mirrors.ustc.edu.cn/qtproject/archive/qt/5.10/5.10.1/qt-opensource-mac-x64-5.10.1.dmg下载完成后直接安装 2.打开pycharm 点击preference 点击Tools 新建一个插件 注意插件地址不要写错了，是qt5的安装路径 3. 创建PyUIC 插件（将pydesigner的布局自动转化为python代码）","categories":[{"name":"python","slug":"python","permalink":"http://wenyiqingnian.xyz/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://wenyiqingnian.xyz/tags/python/"},{"name":"qt","slug":"qt","permalink":"http://wenyiqingnian.xyz/tags/qt/"}]},{"title":"MQTT相关总结","slug":"MQTT相关","date":"2017-12-11T12:30:50.000Z","updated":"2018-05-09T16:54:08.134Z","comments":true,"path":"2017/12/11/MQTT相关/","link":"","permalink":"http://wenyiqingnian.xyz/2017/12/11/MQTT相关/","excerpt":"","text":"MQTT相关MQTT官网：http://mqtt.org/ MQTT介绍：http://www.ibm.com MQTT Android github：https://github.com/eclipse/paho.mqtt.android MQTT API：http://www.eclipse.org/paho/files/javadoc/index.html MQTT Android API： http://www.eclipse.org/paho/files/android-javadoc/index.html MQTT服务器搭建 环境：windows7 64位 JAVA环境:jdk 1.8.0 下载：Apollo服务器 以下为步骤： 下载Apollo服务器后，解压安装； 用命令行进入到安装目录bin目录下 输入 apollo create xxx (xxx为服务器实例名，eg.apollo create xmaihh) 执行之后会在bin目录下创建名称为xxx的文件夹，比如我生成的文件夹是 xmaihhxxx文件夹下etc\\apollo.xml文件是 配置服务器文件信息etc\\users.properties文件包含连接MQTT服务器时用到的用户名和密码，默认为admin=password，即账号为admin，密码为password，可自行更改。 用命令行进入到刚创建的xxx\\bin目录下，输入apollo-broker.cmd run开启服务器 在浏览器输入http://127.0.0.1:61680/，查看是否安装成功MQTT Android客户端 环境：AndroidStudio 3.0.1 topic：中文意思是“话题”。在MQTT中订阅了(subscribe)同一话题（topic）的客户端会同时收到消息推送。 clientId：客户身份唯一标识。 qos：服务质量。 retained：要保留最后的断开连接信息。 MqttAndroidClient#subscribe()：订阅某个话题。 MqttAndroidClient#publish()： 向某个话题发送消息，之后服务器会推送给所有订阅了此话题的客户。 userName：连接到MQTT服务器的用户名。 passWord ：连接到MQTT服务器的密码 以下为步骤： 添加依赖 123456789repositories &#123; maven &#123; url &quot;https://repo.eclipse.org/content/repositories/paho-snapshots/&quot; &#125;&#125;dependencies &#123; compile &apos;org.eclipse.paho:org.eclipse.paho.client.mqttv3:1.1.0&apos; compile &apos;org.eclipse.paho:org.eclipse.paho.android.service:1.1.1&apos;&#125; 添加权限 123&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.WAKE_LOCK&quot; /&gt; 注册Service 12&lt;!-- Mqtt Service --&gt;&lt;service android:name=&quot;org.eclipse.paho.android.service.MqttService&quot; /&gt; 具体实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157/** * MQTT长连接服务 */public class MQTTService extends Service &#123; public static final String TAG = MQTTService.class.getSimpleName(); public static MqttAndroidClient client; private MqttConnectOptions connectOptions; private String host = &quot;tcp://192.168.102.216:61613&quot;;// private String host = &quot;tcp://192.168.8.241:61613&quot;;// private String host = &quot;tcp://10.0.2.2:61613&quot;;// private String host = &quot;tcp://192.168.26.144:1883&quot;; private String username = &quot;admin&quot;; private String password = &quot;password&quot;; private static String myTopic = &quot;topic&quot;; private String clientId = &quot;test123&quot;; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; init(); return super.onStartCommand(intent, flags, startId); &#125; @Nullable @Override public IBinder onBind(Intent intent) &#123; return null; &#125; public static void publish(String msg) &#123; String topic = myTopic; Integer qos = 0; Boolean retained = false; try &#123; client.publish(topic, msg.getBytes(), qos.intValue(), retained.booleanValue()); &#125; catch (MqttException e) &#123; e.printStackTrace(); &#125; &#125; /** * 初始化方法 */ private void init() &#123; // 服务器地址 (协议+地址+端口号) String url = host; client = new MqttAndroidClient(this, url, clientId); client.setCallback(mqttCallback); connectOptions = new MqttConnectOptions(); // 清除缓存 connectOptions.setCleanSession(true); // 设置超时时间,单位:秒 connectOptions.setConnectionTimeout(10); // 心跳包发送时间间隔,单位:秒 connectOptions.setKeepAliveInterval(20); // 用户名 connectOptions.setUserName(username); // 密码 connectOptions.setPassword(password.toCharArray()); // last will message boolean doConnect = true; String message = &quot;&#123;\\&quot;terminal_uid\\&quot;:\\&quot;&quot; + clientId + &quot;\\&quot;&#125;&quot;; String topic = myTopic; Integer qos = 0; Boolean retained = false; if ((!message.equals(&quot;&quot;)) || (!topic.equals(&quot;&quot;))) &#123; //最后的遗嘱 try &#123; connectOptions.setWill(topic, message.getBytes(), qos.intValue(), retained.booleanValue()); &#125; catch (Exception ex) &#123; Log.d(TAG, &quot;Exception Occured&quot;, ex); doConnect = false; iMqttActionListener.onFailure(null, ex); &#125; &#125; if (doConnect) &#123; //连接MQTT服务器 doClientConnection(); &#125; &#125; /** * 连接MQTT服务器 */ private void doClientConnection() &#123; if (!client.isConnected() &amp;&amp; isConnectIsNomarl()) &#123; try &#123; client.connect(connectOptions, null, iMqttActionListener); &#125; catch (MqttException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /** * 判断网络是否连接 * * @return */ private boolean isConnectIsNomarl() &#123; ConnectivityManager connectivityManager = (ConnectivityManager) this.getApplicationContext().getSystemService(Context.CONNECTIVITY_SERVICE); NetworkInfo info = connectivityManager.getActiveNetworkInfo(); if (info != null &amp;&amp; info.isAvailable()) &#123; String name = info.getTypeName(); Log.i(TAG, &quot;MQTT当前网络名称：&quot; + name); return true; &#125; else &#123; Log.i(TAG, &quot;MQTT 没有可用网络&quot;); return false; &#125; &#125; /** * MQTT监听并且接收消息 */ private MqttCallback mqttCallback = new MqttCallback() &#123; @Override public void connectionLost(Throwable cause) &#123; //失去连接，重连 &#125; @Override public void messageArrived(String topic, MqttMessage message) throws Exception &#123; EventBus.getDefault().post(message); String str2 = topic + &quot;;qos :&quot; + message.getQos() + &quot;;retained:&quot; + message.isRetained(); Log.d(TAG, &quot;messageArrived: str2&quot; + str2); &#125; @Override public void deliveryComplete(IMqttDeliveryToken token) &#123; &#125; &#125;; /** * MQTT是否连接成功 */ private IMqttActionListener iMqttActionListener = new IMqttActionListener() &#123; @Override public void onSuccess(IMqttToken asyncActionToken) &#123; Log.d(TAG, &quot;onSuccess: MQTT连接成功&quot;); try &#123; //订阅myTopic话题 client.subscribe(myTopic, 1); &#125; catch (MqttException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void onFailure(IMqttToken asyncActionToken, Throwable exception) &#123; exception.printStackTrace(); //连接失败，重连 &#125; &#125;;&#125; 初始化各个参数，之后连接服务器。连接成功之后在http://127.0.0.1:61680/ 看到自动创建了名称为”topic”的topic。这里我使用两台真机。http://127.0.0.1:61680/ 服务端看到的是这个样子 模拟器运行的时候host = “tcp://10.0.2.2:61613”，因为10.0.2.2 是模拟器设置的特定ip，是你电脑的别名。真机运行的时候host = “tcp://192.168.102.216:61613”。192.168.102.216是我主机的IPv4地址，查看本机IP的cmd命令为ipconfig/all。 两次运行时的clientId不能一样（为了保证客户标识的唯一性） 访问管理界面要修改前面创建的xxx文件夹下etc\\apollo.xml文件，添加你的host就可以通过host访问管理界面，否则只能通过 http://127.0.0.1:61680 和 https://127.0.0.1:61681 访问123456789101112131415161718192021222324252627282930313233343536373839... ... &lt;virtual_host id=&quot;xmaihh&quot;&gt; &lt;!-- You should add all the host names that this virtual host is known as to properly support the STOMP 1.1 virtual host feature. --&gt; &lt;host_name&gt;xmaihh&lt;/host_name&gt; &lt;host_name&gt;localhost&lt;/host_name&gt; &lt;host_name&gt;127.0.0.1&lt;/host_name&gt; &lt;!--以下为添加内容--&gt; &lt;host_name&gt;192.168.102.216&lt;/host_name&gt; &lt;!--以上为添加内容--&gt; &lt;!-- Uncomment to disable security for the virtual host --&gt; &lt;!-- &lt;authentication enabled=&quot;false&quot;/&gt; --&gt; &lt;!-- Uncomment to disable security for the virtual host --&gt; &lt;!-- &lt;authentication enabled=&quot;false&quot;/&gt; --&gt; &lt;access_rule allow=&quot;users&quot; action=&quot;connect create destroy send receive consume&quot;/&gt; &lt;!-- You can delete this element if you want to disable persistence for this virtual host --&gt; &lt;leveldb_store directory=&quot;$&#123;apollo.base&#125;/data&quot;/&gt; &lt;/virtual_host&gt; &lt;web_admin bind=&quot;http://127.0.0.1:61680&quot;/&gt; &lt;web_admin bind=&quot;https://127.0.0.1:61681&quot;/&gt; &lt;!--以下为添加内容--&gt; &lt;web_admin bind=&quot;http://192.168.102.216:61680&quot;/&gt; &lt;web_admin bind=&quot;https://192.168.102.216:61681&quot;/&gt; &lt;!--以上为添加内容--&gt; &lt;connector id=&quot;tcp&quot; bind=&quot;tcp://0.0.0.0:61613&quot; connection_limit=&quot;2000&quot;/&gt; &lt;connector id=&quot;tls&quot; bind=&quot;tls://0.0.0.0:61614&quot; connection_limit=&quot;2000&quot;/&gt; &lt;connector id=&quot;ws&quot; bind=&quot;ws://0.0.0.0:61623&quot; connection_limit=&quot;2000&quot;/&gt; &lt;connector id=&quot;wss&quot; bind=&quot;wss://0.0.0.0:61624&quot; connection_limit=&quot;2000&quot;/&gt; &lt;key_storage file=&quot;$&#123;apollo.base&#125;/etc/keystore&quot; password=&quot;password&quot; key_password=&quot;password&quot;/&gt;","categories":[{"name":"MQTT","slug":"MQTT","permalink":"http://wenyiqingnian.xyz/categories/MQTT/"}],"tags":[{"name":"mqtt","slug":"mqtt","permalink":"http://wenyiqingnian.xyz/tags/mqtt/"}]},{"title":"view 绘制机制","slug":"view 绘制机制","date":"2017-10-12T11:30:50.000Z","updated":"2018-05-24T03:11:00.231Z","comments":true,"path":"2017/10/12/view 绘制机制/","link":"","permalink":"http://wenyiqingnian.xyz/2017/10/12/view 绘制机制/","excerpt":"","text":"View的绘制和事件处理是两个重要的主题，上一篇《图解 Android事件分发机制》已经把事件的分发机制讲得比较详细了，这一篇是针对View的绘制，View的绘制如果你有所了解，基本分为measure、layout、draw 过程，其中比较难理解就是measure过程，所以本篇文章大幅笔地分析measure过程，相对讲得比较详细，文章也比较长，如果你对View的绘制还不是很懂，对measure过程掌握得不是很深刻，那么耐心点，看完这篇文章，相信你会有所收获的。 Measure过程对于测量我们来说几个知识点,了解这几个知识点，之后的实例分析你才看得懂。 1、MeasureSpec 的理解对于View的测量，肯定会和MeasureSpec接触，MeasureSpec是两个单词组成，翻译过来“测量规格”或者“测量参数”，很多博客包括官方文档对他的说明基本都是“一个MeasureSpec封装了从父容器传递给子容器的布局要求”,这个MeasureSpec 封装的是父容器传递给子容器的布局要求，而不是父容器对子容器的布局要求，“传递” 两个字很重要，更精确的说法应该这个MeasureSpec是由父View的MeasureSpec和子View的LayoutParams通过简单的计算得出一个针对子View的测量要求，这个测量要求就是MeasureSpec。 大家都知道一个MeasureSpec是一个大小跟模式的组合值,MeasureSpec中的值是一个整型（32位）将size和mode打包成一个Int型，其中高两位是mode，后面30位存的是size，是为了减少对象的分配开支。MeasureSpec 类似于下图，只不过这边用的是十进制的数，而MeasureSpec 是二进制存储的。 注：-1 代表的是EXACTLY，-2 是AT_MOSTMeasureSpec一共有三种模式 123UPSPECIFIED : 父容器对于子容器没有任何限制,子容器想要多大就多大EXACTLY: 父容器已经为子容器设置了尺寸,子容器应当服从这些边界,不论子容器想要多大的空间。AT_MOST：子容器可以是声明大小内的任意大小 很多文章都会把这三个模式说成这样，当然其实包括官方文档也是这样表达的，但是这样并不好理解。特别是如果把这三种模式又和MATCH_PARENT和WRAP_CONTENT 联系到一起，很多人就懵逼了。如果从代码上来看1view.measure(int widthMeasureSpec, int heightMeasureSpec) 12 的两个MeasureSpec是父类传递过来的，但并不是完全是父View的要求，而是父View的MeasureSpec和子View自己的LayoutParams共同决定的，而子View的LayoutParams其实就是我们在xml写的时候设置的layout_width和layout_height 转化而来的。我们先来看代码会清晰一些： 父View的measure的过程会先测量子View，等子View测量结果出来后，再来测量自己，上面的measureChildWithMargins就是用来测量某个子View的，我们来分析是怎样测量的，具体看注释： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112protected void measureChildWithMargins(View child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed) &#123; // 子View的LayoutParams，你在xml的layout_width和layout_height,// layout_xxx的值最后都会封装到这个个LayoutParams。final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams(); //根据父View的测量规格和父View自己的Padding，//还有子View的Margin和已经用掉的空间大小（widthUsed），就能算出子View的MeasureSpec,具体计算过程看getChildMeasureSpec方法。final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin + widthUsed, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin + heightUsed, lp.height); //通过父View的MeasureSpec和子View的自己LayoutParams的计算，算出子View的MeasureSpec，然后父容器传递给子容器的// 然后让子View用这个MeasureSpec（一个测量要求，比如不能超过多大）去测量自己，如果子View是ViewGroup 那还会递归往下测量。child.measure(childWidthMeasureSpec, childHeightMeasureSpec);&#125;// spec参数 表示父View的MeasureSpec // padding参数 父View的Padding+子View的Margin，父View的大小减去这些边距，才能精确算出// 子View的MeasureSpec的size// childDimension参数 表示该子View内部LayoutParams属性的值（lp.width或者lp.height）// 可以是wrap_content、match_parent、一个精确指(an exactly size), public static int getChildMeasureSpec(int spec, int padding, int childDimension) &#123; int specMode = MeasureSpec.getMode(spec); //获得父View的mode int specSize = MeasureSpec.getSize(spec); //获得父View的大小 //父View的大小-自己的Padding+子View的Margin，得到值才是子View的大小。 int size = Math.max(0, specSize - padding); int resultSize = 0; //初始化值，最后通过这个两个值生成子View的MeasureSpec int resultMode = 0; //初始化值，最后通过这个两个值生成子View的MeasureSpec switch (specMode) &#123; // Parent has imposed an exact size on us //1、父View是EXACTLY的 ！ case MeasureSpec.EXACTLY: //1.1、子View的width或height是个精确值 (an exactly size) if (childDimension &gt;= 0) &#123; resultSize = childDimension; //size为精确值 resultMode = MeasureSpec.EXACTLY; //mode为 EXACTLY 。 &#125; //1.2、子View的width或height为 MATCH_PARENT/FILL_PARENT else if (childDimension == LayoutParams.MATCH_PARENT) &#123; // Child wants to be our size. So be it. resultSize = size; //size为父视图大小 resultMode = MeasureSpec.EXACTLY; //mode为 EXACTLY 。 &#125; //1.3、子View的width或height为 WRAP_CONTENT else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // Child wants to determine its own size. It can't be // bigger than us. resultSize = size; //size为父视图大小 resultMode = MeasureSpec.AT_MOST; //mode为AT_MOST 。 &#125; break; // Parent has imposed a maximum size on us //2、父View是AT_MOST的 ！ case MeasureSpec.AT_MOST: //2.1、子View的width或height是个精确值 (an exactly size) if (childDimension &gt;= 0) &#123; // Child wants a specific size... so be it resultSize = childDimension; //size为精确值 resultMode = MeasureSpec.EXACTLY; //mode为 EXACTLY 。 &#125; //2.2、子View的width或height为 MATCH_PARENT/FILL_PARENT else if (childDimension == LayoutParams.MATCH_PARENT) &#123; // Child wants to be our size, but our size is not fixed. // Constrain child to not be bigger than us. resultSize = size; //size为父视图大小 resultMode = MeasureSpec.AT_MOST; //mode为AT_MOST &#125; //2.3、子View的width或height为 WRAP_CONTENT else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // Child wants to determine its own size. It can't be // bigger than us. resultSize = size; //size为父视图大小 resultMode = MeasureSpec.AT_MOST; //mode为AT_MOST &#125; break; // Parent asked to see how big we want to be //3、父View是UNSPECIFIED的 ！ case MeasureSpec.UNSPECIFIED: //3.1、子View的width或height是个精确值 (an exactly size) if (childDimension &gt;= 0) &#123; // Child wants a specific size... let him have it resultSize = childDimension; //size为精确值 resultMode = MeasureSpec.EXACTLY; //mode为 EXACTLY &#125; //3.2、子View的width或height为 MATCH_PARENT/FILL_PARENT else if (childDimension == LayoutParams.MATCH_PARENT) &#123; // Child wants to be our size... find out how big it should // be resultSize = 0; //size为0！ ,其值未定 resultMode = MeasureSpec.UNSPECIFIED; //mode为 UNSPECIFIED &#125; //3.3、子View的width或height为 WRAP_CONTENT else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // Child wants to determine its own size.... find out how // big it should be resultSize = 0; //size为0! ，其值未定 resultMode = MeasureSpec.UNSPECIFIED; //mode为 UNSPECIFIED &#125; break; &#125; //根据上面逻辑条件获取的mode和size构建MeasureSpec对象。 return MeasureSpec.makeMeasureSpec(resultSize, resultMode); &#125; 上面的代码有点多，希望你仔细看一些注释，代码写得很多，其实计算原理很简单： 如果我们在xml 的layout_width或者layout_height 把值都写死，那么上述的测量完全就不需要了，之所以要上面的这步测量，是因为 match_parent 就是充满父容器，wrap_content 就是自己多大就多大， 我们写代码的时候特别爽，我们编码方便的时候，google就要帮我们计算你match_parent的时候是多大，wrap_content的是多大，这个计算过程，就是计算出来的父View的MeasureSpec不断往子View传递，结合子View的LayoutParams 一起再算出子View的MeasureSpec，然后继续传给子View，不断计算每个View的MeasureSpec，子View有了MeasureSpec才能更测量自己和自己的子View。 上述代码如果这么来理解就简单了 如果父View的MeasureSpec 是EXACTLY，说明父View的大小是确切的，（确切的意思很好理解，如果一个View的MeasureSpec 是EXACTLY，那么它的size 是多大，最后展示到屏幕就一定是那么大）。 1.如果子View 的layout_xxxx是MATCH_PARENT，父View的大小是确切，子View的大小又MATCH_PARENT（充满整个父View），那么子View的大小肯定是确切的，而且大小值就是父View的size。所以子View的size=父View的size，mode=EXACTLY 2.如果子View 的layout_xxxx是WRAP_CONTENT，也就是子View的大小是根据自己的content 来决定的，但是子View的毕竟是子View，大小不能超过父View的大小，但是子View的是WRAP_CONTENT，我们还不知道具体子View的大小是多少，要等到child.measure(childWidthMeasureSpec, childHeightMeasureSpec) 调用的时候才去真正测量子View 自己content的大小（比如TextView wrap_content 的时候你要测量TextView content 的大小，也就是字符占用的大小，这个测量就是在child.measure(childWidthMeasureSpec, childHeightMeasureSpec)的时候，才能测出字符的大小，MeasureSpec 的意思就是假设你字符100px，但是MeasureSpec 要求最大的只能50px，这时候就要截掉了）。通过上述描述，子View MeasureSpec mode的应该是AT_MOST，而size 暂定父View的 size，表示的意思就是子View的大小没有不确切的值，子View的大小最大为父View的大小，不能超过父View的大小（这就是AT_MOST 的意思），然后这个MeasureSpec 做为子View measure方法 的参数，做为子View的大小的约束或者说是要求，有了这个MeasureSpec子View再实现自己的测量。 3、如果如果子View 的layout_xxxx是确定的值（200dp），那么就更简单了，不管你父View的mode和size是什么，我都写死了就是200dp，那么控件最后展示就是就是200dp，不管我的父View有多大，也不管我自己的content 有多大，反正我就是这么大，所以这种情况MeasureSpec 的mode = EXACTLY 大小size=你在layout_xxxx 填的那个值。 如果父View的MeasureSpec 是AT_MOST，说明父View的大小是不确定，最大的大小是MeasureSpec 的size值，不能超过这个值。 1、如果子View 的layout_xxxx是MATCH_PARENT，父View的大小是不确定（只知道最大只能多大），子View的大小MATCH_PARENT（充满整个父View），那么子View你即使充满父容器，你的大小也是不确定的，父View自己都确定不了自己的大小，你MATCH_PARENT你的大小肯定也不能确定的，所以子View的mode=AT_MOST，size=父View的size，也就是你在布局虽然写的是MATCH_PARENT，但是由于你的父容器自己的大小不确定，导致子View的大小也不确定，只知道最大就是父View的大小。 2、如果子View 的layout_xxxx是WRAP_CONTENT，父View的大小是不确定（只知道最大只能多大），子View又是WRAP_CONTENT，那么在子View的Content没算出大小之前，子View的大小最大就是父View的大小，所以子View MeasureSpec mode的就是AT_MOST，而size 暂定父View的 size。 3、如果如果子View 的layout_xxxx是确定的值（200dp），同上，写多少就是多少，改变不了的。 如果父View的MeasureSpec 是UNSPECIFIED(未指定),表示没有任何束缚和约束，不像AT_MOST表示最大只能多大，不也像EXACTLY表示父View确定的大小，子View可以得到任意想要的大小，不受约束 1、如果子View 的layout_xxxx是MATCH_PARENT，因为父View的MeasureSpec是UNSPECIFIED，父View自己的大小并没有任何约束和要求，那么对于子View来说无论是WRAP_CONTENT还是MATCH_PARENT，子View也是没有任何束缚的，想多大就多大，没有不能超过多少的要求，一旦没有任何要求和约束，size的值就没有任何意义了，所以一般都直接设置成0 2、同上… 3、如果如果子View 的layout_xxxx是确定的值（200dp），同上，写多少就是多少，改变不了的（记住，只有设置的确切的值，那么无论怎么测量，大小都是不变的，都是你写的那个值） 2、View的测量过程主要是在onMeasure()方法打开View的源码，找到measure方法，这个方法代码不少，但是测量工作都是在onMeasure()做的，measure方法是final的所以这个方法也不可重写，如果想自定义View的测量，你应该去重写onMeasure()方法 12345public final void measure(int widthMeasureSpec, int heightMeasureSpec) &#123; ...... onMeasure(widthMeasureSpec,heightMeasureSpec); .....&#125; 3、View的onMeasure 的默认实现打开View.java 的源码来看下onMeasure的实现 12345protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasuredDimension( getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));&#125; View的onMeasure方法默认实现很简单，就是调用setMeasuredDimension()，setMeasuredDimension()可以简单理解就是给mMeasuredWidth和mMeasuredHeight设值，如果这两个值一旦设置了，那么意味着对于这个View的测量结束了，这个View的宽高已经有测量的结果出来了。如果我们想设定某个View的高宽，完全可以直接通过setMeasuredDimension（100，200）来设置死它的高宽（不建议），但是setMeasuredDimension方法必须在onMeasure方法中调用，不然会抛异常。我们来看下对于View来说它的默认高宽是怎么获取的。 1234567891011121314151617181920//获取的是android:minHeight属性的值或者View背景图片的大小值protected int getSuggestedMinimumWidth() &#123; return (mBackground == null) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth()); &#125; //@param size参数一般表示设置了android:minHeight属性或者该View背景图片的大小值 public static int getDefaultSize(int size, int measureSpec) &#123; int result = size; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); switch (specMode) &#123; case MeasureSpec.UNSPECIFIED: //表示该View的大小父视图未定，设置为默认值 result = size; break; case MeasureSpec.AT_MOST: case MeasureSpec.EXACTLY: result = specSize; break; &#125; return result;&#125; getDefaultSize的第一个参数size等于getSuggestedMinimumXXXX返回的的值（建议的最小宽度和高度），而建议的最小宽度和高度都是由View的Background尺寸与通过设置View的minXXX属性共同决定的，这个size可以理解为View的默认长度，而第二个参数measureSpec，是父View传给自己的MeasureSpec,这个measureSpec是通过测量计算出来的，具体的计算测量过程前面在讲解MeasureSpec已经讲得比较清楚了（是有父View的MeasureSpec和子View自己的LayoutParams 共同决定的）只要这个测试的mode不是UNSPECIFIED（未确定的），那么默认的就会用这个测量的数值当做View的高度。 对于View默认是测量很简单，大部分情况就是拿计算出来的MeasureSpec的size 当做最终测量的大小。而对于其他的一些View的派生类，如TextView、Button、ImageView等，它们的onMeasure方法系统了都做了重写，不会这么简单直接拿 MeasureSpec 的size来当大小，而去会先去测量字符或者图片的高度等，然后拿到View本身content这个高度（字符高度等），如果MeasureSpec是AT_MOST，而且View本身content的高度不超出MeasureSpec的size，那么可以直接用View本身content的高度（字符高度等），而不是像View.java 直接用MeasureSpec的size做为View的大小。 4、ViewGroup的Measure过程ViewGroup 类并没有实现onMeasure，我们知道测量过程其实都是在onMeasure方法里面做的，我们来看下FrameLayout 的onMeasure 方法,具体分析看注释哦。 1234567891011121314151617181920212223//FrameLayout 的测量protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; ....int maxHeight = 0;int maxWidth = 0;int childState = 0;for (int i = 0; i &lt; count; i++) &#123; final View child = getChildAt(i); if (mMeasureAllChildren || child.getVisibility() != GONE) &#123; // 遍历自己的子View，只要不是GONE的都会参与测量，measureChildWithMargins方法在最上面 // 的源码已经讲过了，如果忘了回头去看看，基本思想就是父View把自己的MeasureSpec // 传给子View结合子View自己的LayoutParams 算出子View 的MeasureSpec，然后继续往下传， // 传递叶子节点，叶子节点没有子View，根据传下来的这个MeasureSpec测量自己就好了。 measureChildWithMargins(child, widthMeasureSpec, 0, heightMeasureSpec, 0); final LayoutParams lp = (LayoutParams) child.getLayoutParams(); maxWidth = Math.max(maxWidth, child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin); maxHeight = Math.max(maxHeight, child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin); .... .... &#125;&#125;.......... //所有的孩子测量之后，经过一系类的计算之后通过setMeasuredDimension设置自己的宽高，//对于FrameLayout 可能用最大的字View的大小，对于LinearLayout，可能是高度的累加，//具体测量的原理去看看源码。总的来说，父View是等所有的子View测量结束之后，再来测量自己。 1234setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState), resolveSizeAndState(maxHeight, heightMeasureSpec, childState &lt;&lt; MEASURED_HEIGHT_STATE_SHIFT));....&#125; 到目前为止，基本把Measure 主要原理都过了一遍，接下来我们会结合实例来讲解整个match的过程，首先看下面的代码： 1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:id=&quot;@+id/linear&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;50dp&quot; android:background=&quot;@android:color/holo_blue_dark&quot; android:paddingBottom=&quot;70dp&quot; android:orientation=&quot;vertical&quot;&gt; &lt;TextView android:id=&quot;@+id/text&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;@color/material_blue_grey_800&quot; android:text=&quot;TextView&quot; android:textColor=&quot;@android:color/white&quot; android:textSize=&quot;20sp&quot; /&gt; &lt;View android:id=&quot;@+id/view&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;150dp&quot; android:background=&quot;@android:color/holo_green_dark&quot; /&gt;&lt;/LinearLayout&gt; 上面的代码对于出来的布局是下面的一张图 对于上面图可能有些不懂，这边做下说明: 整个图是一个DecorView,DecorView可以理解成整个页面的根View,DecorView是一个FrameLayout,包含两个子View，一个id=statusBarBackground的View和一个是LineaLayout，id=statusBarBackground的View，我们可以先不管（我也不是特别懂这个View,应该就是statusBar的设置背景的一个控件，方便设置statusBar的背景)，而这个LinearLayout比较重要，它包含一个title和一个content，title很好理解其实就是TitleBar或者ActionBar,content 就更简单了，setContentView()方法你应该用过吧，android.R.id.content 你应该听过吧，没错就是它,content是一个FrameLayout，你写的页面布局通过setContentView加进来就成了content的直接子View。 整个View的布局图如下： 这张图在下面分析measure，会经常用到，主要用于了解递归的时候view 的measure顺序 注:1、 header的是个ViewStub,用来惰性加载ActionBar，为了便于分析整个测量过程，我把Theme设成NoActionBar，避免ActionBar 相关的measure干扰整个过程，这样可以忽略掉ActionBar 的测量，在调试代码更清晰。2、包含Header(ActionBar）和id/content 的那个父View，我不知道叫什么名字好，我们姑且叫它ViewRoot（看上图）,它是垂直的LinearLayout，放着整个页面除statusBar 的之外所有的东西，叫它ViewRoot 应该还ok，一个代号而已。 既然我们知道整个View的Root是DecorView，那么View的绘制是从哪里开始的呢，我们知道每个Activity 均会创建一个 PhoneWindow对象，是Activity和整个View系统交互的接口，每个Window都对应着一个View和一个ViewRootImpl，Window和View通过ViewRootImpl来建立联系,对于Activity来说，ViewRootImpl是连接WindowManager和DecorView的纽带,绘制的入口是由ViewRootImpl的performTraversals方法来发起Measure，Layout，Draw等流程的。 我们来看下ViewRootImpl的performTraversals 方法： 123456789101112131415161718192021222324private void performTraversals() &#123; ...... int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width); int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height); ...... mView.measure(childWidthMeasureSpec, childHeightMeasureSpec); ......mView.layout(0, 0, mView.getMeasuredWidth(), mView.getMeasuredHeight());...... mView.draw(canvas); ......&#125;private static int getRootMeasureSpec(int windowSize, int rootDimension) &#123; int measureSpec; switch (rootDimension) &#123; case ViewGroup.LayoutParams.MATCH_PARENT: // Window can't resize. Force root view to be windowSize. measureSpec = MeasureSpec.makeMeasureSpec(windowSize,MeasureSpec.EXACTLY); break; ...... &#125; return measureSpec; &#125; performTraversals 中我们看到的mView其实就是DecorView,View的绘制从DecorView开始， 在mView.measure()的时候调用getRootMeasureSpec获得两个MeasureSpec做为参数，getRootMeasureSpec的两个参数（mWidth, lp.width）mWith和mHeight 是屏幕的宽度和高度， lp是WindowManager.LayoutParams，它的lp.width和lp.height的默认值是MATCH_PARENT,所以通过getRootMeasureSpec 生成的测量规格MeasureSpec 的mode是MATCH_PARENT ，size是屏幕的高宽。因为DecorView 是一个FrameLayout 那么接下来会进入FrameLayout 的measure方法，measure的两个参数就是刚才getRootMeasureSpec的生成的两个MeasureSpec，DecorView的测量开始了。首先是DecorView 的 MeasureSpec ，根据上面的分析DecorView 的 MeasureSpec是Windows传过来的，我们画出DecorView 的MeasureSpec 图： 注：1、-1 代表的是EXACTLY，-2 是AT_MOST2、由于屏幕的像素是1440x2560,所以DecorView 的MeasureSpec的size 对应于这两个值 那么接下来在FrameLayout 的onMeasure()方法DecorView开始for循环测量自己的子View,测量完所有的子View再来测量自己，由下图可知，接下来要测量ViewRoot的大小 1234567891011121314151617181920//FrameLayout 的测量protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; ....int maxHeight = 0;int maxWidth = 0;int childState = 0;for (int i = 0; i &lt; count; i++) &#123; final View child = getChildAt(i); if (mMeasureAllChildren || child.getVisibility() != GONE) &#123; // 遍历自己的子View，只要不是GONE的都会参与测量，measureChildWithMargins方法在最上面 // 的源码已经讲过了，如果忘了回头去看看，基本思想就是父View把自己当MeasureSpec // 传给子View结合子View自己的LayoutParams 算出子View 的MeasureSpec，然后继续往下穿， // 传递叶子节点，叶子节点没有子View，只要负责测量自己就好了。 measureChildWithMargins(child, widthMeasureSpec, 0, heightMeasureSpec, 0); .... .... &#125;&#125;....&#125; DecorView 测量ViewRoot 的时候把自己的widthMeasureSpec和heightMeasureSpec传进去了，接下来你就要去看measureChildWithMargins的源码了 123456789101112protected void measureChildWithMargins(View child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed) &#123; final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams(); final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin + widthUsed, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin + heightUsed, lp.height); child.measure(childWidthMeasureSpec, childHeightMeasureSpec);&#125; ViewRoot 是系统的View，它的LayoutParams默认都是match_parent,根据我们文章最开始MeasureSpec 的计算规则，ViewRoot 的MeasureSpec mode应该等于EXACTLY（DecorView MeasureSpec 的mode是EXACTLY，ViewRoot的layoutparams 是match_parent），size 也等于DecorView的size，所以ViewRoot的MeasureSpec图如下： 算出ViewRoot的MeasureSpec 之后，开始调用ViewRoot.measure 方法去测量ViewRoot的大小，然而ViewRoot是一个LinearLayout ，ViewRoot.measure最终会执行的LinearLayout 的onMeasure 方法，LinearLayout 的onMeasure 方法又开始逐个测量它的子View，上面的measureChildWithMargins方法又会被调用，那么根据View的层级图，接下来测量的是header（ViewStub）,由于header的Gone，所以直接跳过不做测量工作，所以接下来轮到ViewRoot的第二个child content（android.R.id.content）,我们要算出这个content 的MeasureSpec，所以又要拿ViewRoot 的MeasureSpec 和 android.R.id.content的LayoutParams 做计算了，计算过程就是调用getChildMeasureSpec的方法， 1234567891011121314protected void measureChildWithMargins(View child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed) &#123; ..... final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin + heightUsed, lp.height); ....&#125;public static int getChildMeasureSpec(int spec, int padding, int childDimension) &#123; int specMode = MeasureSpec.getMode(spec); //获得父View的mode int specSize = MeasureSpec.getSize(spec); //获得父View的大小 int size = Math.max(0, specSize - padding); //父View的大小-自己的Padding+子View的Margin，得到值才是子View可能的最大值。 .....&#125; 由上面的代码 1int size = Math.max(0, specSize - padding); 而1padding=mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin + heightUsed 算出android.R.id.content 的MeasureSpec 的size由于ViewRoot 的mPaddingBottom=100px(这个可能和状态栏的高度有关，我们测量的最后会发现id/statusBarBackground的View的高度刚好等于100px，ViewRoot 是系统的View的它的Padding 我们没法改变，所以计算出来Content（android.R.id.content） 的MeasureSpec 的高度少了100px ，它的宽高的mode 根据算出来也是EXACTLY（ViewRoot 是EXACTLY和android.R.id.content 是match_parent）。所以Content（android.R.id.content）的MeasureSpec 如下（高度少了100px）：Paste_Image.pngContent（android.R.id.content） 是FrameLayout，递归调用开始准备计算id/linear的MeasureSpec，我们先给出结果： 图中有两个要注意的地方：1、id/linear的heightMeasureSpec 的mode=AT_MOST，因为id/linear 的LayoutParams 的layout_height=”wrap_content”2、id/linear的heightMeasureSpec 的size 少了200px, 由上面的代码padding=mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin + heightUsed;int size = Math.max(0, specSize - padding);由于id/linear 的 android:layout_marginTop=”50dp” 使得lp.topMargin=200px (本设备的density=4，px=4*pd)，在计算后id/linear的heightMeasureSpec 的size 少了200px。（布局代码前面已给出，可自行查看id/linear 控件xml中设置的属性） linear.measure接着往下算linear的子View的的MeasureSpec，看下View 层级图，往下走应该是id/text,接下来是计算id/text的MeasureSpec，直接看图，mode=AT_MOST ,size 少了280，别问我为什么 …specSize - padding. 算出id/text 的MeasureSpec 后，接下来text.measure(childWidthMeasureSpec, childHeightMeasureSpec);准备测量id/text 的高宽，这时候已经到底了，id/text是TextView，已经没有子类了，这时候跳到TextView的onMeasure方法了。TextView 拿着刚才计算出来的heightMeasureSpec（mode=AT_MOST,size=1980）,这个就是对TextView的高度和宽度的约束，进到TextView 的onMeasure(widthMeasureSpec,heightMeasureSpec) 方法，在onMeasure 方法执行调试过程中，我们发现下面的代码： 123456int desired = getDesiredHeight(); desired = 107pxif(heightMode == MeasureSpec.AT_MOST)&#123; height = Math.min(desired,heightSize); height = 1980px &#125; setMeasuredDimension(width,height); TextView字符的高度（也就是TextView的content高度[wrap_content]）测出来=107px，107px 并没有超过1980px(允许的最大高度)，所以实际测量出来TextView的高度是107px。最终算出id/text 的mMeasureWidth=1440px,mMeasureHeight=107px。 贴一下布局代码，免得你忘了具体布局。 1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:id=&quot;@+id/linear&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;50dp&quot; android:background=&quot;@android:color/holo_blue_dark&quot; android:paddingBottom=&quot;70dp&quot; android:orientation=&quot;vertical&quot;&gt; &lt;TextView android:id=&quot;@+id/text&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;@color/material_blue_grey_800&quot; android:text=&quot;TextView&quot; android:textColor=&quot;@android:color/white&quot; android:textSize=&quot;20sp&quot; /&gt; &lt;View android:id=&quot;@+id/view&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;150dp&quot; android:background=&quot;@android:color/holo_green_dark&quot; /&gt;&lt;/LinearLayout&gt; TextView的高度已经测量出来了，接下来测量id/linear的第二个child（id/view），同样的原理测出id/view的MeasureSpec. id/view的MeasureSpec 计算出来后，调用view.measure(childWidthMeasureSpec, childHeightMeasureSpec)的测量id/view的高宽，之前已经说过View measure的默认实现是 12345protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasuredDimension( getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));&#125; 最终算出id/view的mMeasureWidth=1440px,mMeasureHeight=600px。 id/linear 的子View的高度都计算完毕了，接下来id/linear就通过所有子View的测量结果计算自己的高宽，id/linear是LinearLayout，所有它的高度计算简单理解就是子View的高度的累积+自己的Padding. 最终算出id/linear的mMeasureWidth=1440px,mMeasureHeight=987px。 最终算出id/linear出来后，id/content 就要根据它唯一的子View id/linear 的测量结果和自己的之前算出的MeasureSpec一起来测量自己的结果，具体计算的逻辑去看FrameLayout onMeasure 函数的计算过程。以此类推，接下来测量ViewRoot,然后再测量id/statusBarBackground,虽然不知道id/statusBarBackground 是什么，但是调试的过程中，测出的它的高度=100px, 和 id/content 的paddingTop 刚好相等。在最后测量DecorView 的高宽，最终整个测量过程结束。所有的View的大小测量完毕。所有的getMeasureWidth 和 getMeasureWidth 都已经有值了。Measure 分析到此为止 layout过程123mView.measure(childWidthMeasureSpec, childHeightMeasureSpec); ......mView.layout(0, 0, mView.getMeasuredWidth(), mView.getMeasuredHeight()); performTraversals 方法执行完mView.measure 计算出mMeasuredXXX后就开始执行layout 函数来确定View具体放在哪个位置，我们计算出来的View目前只知道view矩阵的大小，具体这个矩阵放在哪里，这就是layout 的工作了。layout的主要作用 ：根据子视图的大小以及布局参数将View树放到合适的位置上。 既然是通过mView.layout(0, 0, mView.getMeasuredWidth(), mView.getMeasuredHeight()); 那我们来看下layout 函数做了什么，mView肯定是个ViewGroup，不会是View,我们直接看下ViewGroup 的layout函数 1234567891011public final void layout(int l, int t, int r, int b) &#123; if (!mSuppressLayout &amp;&amp; (mTransition == null || !mTransition.isChangingLayout())) &#123; if (mTransition != null) &#123; mTransition.layoutChange(this); &#125; super.layout(l, t, r, b); &#125; else &#123; // record the fact that we noop'd it; request layout when transition finishes mLayoutCalledWhileSuppressed = true; &#125;&#125; 代码可以看个大概，LayoutTransition是用于处理ViewGroup增加和删除子视图的动画效果，也就是说如果当前ViewGroup未添加LayoutTransition动画，或者LayoutTransition动画此刻并未运行，那么调用super.layout(l, t, r, b)，继而调用到ViewGroup中的onLayout，否则将mLayoutSuppressed设置为true，等待动画完成时再调用requestLayout()。这个函数是final 不能重写，所以ViewGroup的子类都会调用这个函数，layout 的具体实现是在super.layout(l, t, r, b)里面做的，那么我接下来看一下View类的layout函数 12345678910111213141516public final void layout(int l, int t, int r, int b) &#123; ..... //设置View位于父视图的坐标轴 boolean changed = setFrame(l, t, r, b); //判断View的位置是否发生过变化，看有必要进行重新layout吗 if (changed || (mPrivateFlags &amp; LAYOUT_REQUIRED) == LAYOUT_REQUIRED) &#123; if (ViewDebug.TRACE_HIERARCHY) &#123; ViewDebug.trace(this, ViewDebug.HierarchyTraceType.ON_LAYOUT); &#125; //调用onLayout(changed, l, t, r, b); 函数 onLayout(changed, l, t, r, b); mPrivateFlags &amp;= ~LAYOUT_REQUIRED; &#125; mPrivateFlags &amp;= ~FORCE_LAYOUT; ..... &#125; 1、setFrame(l, t, r, b) 可以理解为给mLeft 、mTop、mRight、mBottom赋值，然后基本就能确定View自己在父视图的位置了，这几个值构成的矩形区域就是该View显示的位置，这里的具体位置都是相对与父视图的位置。 2、回调onLayout，对于View来说，onLayout只是一个空实现，一般情况下我们也不需要重载该函数,： 123protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123; &#125; 对于ViewGroup 来说，唯一的差别就是ViewGroup中多了关键字abstract的修饰，要求其子类必须重载onLayout函数。 123@Override protected abstract void onLayout(boolean changed, int l, int t, int r, int b); 而重载onLayout的目的就是安排其children在父视图的具体位置，那么如何安排子View的具体位置呢？ 123456int childCount = getChildCount() ; for(int i=0 ;i&lt;childCount ;i++)&#123; View child = getChildAt(i) ; //整个layout()过程就是个递归过程 child.layout(l, t, r, b) ; &#125; 代码很简单，就是遍历自己的孩子，然后调用 child.layout(l, t, r, b) ，给子view 通过setFrame(l, t, r, b) 确定位置，而重点是(l, t, r, b) 怎么计算出来的呢。还记得我们之前测量过程，测量出来的MeasuredWidth和MeasuredHeight吗？还记得你在xml 设置的Gravity吗？还有RelativeLayout 的其他参数吗，没错，就是这些参数和MeasuredHeight、MeasuredWidth 一起来确定子View在父视图的具体位置的。具体的计算过程大家可以看下最简单FrameLayout 的onLayout 函数的源码，每个不同的ViewGroup 的实现都不一样，这边不做具体分析了吧。 3、MeasuredWidth和MeasuredHeight这两个参数为layout过程提供了一个很重要的依据（如果不知道View的大小，你怎么固定四个点的位置呢），但是这两个参数也不是必须的，layout过程中的4个参数l, t, r, b完全可以由我们任意指定，而View的最终的布局位置和大小（mRight - mLeft=实际宽或者mBottom-mTop=实际高）完全由这4个参数决定，measure过程得到的mMeasuredWidth和mMeasuredHeight提供了视图大小测量的值，但我们完全可以不使用这两个值，所以measure过程并不是必须的。如果我们不使用这两个值，那么getMeasuredWidth() 和getWidth() 就很有可能不是同一个值，它们的计算是不一样的： 123456public final int getMeasuredWidth() &#123; return mMeasuredWidth &amp; MEASURED_SIZE_MASK; &#125; public final int getWidth() &#123; return mRight - mLeft; &#125; layout 过程相对简单些，分析就到此为止。 draw过程performTraversals 方法的下一步就是mView.draw(canvas); 因为View的draw 方法一般不去重写，官网文档也建议不要去重写draw 方法，所以下一步执行就是View.java的draw 方法，我们来看下源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public void draw(Canvas canvas) &#123; ... /* * Draw traversal performs several drawing steps which must be executed * in the appropriate order: * * 1. Draw the background * 2. If necessary, save the canvas' layers to prepare for fading * 3. Draw view's content * 4. Draw children * 5. If necessary, draw the fading edges and restore layers * 6. Draw decorations (scrollbars for instance) */ // Step 1, draw the background, if needed ... background.draw(canvas); ... // skip step 2 &amp; 5 if possible (common case) ... // Step 2, save the canvas' layers ... if (solidColor == 0) &#123; final int flags = Canvas.HAS_ALPHA_LAYER_SAVE_FLAG; if (drawTop) &#123; canvas.saveLayer(left, top, right, top + length, null, flags); &#125; ... // Step 3, draw the content if (!dirtyOpaque) onDraw(canvas); // Step 4, draw the children dispatchDraw(canvas); // Step 5, draw the fade effect and restore layers if (drawTop) &#123; matrix.setScale(1, fadeHeight * topFadeStrength); matrix.postTranslate(left, top); fade.setLocalMatrix(matrix); canvas.drawRect(left, top, right, top + length, p); &#125; ... // Step 6, draw decorations (scrollbars) onDrawScrollBars(canvas); &#125; 注释写得比较清楚，一共分成6步，看到注释没有（ // skip step 2 &amp; 5 if possible (common case)）除了2 和 5之外 我们一步一步来看：1、第一步：背景绘制看注释即可，不是重点 12345678910111213private void drawBackground(Canvas canvas) &#123; Drawable final Drawable background = mBackground; ...... //mRight - mLeft, mBottom - mTop layout确定的四个点来设置背景的绘制区域 if (mBackgroundSizeChanged) &#123; background.setBounds(0, 0, mRight - mLeft, mBottom - mTop); mBackgroundSizeChanged = false; rebuildOutline(); &#125; ...... //调用Drawable的draw() 把背景图片画到画布上 background.draw(canvas); ...... &#125; 2、第三步，对View的内容进行绘制。onDraw(canvas) 方法是view用来draw 自己的，具体如何绘制，颜色线条什么样式就需要子View自己去实现，View.java 的onDraw(canvas) 是空实现，ViewGroup 也没有实现，每个View的内容是各不相同的，所以需要由子类去实现具体逻辑。 3、第4步 对当前View的所有子View进行绘制dispatchDraw(canvas) 方法是用来绘制子View的，View.java 的dispatchDraw()方法是一个空方法,因为View没有子View,不需要实现dispatchDraw ()方法，ViewGroup就不一样了，它实现了dispatchDraw ()方法： 1234567891011121314151617181920@Override protected void dispatchDraw(Canvas canvas) &#123; ... if ((flags &amp; FLAG_USE_CHILD_DRAWING_ORDER) == 0) &#123; for (int i = 0; i &lt; count; i++) &#123; final View child = children[i]; if ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) &#123; more |= drawChild(canvas, child, drawingTime); &#125; &#125; &#125; else &#123; for (int i = 0; i &lt; count; i++) &#123; final View child = children[getChildDrawingOrder(count, i)]; if ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) &#123; more |= drawChild(canvas, child, drawingTime); &#125; &#125; &#125; ...... &#125; 代码一眼看出，就是遍历子View然后drawChild(),drawChild()方法实际调用的是子View.draw()方法,ViewGroup类已经为我们实现绘制子View的默认过程，这个实现基本能满足大部分需求，所以ViewGroup类的子类（LinearLayout,FrameLayout）也基本没有去重写dispatchDraw方法，我们在实现自定义控件，除非比较特别，不然一般也不需要去重写它， drawChild()的核心过程就是为子视图分配合适的cavas剪切区，剪切区的大小正是由layout过程决定的，而剪切区的位置取决于滚动值以及子视图当前的动画。设置完剪切区后就会调用子视图的draw()函数进行具体的绘制了。 4、第6步 对View的滚动条进行绘制不是重点，知道有这东西就行，onDrawScrollBars 的一句注释 ：Request the drawing of the horizontal and the vertical scrollbar. The scrollbars are painted only if they have been awakened first. 一张图看下整个draw的递归流程。 到此整个绘制过程基本讲述完毕了。","categories":[{"name":"Android","slug":"Android","permalink":"http://wenyiqingnian.xyz/categories/Android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://wenyiqingnian.xyz/tags/android/"}]},{"title":"linux用户控件、内和空间","slug":"Linux 用户空间 内核空间","date":"2017-09-07T12:30:15.000Z","updated":"2018-05-06T13:11:43.893Z","comments":true,"path":"2017/09/07/Linux 用户空间 内核空间/","link":"","permalink":"http://wenyiqingnian.xyz/2017/09/07/Linux 用户空间 内核空间/","excerpt":"","text":"用户空间就是用户进程所在的内存区域，相对的，系统空间就是操作系统占据的内存区域。 用户进程和系统进程的所有数据都在内存中。 是谁来划分内存空间的呢？ 在电脑开机之前，内存就是一块原始的物理内存。什么也没有。开机加电，系统启动后，就对物理内存进行了划分。当然，这是系统的规定，物理内存条上并没有划分好的地址和空间范围。这些划分都是操作系统在逻辑上的划分。不同版本的操作系统划分的结果都是不一样的。 为什么要划分用户空间和系统空间呢？当然是有必要的。操作系统的数据都是存放于系统空间的，用户进程的数据是存放于用户空间的。这是第一点，不同的身份，数据放置的位置必然不一样，否则大混战就会导致系统的数据和用户的数据混在一起，系统就不能很好的运行了。分开来存放，就让系统的数据和用户的数据互不干扰，保证系统的稳定性。分开存放，管理上很方便，而更重要的是，将用户的数据和系统的数据隔离开，就可以对两部分的数据的访问进行控制。这样就可以确保用户程序不能随便操作系统的数据，这样防止用户程序误操作或者是恶意破坏系统。 处于用户态的程序只能访问用户空间，而处于内核态的程序可以访问用户空间和内核空间。那么用户态和内核态有什么区别呢？ 当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）。此时处理器处于特权级最高的（0级）内核代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。当进程在执行用户自己的代码时，则称其处于用户运行态（用户态）。即此时处理器在特权级最低的（3级）用户代码中运行。 内核态与用户态是操作系统的两种运行级别,Intel x86架构提供Ring0-Ring3四种级别的运行模式，Ring0级别最高，Ring3最低。Linux使用了Ring3级别运行用户态，Ring0作为 内核态，没有使用Ring1和Ring2。Ring3状态不能访问Ring0的地址空间，包括代码和数据。程序特权级别的不同，其所拥有的权力也不同。如下图所示。 用户态切换到内核态的3种方式 a. 系统调用 这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作，比如fork()实际上就是执行了一个创建新进程的系统调用。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断。 b. 异常 当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。 c. 外围设备的中断 当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。 这3种方式是系统在运行时由用户态转到内核态的最主要方式，其中系统调用可以认为是用户进程主动发起的，异常和外围设备中断则是被动的。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://wenyiqingnian.xyz/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://wenyiqingnian.xyz/tags/linux/"}]},{"title":"webrtc音频总结","slug":"webrtc 音频","date":"2017-08-16T13:10:30.000Z","updated":"2018-05-06T13:37:22.813Z","comments":true,"path":"2017/08/16/webrtc 音频/","link":"","permalink":"http://wenyiqingnian.xyz/2017/08/16/webrtc 音频/","excerpt":"","text":"webrtc/modules/audio_device/android/audio_record_jni.cc 这个文件，是音频采集jni类文件。 Android Audio Record 和 JNI 通信接口包括： 123// java 调用 c++ 接口nativeCacheDirectBufferAddressnativeDataIsRecorded 123456// c++ 回调 java 接口initRecordingstartRecordingstopRecordingenableBuiltInAECenableBuiltInNS nativeCacheDirectBufferAddress 和 nativeDataIsRecorded 只是为了高效的将 AudioRecord 采集到的音频数据传递给 native。 WebRtcVoiceEngineWebRtcVoiceEngine 初始化 12345678910111213WebRtcVoiceEngine::Init()&#123; send_codecs_ = CollectCodecs(encoder_factory_-&gt;GetSupportedEncoders()); recv_codecs_ = CollectCodecs(decoder_factory_-&gt;GetSupportedDecoders()); adm_ = webrtc::AudioDeviceModule::Create( webrtc::AudioDeviceModule::kPlatformDefaultAudio ); webrtc::adm_helpers::Init(adm()); webrtc::apm_helpers::Init(apm());&#125; 可知，WebRtcVoiceEngine 里面的 adm_ 就是 AudioDeviceModule ，代码在 /modules/audio_device/audio_device_impl.cc 在 webrtcvoiceengine.h123456789101112131415161718192021222324252627// WebRtcVoiceEngine//public void Init();AudioState GetAudioState();VoiceMediaChannel* CreateChannel(Call call, MediaConfig config, AudioOptions options);AudioCodec send_codecs();AudioCodec recv_codecs();RtpCapabilities GetCapabilities();void RegisterChannel(WebRtcVoiceMediaChannel* channel);void UnregisterChannel(WebRtcVoiceMediaChannel* channel);bool StartAecDump();void StopAecDump();//privateAudioDeviceModule adm_;AudioEncoderFactory encoder_factory_;AudioDecoderFactory decoder_factory_;AudioMixer audio_mixer_;AudioProcessing apm_;AudioState audio_state_;AudioCodec send_codecs_;AudioCodec recv_codecs_;WebRtcVoiceMediaChannel channels_; audio_device//webrtc/modules/audio_device/ audio_device_impl.cc 123456789AudioDeviceModule::Create()&#123; audioDevice(new AudioDeviceModuleImpl(audio_layer)); audioDevice-&gt;CheckPlatform(); audioDevice-&gt;CreatePlatformSpecificObjects(); audioDevice-&gt;AttachAudioBuffer(); return audioDevice;&#125; 123456789101112131415161718192021222324252627282930313233343536373839AudioDeviceModuleImpl::CreatePlatformSpecificObjects()&#123; // WEBRTC_DUMMY_AUDIO_BUILD audio_device_.reset(new AudioDeviceDummy()); // WEBRTC_DUMMY_FILE_DEVICES audio_device_.reset(FileAudioFactory::CreateFileAudioDevice()); // WEBRTC_WINDOWS_CORE_AUDIO_BUILD audio_device_.reset(new AudioDeviceWindowsCore()); // WEBRTC_ANDROID audio_manager_android_.reset(new AudioManager()); if(audio_layer == kPlatformDefaultAudio)&#123; audio_layer = kAndroidOpenSLESAudio; &#125; else if(isLowLatencySupported)&#123; audio_layer = kAndroidJavaInputAndroidOpenSLESOutputAudio; &#125; else &#123; audio_layer = kAndroidJavaAudio; &#125; if(kAndroidJavaAudio)&#123; audio_device_.reset(new AudioDeviceTemplate&lt;AudioRecordJni, AudioTrackJni&gt;()) &#125; else if(kAndroidOpenSLESAudio)&#123; audio_device_.reset(new AudioDeviceTemplate&lt;OpenSLESRecorder, OpenSLESPlayer&gt;()); &#125; else if(kAndroidJavaInputAndOpenSLESOutputAudio)&#123; audio_device_.reset(new AudioDeviceTemplate&lt;AudioRecordJni, OpenSLESPlayer&gt;()) &#125; // WEBRTC_LINUX if(kLinuxPulseAudio || kPlatformDefaultAudio)&#123; audio_device_.reset(new AudioDeviceLinuxPulse()) &#125; else if(kLinuxAlsaAudio)&#123; audio_device_.reset(new AudioDeviceLinuxALSA()) &#125; // WEBRTC_IOS audio_device_.reset(new AudioDeviceIOS()) // WEBRTC_MAC audio_device_.reset(new AudioDeviceMac())&#125; 我们以 Android 为例；使用 AudioDeviceTemplate 封装 音频输入（采集）、输出类型（渲染）；目前使用 AudioRecordJni 和 AudioTrackJni。如果直接使用 NDK 的openSLES 开发的化，使用的是 OpenSLESRecorder 和 OpenSLESPlayer。 audio_manager.h12345678910// JavaAudioManagerbool Init()void Close()bool IsCommunicationModeEnabled()bool IsDeviceBlacklistedForOpenSLESUsage()// privateJNICALL CacheAudioParameters()void OnCacheAudioParameters() audio_record_jni.h1234567891011121314151617181920212223242526272829//JavaAudioRecordint InitRecording(int sample_reate, size_t channels);bool StartRecording();bool StopRecording();bool EnableBuiltInAEC(bool enable);bool EnableBuiltInNS(bool enable);// publicint32_t Init();int32_t Terminate();int32_t InitRecording();bool RecordingIsInitialized();int32_t StartRecording();int32_t StopRecording();bool Recording();void AttachAudioBuffer();int32_t EnableBuiltInAEC(bool enable);int32_t EnableBuiltInAGC(bool enable);int32_t EnableBuiltInNS(bool enable);// privateJNICALL CacheDirectBufferAddress()void OnCacheDirectBufferAddress(jobject byte_buffer)JNICALL DataIsRecorded();void OnDataIsRecorded(int length); audio_track_jni.h 12345678910111213141516171819202122232425262728293031// JavaAudioTrackbool InitPlayout(int sample_rate, int channels);bool StartPlayout();bool StopPlayout();bool SetStreamVolume(int volume);int GetStreamMaxVolume();int GetStreamVolume();// publicInit()Terminate()InitPlayout()PlayoutIsInitialized()StartPlayout()StopPlayout()Playing()SpeakerVolumeIsAvailable(bool available);SetSpeakerVolume(volume);SpeakerVolume(volume);MaxSpeakerVolume(max_volume);MinSpeakerVolume(min_volume);AttachAudioBuffer(audioBuffer);// privateJNICALL CacheDirectBufferAddress();void OnCacheDirectBufferAddress(jobject byte_buffer);JNICALL GetPlayoutData();void OnGetPlayoutData(size_t length); AudioRecordJni音频采集初始化AudioRecordJni 初始化时，在构造方法中初始化 JavaAudioRecord。123j_audio-record_.reset( new JavaAudioRecord()) 然后在 webrtcvoiceengine 中 AddSendStream 后，SetSend() 配置媒体通道发送。 12345678910111213//media/engine/webrtcvoiceengine.ccWebRtcVoiceMediaChannel::SetSend(bool send)&#123; ... if(send)&#123; engine()-&gt;ApplyOptions(options_); if(!engine()-&gt;adm()-&gt;RecordingIsInitialized() &amp;&amp; !engine()-&gt;adm()-&gt;Recording())&#123; engine()-&gt;adm()-&gt;InitRecording(); &#125; &#125; ...&#125; 这里面会初始化 AudioRecord。 InitRecording() 方法实现，在 Android 中实在 audio_record_jni.cc 的 JavaAudioRecord::InitRecording() ，最终通过 JNI 回调 Java 层的 InitRecording() 方法。 音频采集初始化完成后，就要开始采集音频数据。 /audio/audio_send_stream.cc音频发送流里面 AudioSendStream::Start() 方法启动音频流发送； 1234AudioSendSstream::Start()&#123; channel_proxy_-&gt;StartSend(); audio_state()-&gt;AddSendingStream(this, encoder_sample_rate_hz_, encoder_num_channels_);&#125; 调用 /audio/audio_state.cc 的 AudioState::AddSendingStream() 方法； 123456AudioState::AddSendingStream()&#123; auto* adm = config_.audio_device_module.get(); ... amd-&gt;StartRecording(); ...&#125; 音频开关另外，PeerConnection 提供了 音频采集开关。 1234//org.webrtc.PeerConnection.javapublic void setAudioRecording(boolean recording)&#123; nativeSetAudioRecording();&#125; 对应的JNI方法1234//JNI/pc/peerconnection.ccvoid JNI_PeerConnection_SetAudioRecording()&#123; ExtractNativePC(jni,j_pc)-&gt;SetAudioRecording(recording);&#125; 其实JNI方法也是调用 webrtc 的 peerconnection 1234567//webrtc/pc/peerconnection.ccPeerConnection::SetAudioRecording(bool recording)&#123; auto audio_state = factory_-&gt;channel_manager()-&gt;media_engine()-&gt;GetAudioState(); // AudioState audio_state-&gt;SetRecording(recording);&#125; 由上代码可知， 通过 WebRtcVoiceEngine 的 GetAudioState() 方法获取 audio_state。然后通过 audio_state 设置音频采集开关。 在 AudioState::SetRecording() 方法调用具体设备模块开始或停止音频采集。 123456789//webrtc/audio/audio_state.ccAudioState::SetRecording(bool enabled)&#123; ... if(enabled)&#123; config_.audio_device_module-&gt;StartRecording(); &#125;else&#123; config_.audio_device_module-&gt;StopRecording(); &#125;&#125; 音频采集具体实现这里我们只以Android为例。 如果使用 opensles ndk 采集音频，采集的具体实现在 opensles_recorder.cc 文件的 StartRecording() 方法。 1234// modules/audio_device/android/opensles_recorder.ccint OpenSLESRecorder::StartRecording()&#123; ...&#125; 这种方法的具体实现我们暂时不深入。 我们讨论 java 实现方案。 java 实现的jni类，audio_record_jni.cc123456//modules/audio_device/android/audio_record_jni.ccAudioRecordJni::StartRecording()&#123; ... j_audio_record_-&gt;StartRecording() ...&#125; j_audio_record_-&gt;StartRecording() 调用的就是 AudioRecordJni::JavaAudioRecord::StartRecording() 方法。 123AudioRecordJni::JavaAudioRecord::StartRecording()&#123; return audio_record_-&gt;CallBooleanMethod(start_recording_);&#125; CallBooleanMethod 就是jni回调java 实现的封装，最终实现回调 WebRtcAudioRecord.java 中的 StartRecording() 方法。 123456//org.webrtc.voiceengine.WebRtcAudioRecord.java boolean startRecording()&#123; audioRecord.startRecording(); audioThread = new AudioRecordThread(&quot;AudioRecordJavaThread&quot;); audioThread.start();&#125; 音频采集线程音频采集线 AudioRecordThread；我们只跟踪 run() 方法。 123456789101112131415161718@Overridepublic void run()&#123; ... while(keepAlive)&#123; int bytesRead = audioRecord.read(byteBuffer, byteBuffer.capacity()); // 通知 native 音频数据 nativeDataIsRecorded(bytesRead, nativeAudioRecord); // 应用音频采集回调 byte[] data = Arrays.copyOf(byteBuffer.array(), byteBuffer.capacity()); audioSamplesReadyCallback.onWebRtcAudioRecordSamplesReady( new AudioSamples(audioRecord, data) ); &#125; ...&#125;","categories":[{"name":"webrtc","slug":"webrtc","permalink":"http://wenyiqingnian.xyz/categories/webrtc/"}],"tags":[{"name":"webrtc","slug":"webrtc","permalink":"http://wenyiqingnian.xyz/tags/webrtc/"}]},{"title":"MK语法规范","slug":"MK语法规范","date":"2017-05-07T12:11:15.000Z","updated":"2018-05-06T13:07:44.655Z","comments":true,"path":"2017/05/07/MK语法规范/","link":"","permalink":"http://wenyiqingnian.xyz/2017/05/07/MK语法规范/","excerpt":"","text":"Android.mk文件语法规范及使用模板 Introduction:Android.mk编译文件是用来向Android NDK描述你的C,C++源代码文件的， 这篇文档描述了它的语法。在阅读下面的内容之前，假定你已经阅读了docs/OVERVIEW.TXT文件，了解了它们的用途。 概述:一个 Android.mk file用来向编译系统描述你的源代码。具体来说：-该文件是GNU Makefile的一小部分，会被编译系统解析一次或更多次的build系统。因此，您应尽量减少您声明的变量，不要认为某些变量在解析过程中不会被定义。-这个文件的语法允许把你的源代码组织成模块，一个模块属下列类型之一： 静态库 、共享库 只有共享库将被安装/复制到您的应用软件包。虽然静态库能被用于生成共享库。 你可以在每一个Android.mk file中定义一个或多个模块，你也可以在几个模块中使用同一个源代码文件。 -编译系统为你处理许多细节问题。例如，你不需要在你的Android.mk中列出头文件和依赖文件。NDK编译系统将会为你自动处理这些问题。这也意味着，在升级NDK后，你应该得到新的toolchain/platform支持，而且不需要改变你的Android.mk文件。 注意，这个语法同公开发布的Android平台的开源代码很接近，然而编译系统实现他们的方式却是不同的，这是故意这样设计的，可以让程序开发人员重用外部库的源代码更容易。 简单的例子: 在描述语法细节之前，咱们来看一个简单的”hello world”的例子，比如，下面的文件： 123sources/helloworld/helloworld.csources/helloworld/Android.mk ‘helloworld.c’是一个JNI共享库，实现返回”hello world”字符串的原生方法。 相应的Android.mk文件会象下面这样： 12345678910111213---------- cut here ------------------LOCAL_PATH := $(call my-dir)include $(CLEAR_VARS)LOCAL_MODULE:= helloworldLOCAL_SRC_FILES := helloworld.cinclude $(BUILD_SHARED_LIBRARY)---------- cut here ------------------ 好，我们来解释一下这几行代码： 1LOCAL_PATH := $(call my-dir) 一个Android.mk file首先必须定义好LOCAL_PATH变量。它用于在开发树中查找源文件。在这个例子中，宏函数’my-dir’, 由编译系统提供，用于返回当前路径（即包含Android.mk file文件的目录）。 1include $( CLEAR_VARS) CLEAR_VARS由编译系统提供，指定让GNU MAKEFILE为你清除许多LOCAL_XXX变量（例如 LOCAL_MODULE, LOCAL_SRC_FILES, LOCAL_STATIC_LIBRARIES, 等等…), 除LOCAL_PATH 。这是必要的，因为所有的编译控制文件都在同一个GNU MAKE执行环境中，所有的变量都是全局的。 1LOCAL_MODULE := helloworld LOCAL_MODULE变量必须定义，以标识你在Android.mk文件中描述的每个模块。名称必须是唯一的，而且不包含任何空格。注意编译系统会自动产生合适的前缀和后缀，换句话说，一个被命名为’foo’的共享库模块，将会生成’libfoo.so’文件。 重要注意事项 如果你把库命名为‘libhelloworld’，编译系统将不会添加任何的lib前缀，也会生成libhelloworld.so，这是为了支持来源于Android平台的源代码的Android.mk文件，如果你确实需要这么做的话。 1LOCAL_SRC_FILES := helloworld.c LOCAL_SRC_FILES变量必须包含将要编译打包进模块中的C或C++源代码文件。注意，你不用在这里列出头文件和包含文件，因为编译系统将会自动为你找出依赖型的文件；仅仅列出直接传递给编译器的源代码文件就好。【注意，默认的C++源码文件的扩展名是’.cpp’. 指定一个不同的扩展名也是可能的，只要定义LOCAL_DEFAULT_CPP_EXTENSION变量，不要忘记开始的小圆点（也就是定义为‘.cxx’,而不是‘cxx’）（当然这一步我们一般不会去改它）】 1include $(BUILD_SHARED_LIBRARY) BUILD_SHARED_LIBRARY是编译系统提供的变量，指向一个GNU Makefile脚本（应该就是在build/core目录下的shared_library.mk），负责收集自从上次调用’include $(CLEAR_VARS)’以来，定义在LOCAL_XXX变量中的所有信息，并且决定编译什么，如何正确地去做。并根据其规则生成静态库。同理对于静态库。 在sources/samples目录下有更复杂一点的例子，写有注释的Android.mk文件，你可以看看。 参考: 这是一份你应该在Android.mk中依赖或定义的变量列表，您可以定义其他变量为自己使用， 但是NDK编译系统保留下列变量名： -以LOCAL_开头的名字（例如 LOCAL_MODULE） -以PRIVATE_, NDK_ or APP_开头的名字（内部使用） -小写名字（内部使用，例如’my-dir’） 如果您为了方便在Android.mk中定义自己的变量，我们建议使用MY_前缀，一个小例子： 12345678910111213---------- cut here ------------------MY_SOURCES := foo.cifneq ($(MY_CONFIG_BAR),)MY_SOURCES += bar.cendifLOCAL_SRC_FILES += $(MY_SOURCES)---------- cut here ------------------ 这些GNU Make 变量在你的Android.mk文件解析之前，就由编译系统定义好了。 注意在某些情况下，NDK可能分析Android.mk几次，每一次某些变量的定义会有不同。 1CLEAR_VARS 指向一个编译脚本，几乎所有未定义的LOCAL_XXX变量都在”Module-description”节中列出。 你必须在开始一个新模块之前包含这个脚本。 1include $(CLEAR_VARS) 1BUILD_SHARED_LIBRARY 指向编译脚本，收集所有的你在LOCAL_XXX变量中提供的信息，并且决定如何把你列出的源代码文件编译成一个共享库。注意，你必须至少在包含这个文件之前定义LOCAL_MODULE和LOCAL_SRC_FILES，使用例子： 1include $(BUILD_SHARED_LIBRARY) 注意这将生成一个名为lib$(LOCAL_MODULE).so的文件。 1BUILD_STATIC_LIBRARY 一个BUILD_SHARED_LIBRARY变量用于编译一个静态库。静态库不会复制到你的project/packages中，诞生能够用于编译共享库，（看下面描述的LOCAL_STATIC_LIBRARIES and LOCAL_STATIC_WHOLE_LIBRARIES） 使用例子： 1include $(BUILD_STATIC_LIBRARY) 注意，这将会生成一个名为lib$(LOCAL_MODULE).a的文件。 1TARGET_ARCH 目标CPU平台的名字，如同在android开放源码中指定的那样。如果是’arm’，表示要生成ARM兼容的指令，与CPU架构的修订版无关。 1TARGET_PLATFORM Android.mk解析的时候，目标Android平台的名字.详情可参考/development/ndk/docs/stable-apis.txt. android-3 -&gt; Official Android 1.5 system images android-4 -&gt; Official Android 1.6 system images android-5 -&gt; Official Android 2.0 system images 1TARGET_ARCH_ABI 暂时只支持两个value，armeabi和armeabi-v7a。在现在的版本中一般把这两个值简单的定义为arm，通过android 平台内部对它重定义来获得更好的匹配。 其他的ＡＢＩ将在以后的ＮＤＫ版本中介绍，它们会有不同的名字。注意所有基于ＡＲＭ的ＡＢＩ都会把’TARGET_ARCH’定义成‘ａｒｍ’，但是会有不同的‘TARGET_ARCH_ABI’ 1TARGET_ABI 目标平台和ABI的组合，它事实上被定义成$(TARGET_PLATFORM)-$(TARGET_ARCH_ABI) 在你想要在真实的设备中针对一个特别的目标系统进行测试时，会有用。在默认的情况下，它会是’android-3-arm’。 /*/ 下面是GNU Make ‘功能’宏，必须通过使用’$(call )’来求值，他们返回文本化的信息。 1my-dir 返回当前Android.mk所在的目录路径，相对于ＮＤＫ编译系统的顶层。这是有用的，在Android.mk文件的开头如此定义： 1LOCAL_PATH := $(call my-dir) 1all-subdir-makefiles 返回一个位于当前’my-dir’路径的子目录列表。例如，看下面的目录层次： 12345sources/foo/Android.mksources/foo/lib1/Android.mksources/foo/lib2/Android.mk 如果sources/foo/Android.mk包含一行： 1include $(call all-subdir-makefiles) 那么它就会自动包含sources/foo/lib1/Android.mk 和sources/foo/lib2/Android.mk 这项功能用于向编译系统提供深层次嵌套的代码目录层次。注意，在默认情况下，ＮＤＫ将会只搜索在sources/*/Android.mk中的文件。 1this-makefile 返回当前Makefile的路径（即这个函数调用的地方） 1parent-makefile 返回调用树中父Makefile路径。即包含当前Makefile的Makefile路径。 1grand-parent-makefile 猜猜看… /*/ 模块描述变量:下面的变量用于向编译系统描述你的模块。你应该定义在’include $(CLEAR_VARS)’和’include $(BUILD_XXXXX)’之间定义。正如前面描写的那样，$(CLEAR_VARS是一个脚本，清除所有这些变量，除非在描述中显式注明。 1LOCAL_PATH 这个变量用于给出当前文件的路径。你必须在Android.mk的开头定义，可以这样使用： 1LOCAL_PATH := $(call my-dir) 这个变量不会被$(CLEAR_VARS)清除，因此每个Android.mk只需要定义一次（即使你在一个文件中定义了几个模块的情况下）。 1LOCAL_MODULE 这是你模块的名字，它必须是唯一的，而且不能包含空格。你必须在包含任一的$(BUILD_XXXX)脚本之前定义它。模块的名字决定了生成文件的名字，例如，如果一个一个共享库模块的名字是，那么生成文件的名字就是lib.so。但是，在你的NDK生成文件中（或者Android.mk或者Application.mk），你应该只涉及(引用)有正常名字的其他模块。 1LOCAL_SRC_FILES 这是要编译的源代码文件列表。只要列出要传递给编译器的文件，因为编译系统自动为你计算依赖。 注意源代码文件名称都是相对于LOCAL_PATH的，你可以使用路径部分，例如： 1LOCAL_SRC_FILES := foo.c \\ toto/bar.c注意：在生成文件中都要使用UNIX风格的斜杠(/).windows风格的反斜杠不会被正确的处理。 1LOCAL_CPP_EXTENSION 这是一个可选变量，用来指定C++代码文件的扩展名，默认是’.cpp’,但是你可以改变它，比如： 1LOCAL_CPP_EXTENSION := .cxx 1LOCAL_C_INCLUDES 路径的可选配置，是从根目录开始的， 123456789all sources (C, C++ and Assembly). For example: LOCAL_C_INCLUDES := sources/foo Or even: LOCAL_C_INCLUDES := $(LOCAL_PATH)/../foo 需要在任何包含LOCAL_CFLAGS / LOCAL_CPPFLAGS标志之前。 1LOCAL_CFLAGS 可选的编译器选项，在编译C代码文件的时候使用。 这可能是有用的，指定一个附加的包含路径（相对于NDK的顶层目录），宏定义，或者编译选项。 重要信息：不要在Android.mk中改变optimization/debugging级别，只要在Application.mk中指定合适的信息，就会自动地为你处理这个问题，在调试期间，会让ＮＤＫ自动生成有用的数据文件。 123LOCAL_CXXFLAGSSame as LOCAL_CFLAGS for C++ source files 1LOCAL_CPPFLAGS 与LOCAL_CFLAGS相同，但是对C 和 C++ source files都适用。 1LOCAL_STATIC_LIBRARIES 应该链接到这个模块的静态库列表（使用BUILD_STATIC_LIBRARY生成），这仅仅对共享库模块才有意义。 1LOCAL_SHARED_LIBRARIES 这个模块在运行时要依赖的共享库模块列表，在链接时需要，在生成文件时嵌入的相应的信息。注意：这不会附加列出的模块到编译图，也就是，你仍然需要在Application.mk中把它们添加到程序要求的模块中。 1LOCAL_LDLIBS 编译你的模块要使用的附加的链接器选项。这对于使用”-l”前缀传递指定库的名字是有用的。例如，下面将告诉链接器生成的模块要在加载时刻链接到/system/lib/libz.so 1LOCAL_LDLIBS := -lz 看docs/STABLE-APIS.TXT获取你使用NDK发行版能链接到的开放的系统库列表。 1LOCAL_ALLOW_UNDEFINED_SYMBOLS 默认情况下，在试图编译一个共享库时，任何未定义的引用将导致一个“未定义的符号”错误。这对于在你的源代码文件中捕捉错误会有很大的帮助。 然而，如果你因为某些原因，需要不启动这项检查，把这个变量设为‘ｔｒｕｅ’。注意相应的共享库可能在运行时加载失败。（这个一般尽量不要去设为true） 1LOCAL_ARM_MODE 默认情况下，arm目标二进制会以thumb的形式生成（16位），你可以通过设置这个变量为arm如果你希望你的module是以32位指令的形式。 &apos;arm&apos; (32-bit instructions) mode. E.g.: LOCAL_ARM_MODE := arm 注意你同样可以在编译的时候告诉系统编译特定的类型，比如 LOCAL_SRC_FILES := foo.c bar.c.arm 这样就告诉系统总是将bar.c以arm的模式编译， Android.mk使用模板在一个Android.mk中可以生成多个可执行程序、动态库和静态库。 1，编译应用程序的模板：#Test Exe LOCAL_PATH := $(call my-dir) #include $(CLEAR_VARS) LOCAL_SRC_FILES:= main.c LOCAL_MODULE:= test_exe #LOCAL_C_INCLUDES := #LOCAL_STATIC_LIBRARIES := #LOCAL_SHARED_LIBRARIES := include $(BUILD_EXECUTABLE) （菜鸟级别解释：:=是赋值的意思，$是引用某变量的值）LOCAL_SRC_FILES中加入源文件路径，LOCAL_C_INCLUDES 中加入所需要包含的头文件路径，LOCAL_STATIC_LIBRARIES加入所需要链接的静态库（.a）的名称，LOCAL_SHARED_LIBRARIES中加入所需要链接的动态库（.so）的名称，LOCAL_MODULE表示模块最终的名称，BUILD_EXECUTABLE表示以一个可执行程序的方式进行编译。 2，编译静态库的模板：#Test Static Lib LOCAL_PATH := $(call my-dir) include $(CLEAR_VARS) LOCAL_SRC_FILES:= \\ helloworld.c LOCAL_MODULE:= libtest_static #LOCAL_C_INCLUDES := #LOCAL_STATIC_LIBRARIES := #LOCAL_SHARED_LIBRARIES := include $(BUILD_STATIC_LIBRARY) 一般的和上面相似，BUILD_STATIC_LIBRARY表示编译一个静态库。 3，编译动态库的模板：#Test Shared Lib LOCAL_PATH := $(call my-dir) include $(CLEAR_VARS) LOCAL_SRC_FILES:= \\ helloworld.c LOCAL_MODULE:= libtest_shared TARGET_PRELINK_MODULES := false #LOCAL_C_INCLUDES := #LOCAL_STATIC_LIBRARIES := #LOCAL_SHARED_LIBRARIES := include $(BUILD_SHARED_LIBRARY) 一般的和上面相似，BUILD_SHARED_LIBRARY表示编译一个共享库。 以上三者的生成结果分别在如下，generic依具体target会变： 12345out/target/product/generic/obj/EXECUTABLEout/target/product/generic/obj/STATIC_LIBRARYout/target/product/generic/obj/SHARED_LIBRARY 每个模块的目标文件夹分别为： 12345可执行程序：XXX_intermediates静态库： XXX_static_intermediates动态库： XXX_shared_intermediates 另外，在Android.mk文件中，还可以指定最后的目标安装路径，用LOCAL_MODULE_PATH和LOCAL_UNSTRIPPED_PATH来指定。不同的文件系统路径用以下的宏进行选择： 12345TARGET_ROOT_OUT：表示根文件系统。TARGET_OUT：表示system文件系统。TARGET_OUT_DATA：表示data文件系统。 用法如： 1LOCAL_MODULE_PATH:=$(TARGET_ROOT_OUT)","categories":[{"name":"AOSP","slug":"AOSP","permalink":"http://wenyiqingnian.xyz/categories/AOSP/"}],"tags":[{"name":"编译","slug":"编译","permalink":"http://wenyiqingnian.xyz/tags/编译/"},{"name":"mk","slug":"mk","permalink":"http://wenyiqingnian.xyz/tags/mk/"}]},{"title":"Binder通讯机制","slug":"Binder 进程间通讯机制","date":"2017-04-11T11:20:50.000Z","updated":"2018-05-24T03:48:32.972Z","comments":true,"path":"2017/04/11/Binder 进程间通讯机制/","link":"","permalink":"http://wenyiqingnian.xyz/2017/04/11/Binder 进程间通讯机制/","excerpt":"","text":"什么是Binder？Binder是Android系统中进程间通讯（IPC）的一种方式，也是Android系统中最重要的特性之一。Android中的四大组件Activity，Service，Broadcast，ContentProvider，不同的App等都运行在不同的进程中，它是这些进程间通讯的桥梁。正如其名“粘合剂”一样，它把系统中各个组件粘合到了一起，是各个组件的桥梁。 理解Binder对于理解整个Android系统有着非常重要的作用，如果对Binder不了解，就很难对Android系统机制有更深入的理解。 1. Binder架构 Binder 通信采用 C/S 架构，从组件视角来说，包含 Client、 Server、 ServiceManager 以及 Binder 驱动，其中 ServiceManager 用于管理系统中的各种服务。 Binder 在 framework 层进行了封装，通过 JNI 技术调用 Native（C/C++）层的 Binder 架构。 Binder 在 Native 层以 ioctl 的方式与 Binder 驱动通讯。 2.Binder机制 首先需要注册服务端，只有注册了服务端，客户端才有通讯的目标，服务端通过 ServiceManager 注册服务，注册的过程就是向 Binder 驱动的全局链表 binder_procs 中插入服务端的信息（binder_proc 结构体，每个 binder_proc 结构体中都有 todo 任务队列），然后向 ServiceManager 的 svcinfo 列表中缓存一下注册的服务。 有了服务端，客户端就可以跟服务端通讯了，通讯之前需要先获取到服务，拿到服务的代理，也可以理解为引用。比如下面的代码： 121//获取WindowManager服务引用2 WindowManager wm = (WindowManager)getSystemService(getApplication().WINDOW_SERVICE); 获取服务端的方式就是通过 ServiceManager 向 svcinfo 列表中查询一下返回服务端的代理，svcinfo 列表就是所有已注册服务的通讯录，保存了所有注册的服务信息。 有了服务端的引用我们就可以向服务端发送请求了，通过 BinderProxy 将我们的请求参数发送给 ServiceManager，通过共享内存的方式使用内核方法 copy_from_user() 将我们的参数先拷贝到内核空间，这时我们的客户端进入等待状态，然后 Binder 驱动向服务端的 todo 队列里面插入一条事务，执行完之后把执行结果通过 copy_to_user() 将内核的结果拷贝到用户空间（这里只是执行了拷贝命令，并没有拷贝数据，binder只进行一次拷贝），唤醒等待的客户端并把结果响应回来，这样就完成了一次通讯。 怎么样是不是很简单，以上就是 Binder 机制的主要通讯方式，下面我们来看看具体实现。 3.Binder驱动我们先来了解下用户空间与内核空间是怎么交互的。 先了解一些概念 用户空间/内核空间详细解释可以参考 Kernel Space Definition； 简单理解如下： Kernel space 是 Linux 内核的运行空间，User space 是用户程序的运行空间。 为了安全，它们是隔离的，即使用户的程序崩溃了，内核也不受影响。 Kernel space 可以执行任意命令，调用系统的一切资源； User space 只能执行简单的运算，不能直接调用系统资源，必须通过系统接口（又称 system call），才能向内核发出指令。 系统调用/内核态/用户态虽然从逻辑上抽离出用户空间和内核空间；但是不可避免的的是，总有那么一些用户空间需要访问内核的资源；比如应用程序访问文件，网络是很常见的事情，怎么办呢？ Kernel space can be accessed by user processes only through the use of system calls. 用户空间访问内核空间的唯一方式就是系统调用；通过这个统一入口接口，所有的资源访问都是在内核的控制下执行，以免导致对用户程序对系统资源的越权访问，从而保障了系统的安全和稳定。用户软件良莠不齐，要是它们乱搞把系统玩坏了怎么办？因此对于某些特权操作必须交给安全可靠的内核来执行。 当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）此时处理器处于特权级最高的（0级）内核代码中执行。当进程在执行用户自己的代码时，则称其处于用户运行态（用户态）。即此时处理器在特权级最低的（3级）用户代码中运行。处理器在特权等级高的时候才能执行那些特权CPU指令。 内核模块/驱动通过系统调用，用户空间可以访问内核空间，那么如果一个用户空间想与另外一个用户空间进行通信怎么办呢？很自然想到的是让操作系统内核添加支持；传统的 Linux 通信机制，比如 Socket，管道等都是内核支持的；但是 Binder 并不是 Linux 内核的一部分，它是怎么做到访问内核空间的呢？ Linux 的动态可加载内核模块（Loadable Kernel Module，LKM）机制解决了这个问题；模块是具有独立功能的程序，它可以被单独编译，但不能独立运行。它在运行时被链接到内核作为内核的一部分在内核空间运行。这样，Android系统可以通过添加一个内核模块运行在内核空间，用户进程之间的通过这个模块作为桥梁，就可以完成通信了。 在 Android 系统中，这个运行在内核空间的，负责各个用户进程通过 Binder 通信的内核模块叫做 Binder 驱动; 驱动程序一般指的是设备驱动程序（Device Driver），是一种可以使计算机和设备通信的特殊程序。相当于硬件的接口，操作系统只有通过这个接口，才能控制硬件设备的工作； 驱动就是操作硬件的接口，为了支持Binder通信过程，Binder 使用了一种“硬件”，因此这个模块被称之为驱动。 熟悉了上面这些概念，我们再来看下上面的图，用户空间中 binder_open(), binder_mmap(), binder_ioctl() 这些方法通过 system call 来调用内核空间 Binder 驱动中的方法。内核空间与用户空间共享内存通过 copy_from_user(), copy_to_user() 内核方法来完成用户空间与内核空间内存的数据传输。 Binder驱动中有一个全局的 binder_procs 链表保存了服务端的进程信息。 4. Binder 进程与线程 对于底层Binder驱动，通过 binder_procs 链表记录所有创建的 binder_proc 结构体，binder 驱动层的每一个 binder_proc 结构体都与用户空间的一个用于 binder 通信的进程一一对应，且每个进程有且只有一个 ProcessState 对象，这是通过单例模式来保证的。在每个进程中可以有很多个线程，每个线程对应一个 IPCThreadState 对象，IPCThreadState 对象也是单例模式，即一个线程对应一个 IPCThreadState 对象，在 Binder 驱动层也有与之相对应的结构，那就是 Binder_thread 结构体。在 binder_proc 结构体中通过成员变量 rb_root threads，来记录当前进程内所有的 binder_thread。 Binder 线程池：每个 Server 进程在启动时创建一个 binder 线程池，并向其中注册一个 Binder 线程；之后 Server 进程也可以向 binder 线程池注册新的线程，或者 Binder 驱动在探测到没有空闲 binder 线程时主动向 Server 进程注册新的的 binder 线程。对于一个 Server 进程有一个最大 Binder 线程数限制，默认为16个 binder 线程，例如 Android 的 system_server 进程就存在16个线程。对于所有 Client 端进程的 binder 请求都是交由 Server 端进程的 binder 线程来处理的。 5. ServiceManager 启动了解了 Binder 驱动，怎么与 Binder 驱动进行通讯呢？那就是通过 ServiceManager，好多文章称 ServiceManager 是 Binder 驱动的守护进程，大管家，其实 ServiceManager 的作用很简单就是提供了查询服务和注册服务的功能。下面我们来看一下 ServiceManager 启动的过程。 ServiceManager 分为 framework 层和 native 层，framework 层只是对 native 层进行了封装方便调用，图上展示的是 native 层的 ServiceManager 启动过程。 ServiceManager 的启动是系统在开机时，init 进程解析 init.rc 文件调用 service_manager.c 中的 main() 方法入口启动的。 native 层有一个 binder.c 封装了一些与 Binder 驱动交互的方法。 ServiceManager 的启动分为三步，首先打开驱动创建全局链表 binder_procs，然后将自己当前进程信息保存到 binder_procs 链表，最后开启 loop 不断的处理共享内存中的数据，并处理 BR_xxx 命令（ioctl 的命令，BR 可以理解为 binder reply 驱动处理完的响应）。 6. ServiceManager 注册服务 注册 MediaPlayerService 服务端，我们通过 ServiceManager 的 addService() 方法来注册服务。 首先 ServiceManager 向 Binder 驱动发送 BC_TRANSACTION 命令（ioctl 的命令，BC 可以理解为 binder client 客户端发过来的请求命令）携带 ADD_SERVICE_TRANSACTION 命令，同时注册服务的线程进入等待状态 waitForResponse()。 Binder 驱动收到请求命令向 ServiceManager 的 todo 队列里面添加一条注册服务的事务。事务的任务就是创建服务端进程 binder_node 信息并插入到 binder_procs 链表中。 事务处理完之后发送 BR_TRANSACTION 命令，ServiceManager 收到命令后向 svcinfo 列表中添加已经注册的服务。最后发送 BR_REPLY 命令唤醒等待的线程，通知注册成功。 7. ServiceManager 获取服务 获取服务的过程与注册类似，相反的过程。通过 ServiceManager 的 getService() 方法来注册服务。 首先 ServiceManager 向 Binder 驱动发送 BC_TRANSACTION 命令携带 CHECK_SERVICE_TRANSACTION 命令，同时获取服务的线程进入等待状态 waitForResponse()。 Binder 驱动收到请求命令向 ServiceManager 的发送 BC_TRANSACTION 查询已注册的服务，查询到直接响应 BR_REPLY 唤醒等待的线程。若查询不到将与 binder_procs 链表中的服务进行一次通讯再响应。 8. 进行一次完整通讯 我们在使用 Binder 时基本都是调用 framework 层封装好的方法，AIDL 就是 framework 层提供的傻瓜式是使用方式。假设服务已经注册完，我们来看看客户端怎么执行服务端的方法。 首先我们通过 ServiceManager 获取到服务端的 BinderProxy 代理对象，通过调用 BinderProxy 将参数，方法标识（例如：TRANSACTION_test，AIDL中自动生成）传给 ServiceManager，同时客户端线程进入等待状态。 ServiceManager 将用户空间的参数等请求数据复制到内核空间，并向服务端插入一条执行执行方法的事务。事务执行完通知 ServiceManager 将执行结果从内核空间复制到用户空间，并唤醒等待的线程，响应结果，通讯结束。 总结好了，这里只是从实现逻辑上简单介绍了下 Binder 机制的工作原理，想要深入理解 Binder 机制，还得自己下功夫，看源码，尽管这个过程很痛苦。一遍看不懂就再来一遍，说实话本人理解能力比较差，跟着博客思路看了不下十遍。努力总会有收获，好好欣赏 native 层各方法之间花式跳转的魅力吧。最后你将发现新世界的大门在向你敞开。 网上资料很多，个人觉得比较好的如下： Bander设计与实现 老罗的 Android进程间通信（IPC）机制Binder简要介绍和学习计划 系列 Innost的 深入理解Binder 系列 Gityuan的 Binder系列 (基于 Android 6.0)5. Binder学习指南","categories":[{"name":"Android","slug":"Android","permalink":"http://wenyiqingnian.xyz/categories/Android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://wenyiqingnian.xyz/tags/android/"},{"name":"Binder","slug":"Binder","permalink":"http://wenyiqingnian.xyz/tags/Binder/"}]},{"title":"编译系统环境初始化过程","slug":"编译系统环境初始化过程","date":"2017-04-05T07:10:25.000Z","updated":"2018-05-06T14:15:45.308Z","comments":true,"path":"2017/04/05/编译系统环境初始化过程/","link":"","permalink":"http://wenyiqingnian.xyz/2017/04/05/编译系统环境初始化过程/","excerpt":"","text":"对Android编译环境进行初始化很简单，分为两步。 第一步是打开一个终端，并且将build/envsetup.sh加载到该终端中：123456789101112131415$ . ./build/envsetup.sh including device/asus/grouper/vendorsetup.sh including device/asus/tilapia/vendorsetup.sh including device/generic/armv7-a-neon/vendorsetup.sh including device/generic/armv7-a/vendorsetup.sh including device/generic/mips/vendorsetup.sh including device/generic/x86/vendorsetup.sh including device/lge/mako/vendorsetup.sh including device/samsung/maguro/vendorsetup.sh including device/samsung/manta/vendorsetup.sh including device/samsung/toroplus/vendorsetup.sh including device/samsung/toro/vendorsetup.sh including device/ti/panda/vendorsetup.sh including sdk/bash_completion/adb.bash 从命令的输出可以知道，文件build/envsetup.sh在加载的过程中，又会在device目录中寻找那些名称为vendorsetup.sh的文件，并且也将它们加载到当前终端来。另外，在sdk/bash_completion目录下的adb.bash文件也会加载到当前终端来，它是用来实现adb命令的bash completion功能的。也就是说，加载了该文件之后，我们在运行adb相关的命令的时候，通过按tab键就可以帮助我们自动完成命令的输入。关于bash completion的知识，可以参考官方文档： http://www.gnu.org/s/bash/manual/bash.html#Programmable-Completion。 第二步是执行命令lunch，如下所示：1234567891011121314151617181920212223$ lunch You're building on Linux Lunch menu... pick a combo: 1. full-eng 2. full_x86-eng 3. vbox_x86-eng 4. full_mips-eng 5. full_grouper-userdebug 6. full_tilapia-userdebug 7. mini_armv7a_neon-userdebug 8. mini_armv7a-userdebug 9. mini_mips-userdebug 10. mini_x86-userdebug 11. full_mako-userdebug 12. full_maguro-userdebug 13. full_manta-userdebug 14. full_toroplus-userdebug 15. full_toro-userdebug 16. full_panda-userdebug Which would you like? [full-eng] 我们看到lunch命令输出了一个Lunch菜单，该菜单列出了当前Android源码支持的所有设备型号及其编译类型。例如，第一项“full-eng”表示的设备“full”即为模拟器，并且编译类型为“eng”即为工程机。当我们选定了一个Lunch菜单项序号(1-16)之后，按回车键，就可以完成Android编译环境的初始化过程。例如，我们选择1，可以看到以下输出： 12345678910111213141516171819[html] view plain copyWhich would you like? [full-eng] 1 ============================================ PLATFORM_VERSION_CODENAME=REL PLATFORM_VERSION=4.2 TARGET_PRODUCT=full TARGET_BUILD_VARIANT=eng TARGET_BUILD_TYPE=release TARGET_BUILD_APPS= TARGET_ARCH=arm TARGET_ARCH_VARIANT=armv7-a HOST_ARCH=x86 HOST_OS=linux HOST_OS_EXTRA=Linux-3.8.0-31-generic-x86_64-with-Ubuntu-13.04-raring HOST_BUILD_TYPE=release BUILD_ID=JOP40C OUT_DIR=out ============================================ 我们可以看到，lunch命令帮我们设置好了很多环境变量。通过设置这些环境变量，就配置好了Android编译环境。通过图1我们就可以直观地看到Android编译环境初始化完成后，我们所获得的东西： 图1 Android编译环境初始化完成之后 总体来说，Android编译环境初始化完成之后，获得了以下三样东西： 123451. 将vendor和device目录下的vendorsetup.sh文件加载到了当前终端；2. 新增了lunch、m、mm和mmm等命令；3. 通过执行lunch命令设置好了TARGET_PRODUCT、TARGET_BUILD_VARIANT、TARGET_BUILD_TYPE和TARGET_BUILD_APPS等环境变量。 接下来我们就主要分析build/envsetup.sh文件的加载过程以及lunch命令的执行过程。 一. 文件build/envsetup.sh的加载过程文件build/envsetup.sh是一个bash shell脚本，从它里面定义的函数hmm可以知道，它提供了lunch、m、mm和mmm等命令供我们初始化编译环境或者编译Android源码。 函数hmm的实现如下所示： 12345678910111213141516171819202122232425[plain] view plain copyfunction hmm() &#123; cat &lt;&lt;EOF Invoke &quot;. build/envsetup.sh&quot; from your shell to add the following functions to your environment: - lunch: lunch &lt;product_name&gt;-&lt;build_variant&gt; - tapas: tapas [&lt;App1&gt; &lt;App2&gt; ...] [arm|x86|mips] [eng|userdebug|user] - croot: Changes directory to the top of the tree. - m: Makes from the top of the tree. - mm: Builds all of the modules in the current directory. - mmm: Builds all of the modules in the supplied directories. - cgrep: Greps on all local C/C++ files. - jgrep: Greps on all local Java files. - resgrep: Greps on all local res/*.xml files. - godir: Go to the directory containing a file. Look at the source to view more functions. The complete list is: EOF T=$(gettop) local A A=&quot;&quot; for i in `cat $T/build/envsetup.sh | sed -n &quot;/^function /s/function [a−z]∗.*/\\1/p&quot; | sort`; do A=&quot;$A $i&quot; done echo $A &#125; 我们在当前终端中执行hmm命令即可以看到函数hmm的完整输出。函数hmm主要完成三个工作： 12345671. 调用另外一个函数gettop获得Android源码的根目录T。 2. 通过cat命令显示一个Here Document，说明$T/build/envsetup.sh文件加载到当前终端后所提供的主要命令。3. 通过sed命令解析$T/build/envsetup.sh文件，并且获得在里面定义的所有函数的名称，这些函数名称就是$T/build/envsetup.sh文件加载到当前终端后提供的所有命令。 注意，sed命令是一个强大的文本分析工具，它以行为单位为执行文本替换、删除、新增和选取等操作。函数hmm通过执行以下的sed命令来获得在$T/build/envsetup.sh文件定义的函数的名称： [plain] view plain copysed -n “/^function /s/function [a−z]∗.*/\\1/p” 它表示对所有以“function ”开头的行，如果紧接在“function ”后面的字符串仅由字母a-z和下横线(_)组成，那么就将这个字符串提取出来。这正好就对应于shell脚本里面函数的定义。 文件build/envsetup.sh除了定义一堆函数之外，还有一个重要的代码段，如下所示： 12345678[plain] view plain copy# Execute the contents of any vendorsetup.sh files we can find. for f in `/bin/ls vendor/*/vendorsetup.sh vendor/*/*/vendorsetup.sh device/*/*/vendorsetup.sh 2&gt; /dev/null` do echo &quot;including $f&quot; . $f done unset f 这个for循环遍历vendor目录下的一级子目录和二级子目录以及device目录下的二级子目录中的vendorsetup.sh文件，并且通过source命令(.)将它们加载当前终端来。vendor和device相应子目录下的vendorsetup.sh文件的实现很简单，它们主要就是添加相应的设备型号及其编译类型支持到Lunch菜单中去。 例如，device/samsung/maguro目录下的vendorsetup.sh文件的实现如下所示： 12[plain] view plain copyadd_lunch_combo full_maguro-userdebug 它调用函数add_lunch_combo添加一个名称为“full_maguro-userdebug”的菜单项到Lunch菜单去。函数add_lunch_combo定义在build/envsetup.sh文件中，它的实现如下所示： 123456789101112[plain] view plain copyfunction add_lunch_combo() &#123; local new_combo=$1 local c for c in $&#123;LUNCH_MENU_CHOICES[@]&#125; ; do if [ &quot;$new_combo&quot; = &quot;$c&quot; ] ; then return fi done LUNCH_MENU_CHOICES=($&#123;LUNCH_MENU_CHOICES[@]&#125; $new_combo) &#125; 传递给函数add_lunch_combo的参数保存在位置参数$1中，接着又保存在一个本地变量new_combo中，用来表示一个要即将要添加的Lunch菜单项。函数首先是在数组LUNCH_MENU_CHOICES中检查要添加的菜单项是否已经存在。只有在不存在的情况下，才会将它添加到数组LUNCH_MENU_CHOICES中去。注意，${LUNCH_MENU_CHOICES[@]}表示数组LUNCH_MENU_CHOICES的所有元素。数组LUNCH_MENU_CHOICES是定义在文件build/envsetup.sh的一个全局变量，当文件build/envsetup.sh被加载的时候，这个数组会被初始化为化full-eng、full_x86-eng、vbox_x86-eng和full_mips-eng，如下所示： 123456[plain] view plain copy# add the default one here add_lunch_combo full-eng add_lunch_combo full_x86-eng add_lunch_combo vbox_x86-eng add_lunch_combo full_mips-eng 这样当文件build/envsetup.sh加载完成之后，数组LUNCH_MENU_CHOICES就包含了当前源码支持的所有设备型号及其编译类型，于是当接下来我们执行lunch命令的时候，就可以通过数组LUNCH_MENU_CHOICES看到一个完整的Lunch藤蔓。 二. lunch命令的执行过程lunch命令实际上是定义在文件build/envsetup.sh的一个函数，它的实现如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273[plain] view plain copyfunction lunch() &#123; local answer if [ &quot;$1&quot; ] ; then answer=$1 else print_lunch_menu echo -n &quot;Which would you like? [full-eng] &quot; read answer fi local selection= if [ -z &quot;$answer&quot; ] then selection=full-eng elif (echo -n $answer | grep -q -e &quot;^[0-9][0-9]*$&quot;) then if [ $answer -le $&#123;#LUNCH_MENU_CHOICES[@]&#125; ] then selection=$&#123;LUNCH_MENU_CHOICES[$(($answer-1))]&#125; fi elif (echo -n $answer | grep -q -e &quot;^[^\\-][^\\-]*-[^\\-][^\\-]*$&quot;) then selection=$answer fi if [ -z &quot;$selection&quot; ] then echo echo &quot;Invalid lunch combo: $answer&quot; return 1 fi export TARGET_BUILD_APPS= local product=$(echo -n $selection | sed -e &quot;s/-.*$//&quot;) check_product $product if [ $? -ne 0 ] then echo echo &quot;** Don&apos;t have a product spec for: &apos;$product&apos;&quot; echo &quot;** Do you have the right repo manifest?&quot; product= fi local variant=$(echo -n $selection | sed -e &quot;s/^[^\\-]*-//&quot;) check_variant $variant if [ $? -ne 0 ] then echo echo &quot;** Invalid variant: &apos;$variant&apos;&quot; echo &quot;** Must be one of $&#123;VARIANT_CHOICES[@]&#125;&quot; variant= fi if [ -z &quot;$product&quot; -o -z &quot;$variant&quot; ] then echo return 1 fi export TARGET_PRODUCT=$product export TARGET_BUILD_VARIANT=$variant export TARGET_BUILD_TYPE=release echo set_stuff_for_environment printconfig &#125; 函数lunch的执行逻辑如下所示： 12345678910111. 检查是否带有参数，即位置参数$1是否等于空。如果不等于空的话，就表明带有参数，并且该参数是用来指定要编译的设备型号及其编译类型的。如果等于空的话，那么就调用另外一个函数print_lunch_menu来显示Lunch菜单项，并且通过调用read函数来等待用户输入。无论通过何种方式，最终变量answer的值就保存了用户所指定的备型号及其编译类型。 2. 对变量answer的值的合法性进行检查。如果等于空的话，就将它设置为默认值“full-eng”。如果不等于空的话，就分为三种情况考虑。第一种情况是值为数字，那么就需要确保该数字的大小不能超过Lunch菜单项的个数。在这种情况下，会将输入的数字索引到数组LUNCH_MENU_CHOICES中去，以便获得一个用来表示设备型号及其编译类型的文本。第二种情况是非数字文本，那么就需要确保该文本符合&lt;product&gt;-&lt;variant&gt;的形式，其中&lt;product&gt;表示设备型号，而&lt;variant&gt;表示编译类型 。第三种情况是除了前面两种情况之外的所有情况，这是非法的。经过合法性检查后，变量selection代表了用户所指定的备型号及其编译类型，如果它的值是非法的，即它的值等于空，那么函数lunch就不往下执行了。 3. 接下来是解析变量selection的值，也就是通过sed命令将它的&lt;product&gt;和&lt;variant&gt;值提取出来，并且分别保存在变量product和variant中。提取出来的product和variant值有可能是不合法的，因此需要进一步通过调用函数check_product和check_variant来检查。一旦检查失败，也就是函数check_product和check_variant的返回值$?等于非0，那么函数lunch就不往下执行了。 4. 通过以上合法性检查之后，就将变量product和variant的值保存在环境变量TARGET_PRODUCT和TARGET_BUILD_VARIANT中。此外，另外一个环境变量TARGET_BUILD_TYPE的值会被设置为&quot;release&quot;，表示此次编译是一个release版本的编译。另外，前面还有一个环境变量TARGET_BUILD_APPS，它的值被函数lunch设置为空，用来表示此次编译是对整个系统进行编译。如果环境变量TARGET_BUILD_APPS的值不等于空，那么就表示此次编译是只对某些APP模块进行编译，而这些APP模块就是由环境变量TARGET_BUILD_APPS来指定的。 5. 调用函数set_stuff_for_environment来配置环境，例如设置Java SDK路径和交叉编译工具路径等。 6. 调用函数printfconfig来显示已经配置好的编译环境参数。 在上述执行过程中，函数check_product、check_variant和printconfig是比较关键的，因此接下来我们就继续分析它们的实现。 函数check_product定义在文件build/envsetup.sh中，它的实现如下所示： 1234567891011121314151617[plain] view plain copy# check to see if the supplied product is one we can build function check_product() &#123; T=$(gettop) if [ ! &quot;$T&quot; ]; then echo &quot;Couldn&apos;t locate the top of the tree. Try setting TOP.&quot; &gt;&amp;2 return fi CALLED_FROM_SETUP=true BUILD_SYSTEM=build/core \\ TARGET_PRODUCT=$1 \\ TARGET_BUILD_VARIANT= \\ TARGET_BUILD_TYPE= \\ TARGET_BUILD_APPS= \\ get_build_var TARGET_DEVICE &gt; /dev/null # hide successful answers, but allow the errors to show &#125; 函数gettop用来返回Android源代码工程的根目录。函数check_product需要在Android源代码工程根目录或者子目录下调用。否则的话，函数check_product就出错返回。 接下来函数check_product设置几个环境变量，其中最重要的是前面三个CALLED_FROM_SETUP、BUILD_SYSTEM和TARGET_PRODUCT。环境变量CALLED_FROM_SETUP的值等于true表示接下来执行的make命令是用来初始化Android编译环境的。环境变量BUILD_SYSTEM用来指定Android编译系统的核心目录，它的值被设置为build/core。环境变量TARGET_PRODUCT用来表示要检查的产品名称（也就是我们前面说的设备型号），它的值被设置为$1，即函数check_product的调用参数。 最后函数check_product调用函数get_build_var来检查由环境变量TARGET_PRODUCT指定的产品名称是否合法，注意，它的调用参数为TARGET_DEVICE。 函数get_build_var定义在文件build/envsetup.sh中，它的实现如下所示： 123456789101112[plain] view plain copy# Get the exact value of a build variable. function get_build_var() &#123; T=$(gettop) if [ ! &quot;$T&quot; ]; then echo &quot;Couldn&apos;t locate the top of the tree. Try setting TOP.&quot; &gt;&amp;2 return fi CALLED_FROM_SETUP=true BUILD_SYSTEM=build/core \\ make --no-print-directory -C &quot;$T&quot; -f build/core/config.mk dumpvar-$1 &#125; 这里就可以看到，函数get_build_var实际上就是通过make命令在Android源代码工程根目录中执行build/core/config.mk文件，并且将make目标设置为dumpvar-$1，也就是dumpvar-TARGET_DEVICE。 文件build/core/config.mk的内容比较多，这里我们只关注与产品名称合法性检查相关的逻辑，这些逻辑也基本上涵盖了Android编译系统初始化的逻辑，如下所示： 12345678910111213141516171819202122232425262728[plain] view plain copy...... # --------------------------------------------------------------- # Define most of the global variables. These are the ones that # are specific to the user&apos;s build configuration. include $(BUILD_SYSTEM)/envsetup.mk # Boards may be defined under $(SRC_TARGET_DIR)/board/$(TARGET_DEVICE) # or under vendor/*/$(TARGET_DEVICE). Search in both places, but # make sure only one exists. # Real boards should always be associated with an OEM vendor. board_config_mk := \\ $(strip $(wildcard \\ $(SRC_TARGET_DIR)/board/$(TARGET_DEVICE)/BoardConfig.mk \\ device/*/$(TARGET_DEVICE)/BoardConfig.mk \\ vendor/*/$(TARGET_DEVICE)/BoardConfig.mk \\ )) ifeq ($(board_config_mk),) $(error No config file found for TARGET_DEVICE $(TARGET_DEVICE)) endif ifneq ($(words $(board_config_mk)),1) $(error Multiple board config files for TARGET_DEVICE $(TARGET_DEVICE): $(board_config_mk)) endif include $(board_config_mk) ......include $(BUILD_SYSTEM)/dumpvar.mk 上述代码主要就是将envsetup.mk、BoardConfig,mk和dumpvar.mk三个Makefile片段文件加载进来。其中，envsetup.mk文件位于$(BUILD_SYSTEM)目录中，也就是build/core目录中，BoardConfig.mk文件的位置主要就是由环境变量TARGET_DEVICE来确定，它是用来描述目标产品的硬件模块信息的，例如CPU体系结构。环境变量TARGET_DEVICE用来描述目标设备，它的值是在envsetup.mk文件加载的过程中确定的。一旦目标设备确定后，就可以在$(SRC_TARGET_DIR)/board/$(TARGET_DEVICE)、device//$(TARGET_DEVICE)和vendor//$(TARGET_DEVICE)目录中找到对应的BoradConfig.mk文件。注意，变量SRC_TARGET_DIR的值等于build/target。最后，dumpvar.mk文件也是位于build/core目录中，它用来打印已经配置好的编译环境信息。 接下来我们就通过进入到build/core/envsetup.mk文件来分析变量TARGET_DEVICE的值是如何确定的： [plain] view plain copy Read the product specs so we an get TARGET_DEVICE and othervariables that we need in order to locate the output files.include $(BUILD_SYSTEM)/product_config.mk 它通过加载另外一个文件build/core/product_config.mk文件来确定变量TARGET_DEVICE以及其它与目标产品相关的变量的值。 文件build/core/product_config.mk的内容很多，这里我们只关注变量TARGET_DEVICE设置相关的逻辑，如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667[plain] view plain copy...... ifneq ($(strip $(TARGET_BUILD_APPS)),) # An unbundled app build needs only the core product makefiles. all_product_configs := $(call get-product-makefiles,\\ $(SRC_TARGET_DIR)/product/AndroidProducts.mk) else # Read in all of the product definitions specified by the AndroidProducts.mk # files in the tree. all_product_configs := $(get-all-product-makefiles) endif # all_product_configs consists items like: # &lt;product_name&gt;:&lt;path_to_the_product_makefile&gt; # or just &lt;path_to_the_product_makefile&gt; in case the product name is the # same as the base filename of the product config makefile. current_product_makefile := all_product_makefiles := $(foreach f, $(all_product_configs),\\ $(eval _cpm_words := $(subst :,$(space),$(f)))\\ $(eval _cpm_word1 := $(word 1,$(_cpm_words)))\\ $(eval _cpm_word2 := $(word 2,$(_cpm_words)))\\ $(if $(_cpm_word2),\\ $(eval all_product_makefiles += $(_cpm_word2))\\ $(if $(filter $(TARGET_PRODUCT),$(_cpm_word1)),\\ $(eval current_product_makefile += $(_cpm_word2)),),\\ $(eval all_product_makefiles += $(f))\\ $(if $(filter $(TARGET_PRODUCT),$(basename $(notdir $(f)))),\\ $(eval current_product_makefile += $(f)),))) _cpm_words := _cpm_word1 := _cpm_word2 := current_product_makefile := $(strip $(current_product_makefile)) all_product_makefiles := $(strip $(all_product_makefiles)) ifneq (,$(filter product-graph dump-products, $(MAKECMDGOALS))) # Import all product makefiles. $(call import-products, $(all_product_makefiles)) else # Import just the current product. ifndef current_product_makefile $(error Cannot locate config makefile for product &quot;$(TARGET_PRODUCT)&quot;) endif ifneq (1,$(words $(current_product_makefile))) $(error Product &quot;$(TARGET_PRODUCT)&quot; ambiguous: matches $(current_product_makefile)) endif $(call import-products, $(current_product_makefile)) endif # Import all or just the current product makefile ...... # Convert a short name like &quot;sooner&quot; into the path to the product # file defining that product. # INTERNAL_PRODUCT := $(call resolve-short-product-name, $(TARGET_PRODUCT)) ifneq ($(current_product_makefile),$(INTERNAL_PRODUCT)) $(error PRODUCT_NAME inconsistent in $(current_product_makefile) and $(INTERNAL_PRODUCT)) endif current_product_makefile := all_product_makefiles := all_product_configs := # Find the device that this product maps to. TARGET_DEVICE := $(PRODUCTS.$(INTERNAL_PRODUCT).PRODUCT_DEVICE) ...... 上述代码的执行逻辑如下所示： 1234567891. 检查环境变量TARGET_BUILD_APPS的值是否等于空。如果不等于空，那么就说明此次编译不是针对整个系统，因此只要将核心的产品相关的Makefile文件加载进来就行了，否则的话，就要将所有与产品相关的Makefile文件加载进来的。核心产品Makefile文件在$(SRC_TARGET_DIR)/product/AndroidProducts.mk文件中指定，也就是在build/target/product/AndroidProducts.mk文件，通过调用函数get-product-makefiles可以获得。所有与产品相关的Makefile文件可以通过另外一个函数get-all-product-makefiles获得。无论如何，最终获得的产品Makefie文件列表保存在变量all_product_configs中。 2. 遍历变量all_product_configs所描述的产品Makefile列表，并且在这些Makefile文件中，找到名称与环境变量TARGET_PRODUCT的值相同的文件，保存在另外一个变量current_product_makefile中，作为需要为当前指定的产品所加载的Makefile文件列表。在这个过程当中，上一步找到的所有的产品Makefile文件也会保存在变量all_product_makefiles中。注意，环境变量TARGET_PRODUCT的值是在我们执行lunch命令的时候设置并且传递进来的。 3. 如果指定的make目标等于product-graph或者dump-products，那么就将所有的产品相关的Makefile文件加载进来，否则的话，只加载与目标产品相关的Makefile文件。从前面的分析可以知道，此时的make目标为dumpvar-TARGET_DEVICE，因此接下来只会加载与目标产品，即$(TARGET_PRODUCT)，相关的Makefile文件，这是通过调用另外一个函数import-products实现的。 4. 调用函数resolve-short-product-name解析环境变量TARGET_PRODUCT的值，将它变成一个Makefile文件路径。并且保存在变量INTERNAL_PRODUCT中。这里要求变量INTERNAL_PRODUCT和current_product_makefile的值相等，否则的话，就说明用户指定了一个非法的产品名称。 5. 找到一个名称为PRODUCTS.$(INTERNAL_PRODUCT).PRODUCT_DEVICE的变量，并且将它的值保存另外一个变量TARGET_DEVICE中。变量PRODUCTS.$(INTERNAL_PRODUCT).PRODUCT_DEVICE是在加载产品Makefile文件的过程中定义的，用来描述当前指定的产品的名称。 上述过程主要涉及到了get-all-product-makefiles、import-products和resolve-short-product-name三个关键函数，理解它们的执行过程对理解Android编译系统的初始化过程很有帮助，接下来我们分别分析它们的实现。 函数get-all-product-makefiles定义在文件build/core/product.mk中，如下所示： 123456789[plain] view plain copy# # Returns the sorted concatenation of all PRODUCT_MAKEFILES # variables set in all AndroidProducts.mk files. # $(call ) isn&apos;t necessary. # define get-all-product-makefiles $(call get-product-makefiles,$(_find-android-products-files)) endef 它首先是调用函数_find-android-products-files来找到Android源代码目录中定义的所有AndroidProducts.mk文件，然后再调用函数get-product-makefiles获得在这里AndroidProducts.mk文件里面定义的产品Makefile文件。 函数_find-android-products-files也是定义在文件build/core/product.mk中，如下所示： 12345678910111213141516171819202122232425262728293031[plain] view plain copy# # Returns the list of all AndroidProducts.mk files. # $(call ) isn&apos;t necessary. # define _find-android-products-files $(shell test -d device &amp;&amp; find device -maxdepth 6 -name AndroidProducts.mk) \\ $(shell test -d vendor &amp;&amp; find vendor -maxdepth 6 -name AndroidProducts.mk) \\ $(SRC_TARGET_DIR)/product/AndroidProducts.mk endef 从这里就可以看出，Android源代码目录中定义的所有AndroidProducts.mk文件位于device、vendor或者build/target/product目录或者相应的子目录（最深是6层）中。 函数get-product-makefiles也是定义在文件build/core/product.mk中，如下所示：[plain] view plain copy# # Returns the sorted concatenation of PRODUCT_MAKEFILES # variables set in the given AndroidProducts.mk files. # $(1): the list of AndroidProducts.mk files. # define get-product-makefiles $(sort \\ $(foreach f,$(1), \\ $(eval PRODUCT_MAKEFILES :=) \\ $(eval LOCAL_DIR := $(patsubst %/,%,$(dir $(f)))) \\ $(eval include $(f)) \\ $(PRODUCT_MAKEFILES) \\ ) \\ $(eval PRODUCT_MAKEFILES :=) \\ $(eval LOCAL_DIR :=) \\ ) endef 这个函数实际上就是遍历参数$1所描述的AndroidProucts.mk文件列表，并且将定义在这些AndroidProucts.mk文件中的变量PRODUCT_MAKEFILES的值提取出来，形成一个列表返回给调用者。 例如，在build/target/product/AndroidProducts.mk文件中，变量PRODUCT_MAKEFILES的值如下所示： 12345678910111213141516171819202122[plain] view plain copy# Unbundled apps will be built with the most generic product config. ifneq ($(TARGET_BUILD_APPS),) PRODUCT_MAKEFILES := \\ $(LOCAL_DIR)/full.mk \\ $(LOCAL_DIR)/full_x86.mk \\ $(LOCAL_DIR)/full_mips.mk else PRODUCT_MAKEFILES := \\ $(LOCAL_DIR)/core.mk \\ $(LOCAL_DIR)/generic.mk \\ $(LOCAL_DIR)/generic_x86.mk \\ $(LOCAL_DIR)/generic_mips.mk \\ $(LOCAL_DIR)/full.mk \\ $(LOCAL_DIR)/full_x86.mk \\ $(LOCAL_DIR)/full_mips.mk \\ $(LOCAL_DIR)/vbox_x86.mk \\ $(LOCAL_DIR)/sdk.mk \\ $(LOCAL_DIR)/sdk_x86.mk \\ $(LOCAL_DIR)/sdk_mips.mk \\ $(LOCAL_DIR)/large_emu_hw.mk endif 里列出的每一个文件都对应于一个产品。 我们再来看函数import-products的实现，它定义在文件build/core/product.mk中，如下所示： 12345678[plain] view plain copy# # $(1): product makefile list # #TODO: check to make sure that products have all the necessary vars defined define import-products $(call import-nodes,PRODUCTS,$(1),$(_product_var_list)) endef 它调用另外一个函数import-nodes来加载由参数$1所指定的产品Makefile文件，并且指定了另外两个参数PRODUCTS和$(_product_var_list)。其中，变量_product_var_list也是定义在文件build/core/product.mk中，它的值如下所示： 123456789101112131415161718192021222324252627282930313233[plain] view plain copy_product_var_list := \\ PRODUCT_NAME \\ PRODUCT_MODEL \\ PRODUCT_LOCALES \\ PRODUCT_AAPT_CONFIG \\ PRODUCT_AAPT_PREF_CONFIG \\ PRODUCT_PACKAGES \\ PRODUCT_PACKAGES_DEBUG \\ PRODUCT_PACKAGES_ENG \\ PRODUCT_PACKAGES_TESTS \\ PRODUCT_DEVICE \\ PRODUCT_MANUFACTURER \\ PRODUCT_BRAND \\ PRODUCT_PROPERTY_OVERRIDES \\ PRODUCT_DEFAULT_PROPERTY_OVERRIDES \\ PRODUCT_CHARACTERISTICS \\ PRODUCT_COPY_FILES \\ PRODUCT_OTA_PUBLIC_KEYS \\ PRODUCT_EXTRA_RECOVERY_KEYS \\ PRODUCT_PACKAGE_OVERLAYS \\ DEVICE_PACKAGE_OVERLAYS \\ PRODUCT_TAGS \\ PRODUCT_SDK_ADDON_NAME \\ PRODUCT_SDK_ADDON_COPY_FILES \\ PRODUCT_SDK_ADDON_COPY_MODULES \\ PRODUCT_SDK_ADDON_DOC_MODULES \\ PRODUCT_DEFAULT_WIFI_CHANNELS \\ PRODUCT_DEFAULT_DEV_CERTIFICATE \\ PRODUCT_RESTRICT_VENDOR_FILES \\ PRODUCT_VENDOR_KERNEL_HEADERS \\ PRODUCT_FACTORY_RAMDISK_MODULES \\ PRODUCT_FACTORY_BUNDLE_MODULES 它描述的是在产品Makefile文件中定义在各种变量。 函数import-nodes定义在文件build/core/node_fns.mk中，如下所示： 12345678910111213141516171819202122[plain] view plain copy# # $(1): output list variable name, like &quot;PRODUCTS&quot; or &quot;DEVICES&quot; # $(2): list of makefiles representing nodes to import # $(3): list of node variable names # define import-nodes $(if \\ $(foreach _in,$(2), \\ $(eval _node_import_context := _nic.$(1).[[$(_in)]]) \\ $(if $(_include_stack),$(eval $(error ASSERTION FAILED: _include_stack \\ should be empty here: $(_include_stack))),) \\ $(eval _include_stack := ) \\ $(call _import-nodes-inner,$(_node_import_context),$(_in),$(3)) \\ $(call move-var-list,$(_node_import_context).$(_in),$(1).$(_in),$(3)) \\ $(eval _node_import_context :=) \\ $(eval $(1) := $($(1)) $(_in)) \\ $(if $(_include_stack),$(eval $(error ASSERTION FAILED: _include_stack \\ should be empty here: $(_include_stack))),) \\ ) \\ ,) endef 这个函数主要是做了三件事情： 12345671. 调用函数_import-nodes-inner将参数$2描述的每一个产品Makefile文件加载进来。 2. 调用函数move-var-list将定义在前面所加载的产品Makefile文件里面的由参数$3指定的变量的值分别拷贝到另外一组独立的变量中。 3. 将参数$2描述的每一个产品Makefile文件路径以空格分隔保存在参数$1所描述的变量中，也就是保存在变量PRODUCTS中。 上述第二件事情需要进一步解释一下。由于当前加载的每一个文件都会定义相同的变量，为了区分这些变量，我们需要在这些变量前面加一些前缀。例如，假设加载了build/target/product/full.mk这个产品Makefile文件，它里面定义了以下几个变量： 123456789101112[plain] view plain copy# Overrides PRODUCT_NAME := full PRODUCT_DEVICE := generic PRODUCT_BRAND := Android PRODUCT_MODEL := Full Android on Emulator 当调用了函数move-var-list对它进行解析后，就会得到以下的新变量：[plain] view plain copyPRODUCTS.build/target/product/full.mk.PRODUCT_NAME := full PRODUCTS.build/target/product/full.mk.PRODUCT_DEVICE := generic PRODUCTS.build/target/product/full.mk.PRODUCT_BRAND := Android PRODUCTS.build/target/product/full.mk.PRODUCT_MODEL := Full Android on Emulator 正是由于调用了函数move-var-list，我们在build/core/product_config.mk文件中可以通过PRODUCTS.$(INTERNAL_PRODUCT).PRODUCT_DEVICE来设置变量TARGET_DEVICE的值。 回到build/core/config.mk文件中，接下来我们再看BoardConfig.mk文件的加载过程。前面提到，当前要加载的BoardConfig.mk文件由变量TARGET_DEVICE来确定。例如，假设我们在运行lunch命令时，输入的文本为full-eng，那么build/target/product/full.mk就会被加载，并且我们得到TARGET_DEVICE的值就为generic，接下来加载的BoradConfig.mk文件就会在build/target/board/generic目录中找到。 BoardConfig.mk文件定义的信息可以参考build/target/board/generic/BoardConfig.mk文件的内容，如下所示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647[plain] view plain copy# config.mk # # Product-specific compile-time definitions. # # The generic product target doesn&apos;t have any hardware-specific pieces. TARGET_NO_BOOTLOADER := true TARGET_NO_KERNEL := true TARGET_ARCH := arm # Note: we build the platform images for ARMv7-A _without_ NEON. # # Technically, the emulator supports ARMv7-A _and_ NEON instructions, but # emulated NEON code paths typically ends up 2x slower than the normal C code # it is supposed to replace (unlike on real devices where it is 2x to 3x # faster). # # What this means is that the platform image will not use NEON code paths # that are slower to emulate. On the other hand, it is possible to emulate # application code generated with the NDK that uses NEON in the emulator. # TARGET_ARCH_VARIANT := armv7-a TARGET_CPU_ABI := armeabi-v7a TARGET_CPU_ABI2 := armeabi ARCH_ARM_HAVE_TLS_REGISTER := true HAVE_HTC_AUDIO_DRIVER := true BOARD_USES_GENERIC_AUDIO := true # no hardware camera USE_CAMERA_STUB := true # Enable dex-preoptimization to speed up the first boot sequence # of an SDK AVD. Note that this operation only works on Linux for now ifeq ($(HOST_OS),linux) ifeq ($(WITH_DEXPREOPT),) WITH_DEXPREOPT := true endif endif # Build OpenGLES emulation guest and host libraries BUILD_EMULATOR_OPENGL := true # Build and enable the OpenGL ES View renderer. When running on the emulator, # the GLES renderer disables itself if host GL acceleration isn&apos;t available. USE_OPENGL_RENDERER := true 它描述了产品的Boot Loader、Kernel、CPU体系结构、CPU ABI和Opengl加速等信息。 再回到build/core/config.mk文件中，它最后加载build/core/dumpvar.mk文件。加载build/core/dumpvar.mk文件是为了生成make目标，以便可以对这些目标进行操作。例如，在我们这个情景中，我们要执行的make目标是dumpvar-TARGET_DEVICE，因此在加载build/core/dumpvar.mk文件的过程中，就会生成dumpvar-TARGET_DEVICE目标。 文件build/core/dumpvar.mk的内容也比较多，这里我们只关注生成make目标相关的逻辑： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546[plain] view plain copy...... # The &quot;dumpvar&quot; stuff lets you say something like # # CALLED_FROM_SETUP=true \\ # make -f config/envsetup.make dumpvar-TARGET_OUT # or # CALLED_FROM_SETUP=true \\ # make -f config/envsetup.make dumpvar-abs-HOST_OUT_EXECUTABLES # # The plain (non-abs) version just dumps the value of the named variable. # The &quot;abs&quot; version will treat the variable as a path, and dumps an # absolute path to it. # dumpvar_goals := \\ $(strip $(patsubst dumpvar-%,%,$(filter dumpvar-%,$(MAKECMDGOALS)))) ifdef dumpvar_goals ifneq ($(words $(dumpvar_goals)),1) $(error Only one &quot;dumpvar-&quot; goal allowed. Saw &quot;$(MAKECMDGOALS)&quot;) endif # If the goal is of the form &quot;dumpvar-abs-VARNAME&quot;, then # treat VARNAME as a path and return the absolute path to it. absolute_dumpvar := $(strip $(filter abs-%,$(dumpvar_goals))) ifdef absolute_dumpvar dumpvar_goals := $(patsubst abs-%,%,$(dumpvar_goals)) ifneq ($(filter /%,$($(dumpvar_goals))),) DUMPVAR_VALUE := $($(dumpvar_goals)) else DUMPVAR_VALUE := $(PWD)/$($(dumpvar_goals)) endif dumpvar_target := dumpvar-abs-$(dumpvar_goals) else DUMPVAR_VALUE := $($(dumpvar_goals)) dumpvar_target := dumpvar-$(dumpvar_goals) endif .PHONY: $(dumpvar_target) $(dumpvar_target): @echo $(DUMPVAR_VALUE) endif # dumpvar_goals ...... 我们在执行make命令时，指定的目示会经由MAKECMDGOALS变量传递到Makefile中，因此通过变量MAKECMDGOALS可以获得make目标。 上述代码的逻辑很简单，例如，在我们这个情景中，指定的make目标为dumpvar-TARGET_DEVICE，那么就会得到变量DUMPVAR_VALUE的值为$(TARGET_DEVICE)。TARGET_DEVICE的值在前面已经被设置为“generic”，因此变量DUMPVAR_VALUE的值就等于“generic”。此外，变量dumpvar_target的被设置为“dumpvar-TARGET_DEVICE”。最后我们就可以得到以下的make规则： [plain] view plain copy.PHONY dumpvar-TARGET_DEVICEdumpvar-TARGET_DEVICE: @echo generic 至此，在build/envsetup.sh文件中定义的函数check_product就分析完成了。看完了之后，小伙伴们可能会问，前面不是说这个函数是用来检查用户输入的产品名称是否合法的吗？但是这里没看出哪一段代码给出了true或者false的答案啊。实际上，在前面分析的build/core/config.mk和build/core/product_config.mk等文件的加载过程中，如果发现输入的产品名称是非法的，也就是找不到相应的产品Makefile文件，那么就会通过调用error函数来产生一个错误，这时候函数check_product的返回值$?就会等于非0值。 接下来我们还要继续分析在build/envsetup.sh文件中定义的函数check_variant的实现，如下所示： 123456789101112131415[plain] view plain copyVARIANT_CHOICES=(user userdebug eng) # check to see if the supplied variant is valid function check_variant() &#123; for v in $&#123;VARIANT_CHOICES[@]&#125; do if [ &quot;$v&quot; = &quot;$1&quot; ] then return 0 fi done return 1 &#125; 这个函数的实现就简单多了。合法的编译类型定义在数组VARIANT_CHOICES中，并且它只有三个值user、userdebug和eng。其中，user表示发布版本，userdebug表示带调试信息的发布版本，而eng表标工程机版本。 最后，我们再来分析在build/envsetup.sh文件中定义的函数printconfig的实现，如下所示： 12345678910[plain] view plain copyfunction printconfig() &#123; T=$(gettop) if [ ! &quot;$T&quot; ]; then echo &quot;Couldn&apos;t locate the top of the tree. Try setting TOP.&quot; &gt;&amp;2 return fi get_build_var report_config &#125; 对比我们前面对函数check_product的分析，就会发现函数printconfig的实现与这很相似，都是通过调用get_build_var来获得相关的信息，但是这里传递给函数get_build_var的参数为report_config。 我们跳过前面build/core/config.mk和build/core/envsetup.mk等文件对目标产品Makefile文件的加载，直接跳到build/core/dumpvar.mk文件来查看与report_config这个make目标相关的逻辑： 1234567891011121314151617181920212223242526272829303132[plain] view plain copy...... dumpvar_goals := \\ $(strip $(patsubst dumpvar-%,%,$(filter dumpvar-%,$(MAKECMDGOALS)))) ..... ifneq ($(dumpvar_goals),report_config) PRINT_BUILD_CONFIG:= endif ...... ifneq ($(PRINT_BUILD_CONFIG),) HOST_OS_EXTRA:=$(shell python -c &quot;import platform; print(platform.platform())&quot;) $(info ============================================) $(info PLATFORM_VERSION_CODENAME=$(PLATFORM_VERSION_CODENAME)) $(info PLATFORM_VERSION=$(PLATFORM_VERSION)) $(info TARGET_PRODUCT=$(TARGET_PRODUCT)) $(info TARGET_BUILD_VARIANT=$(TARGET_BUILD_VARIANT)) $(info TARGET_BUILD_TYPE=$(TARGET_BUILD_TYPE)) $(info TARGET_BUILD_APPS=$(TARGET_BUILD_APPS)) $(info TARGET_ARCH=$(TARGET_ARCH)) $(info TARGET_ARCH_VARIANT=$(TARGET_ARCH_VARIANT)) $(info HOST_ARCH=$(HOST_ARCH)) $(info HOST_OS=$(HOST_OS)) $(info HOST_OS_EXTRA=$(HOST_OS_EXTRA)) $(info HOST_BUILD_TYPE=$(HOST_BUILD_TYPE)) $(info BUILD_ID=$(BUILD_ID)) $(info OUT_DIR=$(OUT_DIR)) $(info ============================================) endif 变量PRINT_BUILD_CONFIG定义在文件build/core/envsetup.mk中，默认值设置为true。当make目标为report-config的时候，变量PRINT_BUILD_CONFIG的值就会被设置为空。因此，接下来就会打印一系列用来描述编译环境配置的变量的值，也就是我们执行lunch命令后看到的输出。注意，这些环境配置相关的变量量都是在加载build/core/config.mk和build/core/envsetup.mk文件的过程中设置的，就类似于前面我们分析的TARGET_DEVICE变量的值的设置过程。 至此，我们就分析完成Android编译系统环境的初始化过程了。从分析的过程可以知道，Android编译系统环境是由build/core/config.mk、build/core/envsetup.mk、build/core/product_config.mk、AndroidProducts.mk和BoardConfig.mk等文件来完成的。这些mk文件涉及到非常多的细节，而我们这里只提供了一个大体的骨架和脉络，希望能够起到抛砖引玉的作用。","categories":[{"name":"AOSP","slug":"AOSP","permalink":"http://wenyiqingnian.xyz/categories/AOSP/"}],"tags":[{"name":"编译","slug":"编译","permalink":"http://wenyiqingnian.xyz/tags/编译/"},{"name":"aosp","slug":"aosp","permalink":"http://wenyiqingnian.xyz/tags/aosp/"}]},{"title":"添加SE安全策略","slug":"添加SE安全策略","date":"2017-03-15T11:10:10.000Z","updated":"2018-05-06T13:07:29.880Z","comments":true,"path":"2017/03/15/添加SE安全策略/","link":"","permalink":"http://wenyiqingnian.xyz/2017/03/15/添加SE安全策略/","excerpt":"","text":"一、 问题复现12341.service ro_isn /system/bin/isn.sh 2.class late_start3.user root4.oneshot kernel log会打印以下log： 1Warning! Service ro_isn needs a SELinux domain defined; please fix! 这是因为Service ro_isn没有在SELinux的监控之下，这种情况会提示你定义一个SELinux。在这种情况下，你可以：1.无视该条log，Service功能不受影响。各种权限不受限制。但是这样做会有风险。2.为Service ro_isn定义一个SELinux domain，仅添加需要的权限，未允许的权限操作会被拒绝。具体方法请参照下节。 二、解决方法1.1devices/qcom/sepolicy/common/ 目录下新增ro_isn.te文件，内容如下： 12type ro_isn, domain; type ro_isn_exec, exec_type, file_type; 2.在1devices/qcom/sepolicy/Android.mk 中添加ro_isn.te文件，内容如下： 1234BOARD_SEPOLICY_UNION := \\... \\ hostapd.te \\ ro_isn.te 3.在1devices/qcom/sepolicy/common/file_contexts 中增加如下内容： ################################### 1234567# System files#.../system/vendor/bin/slim_ap_daemonu:object_r:location_exec:s0/system/bin/isn.shu:object_r:ro_isn_exec:s0 4.在init.rc中service ro_isn下添加12345678secure context by seclabel service ro_isn /system/bin/isn.sh class late_start user root oneshot seclabel u:r:ro_isn:s0 5.编译并烧录bootimage 6.如果编译不成功，失败原因如下： 123Error while expanding policylibsepol.check_assertion_helper: neverallow on line 233 of external/sepolicy/domain.te (or line 5194 of policy.conf) violated by allow ro_isn system_file:file &#123; entrypoint &#125;;make: *** [out/target/product/msm8226/obj/ETC/sepolicy_intermediates/sepolicy] 错误 1 这是因为系统在domain.te中定义了全局的neverallow策略，与ro_isn.te中allow的策略有冲突： 12allow ro_isn system_file:file &#123; entrypoint &#125;;neverallow domain &#123; file_type -exec_type &#125;:file entrypoint; 请确定自己的service有必要需要这个权限。如无必要，请在自己的code中删除掉相关操作；如必要，可以在1external/sepolicy/domain.te 中冲突的neverallow语句中添加自己为例外： 1234neverallow &#123; domain -ro_isn&#125; &#123; file_type -exec_type &#125;:file entrypoint; 7.在service ro_isn运行时，搜索关于“ro_isn”的1avc: denied log 123&lt;6&gt;[ 13.547188](CPU:0-pid:320:logd.auditd) type=1400 audit(17468992.410:7): avc: denied &#123; entrypoint &#125; for pid=272 comm=&quot;init&quot; path=&quot;/system/bin/isn.sh &quot; dev=&quot;mmcblk0p38&quot; ino=631 scontext=u:r:ro_isn:s0 tcontext=u:object_r:system_file:s0 tclass=file 8.按照如下规则在ro_isn.te添加权限SELinux规则语句一般如下： 1allow A B:C D; 可以从log中分别获取ABCD四个参数。比如这行12345678warning log：avc: denied &#123; entrypoint &#125; for pid=272 comm=&quot;init&quot; path=&quot;/system/bin/isn.sh &quot; dev=&quot;mmcblk0p38&quot; ino=631 scontext=u:r:ro_isn:s0 tcontext=u:object_r:system_file:s0 tclass=fileavc: denied &#123; transition &#125; for pid=320 comm=&quot;init&quot; path=&quot;/system/xbin/fcgiserver.sh &quot; dev=&quot;mmcblk0p21&quot; ino=7873 scontext=u:r:init:s0 tcontext=u:r:fcgiserver:s0 tclass=process permissive=1 那么我们就得出最后的规则是： 1allow qcomsysd block_device:dir &#123; search &#125;; 1allow ro_isn system_file:file &#123; entrypoint &#125;; 重复步骤5-8,直到没有关于ro_isn的avc: denied log","categories":[{"name":"AOSP","slug":"AOSP","permalink":"http://wenyiqingnian.xyz/categories/AOSP/"}],"tags":[{"name":"编译","slug":"编译","permalink":"http://wenyiqingnian.xyz/tags/编译/"},{"name":"SEAndroid","slug":"SEAndroid","permalink":"http://wenyiqingnian.xyz/tags/SEAndroid/"}]},{"title":"fiddler抓android数据包","slug":"抓包工具 - Fiddler（如何捕获Android数据包）","date":"2016-08-03T12:20:17.000Z","updated":"2018-05-06T13:18:26.134Z","comments":true,"path":"2016/08/03/抓包工具 - Fiddler（如何捕获Android数据包）/","link":"","permalink":"http://wenyiqingnian.xyz/2016/08/03/抓包工具 - Fiddler（如何捕获Android数据包）/","excerpt":"","text":"抓包工具 - Fiddler（如何捕获Android数据包）移动设备访问网络原理 先看看移动设备是怎么去访问网络，如图所示，可以看到，移动端的数据包是从wifi出去的。可以看得出，移动端的数据包，都是要走wifi出去，所以我们可以把自己的电脑开启热点，将手机连上电脑，Fiddler开启代理后，让这些数据通过Fiddler，Fiddler就可以抓到这些包，然后发给路由器（如图）： 二、Fiddler抓取android数据包所需条件 1、电脑需要安装Fiddler 2、测试手机需要支持Wifi 3、测试手机与电脑需要同一网络 4、所测APP需支持代理 注：Iphone、Ipad、WinPhone等支持代理手机均适用 打开Wifi热点，让手机连上（我这里用的360wifi，其实随意一个都行） 打开Fidder，点击菜单栏中的 [Tools] –&gt; [Fiddler Options]Connections，设置代理端口：8888， 勾选 Allow remote computers to connect，即允许远程计算机连接Fiddler. 注：8888为默认端口号，可修改，但需注意两点，一是本机空闲端口，二是手机代理设置时要与fiddler的端口一致。 3、设置解密HTTPS的网络数据 Tools –&gt; Options-&gt; Https，勾选”Decrypt HTTPS traffic”、”Ignore server certificate errors”， 4、查看本机的无线网卡IP 设置了上面的步骤后，就可以在 Fiddler看到自己本机无线网卡的IP了（要是没有的话，重启Fiddler，或者可以在cmd中ipconfig找到自己的网卡IP，注：一定要开启本机的wifi热点）， 也可以在CMD中查看本机网卡的IP，输入命令：ipconfig， 5、手机连接本机的Wifi，并设置代理 每个品牌的手机设置wifi的方式可能不一样，这里以华为手机为例，如图8所示，将手机连接至PC的wifi 勾选“显示高级选项”-&gt; 代理 选择“手动” -&gt;输入服务器主机名和服务器端口 -&gt;IP选择“DHCP”-&gt;连接，即完成手机端设置代理操作，如图9所示 注：服务器主机名：Fiddler所在电脑IP（即开启wifi后，在fiddler或cmd中看到的无线网卡IP地址） 服务器端口： Fiddler使用的端口（即Options-Connections中设置的端口号） 6、手机下载安装Fiddler证书 连接上wifi后，手机打开浏览器输入代理IP+端口号（即是本机无线网卡IP，也是手机连接wifi时所设置的服务器主机名，这里的ip+端口号为192.168.191.1：8888），进入fiddler echo service页面，下载Fiddler的证书，如图10所示，点击FiddlerRoot certificate 下载完成后，进行安装证书 【注意】：如果打开浏览器碰到类似下面的报错，请打开Fiddler的证书解密模式（如上面的步骤3所示）：No root certificate was found. Have you enabled HTTPS traffic decryption in Fiddler yet? 设置完上面6个步骤后，即表明已设置完毕，此时用手机访问应用，就可以看到fiddler抓取到的数据包了.","categories":[{"name":"Android","slug":"Android","permalink":"http://wenyiqingnian.xyz/categories/Android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://wenyiqingnian.xyz/tags/android/"},{"name":"抓包","slug":"抓包","permalink":"http://wenyiqingnian.xyz/tags/抓包/"}]},{"title":"Linux vi用法","slug":"Linux vi命令使用方法","date":"2016-07-04T13:11:15.000Z","updated":"2018-05-06T13:12:58.582Z","comments":true,"path":"2016/07/04/Linux vi命令使用方法/","link":"","permalink":"http://wenyiqingnian.xyz/2016/07/04/Linux vi命令使用方法/","excerpt":"","text":"vi编辑器支持编辑模式和命令模式，编辑模式下可以完成文本的编辑功能，命令模式下可以完成对文件的操作命令，要正确使用vi编辑器就必须熟练掌握着两种模式的切换。默认情况下，打开vi编辑器后自动进入命令模式。从编辑模式切换到命令模式使用“esc”键，从命令模式切换到编辑模式使用“A”、“a”、“O”、“o”、“I”、“i”键。 vi编辑器提供了丰富的内置命令，有些内置命令使用键盘组合键即可完成，有些内置命令则需要以冒号“：”开头输入。常用内置命令如下： 12345678910111213141516171819202122232425262728293031323334Ctrl+u：向文件首翻半屏；Ctrl+d：向文件尾翻半屏；Ctrl+f：向文件尾翻一屏；Ctrl+b：向文件首翻一屏；Esc：从编辑模式切换到命令模式；ZZ：命令模式下保存当前文件所做的修改后退出vi；:行号：光标跳转到指定行的行首；:$：光标跳转到最后一行的行首；x或X：删除一个字符，x删除光标后的，而X删除光标前的；D：删除从当前光标到光标所在行尾的全部字符；dd：删除光标行正行内容；ndd：删除当前行及其后n-1行；nyy：将当前行及其下n行的内容保存到寄存器？中，其中？为一个字母，n为一个数字；p：粘贴文本操作，用于将缓存区的内容粘贴到当前光标所在位置的下方；P：粘贴文本操作，用于将缓存区的内容粘贴到当前光标所在位置的上方；/字符串：文本查找操作，用于从当前光标所在位置开始向文件尾部查找指定字符串的内容，查找的字符串会被加亮显示；？name：文本查找操作，用于从当前光标所在位置开始向文件头部查找指定字符串的内容，查找的字符串会被加亮显示；a，bs/F/T：替换文本操作，用于在第a行到第b行之间，将F字符串换成T字符串。其中，“s/”表示进行替换操作；a：在当前字符后添加文本；A：在行末添加文本；i：在当前字符前插入文本；I：在行首插入文本；o：在当前行后面插入一空行；O：在当前行前面插入一空行；:wq：在命令模式下，执行存盘退出操作；:w：在命令模式下，执行存盘操作；:w！：在命令模式下，执行强制存盘操作；:q：在命令模式下，执行退出vi操作；:q！：在命令模式下，执行强制退出vi操作；:e文件名：在命令模式下，打开并编辑指定名称的文件；:n：在命令模式下，如果同时打开多个文件，则继续编辑下一个文件；:f：在命令模式下，用于显示当前的文件名、光标所在行的行号以及显示比例；:set number：在命令模式下，用于在最左端显示行号；:set nonumber：在命令模式下，用于在最左端不显示行号；","categories":[{"name":"Linux","slug":"Linux","permalink":"http://wenyiqingnian.xyz/categories/Linux/"}],"tags":[{"name":"linux命令","slug":"linux命令","permalink":"http://wenyiqingnian.xyz/tags/linux命令/"}]}]}