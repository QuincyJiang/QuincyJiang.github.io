{"meta":{"title":"瘟疫青年","subtitle":null,"description":null,"author":"QuincyJiang","url":"http://wenyiqingnian.xyz"},"pages":[{"title":"About","date":"2018-05-16T15:32:37.296Z","updated":"2018-05-16T15:32:37.287Z","comments":true,"path":"about/index.html","permalink":"http://wenyiqingnian.xyz/about/index.html","excerpt":"","text":"Name： Quincyjiang Male 24 (1993/08/19) Major：ICS（Information and computer science） Location：Guangzhou，China Contact： &#49;&#48;&#56;&#51;&#x38;&#x37;&#x33;&#x32;&#x37;&#50;&#64;&#113;&#113;&#46;&#x63;&#x6f;&#109; &#x6a;&#x69;&#97;&#x6e;&#103;&#x39;&#51;&#48;&#x36;&#x32;&#x35;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#109; Intro：文艺码农，胶片玩家 Language Java Android Python C/C++"},{"title":"Categories","date":"2018-05-09T16:50:09.425Z","updated":"2018-05-05T15:10:05.116Z","comments":true,"path":"categories/index.html","permalink":"http://wenyiqingnian.xyz/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2018-05-06T06:09:35.982Z","updated":"2018-05-05T15:10:05.117Z","comments":true,"path":"tags/index.html","permalink":"http://wenyiqingnian.xyz/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"JAVA的垃圾回收策略（二）","slug":"JAVA的垃圾回收策略（二）","date":"2018-05-23T08:56:50.000Z","updated":"2018-05-24T03:46:18.907Z","comments":true,"path":"2018/05/23/JAVA的垃圾回收策略（二）/","link":"","permalink":"http://wenyiqingnian.xyz/2018/05/23/JAVA的垃圾回收策略（二）/","excerpt":"","text":"上文说到了一个java对象的生命周期以及生存位置本文主要讲 jvm虚拟机如何判定一个对象是否是垃圾，以及以何种算法回收垃圾。 GC的工作流程1. 判定那些对象已成为垃圾jvm一般有两种方法判断对象是否成为垃圾 1. 引用标记算法1.流程 给每一个对象都增加一个引用计数器 每次对象新增一个引用的时候，该计数器+1 当该引用对象失效（比如超出了作用域）==【注1】==，该引用计数器-1 当该对象的引用计数器为1时，表明该对象不可用，可作为垃圾回收了。 注1：作用域的概念，上文其实已经说过了，见JAVA垃圾回收机制。当在方法内创建了一个引用变量并指向它引用的对象的时候，引用的对象会在方法执行完后仍然存活在堆内存上，只是引用变量会随方法一起出栈销毁而已，见下面的例子。 123456789void fun()&#123;...Persion p = new Person();&#125;/***方法之外，引用变量P就消失了，因为引用变量是存放在*方法栈中的，所以方法执行完毕，p便随着方法栈一起出*栈，但是因为这中间调用了new 关键字,其创建的person对象会一直存放在堆内存中等待**被GC，此时person对象，就是超出了作用域的对象。*/ 123graph LRCLASS_A--&gt;CLASS_BCLASS_B--&gt;CLASS_A 2. 引用标记算法的优缺点 优点：算法简单，执行速度快，不需要长时间中断应用程序的执行 缺陷：无法解决循环引用问题（A引用B，B引用A，此时引用计数器永远无法置0）。2. GC_ROOT 可达性算法1. 原理 以GC root作为根节点 ==（gcroot具体包含那些对象下面会详细解释）==,向下搜寻所有对象 如果可以走到该对象，就建立一个该对象和GCTROOT之间的引用链。 从根节点开始，生成对象引用树，不可达的对象，会被判断为垃圾由GC判断是否回收 123456789101112graph LRGCROOT--&gt;CLASS_AGCROOT--&gt;CLASS_BGCROOT--&gt;CLASS_CGCROOT--&gt;CLASS_ECLASS_A--&gt;CLASS_DCLASS_A--&gt;CLASS_FCLASS_B--&gt;CLASS_FCLASS_B--&gt;CLASS_GCLASS_H--&gt;CLASS_JCLASS_J--&gt;CLASS_HCLASS_E--&gt;CLASS_K 上图的对象h和对象j 就是不可达的引用，但是彼此持有对方的引用，如果用引用计数算法，该对象是无法被回收的，gcroot算法，他们是不可达的，会随时被gc回收。 3.关于回收的一些其他问题当对象被标记为不可达的时候，gc并不会立刻启动回收程序，而是再使用两次标记算法来区分何时回收。在GC启动回收程序的时候，为了保证引用状态不变，系统会暂停所有应用进程（stopt the world ），这个时间很短，反应在UI上就是UI卡顿了一下，所以安卓应用要十分注意合理控制好内存回收，不要频繁处罚GC，不然体验会十分糟糕。 二次标记算法:1.如果对象与GC Root没有连接的引用链，就会被第一次标记，随后判定该对象是否有必要执行finalize()方法 2.如果有必要执行finalize()方法，则这个对象就会被放到F-Queue的队列中，稍后由虚拟机建立低优先级的Finalizer线程去执行，但并不承诺等待它运行结束（对象类中能够重写finalize()方法进行自救，但系统最多只能执行一次） 3.如果没必要执行finalize()方法，则第二次标记 2. 通过特定算法回收垃圾主要包括以下四种算法 12341、标记清除算法2、算法算法3、标记整理算法4、分代回收算法 1. 标记清除算法两步走 标记 标记出无用的对象 清除 清除掉对象的空间 可以看到 优缺点很明显 123缺点：容易造成内存碎片，当下次申请大内存的时候，可能找不到连续的内存给其使用，会频繁出发gc，优点：是算法比较简单。 因为标记无用对象耗时，可以看出 标记清除算法比较适合于 垃圾少，存活对象多的情况，可以减少标记次数。在分代回收算法中，它一般应用在老年代（对象存活率高，需要回收的少） 2. 复制算法（也被成为拷贝回收算法）此方法将内存按容量分为两块，例如A、B两块，每次只使用其中的一块，当要进行回收操作时，将A中还存活的对象复制到B块中（假设上次使用A），然后对A中所有对象清空就又构成一个完整的内存块。这种方法就避免了标记清除的内存碎片问题。 123优点：不会产生内存碎片缺点： 会浪费内存，因为不管A块中有多少存活对象，都只能使用内存的一半，AB块中始终有一块为空，属于用空间换时间。 分代回收法中新生代的部分，使用的是该算法。 适合存活对象少 回收对象多的情况，因为存活对象多复制的过程就长一些，算法效率会受影响。 3. 标记整理算法解决了上述两种算法的缺点，但也带来了新的缺点，就是算法效率不够高。 1231. 标记存活对象2. 移动对象到左上角3. 将其他空间全部回收 123优点： 不会产生内存碎片 不会造成空间使用浪费缺点：标记的过程导致其效率不如复制算法，移动的过程，导致其效率不如标记算法。 适合存活对象多 4. 分代回收算法该算法其实是上述三种算法的组合，因为上述三种算法都有其适用的适用情景，不可能适用所有情况，分代回收算法就是根据jvm里不同对象的存活特性来组合使用上述三种算法。 jvm按照对象生命周期将内存划分为两个区域。 新生代 新生代会产生大量的临时对象。这些对象 朝生夕死。存活时间短，经常需要回收，所以采用拷贝回收算法。在新生代的gc，称之为minor gc。 老年代 一般是生命周期长的对象，回收频率很低，只有当老年代内存占满了之后，才会触发一次full gc，或称之为（major gc）。 内存的具体划分 可以看到 新生代又被分为Eden 区 和 s1，s2区。s1 s2是为了拷贝算法划分的乒乓区域。他们大小是相同的。 2. 分代回收算法的具体回收过程 新生对象全部在Eden区域活动，当Eden区域满了之后，会触发一次minor gc 将Eden区域中还能用的的对象拷贝到From区域。 此时 Eden区域的空间被清空，存活对象在From区。 当From区域满了之后，会再次触发monor gc，将Eden和From区域中还可用的对象拷贝到To区域中。 此时 Eden 和From区的空间被清空。 当To的空间满了之后，会再次触发minor gc，此时会将Eden 和To 空间中还存活的对象拷贝到From区。Eden 和To space被清空。 在多次minor gc之后，有些对象会一直在from和to 区域之间来回拷贝，此时会被算法标注为老年代对象，gc会将该对象从新生代直接拷贝到老年代。JVM虚拟机默认的反复拷贝次数为==15次==。如果对象在From 到 to区域中反复拷贝了15次，就会被划分为老年代。 对象进入老年代之后，当老年代内存区域也满了，便会触发一次Full gc， 此时使用的算法是标记算法和标记整理算法。 为什么老年代的gc 不使用拷贝算法，因为老年代中的对象大多是存活率高的对象，使用拷贝算法要创建一个很大的新内存空间来做拷贝，这样很浪费资源。为什么不只使用标记算法，因为这样会导致内存碎片。使用标记清除算法，会将存活对象做地址移动，都集中在一块连续地址空间中，防止产生内存碎片。 所monor gc的时候，是用空间换时间，因为该gc发生频繁，效率是首要考虑的问题。 而full gc的时候，腾出空间更重要，所以选择用时间（使用标注整理算法）换空间。 3. 新生代老年代的内存划分比新生代：老年代 2：1 新生代中 Eden : s1 : s2 = 8 : 1 : 1 3. GC_ROOT要记住一个概念，选gcroot，就是要以这些当前活跃的gcroot对象为根去遍历所有引用关系，能遍历到的就是存活的，遍历不到的认为死去，所以选gcroot，本质是找到==所有存活的对象==，把其他空间认定为无用去清除掉。所以gcroot必须具备两个性质 必须存活 必须有其他引用（因为要以它自己去遍历引用关系） jvm 运行时内存 所以“GC roots”，或者说tracing GC的“根集合”，就是一组必须==活跃==的==引用==。具体包括以下几种： 1234567891. Class 由System Class Loader/Boot Class Loader加载的类，类似于java.util.*包下的类，因为它一定是贯穿于整个生命周期的，可以以此为根遍历出去找到其他引用的类。被引用到的就一定是存活的。2. Thread 对象，已激活但是未结束的线程对象；3. Stack Local 栈中的对象。每个线程都会分配一个栈，栈中的局部变量或者参数的引用都是GC root，因为仍在栈中，表明方法还没执行完，对象仍存活，（执行后的方法会出栈，就不满足存活条件了），同时是引用对象。4.JNI Local JNI中的局部变量和参数引用的对象；可能在JNI中定义的，也可能在虚拟机中定义5. JNI Global JNI中的全局变量引用的对象；同上6. Monitor Used 用于保证同步的对象，例如wait()，notify()中使用的对象、锁等。7. Held by JVM JVM持有的对象。JVM为了特殊用途保留的对象，它与JVM的具体实现有关。比如有System Class Loader, 一些Exceptions对象，和一些其它的ClassLoader。对于这些类，JVM也没有过多的信息。8. 静态数据结构指向对象堆的引用。 关于1 2 我举几个具体例子来说明一下： 123456789101112131415161718192021222324252627//1.由系统类加载器加载的类public class ServiceManager extends Service &#123; public Person p = new Person();&#125;这里不确切，但是大致可以表明意思，安卓ServiceManager贯穿整个应用生命周期，它里面持有Persion对象的引用，这个ServiceManager对象就是gcroot 它持有的person对象永远不会被释放。2. //Thred Localpublic class A&#123; void main()&#123; Thread t = new Thread(new Runnable() &#123; @Override public void run() &#123; B b = new B(); &#125; &#125;); t.start(); &#125; &#125;t 属于gcroot 如果不停止thread t永远不会被回收，它持有的b 也不会被回收。3. ==注意，是一组必须活跃的引用，不是对象==Tracing GC的根本思路就是：给定一个集合的引用作为根出发，通过引用关系遍历对象图，能被遍历到的（可到达的）对象就被判定为存活，其余对象（也就是没有被遍历到的）就自然被判定为死亡。注意再注意：tracing GC的本质是==通过找出所有活对象来把其余空间认定为“无用”==，而不是==找出所有死掉的对象并回收它们占用的空间==。这里非常容易搞混淆！！GC roots这组引用是tracing GC的起点。 4 . 安卓的Dalvik虚拟机与jvm不同的地方1. 堆的结构不同 Dalvik虚拟机用来分配对象的堆划分为两部分，一部分叫做Active Heap，另一部分叫做Zygote Heap。为什么要划分为两个堆，是为了减少内存拷贝的过程。(5.0之后改为ART虚拟机，ART运行时堆划分为四个空间，分别是Image Space、Zygote Space、Allocation Space和Large Object Space) 123graph LRActiveHeapZygoteHeap 我们知道 安卓系统的父进程是Zygote进程，它在开机的过程中就为Android系统准备好了一个Dalvik虚拟机实例。 安卓的每一个应用程序都是一个独立的进程，都有自己独立的内存空间和虚拟机实例，如果在应用启动的时候都重新为其创建虚拟机实例，是十分消耗资源的，为了加快这个速度，dalvik虚拟机采用写时拷贝的方式，将Zygote进程在开机时就创建好的Dalvik虚拟机实例，复制到应用程序的进程中去，从而加快了Android应用程序进程的启动过程。 因为zygote进程作为核心进程，应用的虚拟机实例都是复制于它，在创建虚拟机实例的时候，要预先加载安卓系统的核心方法还有一些核心类，是重量级的进程。主要做了以下四件事情：12341. 创建了一个Dalvik虚拟机实例；2. 加载了Java核心类及其JNI方法；3. 为主线程的设置了一个JNI环境；4. 注册了Android核心类的JNI方法。 这些核心类可以与应用程序共享，所以说 zygote牺牲自己的启动时间，来提高应用的加载速度。 但拷贝仍然是很费时的操作，为了避免拷贝，dalvik将自己的堆分为两部分，事实上，Dalvik虚拟机的堆最初是只有一个的。也就是Zygote进程在启动过程中创建Dalvik虚拟机的时候，只有一个堆。但是当Zygote进程在fork第一个应用程序进程之前，会将已经使用了的那部分堆内存划分为一部分，还没有使用的堆内存划分为另外一部分。前者就称为Zygote堆，后者就称为Active堆。以后无论是Zygote进程，还是应用程序进程，当它们需要分配对象的时候，都在Active堆上进行。 zygote堆 zygote进程启动创建虚拟机的时候已经用了的那部分内存，主要存的是Zygote进程在启动过程中预加载的类、资源和对象 active堆 zygote启动创建虚拟机时尚未使用的堆内存。应用程序还有zygote进程创建对象都在该堆进行 这样就可以使得Zygote堆尽可能少地被执行写操作，因而就可以减少执行写时拷贝的操作，在zygote堆中存放的预加载的类、资源和对象可以在Zygote进程和应用程序进程中做到长期共享。这样既能减少拷贝操作，还能减少对内存的需求。 2.标记机制不同 虽然dalvik虚拟机也是用的标记-清除算法，但为了减少Stop_the_world 造成的停顿，采用的并行垃圾回收算法（Concurrent GC） 标记被分为两部分 第一步 只标记gcroot 引用的对象 第二步 标记被gcroot 引用对象所引用的其他对象例如，一个栈变量引了一个对象，而这个对象又通过成员变量引用了另外一个对象，那该被引用的对象也会同时标记为正在使用。这个标记被根集对象引用的对象的过程就是第二个子阶段。 注意 在Concurrent GC，第一个子阶段是不允许垃圾收集线程之外的线程运行的，但是第二个子阶段是允许的。不过，在第二个子阶段执行的过程中，如果一个线程修改了一个对象，那么该对象必须要记录起来，因为它很有可能引用了新的对象，或者引用了之前未引用过的对象。如果不这样做的话，那么就会导致被引用对象还在使用然而却被回收。这种情况出现在只进行部分垃圾收集的情况，这时候Card Table的作用就是用来记录非垃圾收集堆对象对垃圾收集堆对象的引用。 4. 由垃圾回收机制引申的内存泄漏问题所谓内存泄漏，其实就是该回收的对象无法回收，造成无法回收的原因就是它还被gcroot直接或者间接引用。 可以看几个内存泄漏的例子 静态类123456public class A &#123; public static Context instance; public A(Context context)&#123; this.instance = context; &#125;&#125; 静态成员变量 instance 持有一个context的引用，instance是gcroot，不会被回收，它持有的context对象也不会被回收，导致内存泄漏。 匿名内部类 创建HashMap的时候， 123public class A &#123; public static List&lt;HashMap&lt;String,Object&gt;&gt; list = new ArrayList&lt;&gt;();&#125; 属于匿名创建，list中会持有外部类的引用，list又是一个gcroot，导致类A 无法被回收，另一个常见的例子：123456789101112131415public class MainActivity extends AppCompatActivity &#123; private static MyHandler handler = new MyHandler(); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); &#125; public class MyHandler extends Handler &#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); &#125; &#125;&#125; 静态成员变量handler指向Myhandler()，是GCROOT成员，但MyHandler是内部类，持有外部类MainActivity的引用，会导致MainActivity 无法被回收。 线程未结束12345678910111213141516public class MainActivity extends MainActivity &#123; void foo()&#123; Thread t = new Thread(new Runnable() &#123; @Override public void run() &#123; Activity a = MainActivity.this; ... ... &#125; &#125;); t.start(); &#125; &#125; 如果t不执行完，Activity1就无法被回收。 JNI LOCAL GLOBAL reference这类对象一般发生在参与Jni交互的类中。 比如说很多close()相关的类，InputStream,OutputStream,Cursor,SqliteDatabase等。这些对象不止被Java代码中的引用持有，也会被虚拟机中的底层代码持有。在将持有它们的引用设置为null之前，要先将他们close()掉。还有一个特殊的类是Bitmap。在Android系统3.0之前，它的内存一部分在虚拟机中，一部分在虚拟机外。因此它的一部分内存不参与垃圾回收，需要我们主动调用recycler()才能回收。 动态链接库中的内存是用C/C++语言申请的，这些内存不受虚拟机的管辖。所以，so库中的数组，类等都有可能发生内存泄漏，使用的时候务必小心。","categories":[{"name":"java基础","slug":"java基础","permalink":"http://wenyiqingnian.xyz/categories/java基础/"}],"tags":[{"name":"java","slug":"java","permalink":"http://wenyiqingnian.xyz/tags/java/"},{"name":"垃圾回收","slug":"垃圾回收","permalink":"http://wenyiqingnian.xyz/tags/垃圾回收/"}]},{"title":"JAVA的垃圾回收策略","slug":"JAVA的垃圾回收策略","date":"2018-05-16T16:56:50.000Z","updated":"2018-05-16T16:56:24.408Z","comments":true,"path":"2018/05/17/JAVA的垃圾回收策略/","link":"","permalink":"http://wenyiqingnian.xyz/2018/05/17/JAVA的垃圾回收策略/","excerpt":"","text":"前言创建了一个对象，就意味着或早或晚，该对象都是需要 被释放掉的，只不过这个时间有长有短，对象从被new出来到被垃圾回收器回收，就是一个生命周期的完整过程，java的垃圾回收机制可以做到自动决定哪些对象是无用的从而被回收掉，无需使用者担心，但是不健壮的java代码会影响到回收算法对无效对象的识别，从而影响对象的生命周期，导致无法回收。为了弄清楚java的垃圾回收机制，有必要先搞懂下面这些概念。 java程序的生存空间： 堆与栈 堆：实例变量（成员变量）与对象的生存空间 栈：方法调用与局部变量的生存空间 注1：实例变量生命在对象内部，而不是方法内，塔代表每一个独立对象的“字段”，是存储在对象中的。 注2：局部变量生命在方法中，他们是暂时的，生命周期只限于方法被放入栈上的时间，也就是方法执行到结束的过程。 注3：方法的调用过程，是伴随方法栈入栈出栈的过程的，方法被调用，一个对应的方法堆栈块也就被放置到栈顶，这个堆栈块里除了存放局部变量和方法参数之外，还会存放方法的执行状态，包括方法执行的行数，当方法执行完毕之后，该方法堆栈块便会出栈。 如果是这样 1234567891011public static void main(String[] args)&#123; foo1();&#125;void bar()&#123;&#125;void foo2()&#123;&#125;void foo1()&#123; foo2();&#125; 方法foo1 调用了foo2 执行到调用时，会将foo2放在foo1()的栈顶上，foo1被压下去。 注4：非primitive（注5）的变量都只是对对象的引用而已，所以所有的局部变量，变量本身都是存放在方法栈空间的，当所指向的对象被实例化了，对象存放在堆空间。 注5：java的变量类型分为 primitive数据类型和 引用类型，primitive 主数据类型用来保存基本类型的值，包括整数、布尔和浮点数等，而对象引用保存的是对象的引用。 注6： 不管是实例变量还是局部变量，对象本身都是存放在堆上的 对象的创建 三部曲：声明、创建、赋值123Duck duck // 1.创建出新的引用变量duck给Duck类型= //3. 赋值该对象给引用变量new Duck(); //2. 创建该对象实例 调用new 方法，便创建了一个duck实例，这其中的过程其实是调用了类的构造方法。 注意 对象构造方法会先与对象实例被赋值给引用对象之前就执行。1234567891011public class People&#123; public People()&#123; System.out.println('people'); &#125;&#125;public class Person&#123; public static void main()&#123; People p = new People(); &#125;&#125; 会打印出people的log 对象的声明周期对象的生命周期是看对象的引用。如果还有引用，对象继续存活在堆上，如果没有引用了，对象就会被垃圾回收器回收。所以==对象的声明周期 要看引用变量的声明周期==，而引用变量的声明周期，又要看它是局部变量还是成员变量。 局部变量： 与方法声明周期同步，只活在该方法内，方法执行完毕，对象立即被释放，对其他程序和方法不可见。 成员变量： 与对象声明周期同步。如果对象活着，该成员变量也活着。关于局部变量，这里需要讲两个概念Life对象的堆栈块还在栈内，方法还没执行完，就还活着。活到方法执行完结束。 Scope局部变量的范围，只存在声明它的方法内，如果该方法调用了其他方法，则该变量仍然存活，只不过在执行调用方法的时候，该变量不在它的范围而已。 只要方法还没执行完，对象就不会死，但只有方法在栈顶，对象才是可用的。 变量的生命周期如何影响对象的生命周期？只要有活的引用，对象会一直活着，如果对某个对象的引用不在它的范围内，但该引用变量还是活的，则该对象也会活着，呆在堆内存中。如果对该对象的唯一引用没有了，对象便会回收 三种方法释放对象引用：12345678910// 方法执行完，引用便释放了void go()&#123; People p = new People();&#125;// 引用被赋值到别处People p = new People();p = new People(); //第一个对象会在此时被释放// 直接置空People p = new People();p =null; —待续 5.17 00:51","categories":[{"name":"java基础","slug":"java基础","permalink":"http://wenyiqingnian.xyz/categories/java基础/"}],"tags":[{"name":"java","slug":"java","permalink":"http://wenyiqingnian.xyz/tags/java/"},{"name":"垃圾回收","slug":"垃圾回收","permalink":"http://wenyiqingnian.xyz/tags/垃圾回收/"}]},{"title":"hexo+icarus","slug":"hexo+icarus","date":"2018-05-13T16:15:50.000Z","updated":"2018-05-24T03:40:05.312Z","comments":true,"path":"2018/05/14/hexo+icarus/","link":"","permalink":"http://wenyiqingnian.xyz/2018/05/14/hexo+icarus/","excerpt":"","text":"安装hexo1. 安装node2. 生成ssh公钥秘钥对 并且添加到github上3. 安装hexo1npm install -g hexo 4. 初始化hexo1hexo init hexo 5. 安装部署依赖文件进入hexo目录1npm install 6. 安装hexo-server1npm install hexo-server hexo-server 会创建本地服务器，你可以使用hexo s来在本地预览你的博客效果。 6. 生成hexo的目录结构1hexo generate 7. 配置_config.yml文件需要修改博客根目录的config文件，添加上你的github.io仓库地址，注意，你的ssh公钥此时应该已经添加到github上了 我的配置如下 1234deploy: type: git repository: https://github.com/QuincyJiang/QuincyJiang.github.io.git branch: master 8.目录结构以及写作流程1234567/scaffoldssource/themes.gitignore_config.ymlpackage.jsonpackage-lock.json public文件夹是每次hexo g 自动生成的网页静态代码 source中存放日志的原始md文件，每次写了新的文章，就需要将文章放置在该目录下，然后1hexo g 来生成静态网页代码，生成的代码会创建1/public 文件夹， 如果启用了 about tags categories等界面 也需要在source目录中创建对应的文件夹（about，tags，categories文件夹，内部放index.md文件，文件头以 123title: &quot;About&quot;layout: &quot;about&quot;--- 这种格式编写。 当文章写完并且已使用 1hexo g 生成public文件夹后，使用 123hexo sINFO Start processingINFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 在浏览器输入 1localhost:4000 来本地预览博客效果。 确认无误，使用 1hexo d 部署博客到github.io仓库。 主题配置下载主题克隆你喜欢的主题到/themes文件夹内。我使用的是icarus主题 自定义主题配置 修改根目录config文件，指定主题为icarus 1theme: icarus 进入themes/icarus/目录下,修改config文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101# Menusmenu: # 配置主页上方的分类项 如果需要开启 要在博客根目录的source 文件夹下创建对应的同名文件并防止index.md 上面已经说过了 Home: . Archives: archives Categories: categories Tags: tags About: about# Customizecustomize: logo: # 左上方小logo 将png文件放在主题目录下的css/image目录下 enabled: true width: 40 height: 40 url: images/logo.png profile: enabled: true # Whether to show profile bar fixed: true avatar: css/images/avatar.png gravatar: # Gravatar email address, if you enable Gravatar, your avatar config will be overriden author: QuincyJiang author_title: Coder &amp; FilmPlayer location: Guangzhou, China follow: https://github.com/QuincyJiang highlight: androidstudio # 代码高亮风格，需要md文件格式支持，在代码块外 要显示标注代码语言 比如 ···java public static void main()&#123; ... &#125; ... sidebar: right # sidebar position, options: left, right or leave it empty thumbnail: true # enable posts thumbnail, options: true, false favicon: css/images/avatar.png social_links: github: https://github.com/QuincyJiang weibo: https://weibo.com/2425393311/ photo: http://aquencyua11.lofter.com/ social_link_tooltip: true # enable the social link tooltip, options: true, false# Widgetswidgets: - recent_posts - category - archive - tag - tagcloud - links# Search 是否启用insight搜索search: insight: true # you need to install `hexo-generator-json-content` before using Insight Search swiftype: # enter swiftype install key here baidu: false # you need to disable other search engines to use Baidu search, options: true, false# Comment 是否开启评论功能 需要disqus账号comment: # disqus: https-quincyjiang-github-io duoshuo: # enter duoshuo shortname here youyan: # enter youyan uid here facebook: # enter true to enable isso: # enter the domain name of your own comment isso server eg. comments.example.com changyan: # please fill in `appid` and `conf` to enable appid: conf: gitment: owner: #QuincyJiang repo: #https://github.com/QuincyJiang/comments.git #Register an OAuth application, and you will get a client ID and a client secret. client_id: client_secret: livere: # enter livere uid here valine: # Valine Comment System https://github.com/xCss/Valine on: # enter true to enable appId: # enter the leancloud application appId here appKey: # enter the leancloud application appKey here notify: # enter true to enable &lt;Mail notifier&gt; https://github.com/xCss/Valine/wiki/Valine-%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E9%82%AE%E4%BB%B6%E6%8F%90%E9%86%92%E8%AE%BE%E7%BD%AE verify: # enter true to enable &lt;Validation code&gt; placeholder: Just Do It # enter the comment box placeholder # Shareshare: default # options: jiathis, bdshare, addtoany, default# Pluginsplugins: lightgallery: true # options: true, false justifiedgallery: true # options: true, false google_analytics: # enter the tracking ID for your Google Analytics google_site_verification: # enter Google site verification code baidu_analytics: # enter Baidu Analytics hash key mathjax: false # options: true, false# Miscellaneousmiscellaneous: open_graph: # see http://ogp.me fb_app_id: fb_admins: twitter_id: google_plus: links: github: https://github.com/QuincyJiang 托管hexo博客源码为了保证切换电脑也可以保留原博客的风格，我们需要将博客的配置用git托管起来 1.创建hexo源码仓库去gitub 新建一个 源码仓库 1https://github.com/QuincyJiang/blog.git 2. 将博客代码使用git托管博客根目录在我们创建hexo项目的时候，就已经生成了一个gitignore文件 1234567.DS_StoreThumbs.dbdb.json*.lognode_modules/public/.deploy*/ 因为mode_modules public .deploy 文件夹都是会动态生成的，所以被添加到git忽略文件列表中了。注意，theme目录下我们克隆下来的第三方theme，它的远程仓库还是跟克隆时的目标仓库保持一致的，我们需要解除它远程仓库的关联，这样推送代码的时候才不会吧主题推送到其他地方。 a 清除第三方主题的远程仓库12cd themes/icarus/rm -rf .git b 修改主题目录下的gitignore文件因为主题的config配置文件我们也要托管起来，对博客的自定义配置主要都是在这里修改的。修改很简单 删除忽略文件中的config.yml就好了 c 创建版本库并与远程仓库链接123456cd ../../git initgit add . git remote add origin https://github/com/QuincyJiang/blog.gitgit commit -m &quot;init commit&quot;git push -u origin master 关于博客贴图一般使用md文件写博客的时候，贴图是最痛苦的事情，一般是现将图片上传到图床之后，再获取图片链接。这边安利一个软件 Mweb md文件编辑器，它可以用拖拽的方式来贴图，图片可以直接上传到github上。官网地址了解一下 用法非常简单 下载安装选择外部模式 点击右下角的加号 将hexo 博客的source文件夹添加进去编辑该folders，右键点击folder 选择图片保存路径以及路径类型 切换电脑后重新恢复博客环境克隆博客源码1git clone https://github/com/QuincyJiang/blog.git 配置基础环境123安装node安装git配置公钥到github 安装hexo1234npm install -g hexonpm install hexo --savenpm install hexo-servernpm install 至此hexo安装完成，回到熟悉的source/_post 目录愉快开始写作吧","categories":[{"name":"备忘录","slug":"备忘录","permalink":"http://wenyiqingnian.xyz/categories/备忘录/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://wenyiqingnian.xyz/tags/hexo/"}]},{"title":"六大设计模式","slug":"六大设计模式","date":"2018-05-12T16:51:50.000Z","updated":"2018-05-16T17:01:06.360Z","comments":true,"path":"2018/05/13/六大设计模式/","link":"","permalink":"http://wenyiqingnian.xyz/2018/05/13/六大设计模式/","excerpt":"","text":"设计模式六大原则（1）：单一职责原则 定义：不要存在多于一个导致类变更的原因。通俗的说，即一个类只负责一项职责。 问题由来：类T负责两个不同的职责：职责P1，职责P2。当由于职责P1需求发生改变而需要修改类T时，有可能会导致原本运行正常的职责P2功能发生故障。 解决方案：遵循单一职责原则。分别建立两个类T1、T2，使T1完成职责P1功能，T2完成职责P2功能。这样，当修改类T1时，不会使职责P2发生故障风险；同理，当修改T2时，也不会使职责P1发生故障风险。 说到单一职责原则，很多人都会不屑一顾。因为它太简单了。稍有经验的程序员即使从来没有读过设计模式、从来没有听说过单一职责原则，在设计软件时也会自觉的遵守这一重要原则，因为这是常识。在软件编程中，谁也不希望因为修改了一个功能导致其他的功能发生故障。而避免出现这一问题的方法便是遵循单一职责原则。虽然单一职责原则如此简单，并且被认为是常识，但是即便是经验丰富的程序员写出的程序，也会有违背这一原则的代码存在。为什么会出现这种现象呢？因为有职责扩散。所谓职责扩散，就是因为某种原因，职责P被分化为粒度更细的职责P1和P2。 比如：类T只负责一个职责P，这样设计是符合单一职责原则的。后来由于某种原因，也许是需求变更了，也许是程序的设计者境界提高了，需要将职责P细分为粒度更细的职责P1，P2，这时如果要使程序遵循单一职责原则，需要将类T也分解为两个类T1和T2，分别负责P1、P2两个职责。但是在程序已经写好的情况下，这样做简直太费时间了。所以，简单的修改类T，用它来负责两个职责是一个比较不错的选择，虽然这样做有悖于单一职责原则。（这样做的风险在于职责扩散的不确定性，因为我们不会想到这个职责P，在未来可能会扩散为P1，P2，P3，P4……Pn。所以记住，在职责扩散到我们无法控制的程度之前，立刻对代码进行重构。） 举例说明，用一个类描述动物呼吸这个场景： 12345678910111213class Animal&#123; public void breathe(String animal)&#123; System.out.println(animal+\"呼吸空气\"); &#125;&#125;public class Client&#123; public static void main(String[] args)&#123; Animal animal = new Animal(); animal.breathe(\"牛\"); animal.breathe(\"羊\"); animal.breathe(\"猪\"); &#125;&#125; 1234567运行结果：牛呼吸空气羊呼吸空气猪呼吸空气 程序上线后，发现问题了，并不是所有的动物都呼吸空气的，比如鱼就是呼吸水的。修改时如果遵循单一职责原则，需要将Animal类细分为陆生动物类Terrestrial，水生动物Aquatic，代码如下： 12345678910111213141516171819202122class Terrestrial&#123; public void breathe(String animal)&#123; System.out.println(animal+\"呼吸空气\"); &#125;&#125;class Aquatic&#123; public void breathe(String animal)&#123; System.out.println(animal+\"呼吸水\"); &#125;&#125;public class Client&#123; public static void main(String[] args)&#123; Terrestrial terrestrial = new Terrestrial(); terrestrial.breathe(\"牛\"); terrestrial.breathe(\"羊\"); terrestrial.breathe(\"猪\"); Aquatic aquatic = new Aquatic(); aquatic.breathe(\"鱼\"); &#125;&#125; 123456789运行结果：牛呼吸空气羊呼吸空气猪呼吸空气鱼呼吸水 我们会发现如果这样修改花销是很大的，除了将原来的类分解之外，还需要修改客户端。而直接修改类Animal来达成目的虽然违背了单一职责原则，但花销却小的多，代码如下： 12345678910111213141516171819class Animal&#123; public void breathe(String animal)&#123; if(\"鱼\".equals(animal))&#123; System.out.println(animal+\"呼吸水\"); &#125;else&#123; System.out.println(animal+\"呼吸空气\"); &#125; &#125;&#125;public class Client&#123; public static void main(String[] args)&#123; Animal animal = new Animal(); animal.breathe(\"牛\"); animal.breathe(\"羊\"); animal.breathe(\"猪\"); animal.breathe(\"鱼\"); &#125;&#125; 可以看到，这种修改方式要简单的多。但是却存在着隐患：有一天需要将鱼分为呼吸淡水的鱼和呼吸海水的鱼，则又需要修改Animal类的breathe方法，而对原有代码的修改会对调用“猪”“牛”“羊”等相关功能带来风险，也许某一天你会发现程序运行的结果变为“牛呼吸水”了。这种修改方式直接在代码级别上违背了单一职责原则，虽然修改起来最简单，但隐患却是最大的。还有一种修改方式： 12345678910111213141516171819class Animal&#123; public void breathe(String animal)&#123; System.out.println(animal+\"呼吸空气\"); &#125; public void breathe2(String animal)&#123; System.out.println(animal+\"呼吸水\"); &#125;&#125;public class Client&#123; public static void main(String[] args)&#123; Animal animal = new Animal(); animal.breathe(\"牛\"); animal.breathe(\"羊\"); animal.breathe(\"猪\"); animal.breathe2(\"鱼\"); &#125;&#125; 可以看到，这种修改方式没有改动原来的方法，而是在类中新加了一个方法，这样虽然也违背了单一职责原则，但在方法级别上却是符合单一职责原则的，因为它并没有动原来方法的代码。这三种方式各有优缺点，那么在实际编程中，采用哪一中呢？其实这真的比较难说，需要根据实际情况来确定。我的原则是：只有逻辑足够简单，才可以在代码级别上违反单一职责原则；只有类中方法数量足够少，才可以在方法级别上违反单一职责原则； 例如本文所举的这个例子，它太简单了，它只有一个方法，所以，无论是在代码级别上违反单一职责原则，还是在方法级别上违反，都不会造成太大的影响。实际应用中的类都要复杂的多，一旦发生职责扩散而需要修改类时，除非这个类本身非常简单，否则还是遵循单一职责原则的好。 遵循单一职责原的优点有： 可以降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多； 提高类的可读性，提高系统的可维护性； 变更引起的风险降低，变更是必然的，如果单一职责原则遵守的好，当修改一个功能时，可以显著降低对其他功能的影响。 需要说明的一点是单一职责原则不只是面向对象编程思想所特有的，只要是模块化的程序设计，都适用单一职责原则。 设计模式六大原则（2）：里氏替换原则肯定有不少人跟我刚看到这项原则的时候一样，对这个原则的名字充满疑惑。其实原因就是这项原则最早是在1988年，由麻省理工学院的一位姓里的女士（Barbara Liskov）提出来的。 定义1：如果对每一个类型为 T1的对象 o1，都有类型为 T2 的对象o2，使得以 T1定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。 定义2：所有引用基类的地方必须能透明地使用其子类的对象。 问题由来：有一功能P1，由类A完成。现需要将功能P1进行扩展，扩展后的功能为P，其中P由原有功能P1与新功能P2组成。新功能P由类A的子类B来完成，则子类B在完成新功能P2的同时，有可能会导致原有功能P1发生故障。 解决方案：当使用继承时，遵循里氏替换原则。类B继承类A时，除添加新的方法完成新增功能P2外，尽量不要重写父类A的方法，也尽量不要重载父类A的方法。 继承包含这样一层含义：==父类中凡是已经实现好的方法（相对于抽象方法而言），实际上是在设定一系列的规范和契约，虽然它不强制要求所有的子类必须遵从这些契约，但是如果子类对这些非抽象方法任意修改，就会对整个继承体系造成破坏==。而里氏替换原则就是表达了这一层含义。 继承作为面向对象三大特性之一，在给程序设计带来巨大便利的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低，增加了对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能会产生故障。 举例说明继承的风险，我们需要完成一个两数相减的功能，由类A来负责。 123456789101112131415161718class A&#123; public int func1(int a, int b)&#123; return a-b; &#125;&#125;public class Client&#123; public static void main(String[] args)&#123; A a = new A(); System.out.println(\"100-50=\"+a.func1(100, 50)); System.out.println(\"100-80=\"+a.func1(100, 80)); &#125;&#125; 运行结果：100-50=50100-80=20 后来，我们需要增加一个新的功能：完成两数相加，然后再与100求和，由类B来负责。即类B需要完成两个功能： 两数相减。两数相加，然后再加100。由于类A已经实现了第一个功能，所以类B继承类A后，只需要再完成第二个功能就可以了，代码如下： 12345678910111213141516171819202122232425class B extends A&#123; public int func1(int a, int b)&#123; return a+b; &#125; public int func2(int a, int b)&#123; return func1(a,b)+100; &#125;&#125;public class Client&#123; public static void main(String[] args)&#123; B b = new B(); System.out.println(\"100-50=\"+b.func1(100, 50)); System.out.println(\"100-80=\"+b.func1(100, 80)); System.out.println(\"100+20+100=\"+b.func2(100, 20)); &#125;&#125; 类B完成后，运行结果：100-50=150100-80=180100+20+100=220 我们发现原本运行正常的相减功能发生了错误。原因就是类B在给方法起名时无意中重写了父类的方法，造成所有运行相减功能的代码全部调用了类B重写后的方法，造成原本运行正常的功能出现了错误。在本例中，引用基类A完成的功能，换成子类B之后，发生了异常。在实际编程中，我们常常会通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的几率非常大。==如果非要重写父类的方法，比较通用的做法是：原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉，采用依赖、聚合，组合等关系代替==。 里氏替换原则通俗的来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。它包含以下4层含义： 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。 子类中可以增加自己特有的方法。 当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。* 当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。 看上去很不可思议，因为我们会发现在自己编程中常常会违反里氏替换原则，程序照样跑的好好的。所以大家都会产生这样的疑问，假如我非要不遵循里氏替换原则会有什么后果？ 后果就是：你写的代码出问题的几率将会大大增加。 设计模式六大原则（3）：依赖倒置原则定义： 高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。 问题由来：类A直接依赖类B，假如要将类A改为依赖类C，则必须通过修改类A的代码来达成。这种场景下，类A一般是高层模块，负责复杂的业务逻辑；类B和类C是低层模块，负责基本的原子操作；假如修改类A，会给程序带来不必要的风险。 ### 解决方案：将类A修改为依赖接口I，类B和类C各自实现接口I，类A通过接口I间接与类B或者类C发生联系，则会大大降低修改类A的几率。 依赖倒置原则基于这样一个事实：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建起来的架构比以细节为基础搭建起来的架构要稳定的多。在java中，抽象指的是接口或者抽象类，细节就是具体的实现类，使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成。 依赖倒置原则的核心思想是==面向接口编程==，我们依旧用一个例子来说明面向接口编程比相对于面向实现编程好在什么地方。场景是这样的，母亲给孩子讲故事，只要给她一本书，她就可以照着书给孩子讲故事了。代码如下： 123456789101112131415161718192021222324class Book&#123; public String getContent()&#123; return \"很久很久以前有一个阿拉伯的故事……\"; &#125;&#125;class Mother&#123; public void narrate(Book book)&#123; System.out.println(\"妈妈开始讲故事\"); System.out.println(book.getContent()); &#125;&#125;public class Client&#123; public static void main(String[] args)&#123; Mother mother = new Mother(); mother.narrate(new Book()); &#125;&#125; 运行结果：妈妈开始讲故事很久很久以前有一个阿拉伯的故事…… 运行良好，假如有一天，需求变成这样：不是给书而是给一份报纸，让这位母亲讲一下报纸上的故事，报纸的代码如下： 12345class Newspaper&#123; public String getContent()&#123; return \"林书豪38+7领导尼克斯击败湖人……\"; &#125;&#125; 这位母亲却办不到，因为她居然不会读报纸上的故事，这太荒唐了，只是将书换成报纸，居然必须要修改Mother才能读。假如以后需求换成杂志呢？换成网页呢？还要不断地修改Mother，这显然不是好的设计。原因就是Mother与Book之间的耦合性太高了，必须降低他们之间的耦合度才行。 我们引入一个抽象的接口IReader。读物，只要是带字的都属于读物： 123456789101112131415161718192021222324252627282930313233343536373839interface IReader&#123; public String getContent();&#125; Mother类与接口IReader发生依赖关系，而Book和Newspaper都属于读物的范畴，他们各自都去实现IReader接口，这样就符合依赖倒置原则了，代码修改为：class Newspaper implements IReader &#123; public String getContent()&#123; return \"林书豪17+9助尼克斯击败老鹰……\"; &#125;&#125;class Book implements IReader&#123; public String getContent()&#123; return \"很久很久以前有一个阿拉伯的故事……\"; &#125;&#125;class Mother&#123; public void narrate(IReader reader)&#123; System.out.println(\"妈妈开始讲故事\"); System.out.println(reader.getContent()); &#125;&#125;public class Client&#123; public static void main(String[] args)&#123; Mother mother = new Mother(); mother.narrate(new Book()); mother.narrate(new Newspaper()); &#125;&#125;运行结果：妈妈开始讲故事很久很久以前有一个阿拉伯的故事……妈妈开始讲故事林书豪17+9助尼克斯击败老鹰…… 这样修改后，无论以后怎样扩展Client类，都不需要再修改Mother类了。这只是一个简单的例子，实际情况中，代表高层模块的Mother类将负责完成主要的业务逻辑，一旦需要对它进行修改，引入错误的风险极大。所以遵循依赖倒置原则可以降低类之间的耦合性，提高系统的稳定性，降低修改程序造成的风险。 采用依赖倒置原则给多人并行开发带来了极大的便利，比如上例中，原本Mother类与Book类直接耦合时，Mother类必须等Book类编码完成后才可以进行编码，因为Mother类依赖于Book类。修改后的程序则可以同时开工，互不影响，因为Mother与Book类一点关系也没有。参与协作开发的人越多、项目越庞大，采用依赖导致原则的意义就越重大。现在很流行的TDD开发模式就是依赖倒置原则最成功的应用。 传递依赖关系有三种方式，以上的例子中使用的方法是接口传递，另外还有两种传递方式：构造方法传递和setter方法传递，相信用过Spring框架的，对依赖的传递方式一定不会陌生。 在实际编程中，我们一般需要做到如下3点： 低层模块尽量都要有抽象类或接口，或者两者都有。 变量的声明类型尽量是抽象类或接口。 使用继承时遵循里氏替换原则。 依赖倒置原则的核心就是要我们面向接口编程，理解了面向接口编程，也就理解了依赖倒置。 设计模式六大原则（4）：接口隔离原则定义： 客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。 问题由来：类A通过接口I依赖类B，类C通过接口I依赖类D，如果接口I对于类A和类B来说不是最小接口，则类B和类D必须去实现他们不需要的方法。 解决方案：将臃肿的接口I拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则。举例来说明接口隔离原则： （图1 未遵循接口隔离原则的设计） 这个图的意思是：类A依赖接口I中的方法1、方法2、方法3，类B是对类A依赖的实现。类C依赖接口I中的方法1、方法4、方法5，类D是对类C依赖的实现。对于类B和类D来说，虽然他们都存在着用不到的方法（也就是图中红色字体标记的方法），但由于实现了接口I，所以也必须要实现这些用不到的方法。对类图不熟悉的可以参照程序代码来理解，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778interface I &#123; public void method1(); public void method2(); public void method3(); public void method4(); public void method5();&#125;class A&#123; public void depend1(I i)&#123; i.method1(); &#125; public void depend2(I i)&#123; i.method2(); &#125; public void depend3(I i)&#123; i.method3(); &#125;&#125;class B implements I&#123; public void method1() &#123; System.out.println(\"类B实现接口I的方法1\"); &#125; public void method2() &#123; System.out.println(\"类B实现接口I的方法2\"); &#125; public void method3() &#123; System.out.println(\"类B实现接口I的方法3\"); &#125; //对于类B来说，method4和method5不是必需的，但是由于接口A中有这两个方法， //所以在实现过程中即使这两个方法的方法体为空，也要将这两个没有作用的方法进行实现。 public void method4() &#123;&#125; public void method5() &#123;&#125;&#125;class C&#123; public void depend1(I i)&#123; i.method1(); &#125; public void depend2(I i)&#123; i.method4(); &#125; public void depend3(I i)&#123; i.method5(); &#125;&#125;class D implements I&#123; public void method1() &#123; System.out.println(\"类D实现接口I的方法1\"); &#125; //对于类D来说，method2和method3不是必需的，但是由于接口A中有这两个方法， //所以在实现过程中即使这两个方法的方法体为空，也要将这两个没有作用的方法进行实现。 public void method2() &#123;&#125; public void method3() &#123;&#125; public void method4() &#123; System.out.println(\"类D实现接口I的方法4\"); &#125; public void method5() &#123; System.out.println(\"类D实现接口I的方法5\"); &#125;&#125;public class Client&#123; public static void main(String[] args)&#123; A a = new A(); a.depend1(new B()); a.depend2(new B()); a.depend3(new B()); C c = new C(); c.depend1(new D()); c.depend2(new D()); c.depend3(new D()); &#125;&#125; 可以看到，如果接口过于臃肿，只要接口中出现的方法，不管对依赖于它的类有没有用处，实现类中都必须去实现这些方法，这显然不是好的设计。如果将这个设计修改为符合接口隔离原则，就必须对接口I进行拆分。在这里我们将原有的接口I拆分为三个接口，拆分后的设计如图2所示： （图2 遵循接口隔离原则的设计） 照例贴出程序的代码，供不熟悉类图的朋友参考： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061interface I1 &#123; public void method1();&#125;interface I2 &#123; public void method2(); public void method3();&#125;interface I3 &#123; public void method4(); public void method5();&#125;class A&#123; public void depend1(I1 i)&#123; i.method1(); &#125; public void depend2(I2 i)&#123; i.method2(); &#125; public void depend3(I2 i)&#123; i.method3(); &#125;&#125;class B implements I1, I2&#123; public void method1() &#123; System.out.println(\"类B实现接口I1的方法1\"); &#125; public void method2() &#123; System.out.println(\"类B实现接口I2的方法2\"); &#125; public void method3() &#123; System.out.println(\"类B实现接口I2的方法3\"); &#125;&#125;class C&#123; public void depend1(I1 i)&#123; i.method1(); &#125; public void depend2(I3 i)&#123; i.method4(); &#125; public void depend3(I3 i)&#123; i.method5(); &#125;&#125;class D implements I1, I3&#123; public void method1() &#123; System.out.println(\"类D实现接口I1的方法1\"); &#125; public void method4() &#123; System.out.println(\"类D实现接口I3的方法4\"); &#125; public void method5() &#123; System.out.println(\"类D实现接口I3的方法5\"); &#125;&#125; 接口隔离原则的含义是： 建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。 也就是说，我们要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。本文例子中，将一个庞大的接口变更为3个专用的接口所采用的就是接口隔离原则。在程序设计中，依赖几个专用的接口要比依赖一个综合的接口更灵活。接口是设计时对外部设定的“契约”，通过分散定义多个接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。 说到这里，很多人会觉的接口隔离原则跟之前的单一职责原则很相似，其实不然。其一，单一职责原则原注重的是职责；而接口隔离原则注重对接口依赖的隔离。其二，单一职责原则主要是约束类，其次才是接口和方法，它针对的是程序中的实现和细节；而接口隔离原则主要约束接口接口，主要针对抽象，针对程序整体框架的构建。 采用接口隔离原则对接口进行约束时，要注意以下几点： 接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。 为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。 提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。 运用接口隔离原则，一定要适度，接口设计的过大或过小都不好。设计接口的时候，只有多花些时间去思考和筹划，才能准确地实践这一原则。 设计模式六大原则（5）：迪米特法则定义： 一个对象应该对其他对象保持最少的了解。 问题由来：类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。 解决方案：尽量降低类与类之间的耦合。 自从我们接触编程开始，就知道了软件编程的总的原则：低耦合，高内聚。无论是面向过程编程还是面向对象编程，只有使各个模块之间的耦合尽量的低，才能提高代码的复用率。低耦合的优点不言而喻，但是怎么样编程才能做到低耦合呢？那正是迪米特法则要去完成的。 迪米特法则又叫最少知道原则，最早是在1987年由美国Northeastern University的Ian Holland提出。通俗的来讲，就是一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类来说，无论逻辑多么复杂，都尽量地的将逻辑封装在类的内部，对外除了提供的public方法，不对外泄漏任何信息。迪米特法则还有一个更简单的定义：==只与直接的朋友通信==。首先来解释一下什么是直接的朋友：==每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系==。耦合的方式很多，依赖、关联、组合、聚合等。其中，我们称出现成员变量、方法参数、方法返回值中的类为直接的朋友，而出现在局部变量中的类则不是直接的朋友。也就是说，陌生的类最好不要作为局部变量的形式出现在类的内部。 举一个例子：有一个集团公司，下属单位有分公司和直属部门，现在要求打印出所有下属单位的员工ID。先来看一下违反迪米特法则的设计。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//总公司员工class Employee&#123; private String id; public void setId(String id)&#123; this.id = id; &#125; public String getId()&#123; return id; &#125;&#125;//分公司员工class SubEmployee&#123; private String id; public void setId(String id)&#123; this.id = id; &#125; public String getId()&#123; return id; &#125;&#125;class SubCompanyManager&#123; public List&lt;SubEmployee&gt; getAllEmployee()&#123; List&lt;SubEmployee&gt; list = new ArrayList&lt;SubEmployee&gt;(); for(int i=0; i&lt;100; i++)&#123; SubEmployee emp = new SubEmployee(); //为分公司人员按顺序分配一个ID emp.setId(\"分公司\"+i); list.add(emp); &#125; return list; &#125;&#125;class CompanyManager&#123; public List&lt;Employee&gt; getAllEmployee()&#123; List&lt;Employee&gt; list = new ArrayList&lt;Employee&gt;(); for(int i=0; i&lt;30; i++)&#123; Employee emp = new Employee(); //为总公司人员按顺序分配一个ID emp.setId(\"总公司\"+i); list.add(emp); &#125; return list; &#125; public void printAllEmployee(SubCompanyManager sub)&#123; List&lt;SubEmployee&gt; list1 = sub.getAllEmployee(); for(SubEmployee e:list1)&#123; System.out.println(e.getId()); &#125; List&lt;Employee&gt; list2 = this.getAllEmployee(); for(Employee e:list2)&#123; System.out.println(e.getId()); &#125; &#125;&#125;public class Client&#123; public static void main(String[] args)&#123; CompanyManager e = new CompanyManager(); e.printAllEmployee(new SubCompanyManager()); &#125;&#125; 现在这个设计的主要问题出在CompanyManager中，根据迪米特法则，只与直接的朋友发生通信，而SubEmployee类并不是CompanyManager类的直接朋友（以局部变量出现的耦合不属于直接朋友），从逻辑上讲总公司只与他的分公司耦合就行了，与分公司的员工并没有任何联系，这样设计显然是增加了不必要的耦合。按照迪米特法则，应该避免类中出现这样非直接朋友关系的耦合。修改后的代码如下: 123456789101112131415161718192021222324252627282930313233343536373839class SubCompanyManager&#123; public List&lt;SubEmployee&gt; getAllEmployee()&#123; List&lt;SubEmployee&gt; list = new ArrayList&lt;SubEmployee&gt;(); for(int i=0; i&lt;100; i++)&#123; SubEmployee emp = new SubEmployee(); //为分公司人员按顺序分配一个ID emp.setId(\"分公司\"+i); list.add(emp); &#125; return list; &#125; public void printEmployee()&#123; List&lt;SubEmployee&gt; list = this.getAllEmployee(); for(SubEmployee e:list)&#123; System.out.println(e.getId()); &#125; &#125;&#125;class CompanyManager&#123; public List&lt;Employee&gt; getAllEmployee()&#123; List&lt;Employee&gt; list = new ArrayList&lt;Employee&gt;(); for(int i=0; i&lt;30; i++)&#123; Employee emp = new Employee(); //为总公司人员按顺序分配一个ID emp.setId(\"总公司\"+i); list.add(emp); &#125; return list; &#125; public void printAllEmployee(SubCompanyManager sub)&#123; sub.printEmployee(); List&lt;Employee&gt; list2 = this.getAllEmployee(); for(Employee e:list2)&#123; System.out.println(e.getId()); &#125; &#125;&#125; 修改后，为分公司增加了打印人员ID的方法，总公司直接调用来打印，从而避免了与分公司的员工发生耦合。 迪米特法则的初衷是降低类之间的耦合，由于每个类都减少了不必要的依赖，因此的确可以降低耦合关系。但是凡事都有度，虽然可以避免与非直接的类通信，但是要通信，必然会通过一个“中介”来发生联系，例如本例中，总公司就是通过分公司这个“中介”来与分公司的员工发生联系的。过分的使用迪米特原则，会产生大量这样的中介和传递类，导致系统复杂度变大。所以在采用迪米特法则时要反复权衡，既做到结构清晰，又要高内聚低耦合。 设计模式六大原则（6）：开闭原则定义： 一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。 问题由来：在软件的生命周期内，因为变化、升级和维护等原因需要对软件原有代码进行修改时，可能会给旧代码中引入错误，也可能会使我们不得不对整个功能进行重构，并且需要原有代码经过重新测试。 解决方案：当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。 开闭原则是面向对象设计中最基础的设计原则，它指导我们如何建立稳定灵活的系统。开闭原则可能是设计模式六项原则中定义最模糊的一个了，它只告诉我们对扩展开放，对修改关闭，可是到底如何才能做到对扩展开放，对修改关闭，并没有明确的告诉我们。以前，如果有人告诉我“你进行设计的时候一定要遵守开闭原则”，我会觉的他什么都没说，但貌似又什么都说了。因为开闭原则真的太虚了。 在仔细思考以及仔细阅读很多设计模式的文章后，终于对开闭原则有了一点认识。其实，我们遵循设计模式前面5大原则，以及使用23种设计模式的目的就是遵循开闭原则。也就是说，只要我们对前面5项原则遵守的好了，设计出的软件自然是符合开闭原则的，这个开闭原则更像是前面五项原则遵守程度的“平均得分”，前面5项原则遵守的好，平均分自然就高，说明软件设计开闭原则遵守的好；如果前面5项原则遵守的不好，则说明开闭原则遵守的不好。 其实笔者认为，开闭原则无非就是想表达这样一层意思：用抽象构建框架，用实现扩展细节。因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节，我们用从抽象派生的实现类来进行扩展，当软件需要发生变化时，我们只需要根据需求重新派生一个实现类来扩展就可以了。当然前提是我们的抽象要合理，要对需求的变更有前瞻性和预见性才行。 说到这里，再回想一下前面说的5项原则，恰恰是告诉我们用抽象构建框架，用实现扩展细节的注意事项而已： 单一职责原则告诉我们实现类要职责单一； 里氏替换原则告诉我们不要破坏继承体系； 依赖倒置原则告诉我们要面向接口编程； 接口隔离原则告诉我们在设计接口的时候要精简单一； 迪米特法则告诉我们要降低耦合。 开闭原则是总纲，他告诉我们要对扩展开放，对修改关闭。 最后说明一下如何去遵守这六个原则。对这六个原则的遵守并不是是和否的问题，而是多和少的问题，也就是说，我们一般不会说有没有遵守，而是说遵守程度的多少。任何事都是过犹不及，设计模式的六个设计原则也是一样，制定这六个原则的目的并不是要我们刻板的遵守他们，而需要根据实际情况灵活运用。对他们的遵守程度只要在一个合理的范围内，就算是良好的设计。我们用一幅图来说明一下。 图中的每一条维度各代表一项原则，我们依据对这项原则的遵守程度在维度上画一个点，则如果对这项原则遵守的合理的话，这个点应该落在红色的同心圆内部；如果遵守的差，点将会在小圆内部；如果过度遵守，点将会落在大圆外部。一个良好的设计体现在图中，应该是六个顶点都在同心圆中的六边形。 在上图中，设计1、设计2属于良好的设计，他们对六项原则的遵守程度都在合理的范围内；设计3、设计4设计虽然有些不足，但也基本可以接受；设计5则严重不足，对各项原则都没有很好的遵守；而设计6则遵守过渡了，设计5和设计6都是迫切需要重构的设计。","categories":[{"name":"java基础","slug":"java基础","permalink":"http://wenyiqingnian.xyz/categories/java基础/"}],"tags":[{"name":"java","slug":"java","permalink":"http://wenyiqingnian.xyz/tags/java/"},{"name":"设计模式","slug":"设计模式","permalink":"http://wenyiqingnian.xyz/tags/设计模式/"}]},{"title":"AnimatedVectorDrawable总结","slug":"AnimatedVectorDrawable 总结","date":"2018-05-09T16:51:50.000Z","updated":"2018-05-24T03:55:08.292Z","comments":true,"path":"2018/05/10/AnimatedVectorDrawable 总结/","link":"","permalink":"http://wenyiqingnian.xyz/2018/05/10/AnimatedVectorDrawable 总结/","excerpt":"","text":"在更新Android N之后 会注意到状态栏上的快捷方式有了新的变化 当我们点击的时候，从开启到关闭状态，会有一个顺滑自然的过渡动画，在学习完AnimatinVectorDrawable的api用法之后，你就会知道该怎么实现这些类似的效果了。 Vector在开始之前，想先说明一下安卓中的矢量图标文件Vector，我们经常会用到矢量图，将一张SVG的图片通过AS自动生成一个以vector为根节点的xml文件，可以直接通过1R.drawable.xx 的格式引用它。矢量图形不管我们如何拉伸都不会模糊，因此广受开发者青睐。看一下一个典型的vector文件结构 12345678910111213&lt;vector android:height=\"24dp\" android:viewportHeight=\"24dp\" android:viewportWidth=\"24\" android:width=\"24\" xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;path android:fillColor=\"#36ab60\" android:pathData=\"M6.4,6.4 L17.6,17.6 M6.4,17.6 L17.6 ,6.4\" android:strokeWidth=\"2\" android:strokeColor=\"#999\" android:trimPathStart=\"0.1\" android:trimPathEnd=\"0.9\"/&gt;&lt;/vector&gt; heigit/width: 图片的宽高 viewportWidth/viewportHeight: 画布宽高，也是必填的，定义Path路径的时候就必须在这个画布大小里去绘制，超出画布就显示不出来了。 path 绘制路径 主要理解几个字母代表的意思 1234M：MOVE 将画笔移动到该点L: LINE 直线连接到该点C: CURVE 曲线连接到该点Z: CLOSE 闭合曲线 strokeWidth: 线的粗细 trimPathStart: 绘制线段起始点偏移的百分比 这么说起来其实有点抽象，用一张图来解释会更加直观一些 12android:trimPathStart=\"0\"android:trimPathEnd=\"1\"/&gt; 12android:trimPathStart=\"0\"android:trimPathEnd=\"0.75\"/&gt; 12android:trimPathStart=\"0.5\"android:trimPathEnd=\"0.75\"/&gt; 123android:trimPathStart=\"0.25\"android:trimPathEnd=\"0.75\"android:trimPathOffset=\"0.25\"/&gt; 123android:trimPathStart=\"0.25\"android:trimPathEnd=\"0.75\"android:trimPathOffset=\"0.375\"/&gt; 其实这几张图片连在一起看，你会发现只要将这几个数值重复循环，这就成了一个进度条动画了。下面正式讲解文章主角 AnimatedVectorDrawable听名字其实可以猜到，它主要是靠两个东西来实现的 ObjectAnimation 属性动画：不用于补间动画，属性动画是直接对view的属性值进行动态、更改，不再只是一种视觉上的动画效果了。它实际上是一种不断地对值进行操作的机制，并将值赋值到指定对象的指定属性上，可以是任意对象的任意属性。关于属性动画的具体介绍不在本文重点，可以参考郭林的博客，属性动画完全解析 VectorDrawable 矢量图型，上文已经介绍过，不再详述 创建一个AnimatedVectorDrawable定义一个vectorDrawable1android:drawable=\"@drawable/foo\" 创建一个animation1234567&lt;ObjectAnimator android:propertyName=\"rotation\" android:valueFrom=\"0\" android:valueTo=\"180\" android:duration=\"200\" android:interpolator=\"@interpolator/...\" android:valueType=\"floatVaule\" valueFrom valueTo propertyName: 要进行变换的属性值该值有以以下几种取值 1234567891011Paths:(support-library 25.3以上 支持变换path数据)Color:Opacity:Trim start /end /offsetPath:Groups:Translate:Scale:Rotate: paths分组下我们可以对颜色 不透明度 起始点偏移量 还有path元数据进行变换 动画1 这是通过动态变换paths分组下的start end的偏移位置，做到x变为对号，同时通过groups分组下的translate 来动态改变位置图像在变化前后还保持中心位置 其实通过trim属性，我们可以做到更多炫酷的动画效果，可以先看下面这个动画 它的完整路径其实是这样的 只是通过变换trim的值，让其部分不可见便实现了上述效果 动画2 本质是将碎裂的心分为两组图片，心的填充颜色默认为白色，点击填充是更改了透明度opacity，裂开的动画是使用groups中的rotation动画 Path Morphing我们还可以直接对path元数据进行变换 1234567&lt;ObjectAnimator android:propertyName=\"pathData\" android:valueFrom=\"M6.4,6.4 L17.6,17.6 M6.4,17.6 L17.6 ,6.4\" android:valueTo=\"M6,10 L4,10 ...\" android:duration=\"200\" android:valueType=\"pathType\" ... 但进行path变换的前提是前后两条path路径 他们的绘制点数量和绘制命令必须是相同的就比如上面代码中 变换前是4个点 变换后也必须是四个点 而且 m l m l 的顺序不可以改变 上面这种 两个正方形 大小变了 形状没变，我们可以选定点的四个点作为变换参考点，只需要改变下四个点的前后坐标就可以了，绘制流程是不变的，符合要求，但如果变换前后是这样的呢？ 圆是没有顶点的，这时候只能变通一下，这样来选择四个点，同时要将连接点与点之间的命令由L （直线）改为C（曲线），这样可以通过控制贝塞尔曲线的控制点坐标，达到绘制圆弧和直线的效果。你可以通过设置更多的控制点 来达到更顺滑的变换效果 进行path变换 因为要操作控制点坐标，也带来了下面几个问题 1.无法精确获取点的坐标我们绘制的矢量图 一般用的是sketch之类的软件，它并不能让我们直接选择变换的点，比如上面的圆，只能得到一个半径和圆心坐标，无法精准的获取四个或者更多控制点的坐标 2.点与点之间无法重叠3.不能直观的看到动画中间状态的样子有时候点选择的不合理，会导致变换中间产生一些非常奇怪的形状，类似sketch之类的设计工具并不能直观看到变化中间态的样子 幸运的是 有个工具可以很好解决上述的三个问题 是一个在线预览工具，shapeshafter 官方的详细介绍 在这里我这边以创建一个-号到+号的变换动画为例，简单介绍下用法 1. 上传两张svg图片分别表示的是变换前，变换后 2.复制第二个涂层的pathdata后，删除该图层 3. 调整第一张图，选择要变换的数据是pathdata，并将变化后 也即第二张图的pathdata 粘贴进去 这时候因为“+”和“-”的节点数不一致，会报错提示，可以点击修改pathdata 按钮去手动删减增加一些节点数据 4.妥善选择好前后的节点位置，就可以点击下方播放按钮直观查看变化效果了，不满意可以修改节点，知道达到预期目标。 待续 —————–18.5.9","categories":[{"name":"CoolUI","slug":"CoolUI","permalink":"http://wenyiqingnian.xyz/categories/CoolUI/"}],"tags":[{"name":"句柄animation","slug":"句柄animation","permalink":"http://wenyiqingnian.xyz/tags/句柄animation/"},{"name":"AnimatedVectorDrawable","slug":"AnimatedVectorDrawable","permalink":"http://wenyiqingnian.xyz/tags/AnimatedVectorDrawable/"}]},{"title":"Rxjava2操作符","slug":"Rxjava2操作符","date":"2018-04-12T12:20:50.000Z","updated":"2018-05-06T14:18:23.807Z","comments":true,"path":"2018/04/12/Rxjava2操作符/","link":"","permalink":"http://wenyiqingnian.xyz/2018/04/12/Rxjava2操作符/","excerpt":"","text":"Rxjava2 操作符 Createcreate操作符，主要用于产生一个 Obserable 被观察者对象，因为Observable主要用于发射事件，Observer主要用于消费时间，所以以后统一把被观察者 Observable 称为发射器（上游事件），观察者 Observer 称为接收器（下游事件）。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; mRxOperatorsText.append(\"Observable emit 1\" + \"\\n\"); Log.e(TAG, \"Observable emit 1\" + \"\\n\"); e.onNext(1); mRxOperatorsText.append(\"Observable emit 2\" + \"\\n\"); Log.e(TAG, \"Observable emit 2\" + \"\\n\"); e.onNext(2); mRxOperatorsText.append(\"Observable emit 3\" + \"\\n\"); Log.e(TAG, \"Observable emit 3\" + \"\\n\"); e.onNext(3); e.onComplete(); mRxOperatorsText.append(\"Observable emit 4\" + \"\\n\"); Log.e(TAG, \"Observable emit 4\" + \"\\n\" ); e.onNext(4); &#125; &#125;).subscribe(new Observer&lt;Integer&gt;() &#123; private int i; private Disposable mDisposable; @Override public void onSubscribe(@NonNull Disposable d) &#123; mRxOperatorsText.append(\"onSubscribe : \" + d.isDisposed() + \"\\n\"); Log.e(TAG, \"onSubscribe : \" + d.isDisposed() + \"\\n\" ); mDisposable = d; &#125; @Override public void onNext(@NonNull Integer integer) &#123; mRxOperatorsText.append(\"onNext : value : \" + integer + \"\\n\"); Log.e(TAG, \"onNext : value : \" + integer + \"\\n\" ); i++; if (i == 2) &#123; // 在RxJava 2.x 中，新增的Disposable可以做到切断的操作，让Observer观察者不再接收上游事件 mDisposable.dispose(); mRxOperatorsText.append(\"onNext : isDisposable : \" + mDisposable.isDisposed() + \"\\n\"); Log.e(TAG, \"onNext : isDisposable : \" + mDisposable.isDisposed() + \"\\n\"); &#125; &#125; @Override public void onError(@NonNull Throwable e) &#123; mRxOperatorsText.append(\"onError : value : \" + e.getMessage() + \"\\n\"); Log.e(TAG, \"onError : value : \" + e.getMessage() + \"\\n\" ); &#125; @Override public void onComplete() &#123; mRxOperatorsText.append(\"onComplete\" + \"\\n\"); Log.e(TAG, \"onComplete\" + \"\\n\" ); &#125; &#125;); MapMap 基本算是 RxJava 中一个最简单的操作符了，熟悉 RxJava 1.x 的知道，它的作用是对发射时间发送的每一个事件应用一个函数，是的每一个事件都按照指定的函数去变化，而在 2.x 中它的作用几乎一致。map 基本作用就是将一个 Observable 通过某种函数关系，转换为另一种 Observable，下面例子中就是把我们的 Integer 数据变成了 String 类型。从Log日志显而易见。 12345678910111213141516171819Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; e.onNext(1); e.onNext(2); e.onNext(3); &#125; &#125;).map(new Function&lt;Integer, String&gt;() &#123; @Override public String apply(@NonNull Integer integer) throws Exception &#123; return \"This is result \" + integer; &#125; &#125;).subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(@NonNull String s) throws Exception &#123; mRxOperatorsText.append(\"accept : \" + s +\"\\n\"); Log.e(TAG, \"accept : \" + s +\"\\n\" ); &#125; &#125;); Zip zip 专用于合并事件，该合并不是连接（连接操作符后面会说），而是两两配对，也就意味着，最终配对出的 Observable 发射事件数目只和少的那个相同。 12345678910111213141516Observable.zip(getStringObservable(), getIntegerObservable(), new BiFunction&lt;String, Integer, String&gt;() &#123; @Override public String apply(@NonNull String s, @NonNull Integer integer) throws Exception &#123; return s + integer; &#125; &#125;).subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(@NonNull String s) throws Exception &#123; mRxOperatorsText.append(\"zip : accept : \" + s + \"\\n\"); Log.e(TAG, \"zip : accept : \" + s + \"\\n\"); &#125; &#125;); /***注： getStringObservable 返回A B C ，getIntegerObservable返回的是1 2 3 4 5 */ 输出结果： zip 组合事件的过程就是分别从发射器 A 和发射器 B 各取出一个事件来组合，并且一个事件只能被使用一次，组合的顺序是严格按照事件发送的顺序来进行的，所以上面截图中，可以看到，1 永远是和 A 结合的，2 永远是和 B 结合的。 最终接收器收到的事件数量是和发送器发送事件最少的那个发送器的发送事件数目相同上面的例子就可以看出 结合后的事件数量是3 Concat 因为zip连接事件有上述两个特点： 121. 分别从两个发射器取一个事件组合成新事件，且事件组合顺序与发射顺序严格相同 2. 最终接受事件数量与原始发射器数量最小的那个相同 对于单一的把两个发射器连接成一个发射器，可以尝试Contact 12345678Observable.concat(Observable.just(1,2,3), Observable.just(4,5,6)) .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(@NonNull Integer integer) throws Exception &#123; mRxOperatorsText.append(\"concat : \"+ integer + \"\\n\"); Log.e(TAG, \"concat : \"+ integer + \"\\n\" ); &#125; &#125;); **输出结果 123456** FlatMap FlatMap ，它可以把一个发射器 Observable 通过某种方法转换为多个 Observables，然后再把这些分散的 Observables装进一个单一的发射器 Observable。但有个需要注意的是，flatMap ==并不能保证事件的顺序==，如果需要保证，需要用到我们下面要讲的 ConcatMap。 123456789101112131415161718192021222324252627Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; e.onNext(1); e.onNext(2); e.onNext(3); &#125; &#125;).flatMap(new Function&lt;Integer, ObservableSource&lt;String&gt;&gt;() &#123; @Override public ObservableSource&lt;String&gt; apply(@NonNull Integer integer) throws Exception &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 3; i++) &#123; list.add(\"I am value \" + integer); &#125; int delayTime = (int) (1 + Math.random() * 10); return Observable.fromIterable(list).delay(delayTime, TimeUnit.MILLISECONDS); // 使用delay操作符，做一个小延时操作，而查看 Log 日志也表明，FlatMap是无序的。 &#125; &#125;).subscribeOn(Schedulers.newThread()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(@NonNull String s) throws Exception &#123; Log.e(TAG, \"flatMap : accept : \" + s + \"\\n\"); mRxOperatorsText.append(\"flatMap : accept : \" + s + \"\\n\"); &#125; &#125;); 输出 12,3,3,3,2,2,1,1 concatMap 上面其实就说了，concatMap 与 FlatMap 的唯一区别就是 concatMap 保证了顺序，所以，我们就直接把 flatMap 替换为 concatMap 验证。 1234567891011121314151617181920212223242526Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; e.onNext(1); e.onNext(2); e.onNext(3); &#125; &#125;).concatMap(new Function&lt;Integer, ObservableSource&lt;String&gt;&gt;() &#123; @Override public ObservableSource&lt;String&gt; apply(@NonNull Integer integer) throws Exception &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 3; i++) &#123; list.add(\"I am value \" + integer); &#125; int delayTime = (int) (1 + Math.random() * 10); return Observable.fromIterable(list).delay(delayTime, TimeUnit.MILLISECONDS); &#125; &#125;).subscribeOn(Schedulers.newThread()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(@NonNull String s) throws Exception &#123; Log.e(TAG, \"flatMap : accept : \" + s + \"\\n\"); mRxOperatorsText.append(\"flatMap : accept : \" + s + \"\\n\"); &#125; &#125;); 输出结果： 11 1 1 2 2 2 3 3 3 distinct作用是去重，输入11 1 2 2 3 4 5 输出11 2 3 4 5 12345678910Observable.just(1, 1, 1, 2, 2, 3, 4, 5) .distinct() .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(@NonNull Integer integer) throws Exception &#123; mRxOperatorsText.append(\"distinct : \" + integer + \"\\n\"); Log.e(TAG, \"distinct : \" + integer + \"\\n\"); &#125; &#125;); FilterFilter 过滤器，可以接受一个参数，让其过滤掉不符合我们条件的值 12345678910111213Observable.just(1, 20, 65, -5, 7, 19) .filter(new Predicate&lt;Integer&gt;() &#123; @Override public boolean test(@NonNull Integer integer) throws Exception &#123; return integer &gt;= 10; &#125; &#125;).subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(@NonNull Integer integer) throws Exception &#123; mRxOperatorsText.append(\"filter : \" + integer + \"\\n\"); Log.e(TAG, \"filter : \" + integer + \"\\n\"); &#125; &#125;); 输出大于10的事件 120 65 19 buffer buffer 操作符接受两个参数，buffer(count,skip)作用是将 Observable 中的数据按 skip (步长) 分成最大不超过 count 的 buffer ，然后生成一个 Observable 。也就是说 ==按照步长，将原始事件 分成一组一组 重新发射出去== 1234567891011121314151617Observable.just(1, 2, 3, 4, 5) .buffer(3, 2) .subscribe(new Consumer&lt;List&lt;Integer&gt;&gt;() &#123; @Override public void accept(@NonNull List&lt;Integer&gt; integers) throws Exception &#123; mRxOperatorsText.append(\"buffer size : \" + integers.size() + \"\\n\"); Log.e(TAG, \"buffer size : \" + integers.size() + \"\\n\"); mRxOperatorsText.append(\"buffer value : \"); Log.e(TAG, \"buffer value : \" ); for (Integer i : integers) &#123; mRxOperatorsText.append(i + \"\"); Log.e(TAG, i + \"\"); &#125; mRxOperatorsText.append(\"\\n\"); Log.e(TAG, \"\\n\"); &#125; &#125;); 输出结果 123456size 3value 1 2 3 size 3value 3 4 5 size 1 value 5 timer timer，相当于一个定时任务。在 1.x 中它还可以执行间隔逻辑，但在 2.x 中此功能被交给了 interval。但需要注意的是，timer 和 interval 均==默认在新线程==。==执行timer方法，将使得接受延时== 123456789101112mRxOperatorsText.append(\"timer start : \" + TimeUtil.getNowStrTime() + \"\\n\"); Log.e(TAG, \"timer start : \" + TimeUtil.getNowStrTime() + \"\\n\"); Observable.timer(2, TimeUnit.SECONDS) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) // timer 默认在新线程，所以需要切换回主线程 .subscribe(new Consumer&lt;Long&gt;() &#123; @Override public void accept(@NonNull Long aLong) throws Exception &#123; mRxOperatorsText.append(\"timer :\" + aLong + \" at \" + TimeUtil.getNowStrTime() + \"\\n\"); Log.e(TAG, \"timer :\" + aLong + \" at \" + TimeUtil.getNowStrTime() + \"\\n\"); &#125; &#125;); 当我们两次点击按钮触发这个事件的时候，接收被延迟了 2 秒。 interval 如同我们上面可说，interval 操作符用于间隔时间执行某个操作，其接受三个参数，分别是第一次发送延迟，间隔时间，时间单位。 123456789101112mRxOperatorsText.append(\"interval start : \" + TimeUtil.getNowStrTime() + \"\\n\"); Log.e(TAG, \"interval start : \" + TimeUtil.getNowStrTime() + \"\\n\"); Observable.interval(3,2, TimeUnit.SECONDS) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) // 由于interval默认在新线程，所以我们应该切回主线程 .subscribe(new Consumer&lt;Long&gt;() &#123; @Override public void accept(@NonNull Long aLong) throws Exception &#123; mRxOperatorsText.append(\"interval :\" + aLong + \" at \" + TimeUtil.getNowStrTime() + \"\\n\"); Log.e(TAG, \"interval :\" + aLong + \" at \" + TimeUtil.getNowStrTime() + \"\\n\"); &#125; &#125;); 执行结果是第一次延迟了 3 秒后接收到，后面每次间隔了 2 秒。然而，由于我们这个是间隔执行，所以当我们的Activity 都销毁的时候，==实际上这个操作还依然在进行==，查看源码发现，我们1subscribe(Cousumer&lt;? super T&gt; onNext) 返回的是Disposable，Disposable 可以用来解除绑定。 1234567891011121314151617181920212223@Override protected void doSomething() &#123; mRxOperatorsText.append(\"interval start : \" + TimeUtil.getNowStrTime() + \"\\n\"); Log.e(TAG, \"interval start : \" + TimeUtil.getNowStrTime() + \"\\n\"); mDisposable = Observable.interval(3, 2, TimeUnit.SECONDS) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) // 由于interval默认在新线程，所以我们应该切回主线程 .subscribe(new Consumer&lt;Long&gt;() &#123; @Override public void accept(@NonNull Long aLong) throws Exception &#123; mRxOperatorsText.append(\"interval :\" + aLong + \" at \" + TimeUtil.getNowStrTime() + \"\\n\"); Log.e(TAG, \"interval :\" + aLong + \" at \" + TimeUtil.getNowStrTime() + \"\\n\"); &#125; &#125;); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); if (mDisposable != null &amp;&amp; !mDisposable.isDisposed()) &#123; mDisposable.dispose(); &#125; &#125; doOnNext doOnNext 它的作用是让订阅者在接收到数据之前做一些其他操作。假如我们在获取到数据之前想先保存一下它，无疑我们可以这样实现。 1234567891011121314Observable.just(1, 2, 3, 4) .doOnNext(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(@NonNull Integer integer) throws Exception &#123; mRxOperatorsText.append(\"doOnNext 保存 \" + integer + \"成功\" + \"\\n\"); Log.e(TAG, \"doOnNext 保存 \" + integer + \"成功\" + \"\\n\"); &#125; &#125;).subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(@NonNull Integer integer) throws Exception &#123; mRxOperatorsText.append(\"doOnNext :\" + integer + \"\\n\"); Log.e(TAG, \"doOnNext :\" + integer + \"\\n\"); &#125; &#125;); skip skip ，接受一个 long 型参数 count ，代表跳过 count 个数目开始接收。 123456789Observable.just(1,2,3,4,5) .skip(2) .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(@NonNull Integer integer) throws Exception &#123; mRxOperatorsText.append(\"skip : \"+integer + \"\\n\"); Log.e(TAG, \"skip : \"+integer + \"\\n\"); &#125; &#125;); 输出： 13 4 5 take take，接受一个 long 型参数 count ，代表至多接收 count 个数据。 123456789Flowable.fromArray(1,2,3,4,5) .take(2) .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(@NonNull Integer integer) throws Exception &#123; mRxOperatorsText.append(\"take : \"+integer + \"\\n\"); Log.e(TAG, \"accept: take : \"+integer + \"\\n\" ); &#125; &#125;); 输出： 11 2 just just一个简单的发射器依次调用 onNext() 方法。 12345678910Observable.just(\"1\", \"2\", \"3\") .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(@NonNull String s) throws Exception &#123; mRxOperatorsText.append(\"accept : onNext : \" + s + \"\\n\"); Log.e(TAG,\"accept : onNext : \" + s + \"\\n\" ); &#125; &#125;); 输出： 11 2 3 Single 顾名思义，Single 只会接收一个参数，也就是只发射一次事件，他的而 SingleObserver 只会调用 onError() 或者 onSuccess()。 12345678910111213141516171819Single.just(new Random().nextInt()) .subscribe(new SingleObserver&lt;Integer&gt;() &#123; @Override public void onSubscribe(@NonNull Disposable d) &#123; &#125; @Override public void onSuccess(@NonNull Integer integer) &#123; mRxOperatorsText.append(\"single : onSuccess : \"+integer+\"\\n\"); Log.e(TAG, \"single : onSuccess : \"+integer+\"\\n\" ); &#125; @Override public void onError(@NonNull Throwable e) &#123; mRxOperatorsText.append(\"single : onError : \"+e.getMessage()+\"\\n\"); Log.e(TAG, \"single : onError : \"+e.getMessage()+\"\\n\"); &#125; &#125;); 输出： 1onSuccess distinct 去重操作符，简单的作用就是去重。 123456789Observable.just(1, 1, 1, 2, 2, 3, 4, 5) .distinct() .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(@NonNull Integer integer) throws Exception &#123; mRxOperatorsText.append(\"distinct : \" + integer + \"\\n\"); Log.e(TAG, \"distinct : \" + integer + \"\\n\"); &#125; &#125;); 输出： 11 2 3 4 5 发射器发送的事件，在接收的时候被去重了。 debounce 去除发送频率过快的项，可以用来过滤点击过快的点击事件 1234567891011121314151617181920212223242526Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(@NonNull ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123; // send events with simulated time wait emitter.onNext(1); // skip Thread.sleep(400); emitter.onNext(2); // deliver Thread.sleep(505); emitter.onNext(3); // skip Thread.sleep(100); emitter.onNext(4); // deliver Thread.sleep(605); emitter.onNext(5); // deliver Thread.sleep(510); emitter.onComplete(); &#125; &#125;).debounce(500, TimeUnit.MILLISECONDS) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(@NonNull Integer integer) throws Exception &#123; mRxOperatorsText.append(\"debounce :\" + integer + \"\\n\"); Log.e(TAG,\"debounce :\" + integer + \"\\n\"); &#125; &#125;); 输出： 12 4 5 代码很清晰，去除发送间隔时间小于 500 毫秒的发射事件，所以 1 和 3 被去掉了。 defer ==直到有订阅，才会创建Observable==具有延时的效果。 代码对比如下： 12345678910a = 10;Observable&lt;String&gt; o1 = Observable.just(\"just result: \" + a);a = 12;o1.subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String t) &#123; System.out.println(t); &#125;&#125;); 输出： 1just result: 10 可见：在使用just的时候，便创建了Observable对象，随后改变a的值，并不会改变Observable对象中的值。 使用defer 123456789101112131415161718a = 12;Observable&lt;String&gt; o2 = Observable.defer(new Func0&lt;Observable&lt;String&gt;&gt;() &#123; @Override public Observable&lt;String&gt; call() &#123; return Observable.just(\"defer result: \" + a); &#125;&#125;);a = 20;o2.subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String t) &#123; System.out.println(t); &#125; &#125;); 输出： 1defer result: 20 可见：在a=12时，虽然定义了一个Observable，但是并没有创建这个示例，当a=20时，这时候订阅这个Observable，则开始创建，所以对象中的a为20. last last 操作符仅取出可观察到的最后一个值，或者是满足某些条件的最后一项。 123456789Observable.just(1, 2, 3) .last() .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(@NonNull Integer integer) throws Exception &#123; mRxOperatorsText.append(\"last : \" + integer + \"\\n\"); Log.e(TAG, \"last : \" + integer + \"\\n\"); &#125; &#125;); 输出：13 merge merge 顾名思义 在 Rx 操作符中，merge 的作用是把多个 Observable 结合起来，接受可变参数，也支持迭代器集合。注意它和 concat 的区别在于，==不用等到 发射器 A 发送完所有的事件再进行发射器 B 的发送==。 12345678Observable.merge(Observable.just(1, 2), Observable.just(3, 4, 5)) .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(@NonNull Integer integer) throws Exception &#123; mRxOperatorsText.append(\"merge :\" + integer + \"\\n\"); Log.e(TAG, \"accept: merge :\" + integer + \"\\n\" ); &#125; &#125;); 输出： 11 2 3 4 5 reduce reduce 操作符每次用一个方法处理一个值，可以有一个 seed 作为初始值。 12345678910111213Observable.just(1, 2, 3) .reduce(new BiFunction&lt;Integer, Integer, Integer&gt;() &#123; @Override public Integer apply(@NonNull Integer integer, @NonNull Integer integer2) throws Exception &#123; return integer + integer2; &#125; &#125;).subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(@NonNull Integer integer) throws Exception &#123; mRxOperatorsText.append(\"reduce : \" + integer + \"\\n\"); Log.e(TAG, \"accept: reduce : \" + integer + \"\\n\"); &#125; &#125;); 输出：16 可以看到，代码中，我们中间采用 reduce ，支持一个 function 为两数值相加，所以应该最后的值是：1 + 2 = 3 + 3 = 6 ， scan scan 操作符作用和上面的 reduce 一致，唯一区别是 reduce 是个只追求结果的坏人，而 scan 会始终如一地把每一个步骤都输出。 12345678910111213Observable.just(1, 2, 3) .scan(new BiFunction&lt;Integer, Integer, Integer&gt;() &#123; @Override public Integer apply(@NonNull Integer integer, @NonNull Integer integer2) throws Exception &#123; return integer + integer2; &#125; &#125;).subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(@NonNull Integer integer) throws Exception &#123; mRxOperatorsText.append(\"scan \" + integer + \"\\n\"); Log.e(TAG, \"accept: scan \" + integer + \"\\n\"); &#125; &#125;); 输出： 11 3 6 window 按照实际划分窗口，将数据发送给不同的 Observable 1234567891011121314151617181920212223mRxOperatorsText.append(\"window\\n\"); Log.e(TAG, \"window\\n\"); Observable.interval(1, TimeUnit.SECONDS) // 间隔一秒发一次 .take(15) // 最多接收15个 .window(3, TimeUnit.SECONDS) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;Observable&lt;Long&gt;&gt;() &#123; @Override public void accept(@NonNull Observable&lt;Long&gt; longObservable) throws Exception &#123; mRxOperatorsText.append(\"Sub Divide begin...\\n\"); Log.e(TAG, \"Sub Divide begin...\\n\"); longObservable.subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer&lt;Long&gt;() &#123; @Override public void accept(@NonNull Long aLong) throws Exception &#123; mRxOperatorsText.append(\"Next:\" + aLong + \"\\n\"); Log.e(TAG, \"Next:\" + aLong + \"\\n\"); &#125; &#125;); &#125; &#125;); 输出：","categories":[{"name":"Android","slug":"Android","permalink":"http://wenyiqingnian.xyz/categories/Android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://wenyiqingnian.xyz/tags/android/"},{"name":"开源框架","slug":"开源框架","permalink":"http://wenyiqingnian.xyz/tags/开源框架/"},{"name":"rxjava2","slug":"rxjava2","permalink":"http://wenyiqingnian.xyz/tags/rxjava2/"}]},{"title":"socket未释放导致句柄泄露","slug":"Socket未释放导致的句柄泄露","date":"2018-03-16T11:40:50.000Z","updated":"2018-05-06T13:28:37.592Z","comments":true,"path":"2018/03/16/Socket未释放导致的句柄泄露/","link":"","permalink":"http://wenyiqingnian.xyz/2018/03/16/Socket未释放导致的句柄泄露/","excerpt":"","text":"问题描述客户反馈话机的voipsdk demo在运行起来之后 放置不动，几小时过后，应用进行任何操作都会崩溃。通过logcat 报错信息 发现出现了句柄泄露。通过ls -l /proc//fd可以查看到在demo进程下，持有的socket数量会规律性上升。 12345lrwx------ system system 2018-03-08 14:11 60 -&gt; socket:[4027431]lrwx------ system system 2018-03-08 14:11 61 -&gt; socket:[4025517]lrwx------ system system 2018-03-08 14:11 62 -&gt; socket:[4028038]lrwx------ system system 2018-03-08 14:11 63 -&gt; socket:[4028322]lrwx------ system system 2018-03-08 14:11 64 -&gt; socket:[4026799] 大概十秒增加一个，一直到超出安卓规定的数量，此时由于已无可用fd句柄，在进行任何操作都会因无可用句柄直接导致崩溃。 可以看到新增socket的inode号码之后，通过查找/proc/net/tcp(udp对应/proc/net/udp)文件，其中也列出了相应socket的inode号，通过比对此字段，我在/proc/net/tcp下获得此套接口的其他信息，对应的&lt;本地地址：端口号，远端地址：端口号&gt;对，窗口大小，状态等信息。具体字段含义详见net/ipv4/tcp_ipv4.c 中的 tcp4_seq_show 函数。cat /proc/net/tcp 如下： 12345678root@TOS_IP:/proc/net # cat tcp6 sl local_address remote_address st tx_queue rx_queue tr tm-&gt;when retrnsmt uid timeout inode 0: 0000000000000000FFFF00007665A8C0:D483 0000000000000000FFFF00009F173379:0050 08 00000000:00000001 00:00000000 00000000 10077 0 3660979 1 00000000 25 4 30 10 -1 1: 0000000000000000FFFF00007665A8C0:E595 0000000000000000FFFF0000DCD5B276:0050 08 00000000:00000001 00:00000000 00000000 10077 0 3661419 1 00000000 24 4 28 10 -1 2: 0000000000000000FFFF00007665A8C0:81EC 0000000000000000FFFF00009F173379:0050 08 00000000:00000001 00:00000000 00000000 1000 0 4019721 1 00000000 23 4 30 10 -1 3: 0000000000000000FFFF00007665A8C0:B885 0000000000000000FFFF0000F28D0D6F:0050 08 00000000:00000001 00:00000000 00000000 1000 0 3659952 1 00000000 26 4 30 10 -1 4: 0000000000000000FFFF00007665A8C0:8AD0 0000000000000000FFFF00009F173379:0050 08 00000000:00000001 00:00000000 00000000 1000 0 4018811 1 00000000 24 4 30 10 -1 5: 0000000000000000FFFF00007665A8C0:E83C 0000000000000000FFFF00009F173379:0050 08 00000000:00000001 00:00000000 00000000 1000 0 4018828 1 00000000 23 4 30 10 -1 将本端16进制端口号转化为10进制可以看到是一个与8080端口在通信的socket。 目前初步猜测是端口争夺导致demo没有获取到端口，就会隔段时间重试去申请该端口。 首先去java端排除，全局搜索发现并没有找到对应的8080端口申请情况 那就只有可能是linphone库里或者webrtc库里做了8080相关的操作了。 请linphone端的李工排查，发现在一段前离职同事的代码里，有一段申请8080端口的相关操作。查看了一下，发现和猜测的一致，因为要和底层通讯，同事使用了socket并通过8080端口，但是在申请资源后并未释放改socket，当系统自带的拨号服务起来之后，因为系统自带拨号和sdk的demo使用的linphone库是相同的，导致两个进程都在抢占8080，那个进程服务先拿到，另一个进程就拿不到该端口，会隔10s重新发起申请，但是之前创建的socket又没有释放，就会导致句柄泄露。 我将系统自带的拨号进程彻底杀死，同事运行起demo，然后再将系统拨号运行起来，发现这时候 系统自带拨号也出现了句柄泄露。而demo就没有出现过了。 应征我之前的猜测。解决这个问题就很简单了，在linphone的代码里将改socket释放。","categories":[{"name":"bug记录","slug":"bug记录","permalink":"http://wenyiqingnian.xyz/categories/bug记录/"}],"tags":[{"name":"句柄泄露","slug":"句柄泄露","permalink":"http://wenyiqingnian.xyz/tags/句柄泄露/"},{"name":"bugs","slug":"bugs","permalink":"http://wenyiqingnian.xyz/tags/bugs/"}]},{"title":"线程阻塞和中断的四种方式","slug":"线程阻塞和中断的四种方式","date":"2018-03-13T12:46:25.000Z","updated":"2018-05-06T14:15:08.753Z","comments":true,"path":"2018/03/13/线程阻塞和中断的四种方式/","link":"","permalink":"http://wenyiqingnian.xyz/2018/03/13/线程阻塞和中断的四种方式/","excerpt":"","text":"1、线程阻塞一个线程进入阻塞状态可能的原因： 通过调用sleep(millseconds)使任务进入休眠状态；123456789101112class Demo1 implements Runnable throws InterruptedException&#123; public void run()&#123; Thread.sleep(1000); &#125;&#125;②通过调用wait（）使线程挂起，直到线程获取notify（）/notifyAll（）消息，（或者在Java SE5中java.util.concurrent类库中等价的signal（）/signalAll（）消息），线程才会进入就绪状态；class Demo2 implements Runnable&#123; public void run()&#123; Thread.await(); Thread.notify(); &#125;&#125; 任务在等待某个输入 / 输出流的完成；123456class Demo3 implements Runnable throws InterruptedException&#123; private InputStream in; public void run()&#123; in.read(); &#125;&#125; 任务试图在某个对象上调用其同步控制方法，但是对象锁不可用，因为另一个任务已经获取了该锁；1234567class Demo4 implements Runnable&#123; public synchronized void method1()&#123; &#125; public synchronized void method2()&#123; &#125; public void run()&#123; method1(); &#125;&#125; 2、线程中断的方法Thread类包含interrupt（）方法，用于终止阻塞任务； 1）中断①②类线程休眠，挂起阻塞的方法1.直接使用Thread.interrupt();1234main()&#123; Thread t = new Thread(new Demo1()); t.interrupt();&#125; 2.使用Executor线程池，中断线程池中的所有线程；123456main()&#123; ExecutorService exec = Executors.newCachedThreadPool(); for(int i=0;i&lt;5;i++) exec.execute(new Demo1()) exec.shutdownNow();&#125; 3.使用Executor线程池，中断线程池中单个阻塞的线程；12345main()&#123; ExecutorService exec = Executors.newCachedThreadPool(); Futrue&lt;?&gt; f = exec.submit(new Demo1()); f.interrupt();&#125; //中断后的清除代码放置在InterruptedException异常的catch捕获的代码块中 2）中断③类I/O阻塞的方法使用Thread.iterrupt方法无法中断I/O阻塞，这对于基于Web的程序是很不利的； 有一种解决方法：关闭任务在其上发生阻塞的底层资源；123456789101112main()&#123; ExecutorService exec = Executors.newCachedThreadPool(); ServerSocket server = new ServerSocket(8080); InputStream socketInput = new Socket(\"localhost\",8080) exec.execute(socketInput); exec.execute(Sytsem.in); //exec.shutdownNow(); 无法中断2个线程； socketInput.close(); in.close(); exec.shutdownNow();&#125; java.nio类库提供了更加人性化的I/O中断，被阻塞的nio通道会自动地响应中断；12345678910111213141516171819202122232425262728class Demo impelenets Runnable&#123; private final SocketChannel sc; public Demo(SocketChannel sc)&#123; this.sc = sc;&#125; public void run()&#123; try&#123; sc.read(ByteBuffer.allocate(1)); &#125;catch(CloseByInteruptedException e1)&#123; &#125;catch(AsyncronousCloseException e2)&#123; &#125;catch(IOException e3)&#123; &#125; &#125;&#125;public Test &#123; public static void main()&#123; ExecutorService exec = Executors.newCachedThreadPool(); ServerSocket server = new ServerSocket(8080); InetSocketAddress isa = new InetSocketAddress(\"localhost\",8080); SocketChannel sc1 = new SocketChannel.open(isa); SocketChannel sc2 = new SocketChannel.open(isa); exec.execute(new Demo(sc1)); Future&lt;?&gt; f = exec.submit(new Demo(sc2)); f.cancel(true); //可以终止sc1通道所在的线程； exec.shutdownNow(); //可以终止exec线程池内所有的线程； sc1.close(); sc2.close(); &#125;&#125; 3）中断④类被互斥阻塞的线程使用Thread.iterrupt方法无法中断互斥类线程， 解决方式1：可以使用ReentrantLock显式加锁，在JavaSE5中引入的新特性，ReentrantLock上阻塞的任务可以被中断；123456789101112131415161718class Task imlements Runnable&#123; private Lock lock = new ReentrantLock(); public void run()&#123; lock.lock(); try&#123; while(true) &#125;catch(InterruptedExcpetion e)&#123; System.out.println(\"The Task is interrupted!\"); &#125;finally&#123; lock.unlock(); &#125; &#125; public void main()&#123; Thread t = new Thread(new Task()); t.start(); t.interrupt(); &#125;&#125; 解决方式2：使用一个while（！Thread.interrupted（））包裹同步的代码块123456789101112131415161718class Task impelments Runnable&#123; private synchronized void method1()&#123; &#125; public void run()&#123; try&#123; whlie(!Thread.interrupted()) method1(); &#125;catch(InteruptedException e)&#123; &#125; &#125; public static void main()&#123; ExecutorService exec = Executors.newCachedThreadPool(); exec.execute(new Task()); exec.shutdownNow(); //线程被打断 /*或 Thread t = new Thread(new Task()); t.start(); t.interrupt(); */ &#125;&#125;","categories":[{"name":"java基础","slug":"java基础","permalink":"http://wenyiqingnian.xyz/categories/java基础/"}],"tags":[{"name":"java","slug":"java","permalink":"http://wenyiqingnian.xyz/tags/java/"},{"name":"多线程","slug":"多线程","permalink":"http://wenyiqingnian.xyz/tags/多线程/"}]},{"title":"MQTT相关总结","slug":"MQTT相关","date":"2017-12-11T12:30:50.000Z","updated":"2018-05-09T16:54:08.134Z","comments":true,"path":"2017/12/11/MQTT相关/","link":"","permalink":"http://wenyiqingnian.xyz/2017/12/11/MQTT相关/","excerpt":"","text":"MQTT相关MQTT官网：http://mqtt.org/ MQTT介绍：http://www.ibm.com MQTT Android github：https://github.com/eclipse/paho.mqtt.android MQTT API：http://www.eclipse.org/paho/files/javadoc/index.html MQTT Android API： http://www.eclipse.org/paho/files/android-javadoc/index.html MQTT服务器搭建 环境：windows7 64位 JAVA环境:jdk 1.8.0 下载：Apollo服务器 以下为步骤： 下载Apollo服务器后，解压安装； 用命令行进入到安装目录bin目录下 输入 apollo create xxx (xxx为服务器实例名，eg.apollo create xmaihh) 执行之后会在bin目录下创建名称为xxx的文件夹，比如我生成的文件夹是 xmaihhxxx文件夹下etc\\apollo.xml文件是 配置服务器文件信息etc\\users.properties文件包含连接MQTT服务器时用到的用户名和密码，默认为admin=password，即账号为admin，密码为password，可自行更改。 用命令行进入到刚创建的xxx\\bin目录下，输入apollo-broker.cmd run开启服务器 在浏览器输入http://127.0.0.1:61680/，查看是否安装成功MQTT Android客户端 环境：AndroidStudio 3.0.1 topic：中文意思是“话题”。在MQTT中订阅了(subscribe)同一话题（topic）的客户端会同时收到消息推送。 clientId：客户身份唯一标识。 qos：服务质量。 retained：要保留最后的断开连接信息。 MqttAndroidClient#subscribe()：订阅某个话题。 MqttAndroidClient#publish()： 向某个话题发送消息，之后服务器会推送给所有订阅了此话题的客户。 userName：连接到MQTT服务器的用户名。 passWord ：连接到MQTT服务器的密码 以下为步骤： 添加依赖 123456789repositories &#123; maven &#123; url &quot;https://repo.eclipse.org/content/repositories/paho-snapshots/&quot; &#125;&#125;dependencies &#123; compile &apos;org.eclipse.paho:org.eclipse.paho.client.mqttv3:1.1.0&apos; compile &apos;org.eclipse.paho:org.eclipse.paho.android.service:1.1.1&apos;&#125; 添加权限 123&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.WAKE_LOCK&quot; /&gt; 注册Service 12&lt;!-- Mqtt Service --&gt;&lt;service android:name=&quot;org.eclipse.paho.android.service.MqttService&quot; /&gt; 具体实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157/** * MQTT长连接服务 */public class MQTTService extends Service &#123; public static final String TAG = MQTTService.class.getSimpleName(); public static MqttAndroidClient client; private MqttConnectOptions connectOptions; private String host = &quot;tcp://192.168.102.216:61613&quot;;// private String host = &quot;tcp://192.168.8.241:61613&quot;;// private String host = &quot;tcp://10.0.2.2:61613&quot;;// private String host = &quot;tcp://192.168.26.144:1883&quot;; private String username = &quot;admin&quot;; private String password = &quot;password&quot;; private static String myTopic = &quot;topic&quot;; private String clientId = &quot;test123&quot;; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; init(); return super.onStartCommand(intent, flags, startId); &#125; @Nullable @Override public IBinder onBind(Intent intent) &#123; return null; &#125; public static void publish(String msg) &#123; String topic = myTopic; Integer qos = 0; Boolean retained = false; try &#123; client.publish(topic, msg.getBytes(), qos.intValue(), retained.booleanValue()); &#125; catch (MqttException e) &#123; e.printStackTrace(); &#125; &#125; /** * 初始化方法 */ private void init() &#123; // 服务器地址 (协议+地址+端口号) String url = host; client = new MqttAndroidClient(this, url, clientId); client.setCallback(mqttCallback); connectOptions = new MqttConnectOptions(); // 清除缓存 connectOptions.setCleanSession(true); // 设置超时时间,单位:秒 connectOptions.setConnectionTimeout(10); // 心跳包发送时间间隔,单位:秒 connectOptions.setKeepAliveInterval(20); // 用户名 connectOptions.setUserName(username); // 密码 connectOptions.setPassword(password.toCharArray()); // last will message boolean doConnect = true; String message = &quot;&#123;\\&quot;terminal_uid\\&quot;:\\&quot;&quot; + clientId + &quot;\\&quot;&#125;&quot;; String topic = myTopic; Integer qos = 0; Boolean retained = false; if ((!message.equals(&quot;&quot;)) || (!topic.equals(&quot;&quot;))) &#123; //最后的遗嘱 try &#123; connectOptions.setWill(topic, message.getBytes(), qos.intValue(), retained.booleanValue()); &#125; catch (Exception ex) &#123; Log.d(TAG, &quot;Exception Occured&quot;, ex); doConnect = false; iMqttActionListener.onFailure(null, ex); &#125; &#125; if (doConnect) &#123; //连接MQTT服务器 doClientConnection(); &#125; &#125; /** * 连接MQTT服务器 */ private void doClientConnection() &#123; if (!client.isConnected() &amp;&amp; isConnectIsNomarl()) &#123; try &#123; client.connect(connectOptions, null, iMqttActionListener); &#125; catch (MqttException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /** * 判断网络是否连接 * * @return */ private boolean isConnectIsNomarl() &#123; ConnectivityManager connectivityManager = (ConnectivityManager) this.getApplicationContext().getSystemService(Context.CONNECTIVITY_SERVICE); NetworkInfo info = connectivityManager.getActiveNetworkInfo(); if (info != null &amp;&amp; info.isAvailable()) &#123; String name = info.getTypeName(); Log.i(TAG, &quot;MQTT当前网络名称：&quot; + name); return true; &#125; else &#123; Log.i(TAG, &quot;MQTT 没有可用网络&quot;); return false; &#125; &#125; /** * MQTT监听并且接收消息 */ private MqttCallback mqttCallback = new MqttCallback() &#123; @Override public void connectionLost(Throwable cause) &#123; //失去连接，重连 &#125; @Override public void messageArrived(String topic, MqttMessage message) throws Exception &#123; EventBus.getDefault().post(message); String str2 = topic + &quot;;qos :&quot; + message.getQos() + &quot;;retained:&quot; + message.isRetained(); Log.d(TAG, &quot;messageArrived: str2&quot; + str2); &#125; @Override public void deliveryComplete(IMqttDeliveryToken token) &#123; &#125; &#125;; /** * MQTT是否连接成功 */ private IMqttActionListener iMqttActionListener = new IMqttActionListener() &#123; @Override public void onSuccess(IMqttToken asyncActionToken) &#123; Log.d(TAG, &quot;onSuccess: MQTT连接成功&quot;); try &#123; //订阅myTopic话题 client.subscribe(myTopic, 1); &#125; catch (MqttException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void onFailure(IMqttToken asyncActionToken, Throwable exception) &#123; exception.printStackTrace(); //连接失败，重连 &#125; &#125;;&#125; 初始化各个参数，之后连接服务器。连接成功之后在http://127.0.0.1:61680/ 看到自动创建了名称为”topic”的topic。这里我使用两台真机。http://127.0.0.1:61680/ 服务端看到的是这个样子 模拟器运行的时候host = “tcp://10.0.2.2:61613”，因为10.0.2.2 是模拟器设置的特定ip，是你电脑的别名。真机运行的时候host = “tcp://192.168.102.216:61613”。192.168.102.216是我主机的IPv4地址，查看本机IP的cmd命令为ipconfig/all。 两次运行时的clientId不能一样（为了保证客户标识的唯一性） 访问管理界面要修改前面创建的xxx文件夹下etc\\apollo.xml文件，添加你的host就可以通过host访问管理界面，否则只能通过 http://127.0.0.1:61680 和 https://127.0.0.1:61681 访问123456789101112131415161718192021222324252627282930313233343536373839... ... &lt;virtual_host id=&quot;xmaihh&quot;&gt; &lt;!-- You should add all the host names that this virtual host is known as to properly support the STOMP 1.1 virtual host feature. --&gt; &lt;host_name&gt;xmaihh&lt;/host_name&gt; &lt;host_name&gt;localhost&lt;/host_name&gt; &lt;host_name&gt;127.0.0.1&lt;/host_name&gt; &lt;!--以下为添加内容--&gt; &lt;host_name&gt;192.168.102.216&lt;/host_name&gt; &lt;!--以上为添加内容--&gt; &lt;!-- Uncomment to disable security for the virtual host --&gt; &lt;!-- &lt;authentication enabled=&quot;false&quot;/&gt; --&gt; &lt;!-- Uncomment to disable security for the virtual host --&gt; &lt;!-- &lt;authentication enabled=&quot;false&quot;/&gt; --&gt; &lt;access_rule allow=&quot;users&quot; action=&quot;connect create destroy send receive consume&quot;/&gt; &lt;!-- You can delete this element if you want to disable persistence for this virtual host --&gt; &lt;leveldb_store directory=&quot;$&#123;apollo.base&#125;/data&quot;/&gt; &lt;/virtual_host&gt; &lt;web_admin bind=&quot;http://127.0.0.1:61680&quot;/&gt; &lt;web_admin bind=&quot;https://127.0.0.1:61681&quot;/&gt; &lt;!--以下为添加内容--&gt; &lt;web_admin bind=&quot;http://192.168.102.216:61680&quot;/&gt; &lt;web_admin bind=&quot;https://192.168.102.216:61681&quot;/&gt; &lt;!--以上为添加内容--&gt; &lt;connector id=&quot;tcp&quot; bind=&quot;tcp://0.0.0.0:61613&quot; connection_limit=&quot;2000&quot;/&gt; &lt;connector id=&quot;tls&quot; bind=&quot;tls://0.0.0.0:61614&quot; connection_limit=&quot;2000&quot;/&gt; &lt;connector id=&quot;ws&quot; bind=&quot;ws://0.0.0.0:61623&quot; connection_limit=&quot;2000&quot;/&gt; &lt;connector id=&quot;wss&quot; bind=&quot;wss://0.0.0.0:61624&quot; connection_limit=&quot;2000&quot;/&gt; &lt;key_storage file=&quot;$&#123;apollo.base&#125;/etc/keystore&quot; password=&quot;password&quot; key_password=&quot;password&quot;/&gt;","categories":[{"name":"MQTT","slug":"MQTT","permalink":"http://wenyiqingnian.xyz/categories/MQTT/"}],"tags":[{"name":"mqtt","slug":"mqtt","permalink":"http://wenyiqingnian.xyz/tags/mqtt/"}]},{"title":"mac搭建Pyqt5环境","slug":"mac搭建PyQt5环境","date":"2017-12-11T12:30:50.000Z","updated":"2018-05-06T13:25:36.596Z","comments":true,"path":"2017/12/11/mac搭建PyQt5环境/","link":"","permalink":"http://wenyiqingnian.xyz/2017/12/11/mac搭建PyQt5环境/","excerpt":"","text":"1.首先基于virtualenv 搭建一个python3的运行环境virtualenv是一个十分好用的python工具，可以为不同的软件创建独立的“隔离”的Python运行环境。 1. 首先，我们用pip安装virtualenv：1$ pip3 install virtualenv 2.创建一个pyhton3的运行环境1jiangxqdeMBP:~ jiangxq$ virtualenv py3 --python=python3 可以通过python=python3来指定要安装的python版本，python3是mac的写法，其他linux系统需要制定为python2.7 或者python3.6 3. 激活该运行环境执行 12jiangxqdeMBP:~ jiangxq$ source ~/py3/bin/activate(py3) jiangxqdeMBP:~ jiangxq$ 当用户名前出现该运行环境的名称时，表示环境已经激活了 2. 检查pip工具的版本 目前最新的为9.0.2 需要更新请 执行1pip3 install --upgrade pip 这里有个窍门是如果mac的默认python运行环境为python2.7，但是不想修改注册文件，可以直接打pip3，pip3是是python3的pip工具，pip是python2的pip工具。 3. 使用pip工具安装PyQt51pip3 install PyQt5 当PyQt5安装完成之后，其实Qt的组件此时已经可用了，如果要测试是否安装成功，可以新建一个Python项目，然后倒入PyQt5的包看看。 4.在pycharm上安装QtDesign工具包QtDesign是Pycharm上的可视化uI设计工具，可以拖动控件来达到实现设计界面的功能安装Qtdesign 需要先安装QT 1. 下载QT安装包下载地址：http://iso.mirrors.ustc.edu.cn/qtproject/archive/qt/5.10/5.10.1/qt-opensource-mac-x64-5.10.1.dmg下载完成后直接安装 2.打开pycharm 点击preference 点击Tools 新建一个插件 注意插件地址不要写错了，是qt5的安装路径 3. 创建PyUIC 插件（将pydesigner的布局自动转化为python代码）","categories":[{"name":"python","slug":"python","permalink":"http://wenyiqingnian.xyz/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://wenyiqingnian.xyz/tags/python/"},{"name":"qt","slug":"qt","permalink":"http://wenyiqingnian.xyz/tags/qt/"}]},{"title":"view 绘制机制","slug":"view 绘制机制","date":"2017-10-12T11:30:50.000Z","updated":"2018-05-24T03:11:00.231Z","comments":true,"path":"2017/10/12/view 绘制机制/","link":"","permalink":"http://wenyiqingnian.xyz/2017/10/12/view 绘制机制/","excerpt":"","text":"View的绘制和事件处理是两个重要的主题，上一篇《图解 Android事件分发机制》已经把事件的分发机制讲得比较详细了，这一篇是针对View的绘制，View的绘制如果你有所了解，基本分为measure、layout、draw 过程，其中比较难理解就是measure过程，所以本篇文章大幅笔地分析measure过程，相对讲得比较详细，文章也比较长，如果你对View的绘制还不是很懂，对measure过程掌握得不是很深刻，那么耐心点，看完这篇文章，相信你会有所收获的。 Measure过程对于测量我们来说几个知识点,了解这几个知识点，之后的实例分析你才看得懂。 1、MeasureSpec 的理解对于View的测量，肯定会和MeasureSpec接触，MeasureSpec是两个单词组成，翻译过来“测量规格”或者“测量参数”，很多博客包括官方文档对他的说明基本都是“一个MeasureSpec封装了从父容器传递给子容器的布局要求”,这个MeasureSpec 封装的是父容器传递给子容器的布局要求，而不是父容器对子容器的布局要求，“传递” 两个字很重要，更精确的说法应该这个MeasureSpec是由父View的MeasureSpec和子View的LayoutParams通过简单的计算得出一个针对子View的测量要求，这个测量要求就是MeasureSpec。 大家都知道一个MeasureSpec是一个大小跟模式的组合值,MeasureSpec中的值是一个整型（32位）将size和mode打包成一个Int型，其中高两位是mode，后面30位存的是size，是为了减少对象的分配开支。MeasureSpec 类似于下图，只不过这边用的是十进制的数，而MeasureSpec 是二进制存储的。 注：-1 代表的是EXACTLY，-2 是AT_MOSTMeasureSpec一共有三种模式 123UPSPECIFIED : 父容器对于子容器没有任何限制,子容器想要多大就多大EXACTLY: 父容器已经为子容器设置了尺寸,子容器应当服从这些边界,不论子容器想要多大的空间。AT_MOST：子容器可以是声明大小内的任意大小 很多文章都会把这三个模式说成这样，当然其实包括官方文档也是这样表达的，但是这样并不好理解。特别是如果把这三种模式又和MATCH_PARENT和WRAP_CONTENT 联系到一起，很多人就懵逼了。如果从代码上来看1view.measure(int widthMeasureSpec, int heightMeasureSpec) 12 的两个MeasureSpec是父类传递过来的，但并不是完全是父View的要求，而是父View的MeasureSpec和子View自己的LayoutParams共同决定的，而子View的LayoutParams其实就是我们在xml写的时候设置的layout_width和layout_height 转化而来的。我们先来看代码会清晰一些： 父View的measure的过程会先测量子View，等子View测量结果出来后，再来测量自己，上面的measureChildWithMargins就是用来测量某个子View的，我们来分析是怎样测量的，具体看注释： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112protected void measureChildWithMargins(View child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed) &#123; // 子View的LayoutParams，你在xml的layout_width和layout_height,// layout_xxx的值最后都会封装到这个个LayoutParams。final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams(); //根据父View的测量规格和父View自己的Padding，//还有子View的Margin和已经用掉的空间大小（widthUsed），就能算出子View的MeasureSpec,具体计算过程看getChildMeasureSpec方法。final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin + widthUsed, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin + heightUsed, lp.height); //通过父View的MeasureSpec和子View的自己LayoutParams的计算，算出子View的MeasureSpec，然后父容器传递给子容器的// 然后让子View用这个MeasureSpec（一个测量要求，比如不能超过多大）去测量自己，如果子View是ViewGroup 那还会递归往下测量。child.measure(childWidthMeasureSpec, childHeightMeasureSpec);&#125;// spec参数 表示父View的MeasureSpec // padding参数 父View的Padding+子View的Margin，父View的大小减去这些边距，才能精确算出// 子View的MeasureSpec的size// childDimension参数 表示该子View内部LayoutParams属性的值（lp.width或者lp.height）// 可以是wrap_content、match_parent、一个精确指(an exactly size), public static int getChildMeasureSpec(int spec, int padding, int childDimension) &#123; int specMode = MeasureSpec.getMode(spec); //获得父View的mode int specSize = MeasureSpec.getSize(spec); //获得父View的大小 //父View的大小-自己的Padding+子View的Margin，得到值才是子View的大小。 int size = Math.max(0, specSize - padding); int resultSize = 0; //初始化值，最后通过这个两个值生成子View的MeasureSpec int resultMode = 0; //初始化值，最后通过这个两个值生成子View的MeasureSpec switch (specMode) &#123; // Parent has imposed an exact size on us //1、父View是EXACTLY的 ！ case MeasureSpec.EXACTLY: //1.1、子View的width或height是个精确值 (an exactly size) if (childDimension &gt;= 0) &#123; resultSize = childDimension; //size为精确值 resultMode = MeasureSpec.EXACTLY; //mode为 EXACTLY 。 &#125; //1.2、子View的width或height为 MATCH_PARENT/FILL_PARENT else if (childDimension == LayoutParams.MATCH_PARENT) &#123; // Child wants to be our size. So be it. resultSize = size; //size为父视图大小 resultMode = MeasureSpec.EXACTLY; //mode为 EXACTLY 。 &#125; //1.3、子View的width或height为 WRAP_CONTENT else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // Child wants to determine its own size. It can't be // bigger than us. resultSize = size; //size为父视图大小 resultMode = MeasureSpec.AT_MOST; //mode为AT_MOST 。 &#125; break; // Parent has imposed a maximum size on us //2、父View是AT_MOST的 ！ case MeasureSpec.AT_MOST: //2.1、子View的width或height是个精确值 (an exactly size) if (childDimension &gt;= 0) &#123; // Child wants a specific size... so be it resultSize = childDimension; //size为精确值 resultMode = MeasureSpec.EXACTLY; //mode为 EXACTLY 。 &#125; //2.2、子View的width或height为 MATCH_PARENT/FILL_PARENT else if (childDimension == LayoutParams.MATCH_PARENT) &#123; // Child wants to be our size, but our size is not fixed. // Constrain child to not be bigger than us. resultSize = size; //size为父视图大小 resultMode = MeasureSpec.AT_MOST; //mode为AT_MOST &#125; //2.3、子View的width或height为 WRAP_CONTENT else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // Child wants to determine its own size. It can't be // bigger than us. resultSize = size; //size为父视图大小 resultMode = MeasureSpec.AT_MOST; //mode为AT_MOST &#125; break; // Parent asked to see how big we want to be //3、父View是UNSPECIFIED的 ！ case MeasureSpec.UNSPECIFIED: //3.1、子View的width或height是个精确值 (an exactly size) if (childDimension &gt;= 0) &#123; // Child wants a specific size... let him have it resultSize = childDimension; //size为精确值 resultMode = MeasureSpec.EXACTLY; //mode为 EXACTLY &#125; //3.2、子View的width或height为 MATCH_PARENT/FILL_PARENT else if (childDimension == LayoutParams.MATCH_PARENT) &#123; // Child wants to be our size... find out how big it should // be resultSize = 0; //size为0！ ,其值未定 resultMode = MeasureSpec.UNSPECIFIED; //mode为 UNSPECIFIED &#125; //3.3、子View的width或height为 WRAP_CONTENT else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // Child wants to determine its own size.... find out how // big it should be resultSize = 0; //size为0! ，其值未定 resultMode = MeasureSpec.UNSPECIFIED; //mode为 UNSPECIFIED &#125; break; &#125; //根据上面逻辑条件获取的mode和size构建MeasureSpec对象。 return MeasureSpec.makeMeasureSpec(resultSize, resultMode); &#125; 上面的代码有点多，希望你仔细看一些注释，代码写得很多，其实计算原理很简单： 如果我们在xml 的layout_width或者layout_height 把值都写死，那么上述的测量完全就不需要了，之所以要上面的这步测量，是因为 match_parent 就是充满父容器，wrap_content 就是自己多大就多大， 我们写代码的时候特别爽，我们编码方便的时候，google就要帮我们计算你match_parent的时候是多大，wrap_content的是多大，这个计算过程，就是计算出来的父View的MeasureSpec不断往子View传递，结合子View的LayoutParams 一起再算出子View的MeasureSpec，然后继续传给子View，不断计算每个View的MeasureSpec，子View有了MeasureSpec才能更测量自己和自己的子View。 上述代码如果这么来理解就简单了 如果父View的MeasureSpec 是EXACTLY，说明父View的大小是确切的，（确切的意思很好理解，如果一个View的MeasureSpec 是EXACTLY，那么它的size 是多大，最后展示到屏幕就一定是那么大）。 1.如果子View 的layout_xxxx是MATCH_PARENT，父View的大小是确切，子View的大小又MATCH_PARENT（充满整个父View），那么子View的大小肯定是确切的，而且大小值就是父View的size。所以子View的size=父View的size，mode=EXACTLY 2.如果子View 的layout_xxxx是WRAP_CONTENT，也就是子View的大小是根据自己的content 来决定的，但是子View的毕竟是子View，大小不能超过父View的大小，但是子View的是WRAP_CONTENT，我们还不知道具体子View的大小是多少，要等到child.measure(childWidthMeasureSpec, childHeightMeasureSpec) 调用的时候才去真正测量子View 自己content的大小（比如TextView wrap_content 的时候你要测量TextView content 的大小，也就是字符占用的大小，这个测量就是在child.measure(childWidthMeasureSpec, childHeightMeasureSpec)的时候，才能测出字符的大小，MeasureSpec 的意思就是假设你字符100px，但是MeasureSpec 要求最大的只能50px，这时候就要截掉了）。通过上述描述，子View MeasureSpec mode的应该是AT_MOST，而size 暂定父View的 size，表示的意思就是子View的大小没有不确切的值，子View的大小最大为父View的大小，不能超过父View的大小（这就是AT_MOST 的意思），然后这个MeasureSpec 做为子View measure方法 的参数，做为子View的大小的约束或者说是要求，有了这个MeasureSpec子View再实现自己的测量。 3、如果如果子View 的layout_xxxx是确定的值（200dp），那么就更简单了，不管你父View的mode和size是什么，我都写死了就是200dp，那么控件最后展示就是就是200dp，不管我的父View有多大，也不管我自己的content 有多大，反正我就是这么大，所以这种情况MeasureSpec 的mode = EXACTLY 大小size=你在layout_xxxx 填的那个值。 如果父View的MeasureSpec 是AT_MOST，说明父View的大小是不确定，最大的大小是MeasureSpec 的size值，不能超过这个值。 1、如果子View 的layout_xxxx是MATCH_PARENT，父View的大小是不确定（只知道最大只能多大），子View的大小MATCH_PARENT（充满整个父View），那么子View你即使充满父容器，你的大小也是不确定的，父View自己都确定不了自己的大小，你MATCH_PARENT你的大小肯定也不能确定的，所以子View的mode=AT_MOST，size=父View的size，也就是你在布局虽然写的是MATCH_PARENT，但是由于你的父容器自己的大小不确定，导致子View的大小也不确定，只知道最大就是父View的大小。 2、如果子View 的layout_xxxx是WRAP_CONTENT，父View的大小是不确定（只知道最大只能多大），子View又是WRAP_CONTENT，那么在子View的Content没算出大小之前，子View的大小最大就是父View的大小，所以子View MeasureSpec mode的就是AT_MOST，而size 暂定父View的 size。 3、如果如果子View 的layout_xxxx是确定的值（200dp），同上，写多少就是多少，改变不了的。 如果父View的MeasureSpec 是UNSPECIFIED(未指定),表示没有任何束缚和约束，不像AT_MOST表示最大只能多大，不也像EXACTLY表示父View确定的大小，子View可以得到任意想要的大小，不受约束 1、如果子View 的layout_xxxx是MATCH_PARENT，因为父View的MeasureSpec是UNSPECIFIED，父View自己的大小并没有任何约束和要求，那么对于子View来说无论是WRAP_CONTENT还是MATCH_PARENT，子View也是没有任何束缚的，想多大就多大，没有不能超过多少的要求，一旦没有任何要求和约束，size的值就没有任何意义了，所以一般都直接设置成0 2、同上… 3、如果如果子View 的layout_xxxx是确定的值（200dp），同上，写多少就是多少，改变不了的（记住，只有设置的确切的值，那么无论怎么测量，大小都是不变的，都是你写的那个值） 2、View的测量过程主要是在onMeasure()方法打开View的源码，找到measure方法，这个方法代码不少，但是测量工作都是在onMeasure()做的，measure方法是final的所以这个方法也不可重写，如果想自定义View的测量，你应该去重写onMeasure()方法 12345public final void measure(int widthMeasureSpec, int heightMeasureSpec) &#123; ...... onMeasure(widthMeasureSpec,heightMeasureSpec); .....&#125; 3、View的onMeasure 的默认实现打开View.java 的源码来看下onMeasure的实现 12345protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasuredDimension( getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));&#125; View的onMeasure方法默认实现很简单，就是调用setMeasuredDimension()，setMeasuredDimension()可以简单理解就是给mMeasuredWidth和mMeasuredHeight设值，如果这两个值一旦设置了，那么意味着对于这个View的测量结束了，这个View的宽高已经有测量的结果出来了。如果我们想设定某个View的高宽，完全可以直接通过setMeasuredDimension（100，200）来设置死它的高宽（不建议），但是setMeasuredDimension方法必须在onMeasure方法中调用，不然会抛异常。我们来看下对于View来说它的默认高宽是怎么获取的。 1234567891011121314151617181920//获取的是android:minHeight属性的值或者View背景图片的大小值protected int getSuggestedMinimumWidth() &#123; return (mBackground == null) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth()); &#125; //@param size参数一般表示设置了android:minHeight属性或者该View背景图片的大小值 public static int getDefaultSize(int size, int measureSpec) &#123; int result = size; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); switch (specMode) &#123; case MeasureSpec.UNSPECIFIED: //表示该View的大小父视图未定，设置为默认值 result = size; break; case MeasureSpec.AT_MOST: case MeasureSpec.EXACTLY: result = specSize; break; &#125; return result;&#125; getDefaultSize的第一个参数size等于getSuggestedMinimumXXXX返回的的值（建议的最小宽度和高度），而建议的最小宽度和高度都是由View的Background尺寸与通过设置View的minXXX属性共同决定的，这个size可以理解为View的默认长度，而第二个参数measureSpec，是父View传给自己的MeasureSpec,这个measureSpec是通过测量计算出来的，具体的计算测量过程前面在讲解MeasureSpec已经讲得比较清楚了（是有父View的MeasureSpec和子View自己的LayoutParams 共同决定的）只要这个测试的mode不是UNSPECIFIED（未确定的），那么默认的就会用这个测量的数值当做View的高度。 对于View默认是测量很简单，大部分情况就是拿计算出来的MeasureSpec的size 当做最终测量的大小。而对于其他的一些View的派生类，如TextView、Button、ImageView等，它们的onMeasure方法系统了都做了重写，不会这么简单直接拿 MeasureSpec 的size来当大小，而去会先去测量字符或者图片的高度等，然后拿到View本身content这个高度（字符高度等），如果MeasureSpec是AT_MOST，而且View本身content的高度不超出MeasureSpec的size，那么可以直接用View本身content的高度（字符高度等），而不是像View.java 直接用MeasureSpec的size做为View的大小。 4、ViewGroup的Measure过程ViewGroup 类并没有实现onMeasure，我们知道测量过程其实都是在onMeasure方法里面做的，我们来看下FrameLayout 的onMeasure 方法,具体分析看注释哦。 1234567891011121314151617181920212223//FrameLayout 的测量protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; ....int maxHeight = 0;int maxWidth = 0;int childState = 0;for (int i = 0; i &lt; count; i++) &#123; final View child = getChildAt(i); if (mMeasureAllChildren || child.getVisibility() != GONE) &#123; // 遍历自己的子View，只要不是GONE的都会参与测量，measureChildWithMargins方法在最上面 // 的源码已经讲过了，如果忘了回头去看看，基本思想就是父View把自己的MeasureSpec // 传给子View结合子View自己的LayoutParams 算出子View 的MeasureSpec，然后继续往下传， // 传递叶子节点，叶子节点没有子View，根据传下来的这个MeasureSpec测量自己就好了。 measureChildWithMargins(child, widthMeasureSpec, 0, heightMeasureSpec, 0); final LayoutParams lp = (LayoutParams) child.getLayoutParams(); maxWidth = Math.max(maxWidth, child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin); maxHeight = Math.max(maxHeight, child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin); .... .... &#125;&#125;.......... //所有的孩子测量之后，经过一系类的计算之后通过setMeasuredDimension设置自己的宽高，//对于FrameLayout 可能用最大的字View的大小，对于LinearLayout，可能是高度的累加，//具体测量的原理去看看源码。总的来说，父View是等所有的子View测量结束之后，再来测量自己。 1234setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState), resolveSizeAndState(maxHeight, heightMeasureSpec, childState &lt;&lt; MEASURED_HEIGHT_STATE_SHIFT));....&#125; 到目前为止，基本把Measure 主要原理都过了一遍，接下来我们会结合实例来讲解整个match的过程，首先看下面的代码： 1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:id=&quot;@+id/linear&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;50dp&quot; android:background=&quot;@android:color/holo_blue_dark&quot; android:paddingBottom=&quot;70dp&quot; android:orientation=&quot;vertical&quot;&gt; &lt;TextView android:id=&quot;@+id/text&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;@color/material_blue_grey_800&quot; android:text=&quot;TextView&quot; android:textColor=&quot;@android:color/white&quot; android:textSize=&quot;20sp&quot; /&gt; &lt;View android:id=&quot;@+id/view&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;150dp&quot; android:background=&quot;@android:color/holo_green_dark&quot; /&gt;&lt;/LinearLayout&gt; 上面的代码对于出来的布局是下面的一张图 对于上面图可能有些不懂，这边做下说明: 整个图是一个DecorView,DecorView可以理解成整个页面的根View,DecorView是一个FrameLayout,包含两个子View，一个id=statusBarBackground的View和一个是LineaLayout，id=statusBarBackground的View，我们可以先不管（我也不是特别懂这个View,应该就是statusBar的设置背景的一个控件，方便设置statusBar的背景)，而这个LinearLayout比较重要，它包含一个title和一个content，title很好理解其实就是TitleBar或者ActionBar,content 就更简单了，setContentView()方法你应该用过吧，android.R.id.content 你应该听过吧，没错就是它,content是一个FrameLayout，你写的页面布局通过setContentView加进来就成了content的直接子View。 整个View的布局图如下： 这张图在下面分析measure，会经常用到，主要用于了解递归的时候view 的measure顺序 注:1、 header的是个ViewStub,用来惰性加载ActionBar，为了便于分析整个测量过程，我把Theme设成NoActionBar，避免ActionBar 相关的measure干扰整个过程，这样可以忽略掉ActionBar 的测量，在调试代码更清晰。2、包含Header(ActionBar）和id/content 的那个父View，我不知道叫什么名字好，我们姑且叫它ViewRoot（看上图）,它是垂直的LinearLayout，放着整个页面除statusBar 的之外所有的东西，叫它ViewRoot 应该还ok，一个代号而已。 既然我们知道整个View的Root是DecorView，那么View的绘制是从哪里开始的呢，我们知道每个Activity 均会创建一个 PhoneWindow对象，是Activity和整个View系统交互的接口，每个Window都对应着一个View和一个ViewRootImpl，Window和View通过ViewRootImpl来建立联系,对于Activity来说，ViewRootImpl是连接WindowManager和DecorView的纽带,绘制的入口是由ViewRootImpl的performTraversals方法来发起Measure，Layout，Draw等流程的。 我们来看下ViewRootImpl的performTraversals 方法： 123456789101112131415161718192021222324private void performTraversals() &#123; ...... int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width); int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height); ...... mView.measure(childWidthMeasureSpec, childHeightMeasureSpec); ......mView.layout(0, 0, mView.getMeasuredWidth(), mView.getMeasuredHeight());...... mView.draw(canvas); ......&#125;private static int getRootMeasureSpec(int windowSize, int rootDimension) &#123; int measureSpec; switch (rootDimension) &#123; case ViewGroup.LayoutParams.MATCH_PARENT: // Window can't resize. Force root view to be windowSize. measureSpec = MeasureSpec.makeMeasureSpec(windowSize,MeasureSpec.EXACTLY); break; ...... &#125; return measureSpec; &#125; performTraversals 中我们看到的mView其实就是DecorView,View的绘制从DecorView开始， 在mView.measure()的时候调用getRootMeasureSpec获得两个MeasureSpec做为参数，getRootMeasureSpec的两个参数（mWidth, lp.width）mWith和mHeight 是屏幕的宽度和高度， lp是WindowManager.LayoutParams，它的lp.width和lp.height的默认值是MATCH_PARENT,所以通过getRootMeasureSpec 生成的测量规格MeasureSpec 的mode是MATCH_PARENT ，size是屏幕的高宽。因为DecorView 是一个FrameLayout 那么接下来会进入FrameLayout 的measure方法，measure的两个参数就是刚才getRootMeasureSpec的生成的两个MeasureSpec，DecorView的测量开始了。首先是DecorView 的 MeasureSpec ，根据上面的分析DecorView 的 MeasureSpec是Windows传过来的，我们画出DecorView 的MeasureSpec 图： 注：1、-1 代表的是EXACTLY，-2 是AT_MOST2、由于屏幕的像素是1440x2560,所以DecorView 的MeasureSpec的size 对应于这两个值 那么接下来在FrameLayout 的onMeasure()方法DecorView开始for循环测量自己的子View,测量完所有的子View再来测量自己，由下图可知，接下来要测量ViewRoot的大小 1234567891011121314151617181920//FrameLayout 的测量protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; ....int maxHeight = 0;int maxWidth = 0;int childState = 0;for (int i = 0; i &lt; count; i++) &#123; final View child = getChildAt(i); if (mMeasureAllChildren || child.getVisibility() != GONE) &#123; // 遍历自己的子View，只要不是GONE的都会参与测量，measureChildWithMargins方法在最上面 // 的源码已经讲过了，如果忘了回头去看看，基本思想就是父View把自己当MeasureSpec // 传给子View结合子View自己的LayoutParams 算出子View 的MeasureSpec，然后继续往下穿， // 传递叶子节点，叶子节点没有子View，只要负责测量自己就好了。 measureChildWithMargins(child, widthMeasureSpec, 0, heightMeasureSpec, 0); .... .... &#125;&#125;....&#125; DecorView 测量ViewRoot 的时候把自己的widthMeasureSpec和heightMeasureSpec传进去了，接下来你就要去看measureChildWithMargins的源码了 123456789101112protected void measureChildWithMargins(View child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed) &#123; final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams(); final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin + widthUsed, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin + heightUsed, lp.height); child.measure(childWidthMeasureSpec, childHeightMeasureSpec);&#125; ViewRoot 是系统的View，它的LayoutParams默认都是match_parent,根据我们文章最开始MeasureSpec 的计算规则，ViewRoot 的MeasureSpec mode应该等于EXACTLY（DecorView MeasureSpec 的mode是EXACTLY，ViewRoot的layoutparams 是match_parent），size 也等于DecorView的size，所以ViewRoot的MeasureSpec图如下： 算出ViewRoot的MeasureSpec 之后，开始调用ViewRoot.measure 方法去测量ViewRoot的大小，然而ViewRoot是一个LinearLayout ，ViewRoot.measure最终会执行的LinearLayout 的onMeasure 方法，LinearLayout 的onMeasure 方法又开始逐个测量它的子View，上面的measureChildWithMargins方法又会被调用，那么根据View的层级图，接下来测量的是header（ViewStub）,由于header的Gone，所以直接跳过不做测量工作，所以接下来轮到ViewRoot的第二个child content（android.R.id.content）,我们要算出这个content 的MeasureSpec，所以又要拿ViewRoot 的MeasureSpec 和 android.R.id.content的LayoutParams 做计算了，计算过程就是调用getChildMeasureSpec的方法， 1234567891011121314protected void measureChildWithMargins(View child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed) &#123; ..... final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin + heightUsed, lp.height); ....&#125;public static int getChildMeasureSpec(int spec, int padding, int childDimension) &#123; int specMode = MeasureSpec.getMode(spec); //获得父View的mode int specSize = MeasureSpec.getSize(spec); //获得父View的大小 int size = Math.max(0, specSize - padding); //父View的大小-自己的Padding+子View的Margin，得到值才是子View可能的最大值。 .....&#125; 由上面的代码 1int size = Math.max(0, specSize - padding); 而1padding=mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin + heightUsed 算出android.R.id.content 的MeasureSpec 的size由于ViewRoot 的mPaddingBottom=100px(这个可能和状态栏的高度有关，我们测量的最后会发现id/statusBarBackground的View的高度刚好等于100px，ViewRoot 是系统的View的它的Padding 我们没法改变，所以计算出来Content（android.R.id.content） 的MeasureSpec 的高度少了100px ，它的宽高的mode 根据算出来也是EXACTLY（ViewRoot 是EXACTLY和android.R.id.content 是match_parent）。所以Content（android.R.id.content）的MeasureSpec 如下（高度少了100px）：Paste_Image.pngContent（android.R.id.content） 是FrameLayout，递归调用开始准备计算id/linear的MeasureSpec，我们先给出结果： 图中有两个要注意的地方：1、id/linear的heightMeasureSpec 的mode=AT_MOST，因为id/linear 的LayoutParams 的layout_height=”wrap_content”2、id/linear的heightMeasureSpec 的size 少了200px, 由上面的代码padding=mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin + heightUsed;int size = Math.max(0, specSize - padding);由于id/linear 的 android:layout_marginTop=”50dp” 使得lp.topMargin=200px (本设备的density=4，px=4*pd)，在计算后id/linear的heightMeasureSpec 的size 少了200px。（布局代码前面已给出，可自行查看id/linear 控件xml中设置的属性） linear.measure接着往下算linear的子View的的MeasureSpec，看下View 层级图，往下走应该是id/text,接下来是计算id/text的MeasureSpec，直接看图，mode=AT_MOST ,size 少了280，别问我为什么 …specSize - padding. 算出id/text 的MeasureSpec 后，接下来text.measure(childWidthMeasureSpec, childHeightMeasureSpec);准备测量id/text 的高宽，这时候已经到底了，id/text是TextView，已经没有子类了，这时候跳到TextView的onMeasure方法了。TextView 拿着刚才计算出来的heightMeasureSpec（mode=AT_MOST,size=1980）,这个就是对TextView的高度和宽度的约束，进到TextView 的onMeasure(widthMeasureSpec,heightMeasureSpec) 方法，在onMeasure 方法执行调试过程中，我们发现下面的代码： 123456int desired = getDesiredHeight(); desired = 107pxif(heightMode == MeasureSpec.AT_MOST)&#123; height = Math.min(desired,heightSize); height = 1980px &#125; setMeasuredDimension(width,height); TextView字符的高度（也就是TextView的content高度[wrap_content]）测出来=107px，107px 并没有超过1980px(允许的最大高度)，所以实际测量出来TextView的高度是107px。最终算出id/text 的mMeasureWidth=1440px,mMeasureHeight=107px。 贴一下布局代码，免得你忘了具体布局。 1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:id=&quot;@+id/linear&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;50dp&quot; android:background=&quot;@android:color/holo_blue_dark&quot; android:paddingBottom=&quot;70dp&quot; android:orientation=&quot;vertical&quot;&gt; &lt;TextView android:id=&quot;@+id/text&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;@color/material_blue_grey_800&quot; android:text=&quot;TextView&quot; android:textColor=&quot;@android:color/white&quot; android:textSize=&quot;20sp&quot; /&gt; &lt;View android:id=&quot;@+id/view&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;150dp&quot; android:background=&quot;@android:color/holo_green_dark&quot; /&gt;&lt;/LinearLayout&gt; TextView的高度已经测量出来了，接下来测量id/linear的第二个child（id/view），同样的原理测出id/view的MeasureSpec. id/view的MeasureSpec 计算出来后，调用view.measure(childWidthMeasureSpec, childHeightMeasureSpec)的测量id/view的高宽，之前已经说过View measure的默认实现是 12345protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasuredDimension( getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));&#125; 最终算出id/view的mMeasureWidth=1440px,mMeasureHeight=600px。 id/linear 的子View的高度都计算完毕了，接下来id/linear就通过所有子View的测量结果计算自己的高宽，id/linear是LinearLayout，所有它的高度计算简单理解就是子View的高度的累积+自己的Padding. 最终算出id/linear的mMeasureWidth=1440px,mMeasureHeight=987px。 最终算出id/linear出来后，id/content 就要根据它唯一的子View id/linear 的测量结果和自己的之前算出的MeasureSpec一起来测量自己的结果，具体计算的逻辑去看FrameLayout onMeasure 函数的计算过程。以此类推，接下来测量ViewRoot,然后再测量id/statusBarBackground,虽然不知道id/statusBarBackground 是什么，但是调试的过程中，测出的它的高度=100px, 和 id/content 的paddingTop 刚好相等。在最后测量DecorView 的高宽，最终整个测量过程结束。所有的View的大小测量完毕。所有的getMeasureWidth 和 getMeasureWidth 都已经有值了。Measure 分析到此为止 layout过程123mView.measure(childWidthMeasureSpec, childHeightMeasureSpec); ......mView.layout(0, 0, mView.getMeasuredWidth(), mView.getMeasuredHeight()); performTraversals 方法执行完mView.measure 计算出mMeasuredXXX后就开始执行layout 函数来确定View具体放在哪个位置，我们计算出来的View目前只知道view矩阵的大小，具体这个矩阵放在哪里，这就是layout 的工作了。layout的主要作用 ：根据子视图的大小以及布局参数将View树放到合适的位置上。 既然是通过mView.layout(0, 0, mView.getMeasuredWidth(), mView.getMeasuredHeight()); 那我们来看下layout 函数做了什么，mView肯定是个ViewGroup，不会是View,我们直接看下ViewGroup 的layout函数 1234567891011public final void layout(int l, int t, int r, int b) &#123; if (!mSuppressLayout &amp;&amp; (mTransition == null || !mTransition.isChangingLayout())) &#123; if (mTransition != null) &#123; mTransition.layoutChange(this); &#125; super.layout(l, t, r, b); &#125; else &#123; // record the fact that we noop'd it; request layout when transition finishes mLayoutCalledWhileSuppressed = true; &#125;&#125; 代码可以看个大概，LayoutTransition是用于处理ViewGroup增加和删除子视图的动画效果，也就是说如果当前ViewGroup未添加LayoutTransition动画，或者LayoutTransition动画此刻并未运行，那么调用super.layout(l, t, r, b)，继而调用到ViewGroup中的onLayout，否则将mLayoutSuppressed设置为true，等待动画完成时再调用requestLayout()。这个函数是final 不能重写，所以ViewGroup的子类都会调用这个函数，layout 的具体实现是在super.layout(l, t, r, b)里面做的，那么我接下来看一下View类的layout函数 12345678910111213141516public final void layout(int l, int t, int r, int b) &#123; ..... //设置View位于父视图的坐标轴 boolean changed = setFrame(l, t, r, b); //判断View的位置是否发生过变化，看有必要进行重新layout吗 if (changed || (mPrivateFlags &amp; LAYOUT_REQUIRED) == LAYOUT_REQUIRED) &#123; if (ViewDebug.TRACE_HIERARCHY) &#123; ViewDebug.trace(this, ViewDebug.HierarchyTraceType.ON_LAYOUT); &#125; //调用onLayout(changed, l, t, r, b); 函数 onLayout(changed, l, t, r, b); mPrivateFlags &amp;= ~LAYOUT_REQUIRED; &#125; mPrivateFlags &amp;= ~FORCE_LAYOUT; ..... &#125; 1、setFrame(l, t, r, b) 可以理解为给mLeft 、mTop、mRight、mBottom赋值，然后基本就能确定View自己在父视图的位置了，这几个值构成的矩形区域就是该View显示的位置，这里的具体位置都是相对与父视图的位置。 2、回调onLayout，对于View来说，onLayout只是一个空实现，一般情况下我们也不需要重载该函数,： 123protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123; &#125; 对于ViewGroup 来说，唯一的差别就是ViewGroup中多了关键字abstract的修饰，要求其子类必须重载onLayout函数。 123@Override protected abstract void onLayout(boolean changed, int l, int t, int r, int b); 而重载onLayout的目的就是安排其children在父视图的具体位置，那么如何安排子View的具体位置呢？ 123456int childCount = getChildCount() ; for(int i=0 ;i&lt;childCount ;i++)&#123; View child = getChildAt(i) ; //整个layout()过程就是个递归过程 child.layout(l, t, r, b) ; &#125; 代码很简单，就是遍历自己的孩子，然后调用 child.layout(l, t, r, b) ，给子view 通过setFrame(l, t, r, b) 确定位置，而重点是(l, t, r, b) 怎么计算出来的呢。还记得我们之前测量过程，测量出来的MeasuredWidth和MeasuredHeight吗？还记得你在xml 设置的Gravity吗？还有RelativeLayout 的其他参数吗，没错，就是这些参数和MeasuredHeight、MeasuredWidth 一起来确定子View在父视图的具体位置的。具体的计算过程大家可以看下最简单FrameLayout 的onLayout 函数的源码，每个不同的ViewGroup 的实现都不一样，这边不做具体分析了吧。 3、MeasuredWidth和MeasuredHeight这两个参数为layout过程提供了一个很重要的依据（如果不知道View的大小，你怎么固定四个点的位置呢），但是这两个参数也不是必须的，layout过程中的4个参数l, t, r, b完全可以由我们任意指定，而View的最终的布局位置和大小（mRight - mLeft=实际宽或者mBottom-mTop=实际高）完全由这4个参数决定，measure过程得到的mMeasuredWidth和mMeasuredHeight提供了视图大小测量的值，但我们完全可以不使用这两个值，所以measure过程并不是必须的。如果我们不使用这两个值，那么getMeasuredWidth() 和getWidth() 就很有可能不是同一个值，它们的计算是不一样的： 123456public final int getMeasuredWidth() &#123; return mMeasuredWidth &amp; MEASURED_SIZE_MASK; &#125; public final int getWidth() &#123; return mRight - mLeft; &#125; layout 过程相对简单些，分析就到此为止。 draw过程performTraversals 方法的下一步就是mView.draw(canvas); 因为View的draw 方法一般不去重写，官网文档也建议不要去重写draw 方法，所以下一步执行就是View.java的draw 方法，我们来看下源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public void draw(Canvas canvas) &#123; ... /* * Draw traversal performs several drawing steps which must be executed * in the appropriate order: * * 1. Draw the background * 2. If necessary, save the canvas' layers to prepare for fading * 3. Draw view's content * 4. Draw children * 5. If necessary, draw the fading edges and restore layers * 6. Draw decorations (scrollbars for instance) */ // Step 1, draw the background, if needed ... background.draw(canvas); ... // skip step 2 &amp; 5 if possible (common case) ... // Step 2, save the canvas' layers ... if (solidColor == 0) &#123; final int flags = Canvas.HAS_ALPHA_LAYER_SAVE_FLAG; if (drawTop) &#123; canvas.saveLayer(left, top, right, top + length, null, flags); &#125; ... // Step 3, draw the content if (!dirtyOpaque) onDraw(canvas); // Step 4, draw the children dispatchDraw(canvas); // Step 5, draw the fade effect and restore layers if (drawTop) &#123; matrix.setScale(1, fadeHeight * topFadeStrength); matrix.postTranslate(left, top); fade.setLocalMatrix(matrix); canvas.drawRect(left, top, right, top + length, p); &#125; ... // Step 6, draw decorations (scrollbars) onDrawScrollBars(canvas); &#125; 注释写得比较清楚，一共分成6步，看到注释没有（ // skip step 2 &amp; 5 if possible (common case)）除了2 和 5之外 我们一步一步来看：1、第一步：背景绘制看注释即可，不是重点 12345678910111213private void drawBackground(Canvas canvas) &#123; Drawable final Drawable background = mBackground; ...... //mRight - mLeft, mBottom - mTop layout确定的四个点来设置背景的绘制区域 if (mBackgroundSizeChanged) &#123; background.setBounds(0, 0, mRight - mLeft, mBottom - mTop); mBackgroundSizeChanged = false; rebuildOutline(); &#125; ...... //调用Drawable的draw() 把背景图片画到画布上 background.draw(canvas); ...... &#125; 2、第三步，对View的内容进行绘制。onDraw(canvas) 方法是view用来draw 自己的，具体如何绘制，颜色线条什么样式就需要子View自己去实现，View.java 的onDraw(canvas) 是空实现，ViewGroup 也没有实现，每个View的内容是各不相同的，所以需要由子类去实现具体逻辑。 3、第4步 对当前View的所有子View进行绘制dispatchDraw(canvas) 方法是用来绘制子View的，View.java 的dispatchDraw()方法是一个空方法,因为View没有子View,不需要实现dispatchDraw ()方法，ViewGroup就不一样了，它实现了dispatchDraw ()方法： 1234567891011121314151617181920@Override protected void dispatchDraw(Canvas canvas) &#123; ... if ((flags &amp; FLAG_USE_CHILD_DRAWING_ORDER) == 0) &#123; for (int i = 0; i &lt; count; i++) &#123; final View child = children[i]; if ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) &#123; more |= drawChild(canvas, child, drawingTime); &#125; &#125; &#125; else &#123; for (int i = 0; i &lt; count; i++) &#123; final View child = children[getChildDrawingOrder(count, i)]; if ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) &#123; more |= drawChild(canvas, child, drawingTime); &#125; &#125; &#125; ...... &#125; 代码一眼看出，就是遍历子View然后drawChild(),drawChild()方法实际调用的是子View.draw()方法,ViewGroup类已经为我们实现绘制子View的默认过程，这个实现基本能满足大部分需求，所以ViewGroup类的子类（LinearLayout,FrameLayout）也基本没有去重写dispatchDraw方法，我们在实现自定义控件，除非比较特别，不然一般也不需要去重写它， drawChild()的核心过程就是为子视图分配合适的cavas剪切区，剪切区的大小正是由layout过程决定的，而剪切区的位置取决于滚动值以及子视图当前的动画。设置完剪切区后就会调用子视图的draw()函数进行具体的绘制了。 4、第6步 对View的滚动条进行绘制不是重点，知道有这东西就行，onDrawScrollBars 的一句注释 ：Request the drawing of the horizontal and the vertical scrollbar. The scrollbars are painted only if they have been awakened first. 一张图看下整个draw的递归流程。 到此整个绘制过程基本讲述完毕了。","categories":[{"name":"Android","slug":"Android","permalink":"http://wenyiqingnian.xyz/categories/Android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://wenyiqingnian.xyz/tags/android/"}]},{"title":"linux用户控件、内和空间","slug":"Linux 用户空间 内核空间","date":"2017-09-07T12:30:15.000Z","updated":"2018-05-06T13:11:43.893Z","comments":true,"path":"2017/09/07/Linux 用户空间 内核空间/","link":"","permalink":"http://wenyiqingnian.xyz/2017/09/07/Linux 用户空间 内核空间/","excerpt":"","text":"用户空间就是用户进程所在的内存区域，相对的，系统空间就是操作系统占据的内存区域。 用户进程和系统进程的所有数据都在内存中。 是谁来划分内存空间的呢？ 在电脑开机之前，内存就是一块原始的物理内存。什么也没有。开机加电，系统启动后，就对物理内存进行了划分。当然，这是系统的规定，物理内存条上并没有划分好的地址和空间范围。这些划分都是操作系统在逻辑上的划分。不同版本的操作系统划分的结果都是不一样的。 为什么要划分用户空间和系统空间呢？当然是有必要的。操作系统的数据都是存放于系统空间的，用户进程的数据是存放于用户空间的。这是第一点，不同的身份，数据放置的位置必然不一样，否则大混战就会导致系统的数据和用户的数据混在一起，系统就不能很好的运行了。分开来存放，就让系统的数据和用户的数据互不干扰，保证系统的稳定性。分开存放，管理上很方便，而更重要的是，将用户的数据和系统的数据隔离开，就可以对两部分的数据的访问进行控制。这样就可以确保用户程序不能随便操作系统的数据，这样防止用户程序误操作或者是恶意破坏系统。 处于用户态的程序只能访问用户空间，而处于内核态的程序可以访问用户空间和内核空间。那么用户态和内核态有什么区别呢？ 当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）。此时处理器处于特权级最高的（0级）内核代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。当进程在执行用户自己的代码时，则称其处于用户运行态（用户态）。即此时处理器在特权级最低的（3级）用户代码中运行。 内核态与用户态是操作系统的两种运行级别,Intel x86架构提供Ring0-Ring3四种级别的运行模式，Ring0级别最高，Ring3最低。Linux使用了Ring3级别运行用户态，Ring0作为 内核态，没有使用Ring1和Ring2。Ring3状态不能访问Ring0的地址空间，包括代码和数据。程序特权级别的不同，其所拥有的权力也不同。如下图所示。 用户态切换到内核态的3种方式 a. 系统调用 这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作，比如fork()实际上就是执行了一个创建新进程的系统调用。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断。 b. 异常 当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。 c. 外围设备的中断 当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。 这3种方式是系统在运行时由用户态转到内核态的最主要方式，其中系统调用可以认为是用户进程主动发起的，异常和外围设备中断则是被动的。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://wenyiqingnian.xyz/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://wenyiqingnian.xyz/tags/linux/"}]},{"title":"webrtc音频总结","slug":"webrtc 音频","date":"2017-08-16T13:10:30.000Z","updated":"2018-05-06T13:37:22.813Z","comments":true,"path":"2017/08/16/webrtc 音频/","link":"","permalink":"http://wenyiqingnian.xyz/2017/08/16/webrtc 音频/","excerpt":"","text":"webrtc/modules/audio_device/android/audio_record_jni.cc 这个文件，是音频采集jni类文件。 Android Audio Record 和 JNI 通信接口包括： 123// java 调用 c++ 接口nativeCacheDirectBufferAddressnativeDataIsRecorded 123456// c++ 回调 java 接口initRecordingstartRecordingstopRecordingenableBuiltInAECenableBuiltInNS nativeCacheDirectBufferAddress 和 nativeDataIsRecorded 只是为了高效的将 AudioRecord 采集到的音频数据传递给 native。 WebRtcVoiceEngineWebRtcVoiceEngine 初始化 12345678910111213WebRtcVoiceEngine::Init()&#123; send_codecs_ = CollectCodecs(encoder_factory_-&gt;GetSupportedEncoders()); recv_codecs_ = CollectCodecs(decoder_factory_-&gt;GetSupportedDecoders()); adm_ = webrtc::AudioDeviceModule::Create( webrtc::AudioDeviceModule::kPlatformDefaultAudio ); webrtc::adm_helpers::Init(adm()); webrtc::apm_helpers::Init(apm());&#125; 可知，WebRtcVoiceEngine 里面的 adm_ 就是 AudioDeviceModule ，代码在 /modules/audio_device/audio_device_impl.cc 在 webrtcvoiceengine.h123456789101112131415161718192021222324252627// WebRtcVoiceEngine//public void Init();AudioState GetAudioState();VoiceMediaChannel* CreateChannel(Call call, MediaConfig config, AudioOptions options);AudioCodec send_codecs();AudioCodec recv_codecs();RtpCapabilities GetCapabilities();void RegisterChannel(WebRtcVoiceMediaChannel* channel);void UnregisterChannel(WebRtcVoiceMediaChannel* channel);bool StartAecDump();void StopAecDump();//privateAudioDeviceModule adm_;AudioEncoderFactory encoder_factory_;AudioDecoderFactory decoder_factory_;AudioMixer audio_mixer_;AudioProcessing apm_;AudioState audio_state_;AudioCodec send_codecs_;AudioCodec recv_codecs_;WebRtcVoiceMediaChannel channels_; audio_device//webrtc/modules/audio_device/ audio_device_impl.cc 123456789AudioDeviceModule::Create()&#123; audioDevice(new AudioDeviceModuleImpl(audio_layer)); audioDevice-&gt;CheckPlatform(); audioDevice-&gt;CreatePlatformSpecificObjects(); audioDevice-&gt;AttachAudioBuffer(); return audioDevice;&#125; 123456789101112131415161718192021222324252627282930313233343536373839AudioDeviceModuleImpl::CreatePlatformSpecificObjects()&#123; // WEBRTC_DUMMY_AUDIO_BUILD audio_device_.reset(new AudioDeviceDummy()); // WEBRTC_DUMMY_FILE_DEVICES audio_device_.reset(FileAudioFactory::CreateFileAudioDevice()); // WEBRTC_WINDOWS_CORE_AUDIO_BUILD audio_device_.reset(new AudioDeviceWindowsCore()); // WEBRTC_ANDROID audio_manager_android_.reset(new AudioManager()); if(audio_layer == kPlatformDefaultAudio)&#123; audio_layer = kAndroidOpenSLESAudio; &#125; else if(isLowLatencySupported)&#123; audio_layer = kAndroidJavaInputAndroidOpenSLESOutputAudio; &#125; else &#123; audio_layer = kAndroidJavaAudio; &#125; if(kAndroidJavaAudio)&#123; audio_device_.reset(new AudioDeviceTemplate&lt;AudioRecordJni, AudioTrackJni&gt;()) &#125; else if(kAndroidOpenSLESAudio)&#123; audio_device_.reset(new AudioDeviceTemplate&lt;OpenSLESRecorder, OpenSLESPlayer&gt;()); &#125; else if(kAndroidJavaInputAndOpenSLESOutputAudio)&#123; audio_device_.reset(new AudioDeviceTemplate&lt;AudioRecordJni, OpenSLESPlayer&gt;()) &#125; // WEBRTC_LINUX if(kLinuxPulseAudio || kPlatformDefaultAudio)&#123; audio_device_.reset(new AudioDeviceLinuxPulse()) &#125; else if(kLinuxAlsaAudio)&#123; audio_device_.reset(new AudioDeviceLinuxALSA()) &#125; // WEBRTC_IOS audio_device_.reset(new AudioDeviceIOS()) // WEBRTC_MAC audio_device_.reset(new AudioDeviceMac())&#125; 我们以 Android 为例；使用 AudioDeviceTemplate 封装 音频输入（采集）、输出类型（渲染）；目前使用 AudioRecordJni 和 AudioTrackJni。如果直接使用 NDK 的openSLES 开发的化，使用的是 OpenSLESRecorder 和 OpenSLESPlayer。 audio_manager.h12345678910// JavaAudioManagerbool Init()void Close()bool IsCommunicationModeEnabled()bool IsDeviceBlacklistedForOpenSLESUsage()// privateJNICALL CacheAudioParameters()void OnCacheAudioParameters() audio_record_jni.h1234567891011121314151617181920212223242526272829//JavaAudioRecordint InitRecording(int sample_reate, size_t channels);bool StartRecording();bool StopRecording();bool EnableBuiltInAEC(bool enable);bool EnableBuiltInNS(bool enable);// publicint32_t Init();int32_t Terminate();int32_t InitRecording();bool RecordingIsInitialized();int32_t StartRecording();int32_t StopRecording();bool Recording();void AttachAudioBuffer();int32_t EnableBuiltInAEC(bool enable);int32_t EnableBuiltInAGC(bool enable);int32_t EnableBuiltInNS(bool enable);// privateJNICALL CacheDirectBufferAddress()void OnCacheDirectBufferAddress(jobject byte_buffer)JNICALL DataIsRecorded();void OnDataIsRecorded(int length); audio_track_jni.h 12345678910111213141516171819202122232425262728293031// JavaAudioTrackbool InitPlayout(int sample_rate, int channels);bool StartPlayout();bool StopPlayout();bool SetStreamVolume(int volume);int GetStreamMaxVolume();int GetStreamVolume();// publicInit()Terminate()InitPlayout()PlayoutIsInitialized()StartPlayout()StopPlayout()Playing()SpeakerVolumeIsAvailable(bool available);SetSpeakerVolume(volume);SpeakerVolume(volume);MaxSpeakerVolume(max_volume);MinSpeakerVolume(min_volume);AttachAudioBuffer(audioBuffer);// privateJNICALL CacheDirectBufferAddress();void OnCacheDirectBufferAddress(jobject byte_buffer);JNICALL GetPlayoutData();void OnGetPlayoutData(size_t length); AudioRecordJni音频采集初始化AudioRecordJni 初始化时，在构造方法中初始化 JavaAudioRecord。123j_audio-record_.reset( new JavaAudioRecord()) 然后在 webrtcvoiceengine 中 AddSendStream 后，SetSend() 配置媒体通道发送。 12345678910111213//media/engine/webrtcvoiceengine.ccWebRtcVoiceMediaChannel::SetSend(bool send)&#123; ... if(send)&#123; engine()-&gt;ApplyOptions(options_); if(!engine()-&gt;adm()-&gt;RecordingIsInitialized() &amp;&amp; !engine()-&gt;adm()-&gt;Recording())&#123; engine()-&gt;adm()-&gt;InitRecording(); &#125; &#125; ...&#125; 这里面会初始化 AudioRecord。 InitRecording() 方法实现，在 Android 中实在 audio_record_jni.cc 的 JavaAudioRecord::InitRecording() ，最终通过 JNI 回调 Java 层的 InitRecording() 方法。 音频采集初始化完成后，就要开始采集音频数据。 /audio/audio_send_stream.cc音频发送流里面 AudioSendStream::Start() 方法启动音频流发送； 1234AudioSendSstream::Start()&#123; channel_proxy_-&gt;StartSend(); audio_state()-&gt;AddSendingStream(this, encoder_sample_rate_hz_, encoder_num_channels_);&#125; 调用 /audio/audio_state.cc 的 AudioState::AddSendingStream() 方法； 123456AudioState::AddSendingStream()&#123; auto* adm = config_.audio_device_module.get(); ... amd-&gt;StartRecording(); ...&#125; 音频开关另外，PeerConnection 提供了 音频采集开关。 1234//org.webrtc.PeerConnection.javapublic void setAudioRecording(boolean recording)&#123; nativeSetAudioRecording();&#125; 对应的JNI方法1234//JNI/pc/peerconnection.ccvoid JNI_PeerConnection_SetAudioRecording()&#123; ExtractNativePC(jni,j_pc)-&gt;SetAudioRecording(recording);&#125; 其实JNI方法也是调用 webrtc 的 peerconnection 1234567//webrtc/pc/peerconnection.ccPeerConnection::SetAudioRecording(bool recording)&#123; auto audio_state = factory_-&gt;channel_manager()-&gt;media_engine()-&gt;GetAudioState(); // AudioState audio_state-&gt;SetRecording(recording);&#125; 由上代码可知， 通过 WebRtcVoiceEngine 的 GetAudioState() 方法获取 audio_state。然后通过 audio_state 设置音频采集开关。 在 AudioState::SetRecording() 方法调用具体设备模块开始或停止音频采集。 123456789//webrtc/audio/audio_state.ccAudioState::SetRecording(bool enabled)&#123; ... if(enabled)&#123; config_.audio_device_module-&gt;StartRecording(); &#125;else&#123; config_.audio_device_module-&gt;StopRecording(); &#125;&#125; 音频采集具体实现这里我们只以Android为例。 如果使用 opensles ndk 采集音频，采集的具体实现在 opensles_recorder.cc 文件的 StartRecording() 方法。 1234// modules/audio_device/android/opensles_recorder.ccint OpenSLESRecorder::StartRecording()&#123; ...&#125; 这种方法的具体实现我们暂时不深入。 我们讨论 java 实现方案。 java 实现的jni类，audio_record_jni.cc123456//modules/audio_device/android/audio_record_jni.ccAudioRecordJni::StartRecording()&#123; ... j_audio_record_-&gt;StartRecording() ...&#125; j_audio_record_-&gt;StartRecording() 调用的就是 AudioRecordJni::JavaAudioRecord::StartRecording() 方法。 123AudioRecordJni::JavaAudioRecord::StartRecording()&#123; return audio_record_-&gt;CallBooleanMethod(start_recording_);&#125; CallBooleanMethod 就是jni回调java 实现的封装，最终实现回调 WebRtcAudioRecord.java 中的 StartRecording() 方法。 123456//org.webrtc.voiceengine.WebRtcAudioRecord.java boolean startRecording()&#123; audioRecord.startRecording(); audioThread = new AudioRecordThread(&quot;AudioRecordJavaThread&quot;); audioThread.start();&#125; 音频采集线程音频采集线 AudioRecordThread；我们只跟踪 run() 方法。 123456789101112131415161718@Overridepublic void run()&#123; ... while(keepAlive)&#123; int bytesRead = audioRecord.read(byteBuffer, byteBuffer.capacity()); // 通知 native 音频数据 nativeDataIsRecorded(bytesRead, nativeAudioRecord); // 应用音频采集回调 byte[] data = Arrays.copyOf(byteBuffer.array(), byteBuffer.capacity()); audioSamplesReadyCallback.onWebRtcAudioRecordSamplesReady( new AudioSamples(audioRecord, data) ); &#125; ...&#125;","categories":[{"name":"webrtc","slug":"webrtc","permalink":"http://wenyiqingnian.xyz/categories/webrtc/"}],"tags":[{"name":"webrtc","slug":"webrtc","permalink":"http://wenyiqingnian.xyz/tags/webrtc/"}]},{"title":"MK语法规范","slug":"MK语法规范","date":"2017-05-07T12:11:15.000Z","updated":"2018-05-06T13:07:44.655Z","comments":true,"path":"2017/05/07/MK语法规范/","link":"","permalink":"http://wenyiqingnian.xyz/2017/05/07/MK语法规范/","excerpt":"","text":"Android.mk文件语法规范及使用模板 Introduction:Android.mk编译文件是用来向Android NDK描述你的C,C++源代码文件的， 这篇文档描述了它的语法。在阅读下面的内容之前，假定你已经阅读了docs/OVERVIEW.TXT文件，了解了它们的用途。 概述:一个 Android.mk file用来向编译系统描述你的源代码。具体来说：-该文件是GNU Makefile的一小部分，会被编译系统解析一次或更多次的build系统。因此，您应尽量减少您声明的变量，不要认为某些变量在解析过程中不会被定义。-这个文件的语法允许把你的源代码组织成模块，一个模块属下列类型之一： 静态库 、共享库 只有共享库将被安装/复制到您的应用软件包。虽然静态库能被用于生成共享库。 你可以在每一个Android.mk file中定义一个或多个模块，你也可以在几个模块中使用同一个源代码文件。 -编译系统为你处理许多细节问题。例如，你不需要在你的Android.mk中列出头文件和依赖文件。NDK编译系统将会为你自动处理这些问题。这也意味着，在升级NDK后，你应该得到新的toolchain/platform支持，而且不需要改变你的Android.mk文件。 注意，这个语法同公开发布的Android平台的开源代码很接近，然而编译系统实现他们的方式却是不同的，这是故意这样设计的，可以让程序开发人员重用外部库的源代码更容易。 简单的例子: 在描述语法细节之前，咱们来看一个简单的”hello world”的例子，比如，下面的文件： 123sources/helloworld/helloworld.csources/helloworld/Android.mk ‘helloworld.c’是一个JNI共享库，实现返回”hello world”字符串的原生方法。 相应的Android.mk文件会象下面这样： 12345678910111213---------- cut here ------------------LOCAL_PATH := $(call my-dir)include $(CLEAR_VARS)LOCAL_MODULE:= helloworldLOCAL_SRC_FILES := helloworld.cinclude $(BUILD_SHARED_LIBRARY)---------- cut here ------------------ 好，我们来解释一下这几行代码： 1LOCAL_PATH := $(call my-dir) 一个Android.mk file首先必须定义好LOCAL_PATH变量。它用于在开发树中查找源文件。在这个例子中，宏函数’my-dir’, 由编译系统提供，用于返回当前路径（即包含Android.mk file文件的目录）。 1include $( CLEAR_VARS) CLEAR_VARS由编译系统提供，指定让GNU MAKEFILE为你清除许多LOCAL_XXX变量（例如 LOCAL_MODULE, LOCAL_SRC_FILES, LOCAL_STATIC_LIBRARIES, 等等…), 除LOCAL_PATH 。这是必要的，因为所有的编译控制文件都在同一个GNU MAKE执行环境中，所有的变量都是全局的。 1LOCAL_MODULE := helloworld LOCAL_MODULE变量必须定义，以标识你在Android.mk文件中描述的每个模块。名称必须是唯一的，而且不包含任何空格。注意编译系统会自动产生合适的前缀和后缀，换句话说，一个被命名为’foo’的共享库模块，将会生成’libfoo.so’文件。 重要注意事项 如果你把库命名为‘libhelloworld’，编译系统将不会添加任何的lib前缀，也会生成libhelloworld.so，这是为了支持来源于Android平台的源代码的Android.mk文件，如果你确实需要这么做的话。 1LOCAL_SRC_FILES := helloworld.c LOCAL_SRC_FILES变量必须包含将要编译打包进模块中的C或C++源代码文件。注意，你不用在这里列出头文件和包含文件，因为编译系统将会自动为你找出依赖型的文件；仅仅列出直接传递给编译器的源代码文件就好。【注意，默认的C++源码文件的扩展名是’.cpp’. 指定一个不同的扩展名也是可能的，只要定义LOCAL_DEFAULT_CPP_EXTENSION变量，不要忘记开始的小圆点（也就是定义为‘.cxx’,而不是‘cxx’）（当然这一步我们一般不会去改它）】 1include $(BUILD_SHARED_LIBRARY) BUILD_SHARED_LIBRARY是编译系统提供的变量，指向一个GNU Makefile脚本（应该就是在build/core目录下的shared_library.mk），负责收集自从上次调用’include $(CLEAR_VARS)’以来，定义在LOCAL_XXX变量中的所有信息，并且决定编译什么，如何正确地去做。并根据其规则生成静态库。同理对于静态库。 在sources/samples目录下有更复杂一点的例子，写有注释的Android.mk文件，你可以看看。 参考: 这是一份你应该在Android.mk中依赖或定义的变量列表，您可以定义其他变量为自己使用， 但是NDK编译系统保留下列变量名： -以LOCAL_开头的名字（例如 LOCAL_MODULE） -以PRIVATE_, NDK_ or APP_开头的名字（内部使用） -小写名字（内部使用，例如’my-dir’） 如果您为了方便在Android.mk中定义自己的变量，我们建议使用MY_前缀，一个小例子： 12345678910111213---------- cut here ------------------MY_SOURCES := foo.cifneq ($(MY_CONFIG_BAR),)MY_SOURCES += bar.cendifLOCAL_SRC_FILES += $(MY_SOURCES)---------- cut here ------------------ 这些GNU Make 变量在你的Android.mk文件解析之前，就由编译系统定义好了。 注意在某些情况下，NDK可能分析Android.mk几次，每一次某些变量的定义会有不同。 1CLEAR_VARS 指向一个编译脚本，几乎所有未定义的LOCAL_XXX变量都在”Module-description”节中列出。 你必须在开始一个新模块之前包含这个脚本。 1include $(CLEAR_VARS) 1BUILD_SHARED_LIBRARY 指向编译脚本，收集所有的你在LOCAL_XXX变量中提供的信息，并且决定如何把你列出的源代码文件编译成一个共享库。注意，你必须至少在包含这个文件之前定义LOCAL_MODULE和LOCAL_SRC_FILES，使用例子： 1include $(BUILD_SHARED_LIBRARY) 注意这将生成一个名为lib$(LOCAL_MODULE).so的文件。 1BUILD_STATIC_LIBRARY 一个BUILD_SHARED_LIBRARY变量用于编译一个静态库。静态库不会复制到你的project/packages中，诞生能够用于编译共享库，（看下面描述的LOCAL_STATIC_LIBRARIES and LOCAL_STATIC_WHOLE_LIBRARIES） 使用例子： 1include $(BUILD_STATIC_LIBRARY) 注意，这将会生成一个名为lib$(LOCAL_MODULE).a的文件。 1TARGET_ARCH 目标CPU平台的名字，如同在android开放源码中指定的那样。如果是’arm’，表示要生成ARM兼容的指令，与CPU架构的修订版无关。 1TARGET_PLATFORM Android.mk解析的时候，目标Android平台的名字.详情可参考/development/ndk/docs/stable-apis.txt. android-3 -&gt; Official Android 1.5 system images android-4 -&gt; Official Android 1.6 system images android-5 -&gt; Official Android 2.0 system images 1TARGET_ARCH_ABI 暂时只支持两个value，armeabi和armeabi-v7a。在现在的版本中一般把这两个值简单的定义为arm，通过android 平台内部对它重定义来获得更好的匹配。 其他的ＡＢＩ将在以后的ＮＤＫ版本中介绍，它们会有不同的名字。注意所有基于ＡＲＭ的ＡＢＩ都会把’TARGET_ARCH’定义成‘ａｒｍ’，但是会有不同的‘TARGET_ARCH_ABI’ 1TARGET_ABI 目标平台和ABI的组合，它事实上被定义成$(TARGET_PLATFORM)-$(TARGET_ARCH_ABI) 在你想要在真实的设备中针对一个特别的目标系统进行测试时，会有用。在默认的情况下，它会是’android-3-arm’。 /*/ 下面是GNU Make ‘功能’宏，必须通过使用’$(call )’来求值，他们返回文本化的信息。 1my-dir 返回当前Android.mk所在的目录路径，相对于ＮＤＫ编译系统的顶层。这是有用的，在Android.mk文件的开头如此定义： 1LOCAL_PATH := $(call my-dir) 1all-subdir-makefiles 返回一个位于当前’my-dir’路径的子目录列表。例如，看下面的目录层次： 12345sources/foo/Android.mksources/foo/lib1/Android.mksources/foo/lib2/Android.mk 如果sources/foo/Android.mk包含一行： 1include $(call all-subdir-makefiles) 那么它就会自动包含sources/foo/lib1/Android.mk 和sources/foo/lib2/Android.mk 这项功能用于向编译系统提供深层次嵌套的代码目录层次。注意，在默认情况下，ＮＤＫ将会只搜索在sources/*/Android.mk中的文件。 1this-makefile 返回当前Makefile的路径（即这个函数调用的地方） 1parent-makefile 返回调用树中父Makefile路径。即包含当前Makefile的Makefile路径。 1grand-parent-makefile 猜猜看… /*/ 模块描述变量:下面的变量用于向编译系统描述你的模块。你应该定义在’include $(CLEAR_VARS)’和’include $(BUILD_XXXXX)’之间定义。正如前面描写的那样，$(CLEAR_VARS是一个脚本，清除所有这些变量，除非在描述中显式注明。 1LOCAL_PATH 这个变量用于给出当前文件的路径。你必须在Android.mk的开头定义，可以这样使用： 1LOCAL_PATH := $(call my-dir) 这个变量不会被$(CLEAR_VARS)清除，因此每个Android.mk只需要定义一次（即使你在一个文件中定义了几个模块的情况下）。 1LOCAL_MODULE 这是你模块的名字，它必须是唯一的，而且不能包含空格。你必须在包含任一的$(BUILD_XXXX)脚本之前定义它。模块的名字决定了生成文件的名字，例如，如果一个一个共享库模块的名字是，那么生成文件的名字就是lib.so。但是，在你的NDK生成文件中（或者Android.mk或者Application.mk），你应该只涉及(引用)有正常名字的其他模块。 1LOCAL_SRC_FILES 这是要编译的源代码文件列表。只要列出要传递给编译器的文件，因为编译系统自动为你计算依赖。 注意源代码文件名称都是相对于LOCAL_PATH的，你可以使用路径部分，例如： 1LOCAL_SRC_FILES := foo.c \\ toto/bar.c注意：在生成文件中都要使用UNIX风格的斜杠(/).windows风格的反斜杠不会被正确的处理。 1LOCAL_CPP_EXTENSION 这是一个可选变量，用来指定C++代码文件的扩展名，默认是’.cpp’,但是你可以改变它，比如： 1LOCAL_CPP_EXTENSION := .cxx 1LOCAL_C_INCLUDES 路径的可选配置，是从根目录开始的， 123456789all sources (C, C++ and Assembly). For example: LOCAL_C_INCLUDES := sources/foo Or even: LOCAL_C_INCLUDES := $(LOCAL_PATH)/../foo 需要在任何包含LOCAL_CFLAGS / LOCAL_CPPFLAGS标志之前。 1LOCAL_CFLAGS 可选的编译器选项，在编译C代码文件的时候使用。 这可能是有用的，指定一个附加的包含路径（相对于NDK的顶层目录），宏定义，或者编译选项。 重要信息：不要在Android.mk中改变optimization/debugging级别，只要在Application.mk中指定合适的信息，就会自动地为你处理这个问题，在调试期间，会让ＮＤＫ自动生成有用的数据文件。 123LOCAL_CXXFLAGSSame as LOCAL_CFLAGS for C++ source files 1LOCAL_CPPFLAGS 与LOCAL_CFLAGS相同，但是对C 和 C++ source files都适用。 1LOCAL_STATIC_LIBRARIES 应该链接到这个模块的静态库列表（使用BUILD_STATIC_LIBRARY生成），这仅仅对共享库模块才有意义。 1LOCAL_SHARED_LIBRARIES 这个模块在运行时要依赖的共享库模块列表，在链接时需要，在生成文件时嵌入的相应的信息。注意：这不会附加列出的模块到编译图，也就是，你仍然需要在Application.mk中把它们添加到程序要求的模块中。 1LOCAL_LDLIBS 编译你的模块要使用的附加的链接器选项。这对于使用”-l”前缀传递指定库的名字是有用的。例如，下面将告诉链接器生成的模块要在加载时刻链接到/system/lib/libz.so 1LOCAL_LDLIBS := -lz 看docs/STABLE-APIS.TXT获取你使用NDK发行版能链接到的开放的系统库列表。 1LOCAL_ALLOW_UNDEFINED_SYMBOLS 默认情况下，在试图编译一个共享库时，任何未定义的引用将导致一个“未定义的符号”错误。这对于在你的源代码文件中捕捉错误会有很大的帮助。 然而，如果你因为某些原因，需要不启动这项检查，把这个变量设为‘ｔｒｕｅ’。注意相应的共享库可能在运行时加载失败。（这个一般尽量不要去设为true） 1LOCAL_ARM_MODE 默认情况下，arm目标二进制会以thumb的形式生成（16位），你可以通过设置这个变量为arm如果你希望你的module是以32位指令的形式。 &apos;arm&apos; (32-bit instructions) mode. E.g.: LOCAL_ARM_MODE := arm 注意你同样可以在编译的时候告诉系统编译特定的类型，比如 LOCAL_SRC_FILES := foo.c bar.c.arm 这样就告诉系统总是将bar.c以arm的模式编译， Android.mk使用模板在一个Android.mk中可以生成多个可执行程序、动态库和静态库。 1，编译应用程序的模板：#Test Exe LOCAL_PATH := $(call my-dir) #include $(CLEAR_VARS) LOCAL_SRC_FILES:= main.c LOCAL_MODULE:= test_exe #LOCAL_C_INCLUDES := #LOCAL_STATIC_LIBRARIES := #LOCAL_SHARED_LIBRARIES := include $(BUILD_EXECUTABLE) （菜鸟级别解释：:=是赋值的意思，$是引用某变量的值）LOCAL_SRC_FILES中加入源文件路径，LOCAL_C_INCLUDES 中加入所需要包含的头文件路径，LOCAL_STATIC_LIBRARIES加入所需要链接的静态库（.a）的名称，LOCAL_SHARED_LIBRARIES中加入所需要链接的动态库（.so）的名称，LOCAL_MODULE表示模块最终的名称，BUILD_EXECUTABLE表示以一个可执行程序的方式进行编译。 2，编译静态库的模板：#Test Static Lib LOCAL_PATH := $(call my-dir) include $(CLEAR_VARS) LOCAL_SRC_FILES:= \\ helloworld.c LOCAL_MODULE:= libtest_static #LOCAL_C_INCLUDES := #LOCAL_STATIC_LIBRARIES := #LOCAL_SHARED_LIBRARIES := include $(BUILD_STATIC_LIBRARY) 一般的和上面相似，BUILD_STATIC_LIBRARY表示编译一个静态库。 3，编译动态库的模板：#Test Shared Lib LOCAL_PATH := $(call my-dir) include $(CLEAR_VARS) LOCAL_SRC_FILES:= \\ helloworld.c LOCAL_MODULE:= libtest_shared TARGET_PRELINK_MODULES := false #LOCAL_C_INCLUDES := #LOCAL_STATIC_LIBRARIES := #LOCAL_SHARED_LIBRARIES := include $(BUILD_SHARED_LIBRARY) 一般的和上面相似，BUILD_SHARED_LIBRARY表示编译一个共享库。 以上三者的生成结果分别在如下，generic依具体target会变： 12345out/target/product/generic/obj/EXECUTABLEout/target/product/generic/obj/STATIC_LIBRARYout/target/product/generic/obj/SHARED_LIBRARY 每个模块的目标文件夹分别为： 12345可执行程序：XXX_intermediates静态库： XXX_static_intermediates动态库： XXX_shared_intermediates 另外，在Android.mk文件中，还可以指定最后的目标安装路径，用LOCAL_MODULE_PATH和LOCAL_UNSTRIPPED_PATH来指定。不同的文件系统路径用以下的宏进行选择： 12345TARGET_ROOT_OUT：表示根文件系统。TARGET_OUT：表示system文件系统。TARGET_OUT_DATA：表示data文件系统。 用法如： 1LOCAL_MODULE_PATH:=$(TARGET_ROOT_OUT)","categories":[{"name":"AOSP","slug":"AOSP","permalink":"http://wenyiqingnian.xyz/categories/AOSP/"}],"tags":[{"name":"编译","slug":"编译","permalink":"http://wenyiqingnian.xyz/tags/编译/"},{"name":"mk","slug":"mk","permalink":"http://wenyiqingnian.xyz/tags/mk/"}]},{"title":"Binder通讯机制","slug":"Binder 进程间通讯机制","date":"2017-04-11T11:20:50.000Z","updated":"2018-05-24T03:48:32.972Z","comments":true,"path":"2017/04/11/Binder 进程间通讯机制/","link":"","permalink":"http://wenyiqingnian.xyz/2017/04/11/Binder 进程间通讯机制/","excerpt":"","text":"什么是Binder？Binder是Android系统中进程间通讯（IPC）的一种方式，也是Android系统中最重要的特性之一。Android中的四大组件Activity，Service，Broadcast，ContentProvider，不同的App等都运行在不同的进程中，它是这些进程间通讯的桥梁。正如其名“粘合剂”一样，它把系统中各个组件粘合到了一起，是各个组件的桥梁。 理解Binder对于理解整个Android系统有着非常重要的作用，如果对Binder不了解，就很难对Android系统机制有更深入的理解。 1. Binder架构 Binder 通信采用 C/S 架构，从组件视角来说，包含 Client、 Server、 ServiceManager 以及 Binder 驱动，其中 ServiceManager 用于管理系统中的各种服务。 Binder 在 framework 层进行了封装，通过 JNI 技术调用 Native（C/C++）层的 Binder 架构。 Binder 在 Native 层以 ioctl 的方式与 Binder 驱动通讯。 2.Binder机制 首先需要注册服务端，只有注册了服务端，客户端才有通讯的目标，服务端通过 ServiceManager 注册服务，注册的过程就是向 Binder 驱动的全局链表 binder_procs 中插入服务端的信息（binder_proc 结构体，每个 binder_proc 结构体中都有 todo 任务队列），然后向 ServiceManager 的 svcinfo 列表中缓存一下注册的服务。 有了服务端，客户端就可以跟服务端通讯了，通讯之前需要先获取到服务，拿到服务的代理，也可以理解为引用。比如下面的代码： 121//获取WindowManager服务引用2 WindowManager wm = (WindowManager)getSystemService(getApplication().WINDOW_SERVICE); 获取服务端的方式就是通过 ServiceManager 向 svcinfo 列表中查询一下返回服务端的代理，svcinfo 列表就是所有已注册服务的通讯录，保存了所有注册的服务信息。 有了服务端的引用我们就可以向服务端发送请求了，通过 BinderProxy 将我们的请求参数发送给 ServiceManager，通过共享内存的方式使用内核方法 copy_from_user() 将我们的参数先拷贝到内核空间，这时我们的客户端进入等待状态，然后 Binder 驱动向服务端的 todo 队列里面插入一条事务，执行完之后把执行结果通过 copy_to_user() 将内核的结果拷贝到用户空间（这里只是执行了拷贝命令，并没有拷贝数据，binder只进行一次拷贝），唤醒等待的客户端并把结果响应回来，这样就完成了一次通讯。 怎么样是不是很简单，以上就是 Binder 机制的主要通讯方式，下面我们来看看具体实现。 3.Binder驱动我们先来了解下用户空间与内核空间是怎么交互的。 先了解一些概念 用户空间/内核空间详细解释可以参考 Kernel Space Definition； 简单理解如下： Kernel space 是 Linux 内核的运行空间，User space 是用户程序的运行空间。 为了安全，它们是隔离的，即使用户的程序崩溃了，内核也不受影响。 Kernel space 可以执行任意命令，调用系统的一切资源； User space 只能执行简单的运算，不能直接调用系统资源，必须通过系统接口（又称 system call），才能向内核发出指令。 系统调用/内核态/用户态虽然从逻辑上抽离出用户空间和内核空间；但是不可避免的的是，总有那么一些用户空间需要访问内核的资源；比如应用程序访问文件，网络是很常见的事情，怎么办呢？ Kernel space can be accessed by user processes only through the use of system calls. 用户空间访问内核空间的唯一方式就是系统调用；通过这个统一入口接口，所有的资源访问都是在内核的控制下执行，以免导致对用户程序对系统资源的越权访问，从而保障了系统的安全和稳定。用户软件良莠不齐，要是它们乱搞把系统玩坏了怎么办？因此对于某些特权操作必须交给安全可靠的内核来执行。 当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）此时处理器处于特权级最高的（0级）内核代码中执行。当进程在执行用户自己的代码时，则称其处于用户运行态（用户态）。即此时处理器在特权级最低的（3级）用户代码中运行。处理器在特权等级高的时候才能执行那些特权CPU指令。 内核模块/驱动通过系统调用，用户空间可以访问内核空间，那么如果一个用户空间想与另外一个用户空间进行通信怎么办呢？很自然想到的是让操作系统内核添加支持；传统的 Linux 通信机制，比如 Socket，管道等都是内核支持的；但是 Binder 并不是 Linux 内核的一部分，它是怎么做到访问内核空间的呢？ Linux 的动态可加载内核模块（Loadable Kernel Module，LKM）机制解决了这个问题；模块是具有独立功能的程序，它可以被单独编译，但不能独立运行。它在运行时被链接到内核作为内核的一部分在内核空间运行。这样，Android系统可以通过添加一个内核模块运行在内核空间，用户进程之间的通过这个模块作为桥梁，就可以完成通信了。 在 Android 系统中，这个运行在内核空间的，负责各个用户进程通过 Binder 通信的内核模块叫做 Binder 驱动; 驱动程序一般指的是设备驱动程序（Device Driver），是一种可以使计算机和设备通信的特殊程序。相当于硬件的接口，操作系统只有通过这个接口，才能控制硬件设备的工作； 驱动就是操作硬件的接口，为了支持Binder通信过程，Binder 使用了一种“硬件”，因此这个模块被称之为驱动。 熟悉了上面这些概念，我们再来看下上面的图，用户空间中 binder_open(), binder_mmap(), binder_ioctl() 这些方法通过 system call 来调用内核空间 Binder 驱动中的方法。内核空间与用户空间共享内存通过 copy_from_user(), copy_to_user() 内核方法来完成用户空间与内核空间内存的数据传输。 Binder驱动中有一个全局的 binder_procs 链表保存了服务端的进程信息。 4. Binder 进程与线程 对于底层Binder驱动，通过 binder_procs 链表记录所有创建的 binder_proc 结构体，binder 驱动层的每一个 binder_proc 结构体都与用户空间的一个用于 binder 通信的进程一一对应，且每个进程有且只有一个 ProcessState 对象，这是通过单例模式来保证的。在每个进程中可以有很多个线程，每个线程对应一个 IPCThreadState 对象，IPCThreadState 对象也是单例模式，即一个线程对应一个 IPCThreadState 对象，在 Binder 驱动层也有与之相对应的结构，那就是 Binder_thread 结构体。在 binder_proc 结构体中通过成员变量 rb_root threads，来记录当前进程内所有的 binder_thread。 Binder 线程池：每个 Server 进程在启动时创建一个 binder 线程池，并向其中注册一个 Binder 线程；之后 Server 进程也可以向 binder 线程池注册新的线程，或者 Binder 驱动在探测到没有空闲 binder 线程时主动向 Server 进程注册新的的 binder 线程。对于一个 Server 进程有一个最大 Binder 线程数限制，默认为16个 binder 线程，例如 Android 的 system_server 进程就存在16个线程。对于所有 Client 端进程的 binder 请求都是交由 Server 端进程的 binder 线程来处理的。 5. ServiceManager 启动了解了 Binder 驱动，怎么与 Binder 驱动进行通讯呢？那就是通过 ServiceManager，好多文章称 ServiceManager 是 Binder 驱动的守护进程，大管家，其实 ServiceManager 的作用很简单就是提供了查询服务和注册服务的功能。下面我们来看一下 ServiceManager 启动的过程。 ServiceManager 分为 framework 层和 native 层，framework 层只是对 native 层进行了封装方便调用，图上展示的是 native 层的 ServiceManager 启动过程。 ServiceManager 的启动是系统在开机时，init 进程解析 init.rc 文件调用 service_manager.c 中的 main() 方法入口启动的。 native 层有一个 binder.c 封装了一些与 Binder 驱动交互的方法。 ServiceManager 的启动分为三步，首先打开驱动创建全局链表 binder_procs，然后将自己当前进程信息保存到 binder_procs 链表，最后开启 loop 不断的处理共享内存中的数据，并处理 BR_xxx 命令（ioctl 的命令，BR 可以理解为 binder reply 驱动处理完的响应）。 6. ServiceManager 注册服务 注册 MediaPlayerService 服务端，我们通过 ServiceManager 的 addService() 方法来注册服务。 首先 ServiceManager 向 Binder 驱动发送 BC_TRANSACTION 命令（ioctl 的命令，BC 可以理解为 binder client 客户端发过来的请求命令）携带 ADD_SERVICE_TRANSACTION 命令，同时注册服务的线程进入等待状态 waitForResponse()。 Binder 驱动收到请求命令向 ServiceManager 的 todo 队列里面添加一条注册服务的事务。事务的任务就是创建服务端进程 binder_node 信息并插入到 binder_procs 链表中。 事务处理完之后发送 BR_TRANSACTION 命令，ServiceManager 收到命令后向 svcinfo 列表中添加已经注册的服务。最后发送 BR_REPLY 命令唤醒等待的线程，通知注册成功。 7. ServiceManager 获取服务 获取服务的过程与注册类似，相反的过程。通过 ServiceManager 的 getService() 方法来注册服务。 首先 ServiceManager 向 Binder 驱动发送 BC_TRANSACTION 命令携带 CHECK_SERVICE_TRANSACTION 命令，同时获取服务的线程进入等待状态 waitForResponse()。 Binder 驱动收到请求命令向 ServiceManager 的发送 BC_TRANSACTION 查询已注册的服务，查询到直接响应 BR_REPLY 唤醒等待的线程。若查询不到将与 binder_procs 链表中的服务进行一次通讯再响应。 8. 进行一次完整通讯 我们在使用 Binder 时基本都是调用 framework 层封装好的方法，AIDL 就是 framework 层提供的傻瓜式是使用方式。假设服务已经注册完，我们来看看客户端怎么执行服务端的方法。 首先我们通过 ServiceManager 获取到服务端的 BinderProxy 代理对象，通过调用 BinderProxy 将参数，方法标识（例如：TRANSACTION_test，AIDL中自动生成）传给 ServiceManager，同时客户端线程进入等待状态。 ServiceManager 将用户空间的参数等请求数据复制到内核空间，并向服务端插入一条执行执行方法的事务。事务执行完通知 ServiceManager 将执行结果从内核空间复制到用户空间，并唤醒等待的线程，响应结果，通讯结束。 总结好了，这里只是从实现逻辑上简单介绍了下 Binder 机制的工作原理，想要深入理解 Binder 机制，还得自己下功夫，看源码，尽管这个过程很痛苦。一遍看不懂就再来一遍，说实话本人理解能力比较差，跟着博客思路看了不下十遍。努力总会有收获，好好欣赏 native 层各方法之间花式跳转的魅力吧。最后你将发现新世界的大门在向你敞开。 网上资料很多，个人觉得比较好的如下： Bander设计与实现 老罗的 Android进程间通信（IPC）机制Binder简要介绍和学习计划 系列 Innost的 深入理解Binder 系列 Gityuan的 Binder系列 (基于 Android 6.0)5. Binder学习指南","categories":[{"name":"Android","slug":"Android","permalink":"http://wenyiqingnian.xyz/categories/Android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://wenyiqingnian.xyz/tags/android/"},{"name":"Binder","slug":"Binder","permalink":"http://wenyiqingnian.xyz/tags/Binder/"}]},{"title":"编译系统环境初始化过程","slug":"编译系统环境初始化过程","date":"2017-04-05T07:10:25.000Z","updated":"2018-05-06T14:15:45.308Z","comments":true,"path":"2017/04/05/编译系统环境初始化过程/","link":"","permalink":"http://wenyiqingnian.xyz/2017/04/05/编译系统环境初始化过程/","excerpt":"","text":"对Android编译环境进行初始化很简单，分为两步。 第一步是打开一个终端，并且将build/envsetup.sh加载到该终端中：123456789101112131415$ . ./build/envsetup.sh including device/asus/grouper/vendorsetup.sh including device/asus/tilapia/vendorsetup.sh including device/generic/armv7-a-neon/vendorsetup.sh including device/generic/armv7-a/vendorsetup.sh including device/generic/mips/vendorsetup.sh including device/generic/x86/vendorsetup.sh including device/lge/mako/vendorsetup.sh including device/samsung/maguro/vendorsetup.sh including device/samsung/manta/vendorsetup.sh including device/samsung/toroplus/vendorsetup.sh including device/samsung/toro/vendorsetup.sh including device/ti/panda/vendorsetup.sh including sdk/bash_completion/adb.bash 从命令的输出可以知道，文件build/envsetup.sh在加载的过程中，又会在device目录中寻找那些名称为vendorsetup.sh的文件，并且也将它们加载到当前终端来。另外，在sdk/bash_completion目录下的adb.bash文件也会加载到当前终端来，它是用来实现adb命令的bash completion功能的。也就是说，加载了该文件之后，我们在运行adb相关的命令的时候，通过按tab键就可以帮助我们自动完成命令的输入。关于bash completion的知识，可以参考官方文档： http://www.gnu.org/s/bash/manual/bash.html#Programmable-Completion。 第二步是执行命令lunch，如下所示：1234567891011121314151617181920212223$ lunch You're building on Linux Lunch menu... pick a combo: 1. full-eng 2. full_x86-eng 3. vbox_x86-eng 4. full_mips-eng 5. full_grouper-userdebug 6. full_tilapia-userdebug 7. mini_armv7a_neon-userdebug 8. mini_armv7a-userdebug 9. mini_mips-userdebug 10. mini_x86-userdebug 11. full_mako-userdebug 12. full_maguro-userdebug 13. full_manta-userdebug 14. full_toroplus-userdebug 15. full_toro-userdebug 16. full_panda-userdebug Which would you like? [full-eng] 我们看到lunch命令输出了一个Lunch菜单，该菜单列出了当前Android源码支持的所有设备型号及其编译类型。例如，第一项“full-eng”表示的设备“full”即为模拟器，并且编译类型为“eng”即为工程机。当我们选定了一个Lunch菜单项序号(1-16)之后，按回车键，就可以完成Android编译环境的初始化过程。例如，我们选择1，可以看到以下输出： 12345678910111213141516171819[html] view plain copyWhich would you like? [full-eng] 1 ============================================ PLATFORM_VERSION_CODENAME=REL PLATFORM_VERSION=4.2 TARGET_PRODUCT=full TARGET_BUILD_VARIANT=eng TARGET_BUILD_TYPE=release TARGET_BUILD_APPS= TARGET_ARCH=arm TARGET_ARCH_VARIANT=armv7-a HOST_ARCH=x86 HOST_OS=linux HOST_OS_EXTRA=Linux-3.8.0-31-generic-x86_64-with-Ubuntu-13.04-raring HOST_BUILD_TYPE=release BUILD_ID=JOP40C OUT_DIR=out ============================================ 我们可以看到，lunch命令帮我们设置好了很多环境变量。通过设置这些环境变量，就配置好了Android编译环境。通过图1我们就可以直观地看到Android编译环境初始化完成后，我们所获得的东西： 图1 Android编译环境初始化完成之后 总体来说，Android编译环境初始化完成之后，获得了以下三样东西： 123451. 将vendor和device目录下的vendorsetup.sh文件加载到了当前终端；2. 新增了lunch、m、mm和mmm等命令；3. 通过执行lunch命令设置好了TARGET_PRODUCT、TARGET_BUILD_VARIANT、TARGET_BUILD_TYPE和TARGET_BUILD_APPS等环境变量。 接下来我们就主要分析build/envsetup.sh文件的加载过程以及lunch命令的执行过程。 一. 文件build/envsetup.sh的加载过程文件build/envsetup.sh是一个bash shell脚本，从它里面定义的函数hmm可以知道，它提供了lunch、m、mm和mmm等命令供我们初始化编译环境或者编译Android源码。 函数hmm的实现如下所示： 12345678910111213141516171819202122232425[plain] view plain copyfunction hmm() &#123; cat &lt;&lt;EOF Invoke &quot;. build/envsetup.sh&quot; from your shell to add the following functions to your environment: - lunch: lunch &lt;product_name&gt;-&lt;build_variant&gt; - tapas: tapas [&lt;App1&gt; &lt;App2&gt; ...] [arm|x86|mips] [eng|userdebug|user] - croot: Changes directory to the top of the tree. - m: Makes from the top of the tree. - mm: Builds all of the modules in the current directory. - mmm: Builds all of the modules in the supplied directories. - cgrep: Greps on all local C/C++ files. - jgrep: Greps on all local Java files. - resgrep: Greps on all local res/*.xml files. - godir: Go to the directory containing a file. Look at the source to view more functions. The complete list is: EOF T=$(gettop) local A A=&quot;&quot; for i in `cat $T/build/envsetup.sh | sed -n &quot;/^function /s/function [a−z]∗.*/\\1/p&quot; | sort`; do A=&quot;$A $i&quot; done echo $A &#125; 我们在当前终端中执行hmm命令即可以看到函数hmm的完整输出。函数hmm主要完成三个工作： 12345671. 调用另外一个函数gettop获得Android源码的根目录T。 2. 通过cat命令显示一个Here Document，说明$T/build/envsetup.sh文件加载到当前终端后所提供的主要命令。3. 通过sed命令解析$T/build/envsetup.sh文件，并且获得在里面定义的所有函数的名称，这些函数名称就是$T/build/envsetup.sh文件加载到当前终端后提供的所有命令。 注意，sed命令是一个强大的文本分析工具，它以行为单位为执行文本替换、删除、新增和选取等操作。函数hmm通过执行以下的sed命令来获得在$T/build/envsetup.sh文件定义的函数的名称： [plain] view plain copysed -n “/^function /s/function [a−z]∗.*/\\1/p” 它表示对所有以“function ”开头的行，如果紧接在“function ”后面的字符串仅由字母a-z和下横线(_)组成，那么就将这个字符串提取出来。这正好就对应于shell脚本里面函数的定义。 文件build/envsetup.sh除了定义一堆函数之外，还有一个重要的代码段，如下所示： 12345678[plain] view plain copy# Execute the contents of any vendorsetup.sh files we can find. for f in `/bin/ls vendor/*/vendorsetup.sh vendor/*/*/vendorsetup.sh device/*/*/vendorsetup.sh 2&gt; /dev/null` do echo &quot;including $f&quot; . $f done unset f 这个for循环遍历vendor目录下的一级子目录和二级子目录以及device目录下的二级子目录中的vendorsetup.sh文件，并且通过source命令(.)将它们加载当前终端来。vendor和device相应子目录下的vendorsetup.sh文件的实现很简单，它们主要就是添加相应的设备型号及其编译类型支持到Lunch菜单中去。 例如，device/samsung/maguro目录下的vendorsetup.sh文件的实现如下所示： 12[plain] view plain copyadd_lunch_combo full_maguro-userdebug 它调用函数add_lunch_combo添加一个名称为“full_maguro-userdebug”的菜单项到Lunch菜单去。函数add_lunch_combo定义在build/envsetup.sh文件中，它的实现如下所示： 123456789101112[plain] view plain copyfunction add_lunch_combo() &#123; local new_combo=$1 local c for c in $&#123;LUNCH_MENU_CHOICES[@]&#125; ; do if [ &quot;$new_combo&quot; = &quot;$c&quot; ] ; then return fi done LUNCH_MENU_CHOICES=($&#123;LUNCH_MENU_CHOICES[@]&#125; $new_combo) &#125; 传递给函数add_lunch_combo的参数保存在位置参数$1中，接着又保存在一个本地变量new_combo中，用来表示一个要即将要添加的Lunch菜单项。函数首先是在数组LUNCH_MENU_CHOICES中检查要添加的菜单项是否已经存在。只有在不存在的情况下，才会将它添加到数组LUNCH_MENU_CHOICES中去。注意，${LUNCH_MENU_CHOICES[@]}表示数组LUNCH_MENU_CHOICES的所有元素。数组LUNCH_MENU_CHOICES是定义在文件build/envsetup.sh的一个全局变量，当文件build/envsetup.sh被加载的时候，这个数组会被初始化为化full-eng、full_x86-eng、vbox_x86-eng和full_mips-eng，如下所示： 123456[plain] view plain copy# add the default one here add_lunch_combo full-eng add_lunch_combo full_x86-eng add_lunch_combo vbox_x86-eng add_lunch_combo full_mips-eng 这样当文件build/envsetup.sh加载完成之后，数组LUNCH_MENU_CHOICES就包含了当前源码支持的所有设备型号及其编译类型，于是当接下来我们执行lunch命令的时候，就可以通过数组LUNCH_MENU_CHOICES看到一个完整的Lunch藤蔓。 二. lunch命令的执行过程lunch命令实际上是定义在文件build/envsetup.sh的一个函数，它的实现如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273[plain] view plain copyfunction lunch() &#123; local answer if [ &quot;$1&quot; ] ; then answer=$1 else print_lunch_menu echo -n &quot;Which would you like? [full-eng] &quot; read answer fi local selection= if [ -z &quot;$answer&quot; ] then selection=full-eng elif (echo -n $answer | grep -q -e &quot;^[0-9][0-9]*$&quot;) then if [ $answer -le $&#123;#LUNCH_MENU_CHOICES[@]&#125; ] then selection=$&#123;LUNCH_MENU_CHOICES[$(($answer-1))]&#125; fi elif (echo -n $answer | grep -q -e &quot;^[^\\-][^\\-]*-[^\\-][^\\-]*$&quot;) then selection=$answer fi if [ -z &quot;$selection&quot; ] then echo echo &quot;Invalid lunch combo: $answer&quot; return 1 fi export TARGET_BUILD_APPS= local product=$(echo -n $selection | sed -e &quot;s/-.*$//&quot;) check_product $product if [ $? -ne 0 ] then echo echo &quot;** Don&apos;t have a product spec for: &apos;$product&apos;&quot; echo &quot;** Do you have the right repo manifest?&quot; product= fi local variant=$(echo -n $selection | sed -e &quot;s/^[^\\-]*-//&quot;) check_variant $variant if [ $? -ne 0 ] then echo echo &quot;** Invalid variant: &apos;$variant&apos;&quot; echo &quot;** Must be one of $&#123;VARIANT_CHOICES[@]&#125;&quot; variant= fi if [ -z &quot;$product&quot; -o -z &quot;$variant&quot; ] then echo return 1 fi export TARGET_PRODUCT=$product export TARGET_BUILD_VARIANT=$variant export TARGET_BUILD_TYPE=release echo set_stuff_for_environment printconfig &#125; 函数lunch的执行逻辑如下所示： 12345678910111. 检查是否带有参数，即位置参数$1是否等于空。如果不等于空的话，就表明带有参数，并且该参数是用来指定要编译的设备型号及其编译类型的。如果等于空的话，那么就调用另外一个函数print_lunch_menu来显示Lunch菜单项，并且通过调用read函数来等待用户输入。无论通过何种方式，最终变量answer的值就保存了用户所指定的备型号及其编译类型。 2. 对变量answer的值的合法性进行检查。如果等于空的话，就将它设置为默认值“full-eng”。如果不等于空的话，就分为三种情况考虑。第一种情况是值为数字，那么就需要确保该数字的大小不能超过Lunch菜单项的个数。在这种情况下，会将输入的数字索引到数组LUNCH_MENU_CHOICES中去，以便获得一个用来表示设备型号及其编译类型的文本。第二种情况是非数字文本，那么就需要确保该文本符合&lt;product&gt;-&lt;variant&gt;的形式，其中&lt;product&gt;表示设备型号，而&lt;variant&gt;表示编译类型 。第三种情况是除了前面两种情况之外的所有情况，这是非法的。经过合法性检查后，变量selection代表了用户所指定的备型号及其编译类型，如果它的值是非法的，即它的值等于空，那么函数lunch就不往下执行了。 3. 接下来是解析变量selection的值，也就是通过sed命令将它的&lt;product&gt;和&lt;variant&gt;值提取出来，并且分别保存在变量product和variant中。提取出来的product和variant值有可能是不合法的，因此需要进一步通过调用函数check_product和check_variant来检查。一旦检查失败，也就是函数check_product和check_variant的返回值$?等于非0，那么函数lunch就不往下执行了。 4. 通过以上合法性检查之后，就将变量product和variant的值保存在环境变量TARGET_PRODUCT和TARGET_BUILD_VARIANT中。此外，另外一个环境变量TARGET_BUILD_TYPE的值会被设置为&quot;release&quot;，表示此次编译是一个release版本的编译。另外，前面还有一个环境变量TARGET_BUILD_APPS，它的值被函数lunch设置为空，用来表示此次编译是对整个系统进行编译。如果环境变量TARGET_BUILD_APPS的值不等于空，那么就表示此次编译是只对某些APP模块进行编译，而这些APP模块就是由环境变量TARGET_BUILD_APPS来指定的。 5. 调用函数set_stuff_for_environment来配置环境，例如设置Java SDK路径和交叉编译工具路径等。 6. 调用函数printfconfig来显示已经配置好的编译环境参数。 在上述执行过程中，函数check_product、check_variant和printconfig是比较关键的，因此接下来我们就继续分析它们的实现。 函数check_product定义在文件build/envsetup.sh中，它的实现如下所示： 1234567891011121314151617[plain] view plain copy# check to see if the supplied product is one we can build function check_product() &#123; T=$(gettop) if [ ! &quot;$T&quot; ]; then echo &quot;Couldn&apos;t locate the top of the tree. Try setting TOP.&quot; &gt;&amp;2 return fi CALLED_FROM_SETUP=true BUILD_SYSTEM=build/core \\ TARGET_PRODUCT=$1 \\ TARGET_BUILD_VARIANT= \\ TARGET_BUILD_TYPE= \\ TARGET_BUILD_APPS= \\ get_build_var TARGET_DEVICE &gt; /dev/null # hide successful answers, but allow the errors to show &#125; 函数gettop用来返回Android源代码工程的根目录。函数check_product需要在Android源代码工程根目录或者子目录下调用。否则的话，函数check_product就出错返回。 接下来函数check_product设置几个环境变量，其中最重要的是前面三个CALLED_FROM_SETUP、BUILD_SYSTEM和TARGET_PRODUCT。环境变量CALLED_FROM_SETUP的值等于true表示接下来执行的make命令是用来初始化Android编译环境的。环境变量BUILD_SYSTEM用来指定Android编译系统的核心目录，它的值被设置为build/core。环境变量TARGET_PRODUCT用来表示要检查的产品名称（也就是我们前面说的设备型号），它的值被设置为$1，即函数check_product的调用参数。 最后函数check_product调用函数get_build_var来检查由环境变量TARGET_PRODUCT指定的产品名称是否合法，注意，它的调用参数为TARGET_DEVICE。 函数get_build_var定义在文件build/envsetup.sh中，它的实现如下所示： 123456789101112[plain] view plain copy# Get the exact value of a build variable. function get_build_var() &#123; T=$(gettop) if [ ! &quot;$T&quot; ]; then echo &quot;Couldn&apos;t locate the top of the tree. Try setting TOP.&quot; &gt;&amp;2 return fi CALLED_FROM_SETUP=true BUILD_SYSTEM=build/core \\ make --no-print-directory -C &quot;$T&quot; -f build/core/config.mk dumpvar-$1 &#125; 这里就可以看到，函数get_build_var实际上就是通过make命令在Android源代码工程根目录中执行build/core/config.mk文件，并且将make目标设置为dumpvar-$1，也就是dumpvar-TARGET_DEVICE。 文件build/core/config.mk的内容比较多，这里我们只关注与产品名称合法性检查相关的逻辑，这些逻辑也基本上涵盖了Android编译系统初始化的逻辑，如下所示： 12345678910111213141516171819202122232425262728[plain] view plain copy...... # --------------------------------------------------------------- # Define most of the global variables. These are the ones that # are specific to the user&apos;s build configuration. include $(BUILD_SYSTEM)/envsetup.mk # Boards may be defined under $(SRC_TARGET_DIR)/board/$(TARGET_DEVICE) # or under vendor/*/$(TARGET_DEVICE). Search in both places, but # make sure only one exists. # Real boards should always be associated with an OEM vendor. board_config_mk := \\ $(strip $(wildcard \\ $(SRC_TARGET_DIR)/board/$(TARGET_DEVICE)/BoardConfig.mk \\ device/*/$(TARGET_DEVICE)/BoardConfig.mk \\ vendor/*/$(TARGET_DEVICE)/BoardConfig.mk \\ )) ifeq ($(board_config_mk),) $(error No config file found for TARGET_DEVICE $(TARGET_DEVICE)) endif ifneq ($(words $(board_config_mk)),1) $(error Multiple board config files for TARGET_DEVICE $(TARGET_DEVICE): $(board_config_mk)) endif include $(board_config_mk) ......include $(BUILD_SYSTEM)/dumpvar.mk 上述代码主要就是将envsetup.mk、BoardConfig,mk和dumpvar.mk三个Makefile片段文件加载进来。其中，envsetup.mk文件位于$(BUILD_SYSTEM)目录中，也就是build/core目录中，BoardConfig.mk文件的位置主要就是由环境变量TARGET_DEVICE来确定，它是用来描述目标产品的硬件模块信息的，例如CPU体系结构。环境变量TARGET_DEVICE用来描述目标设备，它的值是在envsetup.mk文件加载的过程中确定的。一旦目标设备确定后，就可以在$(SRC_TARGET_DIR)/board/$(TARGET_DEVICE)、device//$(TARGET_DEVICE)和vendor//$(TARGET_DEVICE)目录中找到对应的BoradConfig.mk文件。注意，变量SRC_TARGET_DIR的值等于build/target。最后，dumpvar.mk文件也是位于build/core目录中，它用来打印已经配置好的编译环境信息。 接下来我们就通过进入到build/core/envsetup.mk文件来分析变量TARGET_DEVICE的值是如何确定的： [plain] view plain copy Read the product specs so we an get TARGET_DEVICE and othervariables that we need in order to locate the output files.include $(BUILD_SYSTEM)/product_config.mk 它通过加载另外一个文件build/core/product_config.mk文件来确定变量TARGET_DEVICE以及其它与目标产品相关的变量的值。 文件build/core/product_config.mk的内容很多，这里我们只关注变量TARGET_DEVICE设置相关的逻辑，如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667[plain] view plain copy...... ifneq ($(strip $(TARGET_BUILD_APPS)),) # An unbundled app build needs only the core product makefiles. all_product_configs := $(call get-product-makefiles,\\ $(SRC_TARGET_DIR)/product/AndroidProducts.mk) else # Read in all of the product definitions specified by the AndroidProducts.mk # files in the tree. all_product_configs := $(get-all-product-makefiles) endif # all_product_configs consists items like: # &lt;product_name&gt;:&lt;path_to_the_product_makefile&gt; # or just &lt;path_to_the_product_makefile&gt; in case the product name is the # same as the base filename of the product config makefile. current_product_makefile := all_product_makefiles := $(foreach f, $(all_product_configs),\\ $(eval _cpm_words := $(subst :,$(space),$(f)))\\ $(eval _cpm_word1 := $(word 1,$(_cpm_words)))\\ $(eval _cpm_word2 := $(word 2,$(_cpm_words)))\\ $(if $(_cpm_word2),\\ $(eval all_product_makefiles += $(_cpm_word2))\\ $(if $(filter $(TARGET_PRODUCT),$(_cpm_word1)),\\ $(eval current_product_makefile += $(_cpm_word2)),),\\ $(eval all_product_makefiles += $(f))\\ $(if $(filter $(TARGET_PRODUCT),$(basename $(notdir $(f)))),\\ $(eval current_product_makefile += $(f)),))) _cpm_words := _cpm_word1 := _cpm_word2 := current_product_makefile := $(strip $(current_product_makefile)) all_product_makefiles := $(strip $(all_product_makefiles)) ifneq (,$(filter product-graph dump-products, $(MAKECMDGOALS))) # Import all product makefiles. $(call import-products, $(all_product_makefiles)) else # Import just the current product. ifndef current_product_makefile $(error Cannot locate config makefile for product &quot;$(TARGET_PRODUCT)&quot;) endif ifneq (1,$(words $(current_product_makefile))) $(error Product &quot;$(TARGET_PRODUCT)&quot; ambiguous: matches $(current_product_makefile)) endif $(call import-products, $(current_product_makefile)) endif # Import all or just the current product makefile ...... # Convert a short name like &quot;sooner&quot; into the path to the product # file defining that product. # INTERNAL_PRODUCT := $(call resolve-short-product-name, $(TARGET_PRODUCT)) ifneq ($(current_product_makefile),$(INTERNAL_PRODUCT)) $(error PRODUCT_NAME inconsistent in $(current_product_makefile) and $(INTERNAL_PRODUCT)) endif current_product_makefile := all_product_makefiles := all_product_configs := # Find the device that this product maps to. TARGET_DEVICE := $(PRODUCTS.$(INTERNAL_PRODUCT).PRODUCT_DEVICE) ...... 上述代码的执行逻辑如下所示： 1234567891. 检查环境变量TARGET_BUILD_APPS的值是否等于空。如果不等于空，那么就说明此次编译不是针对整个系统，因此只要将核心的产品相关的Makefile文件加载进来就行了，否则的话，就要将所有与产品相关的Makefile文件加载进来的。核心产品Makefile文件在$(SRC_TARGET_DIR)/product/AndroidProducts.mk文件中指定，也就是在build/target/product/AndroidProducts.mk文件，通过调用函数get-product-makefiles可以获得。所有与产品相关的Makefile文件可以通过另外一个函数get-all-product-makefiles获得。无论如何，最终获得的产品Makefie文件列表保存在变量all_product_configs中。 2. 遍历变量all_product_configs所描述的产品Makefile列表，并且在这些Makefile文件中，找到名称与环境变量TARGET_PRODUCT的值相同的文件，保存在另外一个变量current_product_makefile中，作为需要为当前指定的产品所加载的Makefile文件列表。在这个过程当中，上一步找到的所有的产品Makefile文件也会保存在变量all_product_makefiles中。注意，环境变量TARGET_PRODUCT的值是在我们执行lunch命令的时候设置并且传递进来的。 3. 如果指定的make目标等于product-graph或者dump-products，那么就将所有的产品相关的Makefile文件加载进来，否则的话，只加载与目标产品相关的Makefile文件。从前面的分析可以知道，此时的make目标为dumpvar-TARGET_DEVICE，因此接下来只会加载与目标产品，即$(TARGET_PRODUCT)，相关的Makefile文件，这是通过调用另外一个函数import-products实现的。 4. 调用函数resolve-short-product-name解析环境变量TARGET_PRODUCT的值，将它变成一个Makefile文件路径。并且保存在变量INTERNAL_PRODUCT中。这里要求变量INTERNAL_PRODUCT和current_product_makefile的值相等，否则的话，就说明用户指定了一个非法的产品名称。 5. 找到一个名称为PRODUCTS.$(INTERNAL_PRODUCT).PRODUCT_DEVICE的变量，并且将它的值保存另外一个变量TARGET_DEVICE中。变量PRODUCTS.$(INTERNAL_PRODUCT).PRODUCT_DEVICE是在加载产品Makefile文件的过程中定义的，用来描述当前指定的产品的名称。 上述过程主要涉及到了get-all-product-makefiles、import-products和resolve-short-product-name三个关键函数，理解它们的执行过程对理解Android编译系统的初始化过程很有帮助，接下来我们分别分析它们的实现。 函数get-all-product-makefiles定义在文件build/core/product.mk中，如下所示： 123456789[plain] view plain copy# # Returns the sorted concatenation of all PRODUCT_MAKEFILES # variables set in all AndroidProducts.mk files. # $(call ) isn&apos;t necessary. # define get-all-product-makefiles $(call get-product-makefiles,$(_find-android-products-files)) endef 它首先是调用函数_find-android-products-files来找到Android源代码目录中定义的所有AndroidProducts.mk文件，然后再调用函数get-product-makefiles获得在这里AndroidProducts.mk文件里面定义的产品Makefile文件。 函数_find-android-products-files也是定义在文件build/core/product.mk中，如下所示： 12345678910111213141516171819202122232425262728293031[plain] view plain copy# # Returns the list of all AndroidProducts.mk files. # $(call ) isn&apos;t necessary. # define _find-android-products-files $(shell test -d device &amp;&amp; find device -maxdepth 6 -name AndroidProducts.mk) \\ $(shell test -d vendor &amp;&amp; find vendor -maxdepth 6 -name AndroidProducts.mk) \\ $(SRC_TARGET_DIR)/product/AndroidProducts.mk endef 从这里就可以看出，Android源代码目录中定义的所有AndroidProducts.mk文件位于device、vendor或者build/target/product目录或者相应的子目录（最深是6层）中。 函数get-product-makefiles也是定义在文件build/core/product.mk中，如下所示：[plain] view plain copy# # Returns the sorted concatenation of PRODUCT_MAKEFILES # variables set in the given AndroidProducts.mk files. # $(1): the list of AndroidProducts.mk files. # define get-product-makefiles $(sort \\ $(foreach f,$(1), \\ $(eval PRODUCT_MAKEFILES :=) \\ $(eval LOCAL_DIR := $(patsubst %/,%,$(dir $(f)))) \\ $(eval include $(f)) \\ $(PRODUCT_MAKEFILES) \\ ) \\ $(eval PRODUCT_MAKEFILES :=) \\ $(eval LOCAL_DIR :=) \\ ) endef 这个函数实际上就是遍历参数$1所描述的AndroidProucts.mk文件列表，并且将定义在这些AndroidProucts.mk文件中的变量PRODUCT_MAKEFILES的值提取出来，形成一个列表返回给调用者。 例如，在build/target/product/AndroidProducts.mk文件中，变量PRODUCT_MAKEFILES的值如下所示： 12345678910111213141516171819202122[plain] view plain copy# Unbundled apps will be built with the most generic product config. ifneq ($(TARGET_BUILD_APPS),) PRODUCT_MAKEFILES := \\ $(LOCAL_DIR)/full.mk \\ $(LOCAL_DIR)/full_x86.mk \\ $(LOCAL_DIR)/full_mips.mk else PRODUCT_MAKEFILES := \\ $(LOCAL_DIR)/core.mk \\ $(LOCAL_DIR)/generic.mk \\ $(LOCAL_DIR)/generic_x86.mk \\ $(LOCAL_DIR)/generic_mips.mk \\ $(LOCAL_DIR)/full.mk \\ $(LOCAL_DIR)/full_x86.mk \\ $(LOCAL_DIR)/full_mips.mk \\ $(LOCAL_DIR)/vbox_x86.mk \\ $(LOCAL_DIR)/sdk.mk \\ $(LOCAL_DIR)/sdk_x86.mk \\ $(LOCAL_DIR)/sdk_mips.mk \\ $(LOCAL_DIR)/large_emu_hw.mk endif 里列出的每一个文件都对应于一个产品。 我们再来看函数import-products的实现，它定义在文件build/core/product.mk中，如下所示： 12345678[plain] view plain copy# # $(1): product makefile list # #TODO: check to make sure that products have all the necessary vars defined define import-products $(call import-nodes,PRODUCTS,$(1),$(_product_var_list)) endef 它调用另外一个函数import-nodes来加载由参数$1所指定的产品Makefile文件，并且指定了另外两个参数PRODUCTS和$(_product_var_list)。其中，变量_product_var_list也是定义在文件build/core/product.mk中，它的值如下所示： 123456789101112131415161718192021222324252627282930313233[plain] view plain copy_product_var_list := \\ PRODUCT_NAME \\ PRODUCT_MODEL \\ PRODUCT_LOCALES \\ PRODUCT_AAPT_CONFIG \\ PRODUCT_AAPT_PREF_CONFIG \\ PRODUCT_PACKAGES \\ PRODUCT_PACKAGES_DEBUG \\ PRODUCT_PACKAGES_ENG \\ PRODUCT_PACKAGES_TESTS \\ PRODUCT_DEVICE \\ PRODUCT_MANUFACTURER \\ PRODUCT_BRAND \\ PRODUCT_PROPERTY_OVERRIDES \\ PRODUCT_DEFAULT_PROPERTY_OVERRIDES \\ PRODUCT_CHARACTERISTICS \\ PRODUCT_COPY_FILES \\ PRODUCT_OTA_PUBLIC_KEYS \\ PRODUCT_EXTRA_RECOVERY_KEYS \\ PRODUCT_PACKAGE_OVERLAYS \\ DEVICE_PACKAGE_OVERLAYS \\ PRODUCT_TAGS \\ PRODUCT_SDK_ADDON_NAME \\ PRODUCT_SDK_ADDON_COPY_FILES \\ PRODUCT_SDK_ADDON_COPY_MODULES \\ PRODUCT_SDK_ADDON_DOC_MODULES \\ PRODUCT_DEFAULT_WIFI_CHANNELS \\ PRODUCT_DEFAULT_DEV_CERTIFICATE \\ PRODUCT_RESTRICT_VENDOR_FILES \\ PRODUCT_VENDOR_KERNEL_HEADERS \\ PRODUCT_FACTORY_RAMDISK_MODULES \\ PRODUCT_FACTORY_BUNDLE_MODULES 它描述的是在产品Makefile文件中定义在各种变量。 函数import-nodes定义在文件build/core/node_fns.mk中，如下所示： 12345678910111213141516171819202122[plain] view plain copy# # $(1): output list variable name, like &quot;PRODUCTS&quot; or &quot;DEVICES&quot; # $(2): list of makefiles representing nodes to import # $(3): list of node variable names # define import-nodes $(if \\ $(foreach _in,$(2), \\ $(eval _node_import_context := _nic.$(1).[[$(_in)]]) \\ $(if $(_include_stack),$(eval $(error ASSERTION FAILED: _include_stack \\ should be empty here: $(_include_stack))),) \\ $(eval _include_stack := ) \\ $(call _import-nodes-inner,$(_node_import_context),$(_in),$(3)) \\ $(call move-var-list,$(_node_import_context).$(_in),$(1).$(_in),$(3)) \\ $(eval _node_import_context :=) \\ $(eval $(1) := $($(1)) $(_in)) \\ $(if $(_include_stack),$(eval $(error ASSERTION FAILED: _include_stack \\ should be empty here: $(_include_stack))),) \\ ) \\ ,) endef 这个函数主要是做了三件事情： 12345671. 调用函数_import-nodes-inner将参数$2描述的每一个产品Makefile文件加载进来。 2. 调用函数move-var-list将定义在前面所加载的产品Makefile文件里面的由参数$3指定的变量的值分别拷贝到另外一组独立的变量中。 3. 将参数$2描述的每一个产品Makefile文件路径以空格分隔保存在参数$1所描述的变量中，也就是保存在变量PRODUCTS中。 上述第二件事情需要进一步解释一下。由于当前加载的每一个文件都会定义相同的变量，为了区分这些变量，我们需要在这些变量前面加一些前缀。例如，假设加载了build/target/product/full.mk这个产品Makefile文件，它里面定义了以下几个变量： 123456789101112[plain] view plain copy# Overrides PRODUCT_NAME := full PRODUCT_DEVICE := generic PRODUCT_BRAND := Android PRODUCT_MODEL := Full Android on Emulator 当调用了函数move-var-list对它进行解析后，就会得到以下的新变量：[plain] view plain copyPRODUCTS.build/target/product/full.mk.PRODUCT_NAME := full PRODUCTS.build/target/product/full.mk.PRODUCT_DEVICE := generic PRODUCTS.build/target/product/full.mk.PRODUCT_BRAND := Android PRODUCTS.build/target/product/full.mk.PRODUCT_MODEL := Full Android on Emulator 正是由于调用了函数move-var-list，我们在build/core/product_config.mk文件中可以通过PRODUCTS.$(INTERNAL_PRODUCT).PRODUCT_DEVICE来设置变量TARGET_DEVICE的值。 回到build/core/config.mk文件中，接下来我们再看BoardConfig.mk文件的加载过程。前面提到，当前要加载的BoardConfig.mk文件由变量TARGET_DEVICE来确定。例如，假设我们在运行lunch命令时，输入的文本为full-eng，那么build/target/product/full.mk就会被加载，并且我们得到TARGET_DEVICE的值就为generic，接下来加载的BoradConfig.mk文件就会在build/target/board/generic目录中找到。 BoardConfig.mk文件定义的信息可以参考build/target/board/generic/BoardConfig.mk文件的内容，如下所示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647[plain] view plain copy# config.mk # # Product-specific compile-time definitions. # # The generic product target doesn&apos;t have any hardware-specific pieces. TARGET_NO_BOOTLOADER := true TARGET_NO_KERNEL := true TARGET_ARCH := arm # Note: we build the platform images for ARMv7-A _without_ NEON. # # Technically, the emulator supports ARMv7-A _and_ NEON instructions, but # emulated NEON code paths typically ends up 2x slower than the normal C code # it is supposed to replace (unlike on real devices where it is 2x to 3x # faster). # # What this means is that the platform image will not use NEON code paths # that are slower to emulate. On the other hand, it is possible to emulate # application code generated with the NDK that uses NEON in the emulator. # TARGET_ARCH_VARIANT := armv7-a TARGET_CPU_ABI := armeabi-v7a TARGET_CPU_ABI2 := armeabi ARCH_ARM_HAVE_TLS_REGISTER := true HAVE_HTC_AUDIO_DRIVER := true BOARD_USES_GENERIC_AUDIO := true # no hardware camera USE_CAMERA_STUB := true # Enable dex-preoptimization to speed up the first boot sequence # of an SDK AVD. Note that this operation only works on Linux for now ifeq ($(HOST_OS),linux) ifeq ($(WITH_DEXPREOPT),) WITH_DEXPREOPT := true endif endif # Build OpenGLES emulation guest and host libraries BUILD_EMULATOR_OPENGL := true # Build and enable the OpenGL ES View renderer. When running on the emulator, # the GLES renderer disables itself if host GL acceleration isn&apos;t available. USE_OPENGL_RENDERER := true 它描述了产品的Boot Loader、Kernel、CPU体系结构、CPU ABI和Opengl加速等信息。 再回到build/core/config.mk文件中，它最后加载build/core/dumpvar.mk文件。加载build/core/dumpvar.mk文件是为了生成make目标，以便可以对这些目标进行操作。例如，在我们这个情景中，我们要执行的make目标是dumpvar-TARGET_DEVICE，因此在加载build/core/dumpvar.mk文件的过程中，就会生成dumpvar-TARGET_DEVICE目标。 文件build/core/dumpvar.mk的内容也比较多，这里我们只关注生成make目标相关的逻辑： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546[plain] view plain copy...... # The &quot;dumpvar&quot; stuff lets you say something like # # CALLED_FROM_SETUP=true \\ # make -f config/envsetup.make dumpvar-TARGET_OUT # or # CALLED_FROM_SETUP=true \\ # make -f config/envsetup.make dumpvar-abs-HOST_OUT_EXECUTABLES # # The plain (non-abs) version just dumps the value of the named variable. # The &quot;abs&quot; version will treat the variable as a path, and dumps an # absolute path to it. # dumpvar_goals := \\ $(strip $(patsubst dumpvar-%,%,$(filter dumpvar-%,$(MAKECMDGOALS)))) ifdef dumpvar_goals ifneq ($(words $(dumpvar_goals)),1) $(error Only one &quot;dumpvar-&quot; goal allowed. Saw &quot;$(MAKECMDGOALS)&quot;) endif # If the goal is of the form &quot;dumpvar-abs-VARNAME&quot;, then # treat VARNAME as a path and return the absolute path to it. absolute_dumpvar := $(strip $(filter abs-%,$(dumpvar_goals))) ifdef absolute_dumpvar dumpvar_goals := $(patsubst abs-%,%,$(dumpvar_goals)) ifneq ($(filter /%,$($(dumpvar_goals))),) DUMPVAR_VALUE := $($(dumpvar_goals)) else DUMPVAR_VALUE := $(PWD)/$($(dumpvar_goals)) endif dumpvar_target := dumpvar-abs-$(dumpvar_goals) else DUMPVAR_VALUE := $($(dumpvar_goals)) dumpvar_target := dumpvar-$(dumpvar_goals) endif .PHONY: $(dumpvar_target) $(dumpvar_target): @echo $(DUMPVAR_VALUE) endif # dumpvar_goals ...... 我们在执行make命令时，指定的目示会经由MAKECMDGOALS变量传递到Makefile中，因此通过变量MAKECMDGOALS可以获得make目标。 上述代码的逻辑很简单，例如，在我们这个情景中，指定的make目标为dumpvar-TARGET_DEVICE，那么就会得到变量DUMPVAR_VALUE的值为$(TARGET_DEVICE)。TARGET_DEVICE的值在前面已经被设置为“generic”，因此变量DUMPVAR_VALUE的值就等于“generic”。此外，变量dumpvar_target的被设置为“dumpvar-TARGET_DEVICE”。最后我们就可以得到以下的make规则： [plain] view plain copy.PHONY dumpvar-TARGET_DEVICEdumpvar-TARGET_DEVICE: @echo generic 至此，在build/envsetup.sh文件中定义的函数check_product就分析完成了。看完了之后，小伙伴们可能会问，前面不是说这个函数是用来检查用户输入的产品名称是否合法的吗？但是这里没看出哪一段代码给出了true或者false的答案啊。实际上，在前面分析的build/core/config.mk和build/core/product_config.mk等文件的加载过程中，如果发现输入的产品名称是非法的，也就是找不到相应的产品Makefile文件，那么就会通过调用error函数来产生一个错误，这时候函数check_product的返回值$?就会等于非0值。 接下来我们还要继续分析在build/envsetup.sh文件中定义的函数check_variant的实现，如下所示： 123456789101112131415[plain] view plain copyVARIANT_CHOICES=(user userdebug eng) # check to see if the supplied variant is valid function check_variant() &#123; for v in $&#123;VARIANT_CHOICES[@]&#125; do if [ &quot;$v&quot; = &quot;$1&quot; ] then return 0 fi done return 1 &#125; 这个函数的实现就简单多了。合法的编译类型定义在数组VARIANT_CHOICES中，并且它只有三个值user、userdebug和eng。其中，user表示发布版本，userdebug表示带调试信息的发布版本，而eng表标工程机版本。 最后，我们再来分析在build/envsetup.sh文件中定义的函数printconfig的实现，如下所示： 12345678910[plain] view plain copyfunction printconfig() &#123; T=$(gettop) if [ ! &quot;$T&quot; ]; then echo &quot;Couldn&apos;t locate the top of the tree. Try setting TOP.&quot; &gt;&amp;2 return fi get_build_var report_config &#125; 对比我们前面对函数check_product的分析，就会发现函数printconfig的实现与这很相似，都是通过调用get_build_var来获得相关的信息，但是这里传递给函数get_build_var的参数为report_config。 我们跳过前面build/core/config.mk和build/core/envsetup.mk等文件对目标产品Makefile文件的加载，直接跳到build/core/dumpvar.mk文件来查看与report_config这个make目标相关的逻辑： 1234567891011121314151617181920212223242526272829303132[plain] view plain copy...... dumpvar_goals := \\ $(strip $(patsubst dumpvar-%,%,$(filter dumpvar-%,$(MAKECMDGOALS)))) ..... ifneq ($(dumpvar_goals),report_config) PRINT_BUILD_CONFIG:= endif ...... ifneq ($(PRINT_BUILD_CONFIG),) HOST_OS_EXTRA:=$(shell python -c &quot;import platform; print(platform.platform())&quot;) $(info ============================================) $(info PLATFORM_VERSION_CODENAME=$(PLATFORM_VERSION_CODENAME)) $(info PLATFORM_VERSION=$(PLATFORM_VERSION)) $(info TARGET_PRODUCT=$(TARGET_PRODUCT)) $(info TARGET_BUILD_VARIANT=$(TARGET_BUILD_VARIANT)) $(info TARGET_BUILD_TYPE=$(TARGET_BUILD_TYPE)) $(info TARGET_BUILD_APPS=$(TARGET_BUILD_APPS)) $(info TARGET_ARCH=$(TARGET_ARCH)) $(info TARGET_ARCH_VARIANT=$(TARGET_ARCH_VARIANT)) $(info HOST_ARCH=$(HOST_ARCH)) $(info HOST_OS=$(HOST_OS)) $(info HOST_OS_EXTRA=$(HOST_OS_EXTRA)) $(info HOST_BUILD_TYPE=$(HOST_BUILD_TYPE)) $(info BUILD_ID=$(BUILD_ID)) $(info OUT_DIR=$(OUT_DIR)) $(info ============================================) endif 变量PRINT_BUILD_CONFIG定义在文件build/core/envsetup.mk中，默认值设置为true。当make目标为report-config的时候，变量PRINT_BUILD_CONFIG的值就会被设置为空。因此，接下来就会打印一系列用来描述编译环境配置的变量的值，也就是我们执行lunch命令后看到的输出。注意，这些环境配置相关的变量量都是在加载build/core/config.mk和build/core/envsetup.mk文件的过程中设置的，就类似于前面我们分析的TARGET_DEVICE变量的值的设置过程。 至此，我们就分析完成Android编译系统环境的初始化过程了。从分析的过程可以知道，Android编译系统环境是由build/core/config.mk、build/core/envsetup.mk、build/core/product_config.mk、AndroidProducts.mk和BoardConfig.mk等文件来完成的。这些mk文件涉及到非常多的细节，而我们这里只提供了一个大体的骨架和脉络，希望能够起到抛砖引玉的作用。","categories":[{"name":"AOSP","slug":"AOSP","permalink":"http://wenyiqingnian.xyz/categories/AOSP/"}],"tags":[{"name":"编译","slug":"编译","permalink":"http://wenyiqingnian.xyz/tags/编译/"},{"name":"aosp","slug":"aosp","permalink":"http://wenyiqingnian.xyz/tags/aosp/"}]},{"title":"添加SE安全策略","slug":"添加SE安全策略","date":"2017-03-15T11:10:10.000Z","updated":"2018-05-06T13:07:29.880Z","comments":true,"path":"2017/03/15/添加SE安全策略/","link":"","permalink":"http://wenyiqingnian.xyz/2017/03/15/添加SE安全策略/","excerpt":"","text":"一、 问题复现12341.service ro_isn /system/bin/isn.sh 2.class late_start3.user root4.oneshot kernel log会打印以下log： 1Warning! Service ro_isn needs a SELinux domain defined; please fix! 这是因为Service ro_isn没有在SELinux的监控之下，这种情况会提示你定义一个SELinux。在这种情况下，你可以：1.无视该条log，Service功能不受影响。各种权限不受限制。但是这样做会有风险。2.为Service ro_isn定义一个SELinux domain，仅添加需要的权限，未允许的权限操作会被拒绝。具体方法请参照下节。 二、解决方法1.1devices/qcom/sepolicy/common/ 目录下新增ro_isn.te文件，内容如下： 12type ro_isn, domain; type ro_isn_exec, exec_type, file_type; 2.在1devices/qcom/sepolicy/Android.mk 中添加ro_isn.te文件，内容如下： 1234BOARD_SEPOLICY_UNION := \\... \\ hostapd.te \\ ro_isn.te 3.在1devices/qcom/sepolicy/common/file_contexts 中增加如下内容： ################################### 1234567# System files#.../system/vendor/bin/slim_ap_daemonu:object_r:location_exec:s0/system/bin/isn.shu:object_r:ro_isn_exec:s0 4.在init.rc中service ro_isn下添加12345678secure context by seclabel service ro_isn /system/bin/isn.sh class late_start user root oneshot seclabel u:r:ro_isn:s0 5.编译并烧录bootimage 6.如果编译不成功，失败原因如下： 123Error while expanding policylibsepol.check_assertion_helper: neverallow on line 233 of external/sepolicy/domain.te (or line 5194 of policy.conf) violated by allow ro_isn system_file:file &#123; entrypoint &#125;;make: *** [out/target/product/msm8226/obj/ETC/sepolicy_intermediates/sepolicy] 错误 1 这是因为系统在domain.te中定义了全局的neverallow策略，与ro_isn.te中allow的策略有冲突： 12allow ro_isn system_file:file &#123; entrypoint &#125;;neverallow domain &#123; file_type -exec_type &#125;:file entrypoint; 请确定自己的service有必要需要这个权限。如无必要，请在自己的code中删除掉相关操作；如必要，可以在1external/sepolicy/domain.te 中冲突的neverallow语句中添加自己为例外： 1234neverallow &#123; domain -ro_isn&#125; &#123; file_type -exec_type &#125;:file entrypoint; 7.在service ro_isn运行时，搜索关于“ro_isn”的1avc: denied log 123&lt;6&gt;[ 13.547188](CPU:0-pid:320:logd.auditd) type=1400 audit(17468992.410:7): avc: denied &#123; entrypoint &#125; for pid=272 comm=&quot;init&quot; path=&quot;/system/bin/isn.sh &quot; dev=&quot;mmcblk0p38&quot; ino=631 scontext=u:r:ro_isn:s0 tcontext=u:object_r:system_file:s0 tclass=file 8.按照如下规则在ro_isn.te添加权限SELinux规则语句一般如下： 1allow A B:C D; 可以从log中分别获取ABCD四个参数。比如这行12345678warning log：avc: denied &#123; entrypoint &#125; for pid=272 comm=&quot;init&quot; path=&quot;/system/bin/isn.sh &quot; dev=&quot;mmcblk0p38&quot; ino=631 scontext=u:r:ro_isn:s0 tcontext=u:object_r:system_file:s0 tclass=fileavc: denied &#123; transition &#125; for pid=320 comm=&quot;init&quot; path=&quot;/system/xbin/fcgiserver.sh &quot; dev=&quot;mmcblk0p21&quot; ino=7873 scontext=u:r:init:s0 tcontext=u:r:fcgiserver:s0 tclass=process permissive=1 那么我们就得出最后的规则是： 1allow qcomsysd block_device:dir &#123; search &#125;; 1allow ro_isn system_file:file &#123; entrypoint &#125;; 重复步骤5-8,直到没有关于ro_isn的avc: denied log","categories":[{"name":"AOSP","slug":"AOSP","permalink":"http://wenyiqingnian.xyz/categories/AOSP/"}],"tags":[{"name":"编译","slug":"编译","permalink":"http://wenyiqingnian.xyz/tags/编译/"},{"name":"SEAndroid","slug":"SEAndroid","permalink":"http://wenyiqingnian.xyz/tags/SEAndroid/"}]},{"title":"fiddler抓android数据包","slug":"抓包工具 - Fiddler（如何捕获Android数据包）","date":"2016-08-03T12:20:17.000Z","updated":"2018-05-06T13:18:26.134Z","comments":true,"path":"2016/08/03/抓包工具 - Fiddler（如何捕获Android数据包）/","link":"","permalink":"http://wenyiqingnian.xyz/2016/08/03/抓包工具 - Fiddler（如何捕获Android数据包）/","excerpt":"","text":"抓包工具 - Fiddler（如何捕获Android数据包）移动设备访问网络原理 先看看移动设备是怎么去访问网络，如图所示，可以看到，移动端的数据包是从wifi出去的。可以看得出，移动端的数据包，都是要走wifi出去，所以我们可以把自己的电脑开启热点，将手机连上电脑，Fiddler开启代理后，让这些数据通过Fiddler，Fiddler就可以抓到这些包，然后发给路由器（如图）： 二、Fiddler抓取android数据包所需条件 1、电脑需要安装Fiddler 2、测试手机需要支持Wifi 3、测试手机与电脑需要同一网络 4、所测APP需支持代理 注：Iphone、Ipad、WinPhone等支持代理手机均适用 打开Wifi热点，让手机连上（我这里用的360wifi，其实随意一个都行） 打开Fidder，点击菜单栏中的 [Tools] –&gt; [Fiddler Options]Connections，设置代理端口：8888， 勾选 Allow remote computers to connect，即允许远程计算机连接Fiddler. 注：8888为默认端口号，可修改，但需注意两点，一是本机空闲端口，二是手机代理设置时要与fiddler的端口一致。 3、设置解密HTTPS的网络数据 Tools –&gt; Options-&gt; Https，勾选”Decrypt HTTPS traffic”、”Ignore server certificate errors”， 4、查看本机的无线网卡IP 设置了上面的步骤后，就可以在 Fiddler看到自己本机无线网卡的IP了（要是没有的话，重启Fiddler，或者可以在cmd中ipconfig找到自己的网卡IP，注：一定要开启本机的wifi热点）， 也可以在CMD中查看本机网卡的IP，输入命令：ipconfig， 5、手机连接本机的Wifi，并设置代理 每个品牌的手机设置wifi的方式可能不一样，这里以华为手机为例，如图8所示，将手机连接至PC的wifi 勾选“显示高级选项”-&gt; 代理 选择“手动” -&gt;输入服务器主机名和服务器端口 -&gt;IP选择“DHCP”-&gt;连接，即完成手机端设置代理操作，如图9所示 注：服务器主机名：Fiddler所在电脑IP（即开启wifi后，在fiddler或cmd中看到的无线网卡IP地址） 服务器端口： Fiddler使用的端口（即Options-Connections中设置的端口号） 6、手机下载安装Fiddler证书 连接上wifi后，手机打开浏览器输入代理IP+端口号（即是本机无线网卡IP，也是手机连接wifi时所设置的服务器主机名，这里的ip+端口号为192.168.191.1：8888），进入fiddler echo service页面，下载Fiddler的证书，如图10所示，点击FiddlerRoot certificate 下载完成后，进行安装证书 【注意】：如果打开浏览器碰到类似下面的报错，请打开Fiddler的证书解密模式（如上面的步骤3所示）：No root certificate was found. Have you enabled HTTPS traffic decryption in Fiddler yet? 设置完上面6个步骤后，即表明已设置完毕，此时用手机访问应用，就可以看到fiddler抓取到的数据包了.","categories":[{"name":"Android","slug":"Android","permalink":"http://wenyiqingnian.xyz/categories/Android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://wenyiqingnian.xyz/tags/android/"},{"name":"抓包","slug":"抓包","permalink":"http://wenyiqingnian.xyz/tags/抓包/"}]},{"title":"Linux vi用法","slug":"Linux vi命令使用方法","date":"2016-07-04T13:11:15.000Z","updated":"2018-05-06T13:12:58.582Z","comments":true,"path":"2016/07/04/Linux vi命令使用方法/","link":"","permalink":"http://wenyiqingnian.xyz/2016/07/04/Linux vi命令使用方法/","excerpt":"","text":"vi编辑器支持编辑模式和命令模式，编辑模式下可以完成文本的编辑功能，命令模式下可以完成对文件的操作命令，要正确使用vi编辑器就必须熟练掌握着两种模式的切换。默认情况下，打开vi编辑器后自动进入命令模式。从编辑模式切换到命令模式使用“esc”键，从命令模式切换到编辑模式使用“A”、“a”、“O”、“o”、“I”、“i”键。 vi编辑器提供了丰富的内置命令，有些内置命令使用键盘组合键即可完成，有些内置命令则需要以冒号“：”开头输入。常用内置命令如下： 12345678910111213141516171819202122232425262728293031323334Ctrl+u：向文件首翻半屏；Ctrl+d：向文件尾翻半屏；Ctrl+f：向文件尾翻一屏；Ctrl+b：向文件首翻一屏；Esc：从编辑模式切换到命令模式；ZZ：命令模式下保存当前文件所做的修改后退出vi；:行号：光标跳转到指定行的行首；:$：光标跳转到最后一行的行首；x或X：删除一个字符，x删除光标后的，而X删除光标前的；D：删除从当前光标到光标所在行尾的全部字符；dd：删除光标行正行内容；ndd：删除当前行及其后n-1行；nyy：将当前行及其下n行的内容保存到寄存器？中，其中？为一个字母，n为一个数字；p：粘贴文本操作，用于将缓存区的内容粘贴到当前光标所在位置的下方；P：粘贴文本操作，用于将缓存区的内容粘贴到当前光标所在位置的上方；/字符串：文本查找操作，用于从当前光标所在位置开始向文件尾部查找指定字符串的内容，查找的字符串会被加亮显示；？name：文本查找操作，用于从当前光标所在位置开始向文件头部查找指定字符串的内容，查找的字符串会被加亮显示；a，bs/F/T：替换文本操作，用于在第a行到第b行之间，将F字符串换成T字符串。其中，“s/”表示进行替换操作；a：在当前字符后添加文本；A：在行末添加文本；i：在当前字符前插入文本；I：在行首插入文本；o：在当前行后面插入一空行；O：在当前行前面插入一空行；:wq：在命令模式下，执行存盘退出操作；:w：在命令模式下，执行存盘操作；:w！：在命令模式下，执行强制存盘操作；:q：在命令模式下，执行退出vi操作；:q！：在命令模式下，执行强制退出vi操作；:e文件名：在命令模式下，打开并编辑指定名称的文件；:n：在命令模式下，如果同时打开多个文件，则继续编辑下一个文件；:f：在命令模式下，用于显示当前的文件名、光标所在行的行号以及显示比例；:set number：在命令模式下，用于在最左端显示行号；:set nonumber：在命令模式下，用于在最左端不显示行号；","categories":[{"name":"Linux","slug":"Linux","permalink":"http://wenyiqingnian.xyz/categories/Linux/"}],"tags":[{"name":"linux命令","slug":"linux命令","permalink":"http://wenyiqingnian.xyz/tags/linux命令/"}]}]}