<!DOCTYPE html>
<html lang=en>
<head>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
    
    <title>瘟疫青年</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta property="og:type" content="website">
<meta property="og:title" content="瘟疫青年">
<meta property="og:url" content="http://wenyiqingnian.xyz/page/3/index.html">
<meta property="og:site_name" content="瘟疫青年">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="瘟疫青年">
    

    

    
        <link rel="icon" href="/css/images/avatar.png" />
    

    <link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="/libs/open-sans/styles.css">
    <link rel="stylesheet" href="/libs/source-code-pro/styles.css">

    <link rel="stylesheet" href="/css/style.css">

    <script src="/libs/jquery/2.1.3/jquery.min.js"></script>
    
    
        <link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css">
    
    
        <link rel="stylesheet" href="/libs/justified-gallery/justifiedGallery.min.css"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
    
    
    
    


</head>

<body>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="container">
        <header id="header">
    <div id="header-main" class="header-inner">
        <div class="outer">
            <a href="/" id="logo">
                <i class="logo"></i>
                <span class="site-title">瘟疫青年</span>
            </a>
            <nav id="main-nav">
                
                    <a class="main-nav-link" href="/.">Home</a>
                
                    <a class="main-nav-link" href="/archives">Archives</a>
                
                    <a class="main-nav-link" href="/categories">Categories</a>
                
                    <a class="main-nav-link" href="/tags">Tags</a>
                
                    <a class="main-nav-link" href="/about">About</a>
                
            </nav>
            
                
                <nav id="sub-nav">
                    <div class="profile" id="profile-nav">
                        <a id="profile-anchor" href="javascript:;">
                            <img class="avatar" src="/css/images/avatar.png" />
                            <i class="fa fa-caret-down"></i>
                        </a>
                    </div>
                </nav>
            
            <div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="Search" />
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="Type something..." />
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: 'Posts',
            PAGES: 'Pages',
            CATEGORIES: 'Categories',
            TAGS: 'Tags',
            UNTITLED: '(Untitled)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div>
        </div>
    </div>
    <div id="main-nav-mobile" class="header-sub header-inner">
        <table class="menu outer">
            <tr>
                
                    <td><a class="main-nav-link" href="/.">Home</a></td>
                
                    <td><a class="main-nav-link" href="/archives">Archives</a></td>
                
                    <td><a class="main-nav-link" href="/categories">Categories</a></td>
                
                    <td><a class="main-nav-link" href="/tags">Tags</a></td>
                
                    <td><a class="main-nav-link" href="/about">About</a></td>
                
                <td>
                    
    <div class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="Search" />
    </div>

                </td>
            </tr>
        </table>
    </div>
</header>

        <div class="outer">
            
                

<aside id="profile" class="profile-fixed">
    <div class="inner profile-inner">
        <div class="base-info profile-block">
            <img id="avatar" src="/css/images/avatar.png" />
            <h2 id="name">QuincyJiang</h2>
            <h3 id="title">Coder &amp; FilmPlayer</h3>
            <span id="location"><i class="fa fa-map-marker"></i>Guangzhou, China</span>
            <a id="follow" target="_blank" href="https://github.com/QuincyJiang">FOLLOW</a>
        </div>
        <div class="article-info profile-block">
            <div class="article-info-block">
                30
                <span>posts</span>
            </div>
            <div class="article-info-block">
                32
                <span>tags</span>
            </div>
        </div>
        
        <div class="profile-block social-links">
            <table>
                <tr>
                    
                    
                    <td>
                        <a href="https://github.com/QuincyJiang" target="_blank" title="github" class=tooltip>
                            <i class="fa fa-github"></i>
                        </a>
                    </td>
                    
                    <td>
                        <a href="https://weibo.com/2425393311/" target="_blank" title="weibo" class=tooltip>
                            <i class="fa fa-weibo"></i>
                        </a>
                    </td>
                    
                    <td>
                        <a href="http://aquencyua11.lofter.com/" target="_blank" title="photo" class=tooltip>
                            <i class="fa fa-photo"></i>
                        </a>
                    </td>
                    
                </tr>
            </table>
        </div>
        
    </div>
</aside>

            
            <section id="main">
    <article id="post-view 绘制机制" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2017/10/12/view 绘制机制/">view 绘制机制</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2017/10/12/view 绘制机制/">
            <time datetime="2017-10-12T11:30:50.000Z" itemprop="datePublished">2017-10-12</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/Android/">Android</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/android/">android</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p>View的绘制和事件处理是两个重要的主题，上一篇《图解 Android事件分发机制》已经把事件的分发机制讲得比较详细了，这一篇是针对View的绘制，View的绘制如果你有所了解，基本分为measure、layout、draw 过程，其中比较难理解就是measure过程，所以本篇文章大幅笔地分析measure过程，相对讲得比较详细，文章也比较长，如果你对View的绘制还不是很懂，对measure过程掌握得不是很深刻，那么耐心点，看完这篇文章，相信你会有所收获的。</p>
<h1 id="Measure过程"><a href="#Measure过程" class="headerlink" title="Measure过程"></a>Measure过程</h1><p>对于测量我们来说几个知识点,了解这几个知识点，之后的实例分析你才看得懂。</p>
<h2 id="1、MeasureSpec-的理解"><a href="#1、MeasureSpec-的理解" class="headerlink" title="1、MeasureSpec 的理解"></a>1、MeasureSpec 的理解</h2><p>对于View的测量，肯定会和<strong>MeasureSpec</strong>接触，<strong>MeasureSpec</strong>是两个单词组成，翻译过来“测量规格”或者“测量参数”，很多博客包括官方文档对他的说明基本都是“一个MeasureSpec封装了从父容器传递给子容器的布局要求”,这个MeasureSpec 封装的是父容器传递给子容器的布局要求，而不是父容器对子容器的布局要求，“传递” 两个字很重要，更精确的说法应该这个MeasureSpec是由父View的MeasureSpec和子View的LayoutParams通过简单的计算得出一个针对子View的测量要求，这个测量要求就是MeasureSpec。</p>
<p>大家都知道一个MeasureSpec是一个大小跟模式的组合值,MeasureSpec中的值是一个整型（32位）将size和mode打包成一个Int型，其中高两位是mode，后面30位存的是size，是为了减少对象的分配开支。MeasureSpec 类似于下图，只不过这边用的是十进制的数，而MeasureSpec 是二进制存储的。<br><img src="https://upload-images.jianshu.io/upload_images/966283-c330852c971b02a8.png" alt="image"></p>
<h6 id="注：-1-代表的是EXACTLY，-2-是AT-MOST"><a href="#注：-1-代表的是EXACTLY，-2-是AT-MOST" class="headerlink" title="注：-1 代表的是EXACTLY，-2 是AT_MOST"></a>注：-1 代表的是EXACTLY，-2 是AT_MOST</h6><p>MeasureSpec一共有三种模式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPSPECIFIED : 父容器对于子容器没有任何限制,子容器想要多大就多大</span><br><span class="line">EXACTLY: 父容器已经为子容器设置了尺寸,子容器应当服从这些边界,不论子容器想要多大的空间。</span><br><span class="line">AT_MOST：子容器可以是声明大小内的任意大小</span><br></pre></td></tr></table></figure>
<p>很多文章都会把这三个模式说成这样，当然其实包括官方文档也是这样表达的，但是这样并不好理解。特别是如果把这三种模式又和<strong>MATCH_PARENT</strong>和<strong>WRAP_CONTENT</strong> 联系到一起，很多人就懵逼了。如果从代码上来看<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">view.measure(int widthMeasureSpec, int heightMeasureSpec)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> 的两个MeasureSpec是父类传递过来的，但并不是完全是父View的要求，而是父View的MeasureSpec和子View自己的LayoutParams共同决定的，而子View的LayoutParams其实就是我们在xml写的时候设置的layout_width和layout_height 转化而来的。我们先来看代码会清晰一些：</p>
<p>父View的measure的过程会先测量子View，等子View测量结果出来后，再来测量自己，上面的measureChildWithMargins就是用来测量某个子View的，我们来分析是怎样测量的，具体看注释：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChildWithMargins</span><span class="params">(View child, <span class="keyword">int</span> parentWidthMeasureSpec, <span class="keyword">int</span> widthUsed, <span class="keyword">int</span> parentHeightMeasureSpec, <span class="keyword">int</span> heightUsed)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 子View的LayoutParams，你在xml的layout_width和layout_height,</span></span><br><span class="line"><span class="comment">// layout_xxx的值最后都会封装到这个个LayoutParams。</span></span><br><span class="line"><span class="keyword">final</span> MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();   </span><br><span class="line"></span><br><span class="line"><span class="comment">//根据父View的测量规格和父View自己的Padding，</span></span><br><span class="line"><span class="comment">//还有子View的Margin和已经用掉的空间大小（widthUsed），就能算出子View的MeasureSpec,具体计算过程看getChildMeasureSpec方法。</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,            </span><br><span class="line">mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin + widthUsed, lp.width);    </span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,           </span><br><span class="line">mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin  + heightUsed, lp.height);  </span><br><span class="line"></span><br><span class="line"><span class="comment">//通过父View的MeasureSpec和子View的自己LayoutParams的计算，算出子View的MeasureSpec，然后父容器传递给子容器的</span></span><br><span class="line"><span class="comment">// 然后让子View用这个MeasureSpec（一个测量要求，比如不能超过多大）去测量自己，如果子View是ViewGroup 那还会递归往下测量。</span></span><br><span class="line">child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// spec参数   表示父View的MeasureSpec </span></span><br><span class="line"><span class="comment">// padding参数    父View的Padding+子View的Margin，父View的大小减去这些边距，才能精确算出</span></span><br><span class="line"><span class="comment">//               子View的MeasureSpec的size</span></span><br><span class="line"><span class="comment">// childDimension参数  表示该子View内部LayoutParams属性的值（lp.width或者lp.height）</span></span><br><span class="line"><span class="comment">//                    可以是wrap_content、match_parent、一个精确指(an exactly size),  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getChildMeasureSpec</span><span class="params">(<span class="keyword">int</span> spec, <span class="keyword">int</span> padding, <span class="keyword">int</span> childDimension)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> specMode = MeasureSpec.getMode(spec);  <span class="comment">//获得父View的mode  </span></span><br><span class="line">    <span class="keyword">int</span> specSize = MeasureSpec.getSize(spec);  <span class="comment">//获得父View的大小  </span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//父View的大小-自己的Padding+子View的Margin，得到值才是子View的大小。</span></span><br><span class="line">    <span class="keyword">int</span> size = Math.max(<span class="number">0</span>, specSize - padding);   </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">int</span> resultSize = <span class="number">0</span>;    <span class="comment">//初始化值，最后通过这个两个值生成子View的MeasureSpec</span></span><br><span class="line">    <span class="keyword">int</span> resultMode = <span class="number">0</span>;    <span class="comment">//初始化值，最后通过这个两个值生成子View的MeasureSpec</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">switch</span> (specMode) &#123;  </span><br><span class="line">    <span class="comment">// Parent has imposed an exact size on us  </span></span><br><span class="line">    <span class="comment">//1、父View是EXACTLY的 ！  </span></span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.EXACTLY:   </span><br><span class="line">        <span class="comment">//1.1、子View的width或height是个精确值 (an exactly size)  </span></span><br><span class="line">        <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;            </span><br><span class="line">            resultSize = childDimension;         <span class="comment">//size为精确值  </span></span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;    <span class="comment">//mode为 EXACTLY 。  </span></span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="comment">//1.2、子View的width或height为 MATCH_PARENT/FILL_PARENT   </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;  </span><br><span class="line">            <span class="comment">// Child wants to be our size. So be it.  </span></span><br><span class="line">            resultSize = size;                   <span class="comment">//size为父视图大小  </span></span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;    <span class="comment">//mode为 EXACTLY 。  </span></span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="comment">//1.3、子View的width或height为 WRAP_CONTENT  </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;  </span><br><span class="line">            <span class="comment">// Child wants to determine its own size. It can't be  </span></span><br><span class="line">            <span class="comment">// bigger than us.  </span></span><br><span class="line">            resultSize = size;                   <span class="comment">//size为父视图大小  </span></span><br><span class="line">            resultMode = MeasureSpec.AT_MOST;    <span class="comment">//mode为AT_MOST 。  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">break</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Parent has imposed a maximum size on us  </span></span><br><span class="line">    <span class="comment">//2、父View是AT_MOST的 ！      </span></span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.AT_MOST:  </span><br><span class="line">        <span class="comment">//2.1、子View的width或height是个精确值 (an exactly size)  </span></span><br><span class="line">        <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;  </span><br><span class="line">            <span class="comment">// Child wants a specific size... so be it  </span></span><br><span class="line">            resultSize = childDimension;        <span class="comment">//size为精确值  </span></span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;   <span class="comment">//mode为 EXACTLY 。  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//2.2、子View的width或height为 MATCH_PARENT/FILL_PARENT  </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;  </span><br><span class="line">            <span class="comment">// Child wants to be our size, but our size is not fixed.  </span></span><br><span class="line">            <span class="comment">// Constrain child to not be bigger than us.  </span></span><br><span class="line">            resultSize = size;                  <span class="comment">//size为父视图大小  </span></span><br><span class="line">            resultMode = MeasureSpec.AT_MOST;   <span class="comment">//mode为AT_MOST  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//2.3、子View的width或height为 WRAP_CONTENT  </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;  </span><br><span class="line">            <span class="comment">// Child wants to determine its own size. It can't be  </span></span><br><span class="line">            <span class="comment">// bigger than us.  </span></span><br><span class="line">            resultSize = size;                  <span class="comment">//size为父视图大小  </span></span><br><span class="line">            resultMode = MeasureSpec.AT_MOST;   <span class="comment">//mode为AT_MOST  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">break</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Parent asked to see how big we want to be  </span></span><br><span class="line">    <span class="comment">//3、父View是UNSPECIFIED的 ！  </span></span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:  </span><br><span class="line">        <span class="comment">//3.1、子View的width或height是个精确值 (an exactly size)  </span></span><br><span class="line">        <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;  </span><br><span class="line">            <span class="comment">// Child wants a specific size... let him have it  </span></span><br><span class="line">            resultSize = childDimension;        <span class="comment">//size为精确值  </span></span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;   <span class="comment">//mode为 EXACTLY  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//3.2、子View的width或height为 MATCH_PARENT/FILL_PARENT  </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;  </span><br><span class="line">            <span class="comment">// Child wants to be our size... find out how big it should  </span></span><br><span class="line">            <span class="comment">// be  </span></span><br><span class="line">            resultSize = <span class="number">0</span>;                        <span class="comment">//size为0！ ,其值未定  </span></span><br><span class="line">            resultMode = MeasureSpec.UNSPECIFIED;  <span class="comment">//mode为 UNSPECIFIED  </span></span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="comment">//3.3、子View的width或height为 WRAP_CONTENT  </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;  </span><br><span class="line">            <span class="comment">// Child wants to determine its own size.... find out how  </span></span><br><span class="line">            <span class="comment">// big it should be  </span></span><br><span class="line">            resultSize = <span class="number">0</span>;                        <span class="comment">//size为0! ，其值未定  </span></span><br><span class="line">            resultMode = MeasureSpec.UNSPECIFIED;  <span class="comment">//mode为 UNSPECIFIED  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">break</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//根据上面逻辑条件获取的mode和size构建MeasureSpec对象。  </span></span><br><span class="line">    <span class="keyword">return</span> MeasureSpec.makeMeasureSpec(resultSize, resultMode);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码有点多，希望你仔细看一些注释，代码写得很多，其实计算原理很简单：</p>
<ol>
<li>如果我们在xml 的layout_width或者layout_height 把值都写死，那么上述的测量完全就不需要了，之所以要上面的这步测量，是因为 match_parent 就是充满父容器，wrap_content 就是自己多大就多大， 我们写代码的时候特别爽，我们编码方便的时候，google就要帮我们计算你match_parent的时候是多大，wrap_content的是多大，这个计算过程，就是计算出来的父View的MeasureSpec不断往子View传递，结合子View的LayoutParams 一起再算出子View的MeasureSpec，然后继续传给子View，不断计算每个View的MeasureSpec，子View有了MeasureSpec才能更测量自己和自己的子View。</li>
</ol>
<ol start="2">
<li>上述代码如果这么来理解就简单了<blockquote>
<p>如果父View的MeasureSpec 是EXACTLY，说明父View的大小是确切的，（确切的意思很好理解，如果一个View的MeasureSpec 是EXACTLY，那么它的size 是多大，最后展示到屏幕就一定是那么大）。</p>
</blockquote>
</li>
</ol>
<ul>
<li><p>1.如果子View 的layout_xxxx是MATCH_PARENT，父View的大小是确切，子View的大小又MATCH_PARENT（充满整个父View），那么子View的大小肯定是确切的，而且大小值就是父View的size。所以子View的size=父View的size，mode=EXACTLY</p>
<ul>
<li>2.如果子View 的layout_xxxx是WRAP_CONTENT，也就是子View的大小是根据自己的content 来决定的，但是子View的毕竟是子View，大小不能超过父View的大小，但是子View的是WRAP_CONTENT，我们还不知道具体子View的大小是多少，要等到child.measure(childWidthMeasureSpec, childHeightMeasureSpec) 调用的时候才去真正测量子View 自己content的大小（比如TextView wrap_content 的时候你要测量TextView content 的大小，也就是字符占用的大小，这个测量就是在child.measure(childWidthMeasureSpec, childHeightMeasureSpec)的时候，才能测出字符的大小，MeasureSpec 的意思就是假设你字符100px，但是MeasureSpec 要求最大的只能50px，这时候就要截掉了）。通过上述描述，子View MeasureSpec mode的应该是AT_MOST，而size 暂定父View的 size，表示的意思就是子View的大小没有不确切的值，子View的大小最大为父View的大小，不能超过父View的大小（这就是AT_MOST 的意思），然后这个MeasureSpec 做为子View measure方法 的参数，做为子View的大小的约束或者说是要求，有了这个MeasureSpec子View再实现自己的测量。</li>
</ul>
</li>
</ul>
<p>3、如果如果子View 的layout_xxxx是确定的值（200dp），那么就更简单了，不管你父View的mode和size是什么，我都写死了就是200dp，那么控件最后展示就是就是200dp，不管我的父View有多大，也不管我自己的content 有多大，反正我就是这么大，所以这种情况MeasureSpec 的mode = EXACTLY 大小size=你在layout_xxxx 填的那个值。</p>
<blockquote>
<p>如果父View的MeasureSpec 是AT_MOST，说明父View的大小是不确定，最大的大小是MeasureSpec 的size值，不能超过这个值。</p>
</blockquote>
<ul>
<li><p>1、如果子View 的layout_xxxx是MATCH_PARENT，父View的大小是不确定（只知道最大只能多大），子View的大小MATCH_PARENT（充满整个父View），那么子View你即使充满父容器，你的大小也是不确定的，父View自己都确定不了自己的大小，你MATCH_PARENT你的大小肯定也不能确定的，所以子View的mode=AT_MOST，size=父View的size，也就是你在布局虽然写的是MATCH_PARENT，但是由于你的父容器自己的大小不确定，导致子View的大小也不确定，只知道最大就是父View的大小。</p>
</li>
<li><p>2、如果子View 的layout_xxxx是WRAP_CONTENT，父View的大小是不确定（只知道最大只能多大），子View又是WRAP_CONTENT，那么在子View的Content没算出大小之前，子View的大小最大就是父View的大小，所以子View MeasureSpec mode的就是AT_MOST，而size 暂定父View的 size。</p>
</li>
<li><p>3、如果如果子View 的layout_xxxx是确定的值（200dp），同上，写多少就是多少，改变不了的。</p>
</li>
</ul>
<blockquote>
<p>如果父View的MeasureSpec 是UNSPECIFIED(未指定),表示没有任何束缚和约束，不像AT_MOST表示最大只能多大，不也像EXACTLY表示父View确定的大小，子View可以得到任意想要的大小，不受约束</p>
<ul>
<li>1、如果子View 的layout_xxxx是MATCH_PARENT，因为父View的MeasureSpec是UNSPECIFIED，父View自己的大小并没有任何约束和要求，<br>那么对于子View来说无论是WRAP_CONTENT还是MATCH_PARENT，子View也是没有任何束缚的，想多大就多大，没有不能超过多少的要求，一旦没有任何要求和约束，size的值就没有任何意义了，所以一般都直接设置成0</li>
</ul>
</blockquote>
<ul>
<li><p>2、同上…</p>
</li>
<li><p>3、如果如果子View 的layout_xxxx是确定的值（200dp），同上，写多少就是多少，改变不了的（记住，只有设置的确切的值，那么无论怎么测量，大小都是不变的，都是你写的那个值）</p>
</li>
</ul>
<h2 id="2、View的测量过程主要是在onMeasure-方法"><a href="#2、View的测量过程主要是在onMeasure-方法" class="headerlink" title="2、View的测量过程主要是在onMeasure()方法"></a>2、View的测量过程主要是在onMeasure()方法</h2><p>打开View的源码，找到measure方法，这个方法代码不少，但是测量工作都是在onMeasure()做的，measure方法是final的所以这个方法也不可重写，如果想自定义View的测量，你应该去重写onMeasure()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">measure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">  ......</span><br><span class="line">  onMeasure(widthMeasureSpec,heightMeasureSpec);</span><br><span class="line">  .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3、View的onMeasure-的默认实现"><a href="#3、View的onMeasure-的默认实现" class="headerlink" title="3、View的onMeasure 的默认实现"></a>3、View的onMeasure 的默认实现</h2><p>打开View.java 的源码来看下onMeasure的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;    </span><br><span class="line">  setMeasuredDimension(</span><br><span class="line">  getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),            </span><br><span class="line">  getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>View的onMeasure方法默认实现很简单，就是调用setMeasuredDimension()，setMeasuredDimension()可以简单理解就是给mMeasuredWidth和mMeasuredHeight设值，如果这两个值一旦设置了，那么意味着对于这个View的测量结束了，这个View的宽高已经有测量的结果出来了。如果我们想设定某个View的高宽，完全可以直接通过setMeasuredDimension（100，200）来设置死它的高宽（不建议），但是setMeasuredDimension方法必须在onMeasure方法中调用，不然会抛异常。我们来看下对于View来说它的默认高宽是怎么获取的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取的是android:minHeight属性的值或者View背景图片的大小值</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getSuggestedMinimumWidth</span><span class="params">()</span> </span>&#123; </span><br><span class="line">   <span class="keyword">return</span> (mBackground == <span class="keyword">null</span>) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth()); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//@param size参数一般表示设置了android:minHeight属性或者该View背景图片的大小值  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDefaultSize</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> measureSpec)</span> </span>&#123;    </span><br><span class="line">   <span class="keyword">int</span> result = size;    </span><br><span class="line">   <span class="keyword">int</span> specMode = MeasureSpec.getMode(measureSpec);    </span><br><span class="line">   <span class="keyword">int</span> specSize = MeasureSpec.getSize(measureSpec);    </span><br><span class="line">   <span class="keyword">switch</span> (specMode) &#123;    </span><br><span class="line">   <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:        <span class="comment">//表示该View的大小父视图未定，设置为默认值 </span></span><br><span class="line">     result = size;  </span><br><span class="line">     <span class="keyword">break</span>;    </span><br><span class="line">   <span class="keyword">case</span> MeasureSpec.AT_MOST:    </span><br><span class="line">   <span class="keyword">case</span> MeasureSpec.EXACTLY:        </span><br><span class="line">     result = specSize;  </span><br><span class="line">     <span class="keyword">break</span>;   </span><br><span class="line"> &#125;    </span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getDefaultSize的第一个参数size等于getSuggestedMinimumXXXX返回的的值（建议的最小宽度和高度），而建议的最小宽度和高度都是由View的Background尺寸与通过设置View的minXXX属性共同决定的，这个size可以理解为View的默认长度，而第二个参数measureSpec，是父View传给自己的MeasureSpec,这个measureSpec是通过测量计算出来的，具体的计算测量过程前面在讲解MeasureSpec已经讲得比较清楚了（是有父View的MeasureSpec和子View自己的LayoutParams 共同决定的）只要这个测试的mode不是UNSPECIFIED（未确定的），那么默认的就会用这个测量的数值当做View的高度。</p>
<p>对于View默认是测量很简单，大部分情况就是拿计算出来的MeasureSpec的size 当做最终测量的大小。而对于其他的一些View的派生类，如TextView、Button、ImageView等，它们的onMeasure方法系统了都做了重写，不会这么简单直接拿 MeasureSpec 的size来当大小，而去会先去测量字符或者图片的高度等，然后拿到View本身content这个高度（字符高度等），如果MeasureSpec是AT_MOST，而且View本身content的高度不超出MeasureSpec的size，那么可以直接用View本身content的高度（字符高度等），而不是像View.java 直接用MeasureSpec的size做为View的大小。</p>
<h2 id="4、ViewGroup的Measure过程"><a href="#4、ViewGroup的Measure过程" class="headerlink" title="4、ViewGroup的Measure过程"></a>4、ViewGroup的Measure过程</h2><p>ViewGroup 类并没有实现onMeasure，我们知道测量过程其实都是在onMeasure方法里面做的，我们来看下FrameLayout 的onMeasure 方法,具体分析看注释哦。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//FrameLayout 的测量</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;  </span><br><span class="line">....</span><br><span class="line"><span class="keyword">int</span> maxHeight = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> maxWidth = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> childState = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;    </span><br><span class="line">   <span class="keyword">final</span> View child = getChildAt(i);    </span><br><span class="line">   <span class="keyword">if</span> (mMeasureAllChildren || child.getVisibility() != GONE) &#123;   </span><br><span class="line">    <span class="comment">// 遍历自己的子View，只要不是GONE的都会参与测量，measureChildWithMargins方法在最上面</span></span><br><span class="line">    <span class="comment">// 的源码已经讲过了，如果忘了回头去看看，基本思想就是父View把自己的MeasureSpec </span></span><br><span class="line">    <span class="comment">// 传给子View结合子View自己的LayoutParams 算出子View 的MeasureSpec，然后继续往下传，</span></span><br><span class="line">    <span class="comment">// 传递叶子节点，叶子节点没有子View，根据传下来的这个MeasureSpec测量自己就好了。</span></span><br><span class="line">     measureChildWithMargins(child, widthMeasureSpec, <span class="number">0</span>, heightMeasureSpec, <span class="number">0</span>);       </span><br><span class="line">     <span class="keyword">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams(); </span><br><span class="line">     maxWidth = Math.max(maxWidth, child.getMeasuredWidth() +  lp.leftMargin + lp.rightMargin);        </span><br><span class="line">     maxHeight = Math.max(maxHeight, child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);  </span><br><span class="line">     ....</span><br><span class="line">     ....</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">.....</span><br><span class="line">.....</span><br></pre></td></tr></table></figure>
<p>//所有的孩子测量之后，经过一系类的计算之后通过setMeasuredDimension设置自己的宽高，<br>//对于FrameLayout 可能用最大的字View的大小，对于LinearLayout，可能是高度的累加，<br>//具体测量的原理去看看源码。总的来说，父View是等所有的子View测量结束之后，再来测量自己。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState),        </span><br><span class="line">resolveSizeAndState(maxHeight, heightMeasureSpec, childState &lt;&lt; MEASURED_HEIGHT_STATE_SHIFT));</span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到目前为止，基本把Measure 主要原理都过了一遍，接下来我们会结合实例来讲解整个match的过程，首先看下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;LinearLayout  xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    </span><br><span class="line">   android:id=&quot;@+id/linear&quot;</span><br><span class="line">   android:layout_width=&quot;match_parent&quot;    </span><br><span class="line">   android:layout_height=&quot;wrap_content&quot;    </span><br><span class="line">   android:layout_marginTop=&quot;50dp&quot;    </span><br><span class="line">   android:background=&quot;@android:color/holo_blue_dark&quot;    </span><br><span class="line">   android:paddingBottom=&quot;70dp&quot;    </span><br><span class="line">   android:orientation=&quot;vertical&quot;&gt;    </span><br><span class="line">   &lt;TextView        </span><br><span class="line">    android:id=&quot;@+id/text&quot;       </span><br><span class="line">    android:layout_width=&quot;match_parent&quot;     </span><br><span class="line">    android:layout_height=&quot;wrap_content&quot;  </span><br><span class="line">    android:background=&quot;@color/material_blue_grey_800&quot;       </span><br><span class="line">    android:text=&quot;TextView&quot;        </span><br><span class="line">    android:textColor=&quot;@android:color/white&quot;        </span><br><span class="line">    android:textSize=&quot;20sp&quot; /&gt;    </span><br><span class="line">   &lt;View       </span><br><span class="line">      android:id=&quot;@+id/view&quot;       </span><br><span class="line">     android:layout_width=&quot;match_parent&quot; </span><br><span class="line">     android:layout_height=&quot;150dp&quot;    </span><br><span class="line">     android:background=&quot;@android:color/holo_green_dark&quot; /&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/966283-4a11f92ac8c5e224.png" alt="image"><br>上面的代码对于出来的布局是下面的一张图</p>
<p>对于上面图可能有些不懂，这边做下说明:</p>
<blockquote>
<p>整个图是一个DecorView,DecorView可以理解成整个页面的根View,DecorView是一个FrameLayout,包含两个子View，一个id=statusBarBackground的View和一个是LineaLayout，id=statusBarBackground的View，我们可以先不管（我也不是特别懂这个View,应该就是statusBar的设置背景的一个控件，方便设置statusBar的背景)，而这个LinearLayout比较重要，它包含一个title和一个content，title很好理解其实就是TitleBar或者ActionBar,content 就更简单了，setContentView()方法你应该用过吧，android.R.id.content 你应该听过吧，没错就是它,content是一个FrameLayout，你写的页面布局通过setContentView加进来就成了content的直接子View。</p>
</blockquote>
<p>整个View的布局图如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/966283-4096801e91e2eccc.png" alt="image"><br>这张图在下面分析measure，会经常用到，主要用于了解递归的时候view 的measure顺序</p>
<blockquote>
<p>注:<br>1、 header的是个ViewStub,用来惰性加载ActionBar，为了便于分析整个测量过程，我把Theme设成NoActionBar，避免ActionBar 相关的measure干扰整个过程，这样可以忽略掉ActionBar 的测量，在调试代码更清晰。<br>2、包含Header(ActionBar）和id/content 的那个父View，我不知道叫什么名字好，我们姑且叫它ViewRoot（看上图）,它是垂直的LinearLayout，放着整个页面除statusBar 的之外所有的东西，叫它ViewRoot 应该还ok，一个代号而已。</p>
</blockquote>
<p>既然我们知道整个View的Root是DecorView，那么View的绘制是从哪里开始的呢，我们知道每个Activity 均会创建一个 PhoneWindow对象，是Activity和整个View系统交互的接口，每个Window都对应着一个View和一个ViewRootImpl，Window和View通过ViewRootImpl来建立联系,对于Activity来说，ViewRootImpl是连接WindowManager和DecorView的纽带,绘制的入口是由ViewRootImpl的performTraversals方法来发起Measure，Layout，Draw等流程的。</p>
<p>我们来看下ViewRootImpl的performTraversals 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performTraversals</span><span class="params">()</span> </span>&#123; </span><br><span class="line">...... </span><br><span class="line"><span class="keyword">int</span> childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width); </span><br><span class="line"><span class="keyword">int</span> childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height); </span><br><span class="line">...... </span><br><span class="line">mView.measure(childWidthMeasureSpec, childHeightMeasureSpec); </span><br><span class="line">......</span><br><span class="line">mView.layout(<span class="number">0</span>, <span class="number">0</span>, mView.getMeasuredWidth(), mView.getMeasuredHeight());</span><br><span class="line">...... </span><br><span class="line">mView.draw(canvas); </span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getRootMeasureSpec</span><span class="params">(<span class="keyword">int</span> windowSize, <span class="keyword">int</span> rootDimension)</span> </span>&#123; </span><br><span class="line">   <span class="keyword">int</span> measureSpec; </span><br><span class="line">   <span class="keyword">switch</span> (rootDimension) &#123; </span><br><span class="line">   <span class="keyword">case</span> ViewGroup.LayoutParams.MATCH_PARENT: </span><br><span class="line">   <span class="comment">// Window can't resize. Force root view to be windowSize.   </span></span><br><span class="line">   measureSpec = MeasureSpec.makeMeasureSpec(windowSize,MeasureSpec.EXACTLY);</span><br><span class="line">   <span class="keyword">break</span>; </span><br><span class="line">   ...... </span><br><span class="line">  &#125; </span><br><span class="line"> <span class="keyword">return</span> measureSpec; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>performTraversals 中我们看到的mView其实就是DecorView,View的绘制从DecorView开始， 在mView.measure()的时候调用getRootMeasureSpec获得两个MeasureSpec做为参数，getRootMeasureSpec的两个参数（mWidth, lp.width）mWith和mHeight 是屏幕的宽度和高度， lp是WindowManager.LayoutParams，它的lp.width和lp.height的默认值是MATCH_PARENT,所以通过getRootMeasureSpec 生成的测量规格MeasureSpec 的mode是MATCH_PARENT ，size是屏幕的高宽。<br>因为DecorView 是一个FrameLayout 那么接下来会进入FrameLayout 的measure方法，measure的两个参数就是刚才getRootMeasureSpec的生成的两个MeasureSpec，DecorView的测量开始了。<br>首先是DecorView 的 MeasureSpec ，根据上面的分析DecorView 的 MeasureSpec是Windows传过来的，我们画出DecorView 的MeasureSpec 图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/966283-c330852c971b02a8.png" alt="image"></p>
<blockquote>
<p>注：<br>1、-1 代表的是EXACTLY，-2 是AT_MOST<br>2、由于屏幕的像素是1440x2560,所以DecorView 的MeasureSpec的size 对应于这两个值</p>
</blockquote>
<p>那么接下来在FrameLayout 的onMeasure()方法DecorView开始for循环测量自己的子View,测量完所有的子View再来测量自己，由下图可知，接下来要测量ViewRoot的大小<br><img src="https://upload-images.jianshu.io/upload_images/966283-4096801e91e2eccc.png" alt="image"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//FrameLayout 的测量</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;  </span><br><span class="line">....</span><br><span class="line"><span class="keyword">int</span> maxHeight = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> maxWidth = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> childState = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;    </span><br><span class="line">   <span class="keyword">final</span> View child = getChildAt(i);    </span><br><span class="line">   <span class="keyword">if</span> (mMeasureAllChildren || child.getVisibility() != GONE) &#123;   </span><br><span class="line">    <span class="comment">// 遍历自己的子View，只要不是GONE的都会参与测量，measureChildWithMargins方法在最上面</span></span><br><span class="line">    <span class="comment">// 的源码已经讲过了，如果忘了回头去看看，基本思想就是父View把自己当MeasureSpec </span></span><br><span class="line">    <span class="comment">// 传给子View结合子View自己的LayoutParams 算出子View 的MeasureSpec，然后继续往下穿，</span></span><br><span class="line">    <span class="comment">// 传递叶子节点，叶子节点没有子View，只要负责测量自己就好了。</span></span><br><span class="line">     measureChildWithMargins(child, widthMeasureSpec, <span class="number">0</span>, heightMeasureSpec, <span class="number">0</span>);      </span><br><span class="line">     ....</span><br><span class="line">     ....</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DecorView 测量ViewRoot 的时候把自己的widthMeasureSpec和heightMeasureSpec传进去了，接下来你就要去看measureChildWithMargins的源码了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChildWithMargins</span><span class="params">(View child, <span class="keyword">int</span> parentWidthMeasureSpec, <span class="keyword">int</span> widthUsed, <span class="keyword">int</span> parentHeightMeasureSpec, <span class="keyword">int</span> heightUsed)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();   </span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,            </span><br><span class="line">mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin + widthUsed, lp.width);    </span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,           </span><br><span class="line">mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin  + heightUsed, lp.height);  </span><br><span class="line"></span><br><span class="line">child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ViewRoot 是系统的View，它的LayoutParams默认都是match_parent,根据我们文章最开始MeasureSpec 的计算规则，ViewRoot 的MeasureSpec mode应该等于EXACTLY（DecorView MeasureSpec 的mode是EXACTLY，ViewRoot的layoutparams 是match_parent），size 也等于DecorView的size，所以ViewRoot的MeasureSpec图如下：<br><img src="https://upload-images.jianshu.io/upload_images/966283-ed0ffedcca47672a.png" alt="image"></p>
<p>算出ViewRoot的MeasureSpec 之后，开始调用ViewRoot.measure 方法去测量ViewRoot的大小，然而ViewRoot是一个LinearLayout ，ViewRoot.measure最终会执行的LinearLayout 的onMeasure 方法，LinearLayout 的onMeasure 方法又开始逐个测量它的子View，上面的measureChildWithMargins方法又会被调用，那么根据View的层级图，接下来测量的是header（ViewStub）,由于header的Gone，所以直接跳过不做测量工作，所以接下来轮到ViewRoot的第二个child content（android.R.id.content）,我们要算出这个content 的MeasureSpec，所以又要拿ViewRoot 的MeasureSpec 和 android.R.id.content的LayoutParams 做计算了，计算过程就是调用getChildMeasureSpec的方法，</p>
<p><img src="https://upload-images.jianshu.io/upload_images/966283-527eb25fd49d38ef.png" alt="image"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChildWithMargins</span><span class="params">(View child, <span class="keyword">int</span> parentWidthMeasureSpec, <span class="keyword">int</span> widthUsed, <span class="keyword">int</span> parentHeightMeasureSpec, <span class="keyword">int</span> heightUsed)</span> </span>&#123; </span><br><span class="line">   .....</span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,           </span><br><span class="line">mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin  + heightUsed, lp.height);  </span><br><span class="line">   ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getChildMeasureSpec</span><span class="params">(<span class="keyword">int</span> spec, <span class="keyword">int</span> padding, <span class="keyword">int</span> childDimension)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> specMode = MeasureSpec.getMode(spec);  <span class="comment">//获得父View的mode  </span></span><br><span class="line">    <span class="keyword">int</span> specSize = MeasureSpec.getSize(spec);  <span class="comment">//获得父View的大小  </span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">int</span> size = Math.max(<span class="number">0</span>, specSize - padding); <span class="comment">//父View的大小-自己的Padding+子View的Margin，得到值才是子View可能的最大值。  </span></span><br><span class="line">     .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由上面的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int size = Math.max(0, specSize - padding);</span><br></pre></td></tr></table></figure>
<p>而<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">padding=mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin + heightUsed</span><br></pre></td></tr></table></figure></p>
<p>算出android.R.id.content 的MeasureSpec 的size<br>由于ViewRoot 的mPaddingBottom=100px(这个可能和状态栏的高度有关，我们测量的最后会发现id/statusBarBackground的View的高度刚好等于100px，ViewRoot 是系统的View的它的Padding 我们没法改变，所以计算出来Content（android.R.id.content） 的MeasureSpec 的高度少了100px ，它的宽高的mode 根据算出来也是EXACTLY（ViewRoot 是EXACTLY和android.R.id.content 是match_parent）。所以Content（android.R.id.content）的MeasureSpec 如下（高度少了100px）：<br><img src="https://upload-images.jianshu.io/upload_images/966283-5ce615a3684d7815.png" alt="image"><br>Paste_Image.png<br>Content（android.R.id.content） 是FrameLayout，递归调用开始准备计算id/linear的MeasureSpec，我们先给出结果：<br><img src="https://upload-images.jianshu.io/upload_images/966283-c7e86f4510ddf84a.png" alt="image"></p>
<blockquote>
<p>图中有两个要注意的地方：<br>1、id/linear的heightMeasureSpec 的mode=AT_MOST，因为id/linear 的LayoutParams 的layout_height=”wrap_content”<br>2、id/linear的heightMeasureSpec 的size 少了200px, 由上面的代码<br>padding=mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin + heightUsed;<br>int size = Math.max(0, specSize - padding);<br>由于id/linear 的 android:layout_marginTop=”50dp” 使得lp.topMargin=200px (本设备的density=4，px=4*pd)，在计算后id/linear的heightMeasureSpec 的size 少了200px。（布局代码前面已给出，可自行查看id/linear 控件xml中设置的属性）</p>
</blockquote>
<p>linear.measure接着往下算linear的子View的的MeasureSpec，看下View 层级图，往下走应该是id/text,接下来是计算id/text的MeasureSpec，直接看图，mode=AT_MOST ,size 少了280，别问我为什么 …specSize - padding.<br><img src="https://upload-images.jianshu.io/upload_images/966283-058c5a6ce57b3125.png" alt="image"></p>
<p>算出id/text 的MeasureSpec 后，接下来text.measure(childWidthMeasureSpec, childHeightMeasureSpec);准备测量id/text 的高宽，这时候已经到底了，id/text是TextView，已经没有子类了，这时候跳到TextView的onMeasure方法了。TextView 拿着刚才计算出来的heightMeasureSpec（mode=AT_MOST,size=1980）,这个就是对TextView的高度和宽度的约束，进到TextView 的onMeasure(widthMeasureSpec,heightMeasureSpec) 方法，在onMeasure 方法执行调试过程中，我们发现下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int desired = getDesiredHeight(); desired = 107px</span><br><span class="line">if(heightMode == MeasureSpec.AT_MOST)&#123;</span><br><span class="line">    height = Math.min(desired,heightSize); height = 1980px</span><br><span class="line">   &#125;</span><br><span class="line">    setMeasuredDimension(width,height);</span><br></pre></td></tr></table></figure>
<p>TextView字符的高度（也就是TextView的content高度[wrap_content]）测出来=107px，107px 并没有超过1980px(允许的最大高度)，所以实际测量出来TextView的高度是107px。<br>最终算出id/text 的mMeasureWidth=1440px,mMeasureHeight=107px。</p>
<p>贴一下布局代码，免得你忘了具体布局。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;LinearLayout  xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    </span><br><span class="line">   android:id=&quot;@+id/linear&quot;</span><br><span class="line">   android:layout_width=&quot;match_parent&quot;    </span><br><span class="line">   android:layout_height=&quot;wrap_content&quot;    </span><br><span class="line">   android:layout_marginTop=&quot;50dp&quot;    </span><br><span class="line">   android:background=&quot;@android:color/holo_blue_dark&quot;    </span><br><span class="line">   android:paddingBottom=&quot;70dp&quot;    </span><br><span class="line">   android:orientation=&quot;vertical&quot;&gt;    </span><br><span class="line">   &lt;TextView        </span><br><span class="line">    android:id=&quot;@+id/text&quot;       </span><br><span class="line">    android:layout_width=&quot;match_parent&quot;     </span><br><span class="line">    android:layout_height=&quot;wrap_content&quot;  </span><br><span class="line">    android:background=&quot;@color/material_blue_grey_800&quot;       </span><br><span class="line">    android:text=&quot;TextView&quot;        </span><br><span class="line">    android:textColor=&quot;@android:color/white&quot;        </span><br><span class="line">    android:textSize=&quot;20sp&quot; /&gt;    </span><br><span class="line">   &lt;View       </span><br><span class="line">      android:id=&quot;@+id/view&quot;       </span><br><span class="line">     android:layout_width=&quot;match_parent&quot; </span><br><span class="line">     android:layout_height=&quot;150dp&quot;    </span><br><span class="line">     android:background=&quot;@android:color/holo_green_dark&quot; /&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure>
<p>TextView的高度已经测量出来了，接下来测量id/linear的第二个child（id/view），同样的原理测出id/view的MeasureSpec.</p>
<p><img src="https://upload-images.jianshu.io/upload_images/966283-55810a48922ac8fe.png" alt="image"><br>id/view的MeasureSpec 计算出来后，调用view.measure(childWidthMeasureSpec, childHeightMeasureSpec)的测量id/view的高宽，之前已经说过View measure的默认实现是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;    </span><br><span class="line">  setMeasuredDimension(</span><br><span class="line">  getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),            </span><br><span class="line">  getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终算出id/view的mMeasureWidth=1440px,mMeasureHeight=600px。</p>
<p>id/linear 的子View的高度都计算完毕了，接下来id/linear就通过所有子View的测量结果计算自己的高宽，id/linear是LinearLayout，所有它的高度计算简单理解就是子View的高度的累积+自己的Padding.<br><img src="https://upload-images.jianshu.io/upload_images/966283-b089fd286ca7fc05.png" alt="image"></p>
<p>最终算出id/linear的mMeasureWidth=1440px,mMeasureHeight=987px。</p>
<p>最终算出id/linear出来后，id/content 就要根据它唯一的子View id/linear 的测量结果和自己的之前算出的MeasureSpec一起来测量自己的结果，具体计算的逻辑去看FrameLayout onMeasure 函数的计算过程。以此类推，接下来测量ViewRoot,然后再测量id/statusBarBackground,虽然不知道id/statusBarBackground 是什么，但是调试的过程中，测出的它的高度=100px, 和 id/content 的paddingTop 刚好相等。在最后测量DecorView 的高宽，最终整个测量过程结束。所有的View的大小测量完毕。所有的getMeasureWidth 和 getMeasureWidth 都已经有值了。Measure 分析到此为止</p>
<h1 id="layout过程"><a href="#layout过程" class="headerlink" title="layout过程"></a>layout过程</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mView.measure(childWidthMeasureSpec, childHeightMeasureSpec); </span><br><span class="line">......</span><br><span class="line">mView.layout(0, 0, mView.getMeasuredWidth(), mView.getMeasuredHeight());</span><br></pre></td></tr></table></figure>
<p>performTraversals 方法执行完mView.measure 计算出mMeasuredXXX后就开始执行layout 函数来确定View具体放在哪个位置，我们计算出来的View目前只知道view矩阵的大小，具体这个矩阵放在哪里，这就是layout 的工作了。layout的主要作用 ：根据子视图的大小以及布局参数将View树放到合适的位置上。</p>
<p>既然是通过mView.layout(0, 0, mView.getMeasuredWidth(), mView.getMeasuredHeight()); 那我们来看下layout 函数做了什么，mView肯定是个ViewGroup，不会是View,我们直接看下ViewGroup 的layout函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">layout</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;    </span><br><span class="line">   <span class="keyword">if</span> (!mSuppressLayout &amp;&amp; (mTransition == <span class="keyword">null</span> || !mTransition.isChangingLayout())) &#123;        </span><br><span class="line">    <span class="keyword">if</span> (mTransition != <span class="keyword">null</span>) &#123;            </span><br><span class="line">       mTransition.layoutChange(<span class="keyword">this</span>);        </span><br><span class="line">    &#125;       </span><br><span class="line">    <span class="keyword">super</span>.layout(l, t, r, b);    </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;        </span><br><span class="line">    <span class="comment">// record the fact that we noop'd it; request layout when transition finishes        </span></span><br><span class="line">      mLayoutCalledWhileSuppressed = <span class="keyword">true</span>;    </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码可以看个大概，LayoutTransition是用于处理ViewGroup增加和删除子视图的动画效果，也就是说如果当前ViewGroup未添加LayoutTransition动画，或者LayoutTransition动画此刻并未运行，那么调用super.layout(l, t, r, b)，继而调用到ViewGroup中的onLayout，否则将mLayoutSuppressed设置为true，等待动画完成时再调用requestLayout()。<br>这个函数是final 不能重写，所以ViewGroup的子类都会调用这个函数，layout 的具体实现是在super.layout(l, t, r, b)里面做的，那么我接下来看一下View类的layout函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">layout</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">       .....</span><br><span class="line">      <span class="comment">//设置View位于父视图的坐标轴</span></span><br><span class="line">       <span class="keyword">boolean</span> changed = setFrame(l, t, r, b); </span><br><span class="line">       <span class="comment">//判断View的位置是否发生过变化，看有必要进行重新layout吗</span></span><br><span class="line">       <span class="keyword">if</span> (changed || (mPrivateFlags &amp; LAYOUT_REQUIRED) == LAYOUT_REQUIRED) &#123;</span><br><span class="line">           <span class="keyword">if</span> (ViewDebug.TRACE_HIERARCHY) &#123;</span><br><span class="line">               ViewDebug.trace(<span class="keyword">this</span>, ViewDebug.HierarchyTraceType.ON_LAYOUT);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//调用onLayout(changed, l, t, r, b); 函数</span></span><br><span class="line">           onLayout(changed, l, t, r, b);</span><br><span class="line">           mPrivateFlags &amp;= ~LAYOUT_REQUIRED;</span><br><span class="line">       &#125;</span><br><span class="line">       mPrivateFlags &amp;= ~FORCE_LAYOUT;</span><br><span class="line">       .....</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>1、setFrame(l, t, r, b) 可以理解为给mLeft 、mTop、mRight、mBottom赋值，然后基本就能确定View自己在父视图的位置了，这几个值构成的矩形区域就是该View显示的位置，这里的具体位置都是相对与父视图的位置。</p>
<p>2、回调onLayout，对于View来说，onLayout只是一个空实现，一般情况下我们也不需要重载该函数,：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>对于ViewGroup 来说，唯一的差别就是ViewGroup中多了关键字abstract的修饰，要求其子类必须重载onLayout函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Override  </span><br><span class="line">protected abstract void onLayout(boolean changed,  </span><br><span class="line">        int l, int t, int r, int b);</span><br></pre></td></tr></table></figure>
<p>而重载onLayout的目的就是安排其children在父视图的具体位置，那么如何安排子View的具体位置呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int childCount = getChildCount() ; </span><br><span class="line">  for(int i=0 ;i&lt;childCount ;i++)&#123;</span><br><span class="line">       View child = getChildAt(i) ;</span><br><span class="line">       //整个layout()过程就是个递归过程</span><br><span class="line">       child.layout(l, t, r, b) ;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>代码很简单，就是遍历自己的孩子，然后调用 child.layout(l, t, r, b) ，给子view 通过setFrame(l, t, r, b) 确定位置，而重点是(l, t, r, b) 怎么计算出来的呢。还记得我们之前测量过程，测量出来的MeasuredWidth和MeasuredHeight吗？还记得你在xml 设置的Gravity吗？还有RelativeLayout 的其他参数吗，没错，就是这些参数和MeasuredHeight、MeasuredWidth 一起来确定子View在父视图的具体位置的。具体的计算过程大家可以看下最简单FrameLayout 的onLayout 函数的源码，每个不同的ViewGroup 的实现都不一样，这边不做具体分析了吧。</p>
<p>3、MeasuredWidth和MeasuredHeight这两个参数为layout过程提供了一个很重要的依据（如果不知道View的大小，你怎么固定四个点的位置呢），但是这两个参数也不是必须的，layout过程中的4个参数l, t, r, b完全可以由我们任意指定，而View的最终的布局位置和大小（mRight - mLeft=实际宽或者mBottom-mTop=实际高）完全由这4个参数决定，measure过程得到的mMeasuredWidth和mMeasuredHeight提供了视图大小测量的值，但我们完全可以不使用这两个值，所以measure过程并不是必须的。如果我们不使用这两个值，那么getMeasuredWidth() 和getWidth() 就很有可能不是同一个值，它们的计算是不一样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getMeasuredWidth</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> mMeasuredWidth &amp; MEASURED_SIZE_MASK;  </span><br><span class="line">    &#125;  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getWidth</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> mRight - mLeft;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>layout 过程相对简单些，分析就到此为止。</p>
<h1 id="draw过程"><a href="#draw过程" class="headerlink" title="draw过程"></a>draw过程</h1><p>performTraversals 方法的下一步就是mView.draw(canvas); 因为View的draw 方法一般不去重写，官网文档也建议不要去重写draw 方法，所以下一步执行就是View.java的draw 方法，我们来看下源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Draw traversal performs several drawing steps which must be executed</span></span><br><span class="line"><span class="comment">         * in the appropriate order:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *      1. Draw the background</span></span><br><span class="line"><span class="comment">         *      2. If necessary, save the canvas' layers to prepare for fading</span></span><br><span class="line"><span class="comment">         *      3. Draw view's content</span></span><br><span class="line"><span class="comment">         *      4. Draw children</span></span><br><span class="line"><span class="comment">         *      5. If necessary, draw the fading edges and restore layers</span></span><br><span class="line"><span class="comment">         *      6. Draw decorations (scrollbars for instance)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Step 1, draw the background, if needed</span></span><br><span class="line">    ...</span><br><span class="line">        background.draw(canvas);</span><br><span class="line">    ...</span><br><span class="line">        <span class="comment">// skip step 2 &amp; 5 if possible (common case)</span></span><br><span class="line">    ...</span><br><span class="line">        <span class="comment">// Step 2, save the canvas' layers</span></span><br><span class="line">    ...</span><br><span class="line">        <span class="keyword">if</span> (solidColor == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> flags = Canvas.HAS_ALPHA_LAYER_SAVE_FLAG;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (drawTop) &#123;</span><br><span class="line">                canvas.saveLayer(left, top, right, top + length, <span class="keyword">null</span>, flags);</span><br><span class="line">            &#125;</span><br><span class="line">    ...</span><br><span class="line">        <span class="comment">// Step 3, draw the content</span></span><br><span class="line">        <span class="keyword">if</span> (!dirtyOpaque) onDraw(canvas);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Step 4, draw the children</span></span><br><span class="line">        dispatchDraw(canvas);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Step 5, draw the fade effect and restore layers</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (drawTop) &#123;</span><br><span class="line">            matrix.setScale(<span class="number">1</span>, fadeHeight * topFadeStrength);</span><br><span class="line">            matrix.postTranslate(left, top);</span><br><span class="line">            fade.setLocalMatrix(matrix);</span><br><span class="line">            canvas.drawRect(left, top, right, top + length, p);</span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br><span class="line">        <span class="comment">// Step 6, draw decorations (scrollbars)</span></span><br><span class="line">        onDrawScrollBars(canvas);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>注释写得比较清楚，一共分成6步，看到注释没有（ // skip step 2 &amp; 5 if possible (common case)）除了2 和 5之外 我们一步一步来看：<br>1、第一步：背景绘制<br>看注释即可，不是重点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private void drawBackground(Canvas canvas) &#123; </span><br><span class="line">     Drawable final Drawable background = mBackground; </span><br><span class="line">      ...... </span><br><span class="line">     //mRight - mLeft, mBottom - mTop layout确定的四个点来设置背景的绘制区域 </span><br><span class="line">     if (mBackgroundSizeChanged) &#123; </span><br><span class="line">        background.setBounds(0, 0, mRight - mLeft, mBottom - mTop);   </span><br><span class="line">        mBackgroundSizeChanged = false; rebuildOutline(); </span><br><span class="line">     &#125; </span><br><span class="line">     ...... </span><br><span class="line">     //调用Drawable的draw() 把背景图片画到画布上</span><br><span class="line">     background.draw(canvas); </span><br><span class="line">     ...... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、第三步，对View的内容进行绘制。<br>onDraw(canvas) 方法是view用来draw 自己的，具体如何绘制，颜色线条什么样式就需要子View自己去实现，View.java 的onDraw(canvas) 是空实现，ViewGroup 也没有实现，每个View的内容是各不相同的，所以需要由子类去实现具体逻辑。</p>
<p>3、第4步 对当前View的所有子View进行绘制<br>dispatchDraw(canvas) 方法是用来绘制子View的，View.java 的dispatchDraw()方法是一个空方法,因为View没有子View,不需要实现dispatchDraw ()方法，ViewGroup就不一样了，它实现了dispatchDraw ()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"> protected void dispatchDraw(Canvas canvas) &#123;</span><br><span class="line">       ...</span><br><span class="line">        if ((flags &amp; FLAG_USE_CHILD_DRAWING_ORDER) == 0) &#123;</span><br><span class="line">            for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">                final View child = children[i];</span><br><span class="line">                if ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) &#123;</span><br><span class="line">                    more |= drawChild(canvas, child, drawingTime);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">                final View child = children[getChildDrawingOrder(count, i)];</span><br><span class="line">                if ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) &#123;</span><br><span class="line">                    more |= drawChild(canvas, child, drawingTime);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>代码一眼看出，就是遍历子View然后drawChild(),drawChild()方法实际调用的是子View.draw()方法,ViewGroup类已经为我们实现绘制子View的默认过程，这个实现基本能满足大部分需求，所以ViewGroup类的子类（LinearLayout,FrameLayout）也基本没有去重写dispatchDraw方法，我们在实现自定义控件，除非比较特别，不然一般也不需要去重写它， drawChild()的核心过程就是为子视图分配合适的cavas剪切区，剪切区的大小正是由layout过程决定的，而剪切区的位置取决于滚动值以及子视图当前的动画。设置完剪切区后就会调用子视图的draw()函数进行具体的绘制了。</p>
<p>4、第6步 对View的滚动条进行绘制<br>不是重点，知道有这东西就行，onDrawScrollBars 的一句注释 ：Request the drawing of the horizontal and the vertical scrollbar. The scrollbars are painted only if they have been awakened first.</p>
<p>一张图看下整个draw的递归流程。</p>
<p>到此整个绘制过程基本讲述完毕了。</p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://wenyiqingnian.xyz/2017/10/12/view 绘制机制/" data-id="cjl3hswwg001fum8xm2eijahl" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    
        <a href="http://wenyiqingnian.xyz/2017/10/12/view 绘制机制/#comments" class="article-comment-link">Comments</a>
    

        </footer>
    </div>
    
</article>



    <article id="post-Linux 用户空间 内核空间" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2017/09/07/Linux 用户空间 内核空间/">linux用户控件、内和空间</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2017/09/07/Linux 用户空间 内核空间/">
            <time datetime="2017-09-07T12:30:15.000Z" itemprop="datePublished">2017-09-07</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/Linux/">Linux</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/linux/">linux</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p>用户空间就是用户进程所在的内存区域，相对的，系统空间就是操作系统占据的内存区域。</p>
<p>用户进程和系统进程的所有数据都在内存中。<br>  是谁来划分内存空间的呢？</p>
<p>  在电脑开机之前，内存就是一块原始的物理内存。什么也没有。开机加电，系统启动后，就对物理内存进行了划分。当然，这是系统的规定，物理内存条上并没有划分好的地址和空间范围。这些划分都是操作系统在逻辑上的划分。不同版本的操作系统划分的结果都是不一样的。<br>  为什么要划分用户空间和系统空间呢？当然是有必要的。操作系统的数据都是存放于系统空间的，用户进程的数据是存放于用户空间的。这是第一点，不同的身份，数据放置的位置必然不一样，否则大混战就会导致系统的数据和用户的数据混在一起，系统就不能很好的运行了。分开来存放，就让系统的数据和用户的数据互不干扰，保证系统的稳定性。分开存放，管理上很方便，而更重要的是，将用户的数据和系统的数据隔离开，就可以对两部分的数据的访问进行控制。这样就可以确保用户程序不能随便操作系统的数据，这样防止用户程序误操作或者是恶意破坏系统。</p>
<p>处于用户态的程序只能访问用户空间，而处于内核态的程序可以访问用户空间和内核空间。那么用户态和内核态有什么区别呢？</p>
<p>当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）。此时处理器处于特权级最高的（0级）内核代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。当进程在执行用户自己的代码时，则称其处于用户运行态（用户态）。即此时处理器在特权级最低的（3级）用户代码中运行。</p>
<p>内核态与用户态是操作系统的两种运行级别,Intel x86架构提供Ring0-Ring3四种级别的运行模式，Ring0级别最高，Ring3最低。Linux使用了Ring3级别运行用户态，Ring0作为 内核态，没有使用Ring1和Ring2。Ring3状态不能访问Ring0的地址空间，包括代码和数据。程序特权级别的不同，其所拥有的权力也不同。如下图所示。</p>
<p><img src="https://img-blog.csdn.net/20170610171008637?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzQyMjg1NzA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="image"></p>
<p>用户态切换到内核态的3种方式</p>
<h4 id="a-系统调用"><a href="#a-系统调用" class="headerlink" title="a. 系统调用"></a>a. 系统调用</h4><blockquote>
<p>这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作，比如fork()实际上就是执行了一个创建新进程的系统调用。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断。</p>
</blockquote>
<h4 id="b-异常"><a href="#b-异常" class="headerlink" title="b. 异常"></a>b. 异常</h4><blockquote>
<p>当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。</p>
</blockquote>
<h4 id="c-外围设备的中断"><a href="#c-外围设备的中断" class="headerlink" title="c. 外围设备的中断"></a>c. 外围设备的中断</h4><blockquote>
<p>当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。</p>
</blockquote>
<p>这3种方式是系统在运行时由用户态转到内核态的最主要方式，其中系统调用可以认为是用户进程主动发起的，异常和外围设备中断则是被动的。</p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://wenyiqingnian.xyz/2017/09/07/Linux 用户空间 内核空间/" data-id="cjl3hswvv000cum8x2ta7lkqb" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    
        <a href="http://wenyiqingnian.xyz/2017/09/07/Linux 用户空间 内核空间/#comments" class="article-comment-link">Comments</a>
    

        </footer>
    </div>
    
</article>



    <article id="post-webrtc 音频" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2017/08/16/webrtc 音频/">webrtc音频总结</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2017/08/16/webrtc 音频/">
            <time datetime="2017-08-16T13:10:30.000Z" itemprop="datePublished">2017-08-16</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/webrtc/">webrtc</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/webrtc/">webrtc</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p>webrtc/modules/audio_device/android/audio_record_jni.cc</p>
<p>这个文件，是音频采集jni类文件。</p>
<p>Android Audio Record 和 JNI 通信接口包括：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// java 调用 c++ 接口</span><br><span class="line">nativeCacheDirectBufferAddress</span><br><span class="line">nativeDataIsRecorded</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// c++ 回调 java 接口</span><br><span class="line">initRecording</span><br><span class="line">startRecording</span><br><span class="line">stopRecording</span><br><span class="line">enableBuiltInAEC</span><br><span class="line">enableBuiltInNS</span><br></pre></td></tr></table></figure>
<p>nativeCacheDirectBufferAddress 和 nativeDataIsRecorded 只是为了高效的将 AudioRecord 采集到的音频数据传递给 native。</p>
<h1 id="WebRtcVoiceEngine"><a href="#WebRtcVoiceEngine" class="headerlink" title="WebRtcVoiceEngine"></a>WebRtcVoiceEngine</h1><p>WebRtcVoiceEngine 初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">WebRtcVoiceEngine::Init()&#123;</span><br><span class="line">    send_codecs_ = CollectCodecs(encoder_factory_-&gt;GetSupportedEncoders());</span><br><span class="line">    recv_codecs_ = CollectCodecs(decoder_factory_-&gt;GetSupportedDecoders());</span><br><span class="line"></span><br><span class="line">    adm_ = webrtc::AudioDeviceModule::Create(</span><br><span class="line">        webrtc::AudioDeviceModule::kPlatformDefaultAudio</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    webrtc::adm_helpers::Init(adm());</span><br><span class="line">    webrtc::apm_helpers::Init(apm());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可知，WebRtcVoiceEngine 里面的 adm_ 就是 AudioDeviceModule ，代码在 /modules/audio_device/audio_device_impl.cc</p>
<p>在 webrtcvoiceengine.h<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// WebRtcVoiceEngine</span><br><span class="line"></span><br><span class="line">//public </span><br><span class="line">void Init();</span><br><span class="line">AudioState GetAudioState();</span><br><span class="line">VoiceMediaChannel* CreateChannel(Call call, MediaConfig config, AudioOptions options);</span><br><span class="line">AudioCodec send_codecs();</span><br><span class="line">AudioCodec recv_codecs();</span><br><span class="line">RtpCapabilities GetCapabilities();</span><br><span class="line"></span><br><span class="line">void RegisterChannel(WebRtcVoiceMediaChannel* channel);</span><br><span class="line">void UnregisterChannel(WebRtcVoiceMediaChannel* channel);</span><br><span class="line"></span><br><span class="line">bool StartAecDump();</span><br><span class="line">void StopAecDump();</span><br><span class="line"></span><br><span class="line">//private</span><br><span class="line">AudioDeviceModule adm_;</span><br><span class="line">AudioEncoderFactory encoder_factory_;</span><br><span class="line">AudioDecoderFactory decoder_factory_;</span><br><span class="line">AudioMixer audio_mixer_;</span><br><span class="line">AudioProcessing apm_;</span><br><span class="line">AudioState audio_state_;</span><br><span class="line">AudioCodec send_codecs_;</span><br><span class="line">AudioCodec recv_codecs_;</span><br><span class="line"></span><br><span class="line">WebRtcVoiceMediaChannel channels_;</span><br></pre></td></tr></table></figure></p>
<h2 id="audio-device"><a href="#audio-device" class="headerlink" title="audio_device"></a>audio_device</h2><p>//webrtc/modules/audio_device/</p>
<p>audio_device_impl.cc</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">AudioDeviceModule::Create()&#123;</span><br><span class="line">    audioDevice(new AudioDeviceModuleImpl(audio_layer));</span><br><span class="line"></span><br><span class="line">    audioDevice-&gt;CheckPlatform();</span><br><span class="line">    audioDevice-&gt;CreatePlatformSpecificObjects();</span><br><span class="line">    audioDevice-&gt;AttachAudioBuffer();</span><br><span class="line"></span><br><span class="line">    return audioDevice;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">AudioDeviceModuleImpl::CreatePlatformSpecificObjects()&#123;</span><br><span class="line">    // WEBRTC_DUMMY_AUDIO_BUILD</span><br><span class="line">    audio_device_.reset(new AudioDeviceDummy());</span><br><span class="line">    // WEBRTC_DUMMY_FILE_DEVICES</span><br><span class="line">    audio_device_.reset(FileAudioFactory::CreateFileAudioDevice());</span><br><span class="line"></span><br><span class="line">    // WEBRTC_WINDOWS_CORE_AUDIO_BUILD</span><br><span class="line">    audio_device_.reset(new AudioDeviceWindowsCore());</span><br><span class="line"></span><br><span class="line">    // WEBRTC_ANDROID</span><br><span class="line">    audio_manager_android_.reset(new AudioManager());</span><br><span class="line">    if(audio_layer == kPlatformDefaultAudio)&#123;</span><br><span class="line">        audio_layer = kAndroidOpenSLESAudio;</span><br><span class="line">    &#125; else if(isLowLatencySupported)&#123;</span><br><span class="line">        audio_layer = kAndroidJavaInputAndroidOpenSLESOutputAudio;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        audio_layer = kAndroidJavaAudio;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(kAndroidJavaAudio)&#123;</span><br><span class="line">        audio_device_.reset(new AudioDeviceTemplate&lt;AudioRecordJni, AudioTrackJni&gt;())</span><br><span class="line">    &#125; else if(kAndroidOpenSLESAudio)&#123;</span><br><span class="line">        audio_device_.reset(new AudioDeviceTemplate&lt;OpenSLESRecorder, OpenSLESPlayer&gt;());</span><br><span class="line">    &#125; else if(kAndroidJavaInputAndOpenSLESOutputAudio)&#123;</span><br><span class="line">        audio_device_.reset(new AudioDeviceTemplate&lt;AudioRecordJni, OpenSLESPlayer&gt;())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // WEBRTC_LINUX</span><br><span class="line">    if(kLinuxPulseAudio || kPlatformDefaultAudio)&#123;</span><br><span class="line">        audio_device_.reset(new AudioDeviceLinuxPulse())</span><br><span class="line">    &#125; else if(kLinuxAlsaAudio)&#123;</span><br><span class="line">        audio_device_.reset(new AudioDeviceLinuxALSA())</span><br><span class="line">    &#125;</span><br><span class="line">    // WEBRTC_IOS</span><br><span class="line">    audio_device_.reset(new AudioDeviceIOS())</span><br><span class="line">    // WEBRTC_MAC</span><br><span class="line">    audio_device_.reset(new AudioDeviceMac())</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们以 Android 为例；使用 AudioDeviceTemplate 封装 音频输入（采集）、输出类型（渲染）；<br>目前使用 AudioRecordJni 和 AudioTrackJni。<br>如果直接使用 NDK 的openSLES 开发的化，使用的是 OpenSLESRecorder 和 OpenSLESPlayer。</p>
<p>audio_manager.h<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// JavaAudioManager</span><br><span class="line">bool Init()</span><br><span class="line">void Close()</span><br><span class="line">bool IsCommunicationModeEnabled()</span><br><span class="line">bool IsDeviceBlacklistedForOpenSLESUsage()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// private</span><br><span class="line">JNICALL CacheAudioParameters()</span><br><span class="line">void OnCacheAudioParameters()</span><br></pre></td></tr></table></figure></p>
<p>audio_record_jni.h<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//JavaAudioRecord</span><br><span class="line">int InitRecording(int sample_reate, size_t channels);</span><br><span class="line">bool StartRecording();</span><br><span class="line">bool StopRecording();</span><br><span class="line">bool EnableBuiltInAEC(bool enable);</span><br><span class="line">bool EnableBuiltInNS(bool enable);</span><br><span class="line"></span><br><span class="line">// public</span><br><span class="line">int32_t Init();</span><br><span class="line">int32_t Terminate();</span><br><span class="line"></span><br><span class="line">int32_t InitRecording();</span><br><span class="line">bool RecordingIsInitialized();</span><br><span class="line"></span><br><span class="line">int32_t StartRecording();</span><br><span class="line">int32_t StopRecording();</span><br><span class="line">bool Recording();</span><br><span class="line"></span><br><span class="line">void AttachAudioBuffer();</span><br><span class="line">int32_t EnableBuiltInAEC(bool enable);</span><br><span class="line">int32_t EnableBuiltInAGC(bool enable);</span><br><span class="line">int32_t EnableBuiltInNS(bool enable);</span><br><span class="line"></span><br><span class="line">// private</span><br><span class="line">JNICALL CacheDirectBufferAddress()</span><br><span class="line">void OnCacheDirectBufferAddress(jobject byte_buffer)</span><br><span class="line"></span><br><span class="line">JNICALL DataIsRecorded();</span><br><span class="line">void OnDataIsRecorded(int length);</span><br></pre></td></tr></table></figure></p>
<p>audio_track_jni.h</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// JavaAudioTrack</span><br><span class="line">bool InitPlayout(int sample_rate, int channels);</span><br><span class="line">bool StartPlayout();</span><br><span class="line">bool StopPlayout();</span><br><span class="line">bool SetStreamVolume(int volume);</span><br><span class="line">int GetStreamMaxVolume();</span><br><span class="line">int GetStreamVolume();</span><br><span class="line"></span><br><span class="line">// public</span><br><span class="line">Init()</span><br><span class="line">Terminate()</span><br><span class="line">InitPlayout()</span><br><span class="line">PlayoutIsInitialized()</span><br><span class="line">StartPlayout()</span><br><span class="line">StopPlayout()</span><br><span class="line">Playing()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SpeakerVolumeIsAvailable(bool available);</span><br><span class="line">SetSpeakerVolume(volume);</span><br><span class="line">SpeakerVolume(volume);</span><br><span class="line">MaxSpeakerVolume(max_volume);</span><br><span class="line">MinSpeakerVolume(min_volume);</span><br><span class="line">AttachAudioBuffer(audioBuffer);</span><br><span class="line"></span><br><span class="line">// private</span><br><span class="line">JNICALL CacheDirectBufferAddress();</span><br><span class="line">void OnCacheDirectBufferAddress(jobject byte_buffer);</span><br><span class="line"></span><br><span class="line">JNICALL GetPlayoutData();</span><br><span class="line">void OnGetPlayoutData(size_t length);</span><br></pre></td></tr></table></figure>
<h3 id="AudioRecordJni"><a href="#AudioRecordJni" class="headerlink" title="AudioRecordJni"></a>AudioRecordJni</h3><h4 id="音频采集初始化"><a href="#音频采集初始化" class="headerlink" title="音频采集初始化"></a>音频采集初始化</h4><p>AudioRecordJni 初始化时，在构造方法中初始化 JavaAudioRecord。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">j_audio-record_.reset(</span><br><span class="line">    new JavaAudioRecord()</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>然后在 webrtcvoiceengine 中 AddSendStream 后，SetSend() 配置媒体通道发送。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//media/engine/webrtcvoiceengine.cc</span><br><span class="line">WebRtcVoiceMediaChannel::SetSend(bool send)&#123;</span><br><span class="line">    ...</span><br><span class="line">    if(send)&#123;</span><br><span class="line">        engine()-&gt;ApplyOptions(options_);</span><br><span class="line">        if(!engine()-&gt;adm()-&gt;RecordingIsInitialized() </span><br><span class="line">        &amp;&amp; !engine()-&gt;adm()-&gt;Recording())&#123;</span><br><span class="line"></span><br><span class="line">            engine()-&gt;adm()-&gt;InitRecording();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里面会初始化 AudioRecord。</p>
<p>InitRecording() 方法实现，在 Android 中实在 audio_record_jni.cc 的 JavaAudioRecord::InitRecording() ，最终通过 JNI 回调 Java 层的 InitRecording() 方法。</p>
<h4 id="音频采集"><a href="#音频采集" class="headerlink" title="音频采集"></a>音频采集</h4><p>初始化完成后，就要开始采集音频数据。</p>
<p>/audio/audio_send_stream.cc<br>音频发送流里面 AudioSendStream::Start() 方法启动音频流发送；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AudioSendSstream::Start()&#123;</span><br><span class="line">    channel_proxy_-&gt;StartSend();</span><br><span class="line">    audio_state()-&gt;AddSendingStream(this, encoder_sample_rate_hz_, encoder_num_channels_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用 /audio/audio_state.cc 的 AudioState::AddSendingStream() 方法；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">AudioState::AddSendingStream()&#123;</span><br><span class="line">    auto* adm = config_.audio_device_module.get();</span><br><span class="line">    ...</span><br><span class="line">    amd-&gt;StartRecording();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="音频开关"><a href="#音频开关" class="headerlink" title="音频开关"></a>音频开关</h4><p>另外，PeerConnection 提供了 音频采集开关。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//org.webrtc.PeerConnection.java</span><br><span class="line">public void setAudioRecording(boolean recording)&#123;</span><br><span class="line">    nativeSetAudioRecording();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应的JNI方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//JNI/pc/peerconnection.cc</span><br><span class="line">void JNI_PeerConnection_SetAudioRecording()&#123;</span><br><span class="line">    ExtractNativePC(jni,j_pc)-&gt;SetAudioRecording(recording);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其实JNI方法也是调用 webrtc 的 peerconnection</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//webrtc/pc/peerconnection.cc</span><br><span class="line">PeerConnection::SetAudioRecording(bool recording)&#123;</span><br><span class="line">    auto audio_state = </span><br><span class="line">        factory_-&gt;channel_manager()-&gt;media_engine()-&gt;GetAudioState();</span><br><span class="line">    // AudioState</span><br><span class="line">    audio_state-&gt;SetRecording(recording);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由上代码可知， 通过 WebRtcVoiceEngine 的 GetAudioState() 方法获取 audio_state。<br>然后通过 audio_state 设置音频采集开关。</p>
<p>在 AudioState::SetRecording() 方法调用具体设备模块开始或停止音频采集。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//webrtc/audio/audio_state.cc</span><br><span class="line">AudioState::SetRecording(bool enabled)&#123;</span><br><span class="line">    ...</span><br><span class="line">    if(enabled)&#123;</span><br><span class="line">        config_.audio_device_module-&gt;StartRecording();</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        config_.audio_device_module-&gt;StopRecording();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="音频采集具体实现"><a href="#音频采集具体实现" class="headerlink" title="音频采集具体实现"></a>音频采集具体实现</h4><p>这里我们只以Android为例。</p>
<p>如果使用 opensles ndk 采集音频，采集的具体实现在 opensles_recorder.cc 文件的 StartRecording() 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// modules/audio_device/android/opensles_recorder.cc</span><br><span class="line">int OpenSLESRecorder::StartRecording()&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方法的具体实现我们暂时不深入。</p>
<p>我们讨论 java 实现方案。</p>
<p>java 实现的jni类，audio_record_jni.cc<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//modules/audio_device/android/audio_record_jni.cc</span><br><span class="line">AudioRecordJni::StartRecording()&#123;</span><br><span class="line">    ...</span><br><span class="line">    j_audio_record_-&gt;StartRecording()</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>j_audio_record_-&gt;StartRecording() 调用的就是 AudioRecordJni::JavaAudioRecord::StartRecording() 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AudioRecordJni::JavaAudioRecord::StartRecording()&#123;</span><br><span class="line">    return audio_record_-&gt;CallBooleanMethod(start_recording_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CallBooleanMethod 就是jni回调java 实现的封装，最终实现回调 WebRtcAudioRecord.java 中的 StartRecording() 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//org.webrtc.voiceengine.WebRtcAudioRecord.java </span><br><span class="line">boolean startRecording()&#123;</span><br><span class="line">    audioRecord.startRecording();</span><br><span class="line">    audioThread = new AudioRecordThread(&quot;AudioRecordJavaThread&quot;);</span><br><span class="line">    audioThread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="音频采集线程"><a href="#音频采集线程" class="headerlink" title="音频采集线程"></a>音频采集线程</h4><p>音频采集线 AudioRecordThread；我们只跟踪 run() 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void run()&#123;</span><br><span class="line">    ...</span><br><span class="line">    while(keepAlive)&#123;</span><br><span class="line">        int bytesRead = audioRecord.read(byteBuffer, byteBuffer.capacity());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        // 通知 native 音频数据</span><br><span class="line">        nativeDataIsRecorded(bytesRead, nativeAudioRecord);</span><br><span class="line"></span><br><span class="line">        // 应用音频采集回调</span><br><span class="line">        byte[] data = Arrays.copyOf(byteBuffer.array(), byteBuffer.capacity());</span><br><span class="line">        audioSamplesReadyCallback.onWebRtcAudioRecordSamplesReady(</span><br><span class="line">            new AudioSamples(audioRecord, data)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://wenyiqingnian.xyz/2017/08/16/webrtc 音频/" data-id="cjl3hswwc0016um8xcpl8aitz" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    
        <a href="http://wenyiqingnian.xyz/2017/08/16/webrtc 音频/#comments" class="article-comment-link">Comments</a>
    

        </footer>
    </div>
    
</article>



    <article id="post-linux的地址映射" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2017/06/18/linux的地址映射/">linux的地址映射</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2017/06/18/linux的地址映射/">
            <time datetime="2017-06-18T12:30:15.000Z" itemprop="datePublished">2017-06-18</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/Linux/">Linux</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/linux/">linux</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="1-物理内存"><a href="#1-物理内存" class="headerlink" title="1 物理内存"></a>1 物理内存</h2><p>Linux 内存的最小单位为页，一页通常是4K，初始化时，linux 会为每个物理内存建立一个page的管理结构，操作物理内存时 实际上就是操作page。</p>
<h2 id="2-进程内存"><a href="#2-进程内存" class="headerlink" title="2 进程内存"></a>2 进程内存</h2><p>Linux 进程是通过<code>vma</code>进行管理的，每一个进程都有一个<code>task_struct</code> 结构体进行维护，其中<code>mm_struct</code>结构体管理进程内的所有内存。<br><code>mm_struct</code> 的结构如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> * <span class="title">mmap</span>;</span> <span class="comment">/* list of VMAs */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> map_count; <span class="comment">/* number of VMAs */</span></span><br></pre></td></tr></table></figure>
<p>可以看到 <code>mm_struct</code> 中有个<code>vma</code>链表，其中每个<code>vma</code>节点对应一段连续内存，（在进程的虚拟地址空间是连续的，物理空间中不一定）。当使用<code>malloc</code> 申请内存时，内核会给进程增加<code>vma</code>节点。</p>
<p>对于32位的linux 操作系统，为每一个进程分配的寻址空间都是4g，linux将这4g的虚拟内存分为两部分</p>
<ol>
<li>用户空间 0-3g</li>
<li>内核空间 3-4g</li>
</ol>
<h3 id="用户空间和内核空间"><a href="#用户空间和内核空间" class="headerlink" title="用户空间和内核空间"></a>用户空间和内核空间</h3><p>linux将 进程虚拟地址中的0-3g空间 用作用户空间.</p>
<h4 id="为什么会有用户控件和内核空间的划分"><a href="#为什么会有用户控件和内核空间的划分" class="headerlink" title="为什么会有用户控件和内核空间的划分"></a>为什么会有用户控件和内核空间的划分</h4><p>是为了将用户空间与内核空间区分开，为了访问安全<br>Linux使用两级保护机制：0级供内核使用，3级供用户程序使用。每个进程有各自的私有用户空间（0～3G），这个空间对系统中的其他进程是不可见的。如果要访问内核空间，会有优先级的限制从而在一定程度上保护了内核空间的安全性。</p>
<h4 id="为什么会按照内核空间1g，用户空间3g来划分。"><a href="#为什么会按照内核空间1g，用户空间3g来划分。" class="headerlink" title="为什么会按照内核空间1g，用户空间3g来划分。"></a>为什么会按照内核空间1g，用户空间3g来划分。</h4><p>这个比例其实并不是固定的，它可以是一个人为设定值，可以通过重新编译linux内核来实现更改。</p>
<h4 id="进程只分配了4g虚拟内存，如果物理内存大于4g，如何做到访问其余的内存呢"><a href="#进程只分配了4g虚拟内存，如果物理内存大于4g，如何做到访问其余的内存呢" class="headerlink" title="进程只分配了4g虚拟内存，如果物理内存大于4g，如何做到访问其余的内存呢"></a>进程只分配了4g虚拟内存，如果物理内存大于4g，如何做到访问其余的内存呢</h4><p>这里涉及到高端地址的概念了</p>
<p>当内核模块代码或线程访问内存时，代码中的内存地址都为逻辑地址，而对应到真正的物理内存地址，需要地址一对一的映射，如果将内核空间的1g内存全部做线性映射【注1】，那么当物理内存为8g的时候，剩下的4g内存将无法被访问到。为了解决这个问题，linux将内核空间分为了3部分</p>
<ul>
<li><p><code>ZONE_DMA</code>        内存开始的16MB</p>
</li>
<li><p><code>ZONE_NORMAL</code>       16MB~896MB</p>
</li>
<li><p><code>ZONE_HIGHMEM</code>       896MB ~ 结束<br><img src="/media/15297335067219.jpg" alt=""></p>
</li>
</ul>
<p>可以看到，低dma 和 normal  内存区与物理内存做了线性映射。<br>但是高端内存（最上面的128m）并未与物理内存进行线性映射，事实上，linux正是借助这小块高端内存 才做到了用128m 访问剩余4g物理内存的。</p>
<p>当内核想访问高于896MB物理地址内存时，从<code>0xF8000000 ~ 0xFFFFFFFF</code>地址空间范围内找一段相应大小空闲的逻辑地址空间，<strong>借用一会</strong>。借用这段逻辑地址空间，建立映射到想访问的那段物理内存（即填充内核PTE页面表），<strong>临时用一会，用完后归还</strong>。这样别人也可以借用这段地址空间访问其他物理内存，实现了使用有限的地址空间，访问所有所有物理内存。如下图。<br><img src="/media/15297337063815.jpg" alt=""></p>
<p>从上面的描述，我们可以知道高端内存的最基本思想：<strong>借一段地址空间，建立临时地址映射，用完后释放，达到这段地址空间可以循环使用，访问所有物理内存。</strong></p>
<blockquote>
<p>注1：线性映射与非线性映射：<br>Linux内核只有1G的空间，通常内核把物理内存与其地址空间做了线性映射，也就是一一映，这样可以提高内存访问速度。<br>当内存超过1G时，线性访问机制就不够用了，只能有1G的内存可以被映射，剩余的内存无法被内核使用。当然无法忍受。<br>为了解决这一问题，linux把内核分为线性区与非线性区两部分。线性区规定最大为896M，剩下的为非线性区。与线性区不同，非线性区不会提前进行内存映射，而是在使用时动态映射。线性区映射的物理内存成为低端内存，剩下的内存被称为高端内存。<br>假设物理内存为2G，则地段的896M为低端内存，通过线性映射给内核使用。其他的1128M内存为高端内存，可以被内核的非线性区使用。由于要使用128M非线性区来管理超过1G的高端内存，所以通常都不会映射，只有使用时才使<code>kmap</code>映射，使用完后要尽快用<code>kunmap</code>释放。<br>对于物理内存为1G的内核，系统不会真的分配896M给线性空间，896M最大限制。下面是一个1.5G物理内存linux系统的真实分配情况，只有721M分配给了低端内存区，如果是1G的linxu系统，分配的就更少了。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MemTotal   1547MB</span><br><span class="line">HighTotal     825MB</span><br><span class="line">LowTotal     721MB</span><br></pre></td></tr></table></figure>
<p>申请高端内存时，如果高端内存不够了，linux也会去低端内存区申请，反之则不行。</p>
<h4 id="内核空间被所有进程共享，那么进程里的内核空间都是一样的吗？"><a href="#内核空间被所有进程共享，那么进程里的内核空间都是一样的吗？" class="headerlink" title="内核空间被所有进程共享，那么进程里的内核空间都是一样的吗？"></a>内核空间被所有进程共享，那么进程里的内核空间都是一样的吗？</h4><p>是的，进程里的内核空间都是一样的。<br>Linux启动后，第一个进程是init进程，它的页表与内核页表是一致的，系统中的其他所有进程都是init进程的儿子或后代。Linux中进程创建通过fork()实现，子进程的PGD（进程页目录）与PTE（进程页表项，里面记录了具体的物理地址）是父进程的拷贝此时会把内核进程的页表拷贝到每个进程中。在各个进程的运行过程中，他们的页表可能会发生变化，比如发生缺页异常。如果是进程页表发生改变，则只要改变进程的页表项（0G~3G）就够了，如果是内核页表发生变化，则必须通知到所有进程改变各自维护的一份内核页表（3G~4G）。最简单的方法是每次内核页表改变后，遍历所有进程去改变他们维护的内核页表，显然效率很低。<strong>Linux内核通过page fault机制实现内核页表的一致。</strong><br>内核页表改变时，只改变init进程的内核页表。当进程访问该页时，会发生一个缺页异常，异常处理中通过init进程更新当前进程的内核页表。</p>
<h4 id="进程的内核空间都是一样的，那为什么要把每个进程的内核空间都拷贝一份，不可以进程的虚拟地址只有进程空间，而所有内核空间单独只维持一份吗？"><a href="#进程的内核空间都是一样的，那为什么要把每个进程的内核空间都拷贝一份，不可以进程的虚拟地址只有进程空间，而所有内核空间单独只维持一份吗？" class="headerlink" title="进程的内核空间都是一样的，那为什么要把每个进程的内核空间都拷贝一份，不可以进程的虚拟地址只有进程空间，而所有内核空间单独只维持一份吗？"></a>进程的内核空间都是一样的，那为什么要把每个进程的内核空间都拷贝一份，不可以进程的虚拟地址只有进程空间，而所有内核空间单独只维持一份吗？</h4><p>目的其实很简单，为了减少内核调用的系统开销。<br>我们常说，切换线程和切换进程相比，进程切换的开销更大，是因为每一个进程都对应着一个进程页表，切换进程会对应页表的切换，线程因为在同一个进程里，很多资源是共享的，切换线程（其实linux里 线程与进程是同一个东西，切换线程也对应页表的切换，只不过页表内容没有变而已）相当于只切换一些上下文。<br>从问题中提出的两个方式来考虑开销问题。</p>
<ol>
<li>每个进程使用独立页表 （当前内核的做法）</li>
<li>所有进程在内核态使用同一页表，但用户态每进程使用独立页表</li>
</ol>
<p>考虑两个场景</p>
<ul>
<li>场景1：用户态切陷入内核态采用方案1），进程从用户态陷入内核态时（系统调用，中断都可触发），不需要切换页表；采用方案2），用户态陷入内核态时，需要切换页表。并且进入内核态时，根据没有跳板(一段专代码）来完成切换，因为内核地址空间在切换之后根本没有映射。</li>
<li>场景2：任务切换如果进程跑在用户态，来了中断，陷入内核态，然后任务切换。 方案1）在陷入内核态时有一次页表切换；方案2）在任务切切换有一次页表切换。两者打平手。但通常任务切换之后，新任务也要回到用户态的，那方案1）又会引入一次页切换。在程序的实际运行过程中，程序调用系统调用的次数比任务切换的次数多，所以方案1）远比方案2）有优势。</li>
</ul>
<h2 id="地址转换"><a href="#地址转换" class="headerlink" title="地址转换"></a>地址转换</h2><p>一张图解释 用户空间 内核空间  物理地址的转换关系</p>
<p><img src="/media/15297354836739.jpg" alt=""></p>
<p>在linux中，物理地址用<code>page</code>结构 表示，物理内存在初始化时已经生成了<code>page</code>结构管理，其他地址空间则需要生成<code>page</code>再进行管理（<code>ioremap</code>）。物理地址可以被映射到内核空间或进程空间，也可以从内核空间或进程用户空间解除物理地址（<code>page</code>）。</p>
<p>所有转换中，只有<code>mmap</code>可以在进程中使用，其他都是内核函数。即使使用<code>mmap</code>，其内部也是靠内核中使用<code>remap_pfn_range</code>实现的。所有地址空间转换都在内核中实现。</p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://wenyiqingnian.xyz/2017/06/18/linux的地址映射/" data-id="cjl3hsww5000pum8x9zq9hgp7" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    
        <a href="http://wenyiqingnian.xyz/2017/06/18/linux的地址映射/#comments" class="article-comment-link">Comments</a>
    

        </footer>
    </div>
    
</article>



    <article id="post-MK语法规范" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2017/05/07/MK语法规范/">MK语法规范</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2017/05/07/MK语法规范/">
            <time datetime="2017-05-07T12:11:15.000Z" itemprop="datePublished">2017-05-07</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/AOSP/">AOSP</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/mk/">mk</a>, <a class="tag-link" href="/tags/编译/">编译</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <h1 id="Android-mk文件语法规范及使用模板"><a href="#Android-mk文件语法规范及使用模板" class="headerlink" title="Android.mk文件语法规范及使用模板"></a>Android.mk文件语法规范及使用模板</h1><hr>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction:"></a>Introduction:</h2><p>Android.mk编译文件是用来向Android NDK描述你的C,C++源代码文件的， 这篇文档描述了它的语法。在阅读下面的内容之前，假定你已经阅读了docs/OVERVIEW.TXT文件，了解了它们的用途。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述:"></a>概述:</h2><p>一个 Android.mk file用来向编译系统描述你的源代码。具体来说：-该文件是GNU Makefile的一小部分，会被编译系统解析一次或更多次的build系统。因此，您应尽量减少您声明的变量，不要认为某些变量在解析过程中不会被定义。-这个文件的语法允许把你的源代码组织成模块，一个模块属下列类型之一：  静态库  、共享库</p>
<p>只有共享库将被安装/复制到您的应用软件包。虽然静态库能被用于生成共享库。</p>
<p>你可以在每一个Android.mk file中定义一个或多个模块，你也可以在几个模块中使用同一个源代码文件。</p>
<hr>
<p>-编译系统为你处理许多细节问题。例如，你不需要在你的Android.mk中列出头文件和依赖文件。NDK编译系统将会为你自动处理这些问题。这也意味着，在升级NDK后，你应该得到新的toolchain/platform支持，而且不需要改变你的Android.mk文件。</p>
<p>注意，这个语法同公开发布的Android平台的开源代码很接近，然而编译系统实现他们的方式却是不同的，这是故意这样设计的，可以让程序开发人员重用外部库的源代码更容易。</p>
<h3 id="简单的例子"><a href="#简单的例子" class="headerlink" title="简单的例子:"></a>简单的例子:</h3><hr>
<p>在描述语法细节之前，咱们来看一个简单的”hello world”的例子，比如，下面的文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sources/helloworld/helloworld.c</span><br><span class="line"></span><br><span class="line">sources/helloworld/Android.mk</span><br></pre></td></tr></table></figure>
<p>‘helloworld.c’是一个JNI共享库，实现返回”hello world”字符串的原生方法。</p>
<p>相应的Android.mk文件会象下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">---------- cut here ------------------</span><br><span class="line"></span><br><span class="line">LOCAL_PATH := $(call my-dir)</span><br><span class="line"></span><br><span class="line">include $(CLEAR_VARS)</span><br><span class="line"></span><br><span class="line">LOCAL_MODULE:= helloworld</span><br><span class="line"></span><br><span class="line">LOCAL_SRC_FILES := helloworld.c</span><br><span class="line"></span><br><span class="line">include $(BUILD_SHARED_LIBRARY)</span><br><span class="line"></span><br><span class="line">---------- cut here ------------------</span><br></pre></td></tr></table></figure>
<p>好，我们来解释一下这几行代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_PATH := $(call my-dir)</span><br></pre></td></tr></table></figure>
<p>一个Android.mk file首先必须定义好LOCAL_PATH变量。它用于在开发树中查找源文件。在这个例子中，宏函数’my-dir’, 由编译系统提供，用于返回当前路径（即包含Android.mk file文件的目录）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include $( CLEAR_VARS)</span><br></pre></td></tr></table></figure>
<p>CLEAR_VARS由编译系统提供，指定让GNU MAKEFILE为你清除许多LOCAL_XXX变量（例如 LOCAL_MODULE, LOCAL_SRC_FILES, LOCAL_STATIC_LIBRARIES, 等等…),</p>
<p>除LOCAL_PATH 。这是必要的，因为所有的编译控制文件都在同一个GNU MAKE执行环境中，所有的变量都是全局的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_MODULE := helloworld</span><br></pre></td></tr></table></figure>
<p>LOCAL_MODULE变量必须定义，以标识你在Android.mk文件中描述的每个模块。名称必须是唯一的，而且不包含任何空格。注意编译系统会自动产生合适的前缀和后缀，换句话说，一个被命名为’foo’的共享库模块，将会生成’libfoo.so’文件。</p>
<p>重要注意事项</p>
<p>如果你把库命名为‘libhelloworld’，编译系统将不会添加任何的lib前缀，也会生成libhelloworld.so，这是为了支持来源于Android平台的源代码的Android.mk文件，如果你确实需要这么做的话。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_SRC_FILES := helloworld.c</span><br></pre></td></tr></table></figure>
<p>LOCAL_SRC_FILES变量必须包含将要编译打包进模块中的C或C++源代码文件。注意，你不用在这里列出头文件和包含文件，因为编译系统将会自动为你找出依赖型的文件；仅仅列出直接传递给编译器的源代码文件就好。【注意，默认的C++源码文件的扩展名是’.cpp’. 指定一个不同的扩展名也是可能的，只要定义LOCAL_DEFAULT_CPP_EXTENSION变量，不要忘记开始的小圆点（也就是定义为‘.cxx’,而不是‘cxx’）（当然这一步我们一般不会去改它）】</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include $(BUILD_SHARED_LIBRARY)</span><br></pre></td></tr></table></figure>
<p>BUILD_SHARED_LIBRARY是编译系统提供的变量，指向一个GNU Makefile脚本（应该就是在build/core目录下的shared_library.mk），负责收集自从上次调用’include $(CLEAR_VARS)’以来，定义在LOCAL_XXX变量中的所有信息，并且决定编译什么，如何正确地去做。并根据其规则生成静态库。同理对于静态库。</p>
<hr>
<p>在sources/samples目录下有更复杂一点的例子，写有注释的Android.mk文件，你可以看看。</p>
<p>参考:</p>
<p>这是一份你应该在Android.mk中依赖或定义的变量列表，您可以定义其他变量为自己使用，</p>
<p>但是NDK编译系统保留下列变量名：</p>
<p>-以LOCAL_开头的名字（例如 LOCAL_MODULE）</p>
<p>-以PRIVATE_, NDK_ or APP_开头的名字（内部使用）</p>
<p>-小写名字（内部使用，例如’my-dir’）</p>
<p>如果您为了方便在Android.mk中定义自己的变量，我们建议使用MY_前缀，一个小例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">---------- cut here ------------------</span><br><span class="line"></span><br><span class="line">MY_SOURCES := foo.c</span><br><span class="line"></span><br><span class="line">ifneq ($(MY_CONFIG_BAR),)</span><br><span class="line"></span><br><span class="line">MY_SOURCES += bar.c</span><br><span class="line"></span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">LOCAL_SRC_FILES += $(MY_SOURCES)</span><br><span class="line"></span><br><span class="line">---------- cut here ------------------</span><br></pre></td></tr></table></figure>
<hr>
<p>这些GNU Make 变量在你的Android.mk文件解析之前，就由编译系统定义好了。</p>
<p>注意在某些情况下，NDK可能分析Android.mk几次，每一次某些变量的定义会有不同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLEAR_VARS</span><br></pre></td></tr></table></figure>
<p>指向一个编译脚本，几乎所有未定义的LOCAL_XXX变量都在”Module-description”节中列出。</p>
<p>你必须在开始一个新模块之前包含这个脚本。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include $(CLEAR_VARS)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BUILD_SHARED_LIBRARY</span><br></pre></td></tr></table></figure>
<p>指向编译脚本，收集所有的你在LOCAL_XXX变量中提供的信息，并且决定如何把你列出的源代码文件编译成一个共享库。注意，你必须至少在包含这个文件之前定义LOCAL_MODULE和LOCAL_SRC_FILES，使用例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include $(BUILD_SHARED_LIBRARY)</span><br></pre></td></tr></table></figure>
<p>注意这将生成一个名为lib$(LOCAL_MODULE).so的文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BUILD_STATIC_LIBRARY</span><br></pre></td></tr></table></figure>
<p>一个BUILD_SHARED_LIBRARY变量用于编译一个静态库。静态库不会复制到你的project/packages中，诞生能够用于编译共享库，（看下面描述的LOCAL_STATIC_LIBRARIES and LOCAL_STATIC_WHOLE_LIBRARIES）</p>
<p>使用例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include $(BUILD_STATIC_LIBRARY)</span><br></pre></td></tr></table></figure>
<p>注意，这将会生成一个名为lib$(LOCAL_MODULE).a的文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TARGET_ARCH</span><br></pre></td></tr></table></figure>
<p>目标CPU平台的名字，如同在android开放源码中指定的那样。如果是’arm’，表示要生成ARM兼容的指令，与CPU架构的修订版无关。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TARGET_PLATFORM</span><br></pre></td></tr></table></figure>
<p>Android.mk解析的时候，目标Android平台的名字.详情可参考/development/ndk/docs/stable-apis.txt.</p>
<pre><code>android-3      -&gt; Official Android 1.5 system images

android-4      -&gt; Official Android 1.6 system images

android-5      -&gt; Official Android 2.0 system images
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TARGET_ARCH_ABI</span><br></pre></td></tr></table></figure>
<p>暂时只支持两个value，armeabi和armeabi-v7a。在现在的版本中一般把这两个值简单的定义为arm，通过android 平台内部对它重定义来获得更好的匹配。</p>
<p>其他的ＡＢＩ将在以后的ＮＤＫ版本中介绍，它们会有不同的名字。注意所有基于ＡＲＭ的ＡＢＩ都会把’TARGET_ARCH’定义成‘ａｒｍ’，但是会有不同的‘TARGET_ARCH_ABI’</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TARGET_ABI</span><br></pre></td></tr></table></figure>
<p>　　目标平台和ABI的组合，它事实上被定义成$(TARGET_PLATFORM)-$(TARGET_ARCH_ABI) 在你想要在真实的设备中针对一个特别的目标系统进行测试时，会有用。在默认的情况下，它会是’android-3-arm’。</p>
<p>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>*</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/</p>
<p>下面是GNU Make　‘功能’宏，必须通过使用’$(call <function>)’来求值，他们返回文本化的信息。</function></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my-dir</span><br></pre></td></tr></table></figure>
<p>返回当前Android.mk所在的目录路径，相对于ＮＤＫ编译系统的顶层。这是有用的，在Android.mk文件的开头如此定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_PATH := $(call my-dir)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">all-subdir-makefiles</span><br></pre></td></tr></table></figure>
<p>　　　返回一个位于当前’my-dir’路径的子目录列表。例如，看下面的目录层次：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sources/foo/Android.mk</span><br><span class="line"></span><br><span class="line">sources/foo/lib1/Android.mk</span><br><span class="line"></span><br><span class="line">sources/foo/lib2/Android.mk</span><br></pre></td></tr></table></figure>
<p>如果sources/foo/Android.mk包含一行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include $(call all-subdir-makefiles)</span><br></pre></td></tr></table></figure>
<p>那么它就会自动包含sources/foo/lib1/Android.mk 和sources/foo/lib2/Android.mk</p>
<p>这项功能用于向编译系统提供深层次嵌套的代码目录层次。注意，在默认情况下，ＮＤＫ将会只搜索在sources/*/Android.mk中的文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this-makefile</span><br></pre></td></tr></table></figure>
<p>返回当前Makefile的路径（即这个函数调用的地方）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parent-makefile</span><br></pre></td></tr></table></figure>
<p>　　返回调用树中父Makefile路径。即包含当前Makefile的Makefile路径。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grand-parent-makefile</span><br></pre></td></tr></table></figure>
<p>猜猜看…</p>
<p>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>*</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/</p>
<h3 id="模块描述变量"><a href="#模块描述变量" class="headerlink" title="模块描述变量:"></a>模块描述变量:</h3><p>下面的变量用于向编译系统描述你的模块。你应该定义在’include $(CLEAR_VARS)’和’include $(BUILD_XXXXX)’之间定义。正如前面描写的那样，$(CLEAR_VARS是一个脚本，清除所有这些变量，除非在描述中显式注明。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_PATH</span><br></pre></td></tr></table></figure>
<p>　　这个变量用于给出当前文件的路径。你必须在Android.mk的开头定义，可以这样使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_PATH := $(call my-dir)</span><br></pre></td></tr></table></figure>
<p>这个变量不会被$(CLEAR_VARS)清除，因此每个Android.mk只需要定义一次（即使你在一个文件中定义了几个模块的情况下）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_MODULE</span><br></pre></td></tr></table></figure>
<p>这是你模块的名字，它必须是唯一的，而且不能包含空格。你必须在包含任一的$(BUILD_XXXX)脚本之前定义它。模块的名字决定了生成文件的名字，例如，如果一个一个共享库模块的名字是<foo>，那么生成文件的名字就是lib<foo>.so。但是，在你的NDK生成文件中（或者Android.mk或者Application.mk），你应该只涉及(引用)有正常名字的其他模块。</foo></foo></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_SRC_FILES</span><br></pre></td></tr></table></figure>
<p>这是要编译的源代码文件列表。只要列出要传递给编译器的文件，因为编译系统自动为你计算依赖。</p>
<p>注意源代码文件名称都是相对于LOCAL_PATH的，你可以使用路径部分，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_SRC_FILES := foo.c \</span><br></pre></td></tr></table></figure>
<p>toto/bar.c<br>注意：在生成文件中都要使用UNIX风格的斜杠(/).windows风格的反斜杠不会被正确的处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_CPP_EXTENSION</span><br></pre></td></tr></table></figure>
<p>这是一个可选变量，用来指定C++代码文件的扩展名，默认是’.cpp’,但是你可以改变它，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_CPP_EXTENSION := .cxx</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_C_INCLUDES</span><br></pre></td></tr></table></figure>
<p>路径的可选配置，是从根目录开始的，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">all sources (C, C++ and Assembly). For example:</span><br><span class="line"></span><br><span class="line">        LOCAL_C_INCLUDES := sources/foo</span><br><span class="line"></span><br><span class="line">    Or even:</span><br><span class="line"></span><br><span class="line">        LOCAL_C_INCLUDES := $(LOCAL_PATH)/../foo</span><br><span class="line"></span><br><span class="line">       需要在任何包含LOCAL_CFLAGS / LOCAL_CPPFLAGS标志之前。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_CFLAGS</span><br></pre></td></tr></table></figure>
<p>可选的编译器选项，在编译C代码文件的时候使用。</p>
<p>这可能是有用的，指定一个附加的包含路径（相对于NDK的顶层目录），宏定义，或者编译选项。</p>
<p>　重要信息：不要在Android.mk中改变optimization/debugging级别，只要在Application.mk中指定合适的信息，就会自动地为你处理这个问题，在调试期间，会让ＮＤＫ自动生成有用的数据文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_CXXFLAGS</span><br><span class="line"></span><br><span class="line">Same as LOCAL_CFLAGS for C++ source files</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_CPPFLAGS</span><br></pre></td></tr></table></figure>
<p>与LOCAL_CFLAGS相同，但是对C 和　C++ source files都适用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_STATIC_LIBRARIES</span><br></pre></td></tr></table></figure>
<p>应该链接到这个模块的静态库列表（使用BUILD_STATIC_LIBRARY生成），这仅仅对共享库模块才有意义。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_SHARED_LIBRARIES</span><br></pre></td></tr></table></figure>
<p>这个模块在运行时要依赖的共享库模块列表，在链接时需要，在生成文件时嵌入的相应的信息。注意：这不会附加列出的模块到编译图，也就是，你仍然需要在Application.mk中把它们添加到程序要求的模块中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_LDLIBS</span><br></pre></td></tr></table></figure>
<p>编译你的模块要使用的附加的链接器选项。这对于使用”-l”前缀传递指定库的名字是有用的。例如，下面将告诉链接器生成的模块要在加载时刻链接到/system/lib/libz.so</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_LDLIBS := -lz</span><br></pre></td></tr></table></figure>
<p>看docs/STABLE-APIS.TXT获取你使用NDK发行版能链接到的开放的系统库列表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_ALLOW_UNDEFINED_SYMBOLS</span><br></pre></td></tr></table></figure>
<p>　　默认情况下，在试图编译一个共享库时，任何未定义的引用将导致一个“未定义的符号”错误。这对于在你的源代码文件中捕捉错误会有很大的帮助。</p>
<p>然而，如果你因为某些原因，需要不启动这项检查，把这个变量设为‘ｔｒｕｅ’。注意相应的共享库可能在运行时加载失败。（这个一般尽量不要去设为true）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_ARM_MODE</span><br></pre></td></tr></table></figure>
<p>默认情况下，arm目标二进制会以thumb的形式生成（16位），你可以通过设置这个变量为arm如果你希望你的module是以32位指令的形式。</p>
<pre><code>&apos;arm&apos; (32-bit instructions) mode. E.g.:

  LOCAL_ARM_MODE := arm
</code></pre><p>注意你同样可以在编译的时候告诉系统编译特定的类型，比如</p>
<pre><code>LOCAL_SRC_FILES := foo.c bar.c.arm
</code></pre><p>这样就告诉系统总是将bar.c以arm的模式编译，</p>
<h3 id="Android-mk使用模板"><a href="#Android-mk使用模板" class="headerlink" title="Android.mk使用模板"></a>Android.mk使用模板</h3><p>在一个Android.mk中可以生成多个可执行程序、动态库和静态库。</p>
<h4 id="1，编译应用程序的模板："><a href="#1，编译应用程序的模板：" class="headerlink" title="1，编译应用程序的模板："></a>1，编译应用程序的模板：</h4><pre><code>#Test Exe

LOCAL_PATH := $(call my-dir)

#include $(CLEAR_VARS)

LOCAL_SRC_FILES:= main.c

LOCAL_MODULE:= test_exe

#LOCAL_C_INCLUDES :=

#LOCAL_STATIC_LIBRARIES :=

#LOCAL_SHARED_LIBRARIES :=

include $(BUILD_EXECUTABLE)
</code></pre><p>（菜鸟级别解释：:=是赋值的意思，$是引用某变量的值）LOCAL_SRC_FILES中加入源文件路径，LOCAL_C_INCLUDES 中加入所需要包含的头文件路径，LOCAL_STATIC_LIBRARIES加入所需要链接的静态库（<em>.a）的名称，LOCAL_SHARED_LIBRARIES中加入所需要链接的动态库（</em>.so）的名称，LOCAL_MODULE表示模块最终的名称，BUILD_EXECUTABLE表示以一个可执行程序的方式进行编译。</p>
<h4 id="2，编译静态库的模板："><a href="#2，编译静态库的模板：" class="headerlink" title="2，编译静态库的模板："></a>2，编译静态库的模板：</h4><pre><code>#Test Static Lib

LOCAL_PATH := $(call my-dir)

include $(CLEAR_VARS)

LOCAL_SRC_FILES:= \

          helloworld.c

LOCAL_MODULE:= libtest_static

#LOCAL_C_INCLUDES :=

#LOCAL_STATIC_LIBRARIES :=

#LOCAL_SHARED_LIBRARIES :=

include $(BUILD_STATIC_LIBRARY)
</code></pre><p>一般的和上面相似，BUILD_STATIC_LIBRARY表示编译一个静态库。</p>
<h4 id="3，编译动态库的模板："><a href="#3，编译动态库的模板：" class="headerlink" title="3，编译动态库的模板："></a>3，编译动态库的模板：</h4><pre><code>#Test Shared Lib

LOCAL_PATH := $(call my-dir)

include $(CLEAR_VARS)

LOCAL_SRC_FILES:= \

          helloworld.c

LOCAL_MODULE:= libtest_shared

TARGET_PRELINK_MODULES := false

#LOCAL_C_INCLUDES :=

#LOCAL_STATIC_LIBRARIES :=

#LOCAL_SHARED_LIBRARIES :=

 include $(BUILD_SHARED_LIBRARY)
</code></pre><p>一般的和上面相似，BUILD_SHARED_LIBRARY表示编译一个共享库。</p>
<p>以上三者的生成结果分别在如下，generic依具体target会变：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">out/target/product/generic/obj/EXECUTABLE</span><br><span class="line"></span><br><span class="line">out/target/product/generic/obj/STATIC_LIBRARY</span><br><span class="line"></span><br><span class="line">out/target/product/generic/obj/SHARED_LIBRARY</span><br></pre></td></tr></table></figure>
<p>每个模块的目标文件夹分别为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">可执行程序：XXX_intermediates</span><br><span class="line"></span><br><span class="line">静态库：      XXX_static_intermediates</span><br><span class="line"></span><br><span class="line">动态库：      XXX_shared_intermediates</span><br></pre></td></tr></table></figure>
<p>另外，在Android.mk文件中，还可以指定最后的目标安装路径，用LOCAL_MODULE_PATH和LOCAL_UNSTRIPPED_PATH来指定。不同的文件系统路径用以下的宏进行选择：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TARGET_ROOT_OUT：表示根文件系统。</span><br><span class="line"></span><br><span class="line">TARGET_OUT：表示system文件系统。</span><br><span class="line"></span><br><span class="line">TARGET_OUT_DATA：表示data文件系统。</span><br></pre></td></tr></table></figure>
<p>用法如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_MODULE_PATH:=$(TARGET_ROOT_OUT)</span><br></pre></td></tr></table></figure>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://wenyiqingnian.xyz/2017/05/07/MK语法规范/" data-id="cjl3hswvz000hum8xckrahuaj" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    
        <a href="http://wenyiqingnian.xyz/2017/05/07/MK语法规范/#comments" class="article-comment-link">Comments</a>
    

        </footer>
    </div>
    
</article>



    <article id="post-Binder 进程间通讯机制" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2017/04/11/Binder 进程间通讯机制/">Binder通讯机制</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2017/04/11/Binder 进程间通讯机制/">
            <time datetime="2017-04-11T11:20:50.000Z" itemprop="datePublished">2017-04-11</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/Android/">Android</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/Binder/">Binder</a>, <a class="tag-link" href="/tags/android/">android</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <h1 id="什么是Binder？"><a href="#什么是Binder？" class="headerlink" title="什么是Binder？"></a>什么是Binder？</h1><p>Binder是Android系统中进程间通讯（IPC）的一种方式，也是Android系统中最重要的特性之一。Android中的四大组件Activity，Service，Broadcast，ContentProvider，不同的App等都运行在不同的进程中，它是这些进程间通讯的桥梁。正如其名“粘合剂”一样，它把系统中各个组件粘合到了一起，是各个组件的桥梁。</p>
<p>理解Binder对于理解整个Android系统有着非常重要的作用，如果对Binder不了解，就很难对Android系统机制有更深入的理解。</p>
<h1 id="1-Binder架构"><a href="#1-Binder架构" class="headerlink" title="1. Binder架构"></a>1. Binder架构</h1><p><img src="/media/binder_1-1.jpeg" alt="binder_1"></p>
<ul>
<li>Binder 通信采用 C/S 架构，从组件视角来说，包含 Client、 Server、 ServiceManager 以及 Binder 驱动，其中 ServiceManager 用于管理系统中的各种服务。</li>
<li>Binder 在 framework 层进行了封装，通过 JNI 技术调用 Native（C/C++）层的 Binder 架构。</li>
<li><p>Binder 在 Native 层以 ioctl 的方式与 Binder 驱动通讯。</p>
<h1 id="2-Binder机制"><a href="#2-Binder机制" class="headerlink" title="2.Binder机制"></a>2.Binder机制</h1><p><img src="/media/binder_2.jpeg" alt="binder_2"></p>
</li>
<li><p>首先需要注册服务端，只有注册了服务端，客户端才有通讯的目标，服务端通过 ServiceManager 注册服务，注册的过程就是向 Binder 驱动的全局链表 binder_procs 中插入服务端的信息（binder_proc 结构体，每个 binder_proc 结构体中都有 todo 任务队列），然后向 ServiceManager 的 svcinfo 列表中缓存一下注册的服务。</p>
</li>
<li><p>有了服务端，客户端就可以跟服务端通讯了，通讯之前需要先获取到服务，拿到服务的代理，也可以理解为引用。比如下面的代码：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1//获取WindowManager服务引用</span><br><span class="line">2 WindowManager wm = (WindowManager)getSystemService(getApplication().WINDOW_SERVICE);</span><br></pre></td></tr></table></figure>
<p>获取服务端的方式就是通过 ServiceManager 向 svcinfo 列表中查询一下返回服务端的代理，svcinfo 列表就是所有已注册服务的通讯录，保存了所有注册的服务信息。</p>
<ul>
<li>有了服务端的引用我们就可以向服务端发送请求了，通过 BinderProxy 将我们的请求参数发送给 ServiceManager，通过共享内存的方式使用内核方法 copy_from_user() 将我们的参数先拷贝到内核空间，这时我们的客户端进入等待状态，然后 Binder 驱动向服务端的 todo 队列里面插入一条事务，执行完之后把执行结果通过 copy_to_user() 将内核的结果拷贝到用户空间（这里只是执行了拷贝命令，并没有拷贝数据，binder只进行一次拷贝），唤醒等待的客户端并把结果响应回来，这样就完成了一次通讯。</li>
</ul>
<p>怎么样是不是很简单，以上就是 Binder 机制的主要通讯方式，下面我们来看看具体实现。</p>
<h1 id="3-Binder驱动"><a href="#3-Binder驱动" class="headerlink" title="3.Binder驱动"></a>3.Binder驱动</h1><p>我们先来了解下<strong>用户空间</strong>与<strong>内核空间</strong>是怎么交互的。<br><img src="/media/binder_3.jpeg" alt="binder_3"></p>
<p>先了解一些概念</p>
<h3 id="用户空间-内核空间"><a href="#用户空间-内核空间" class="headerlink" title="用户空间/内核空间"></a>用户空间/内核空间</h3><p>详细解释可以参考 Kernel Space Definition； 简单理解如下：</p>
<p>Kernel space 是 Linux 内核的运行空间，User space 是用户程序的运行空间。 为了安全，它们是隔离的，即使用户的程序崩溃了，内核也不受影响。</p>
<p>Kernel space 可以执行任意命令，调用系统的一切资源； User space 只能执行简单的运算，不能直接调用系统资源，必须通过系统接口（又称 system call），才能向内核发出指令。</p>
<h3 id="系统调用-内核态-用户态"><a href="#系统调用-内核态-用户态" class="headerlink" title="系统调用/内核态/用户态"></a>系统调用/内核态/用户态</h3><p>虽然从逻辑上抽离出用户空间和内核空间；但是不可避免的的是，总有那么一些用户空间需要访问内核的资源；比如应用程序访问文件，网络是很常见的事情，怎么办呢？</p>
<blockquote>
<p>Kernel space can be accessed by user processes only through the use of system calls.</p>
</blockquote>
<p>用户空间访问内核空间的唯一方式就是系统调用；通过这个统一入口接口，所有的资源访问都是在内核的控制下执行，以免导致对用户程序对系统资源的越权访问，从而保障了系统的安全和稳定。用户软件良莠不齐，要是它们乱搞把系统玩坏了怎么办？因此对于某些特权操作必须交给安全可靠的内核来执行。</p>
<p>当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）此时处理器处于特权级最高的（0级）内核代码中执行。当进程在执行用户自己的代码时，则称其处于用户运行态（用户态）。即此时处理器在特权级最低的（3级）用户代码中运行。处理器在特权等级高的时候才能执行那些特权CPU指令。</p>
<h3 id="内核模块-驱动"><a href="#内核模块-驱动" class="headerlink" title="内核模块/驱动"></a>内核模块/驱动</h3><p>通过系统调用，用户空间可以访问内核空间，那么如果一个用户空间想与另外一个用户空间进行通信怎么办呢？很自然想到的是让操作系统内核添加支持；传统的 Linux 通信机制，比如 Socket，管道等都是内核支持的；但是 Binder 并不是 Linux 内核的一部分，它是怎么做到访问内核空间的呢？ Linux 的动态可加载内核模块（Loadable Kernel Module，LKM）机制解决了这个问题；模块是具有独立功能的程序，它可以被单独编译，但不能独立运行。它在运行时被链接到内核作为内核的一部分在内核空间运行。这样，Android系统可以通过添加一个内核模块运行在内核空间，用户进程之间的通过这个模块作为桥梁，就可以完成通信了。</p>
<p>在 Android 系统中，这个运行在内核空间的，负责各个用户进程通过 Binder 通信的内核模块叫做 Binder 驱动;</p>
<blockquote>
<p>驱动程序一般指的是设备驱动程序（Device Driver），是一种可以使计算机和设备通信的特殊程序。相当于硬件的接口，操作系统只有通过这个接口，才能控制硬件设备的工作；</p>
</blockquote>
<p>驱动就是操作硬件的接口，为了支持Binder通信过程，Binder 使用了一种“硬件”，因此这个模块被称之为驱动。</p>
<p>熟悉了上面这些概念，我们再来看下上面的图，用户空间中 binder_open(), binder_mmap(), binder_ioctl() 这些方法通过 system call 来调用内核空间 Binder 驱动中的方法。内核空间与用户空间共享内存通过 copy_from_user(), copy_to_user() 内核方法来完成用户空间与内核空间内存的数据传输。 Binder驱动中有一个全局的 binder_procs 链表保存了服务端的进程信息。</p>
<h1 id="4-Binder-进程与线程"><a href="#4-Binder-进程与线程" class="headerlink" title="4. Binder 进程与线程"></a>4. Binder 进程与线程</h1><p><img src="/media/binder4.jpeg" alt="binde"></p>
<p>对于底层Binder驱动，通过 binder_procs 链表记录所有创建的 binder_proc 结构体，binder 驱动层的每一个 binder_proc 结构体都与用户空间的一个用于 binder 通信的进程一一对应，且每个进程有且只有一个 ProcessState 对象，这是通过单例模式来保证的。在每个进程中可以有很多个线程，每个线程对应一个 IPCThreadState 对象，IPCThreadState 对象也是单例模式，即一个线程对应一个 IPCThreadState 对象，在 Binder 驱动层也有与之相对应的结构，那就是 Binder_thread 结构体。在 binder_proc 结构体中通过成员变量 rb_root threads，来记录当前进程内所有的 binder_thread。</p>
<p>Binder 线程池：每个 Server 进程在启动时创建一个 binder 线程池，并向其中注册一个 Binder 线程；之后 Server 进程也可以向 binder 线程池注册新的线程，或者 Binder 驱动在探测到没有空闲 binder 线程时主动向 Server 进程注册新的的 binder 线程。对于一个 Server 进程有一个最大 Binder 线程数限制，默认为16个 binder 线程，例如 Android 的 system_server 进程就存在16个线程。对于所有 Client 端进程的 binder 请求都是交由 Server 端进程的 binder 线程来处理的。</p>
<h1 id="5-ServiceManager-启动"><a href="#5-ServiceManager-启动" class="headerlink" title="5. ServiceManager 启动"></a>5. ServiceManager 启动</h1><p>了解了 Binder 驱动，怎么与 Binder 驱动进行通讯呢？那就是通过 ServiceManager，好多文章称 ServiceManager 是 Binder 驱动的守护进程，大管家，其实 ServiceManager 的作用很简单就是提供了查询服务和注册服务的功能。下面我们来看一下 ServiceManager 启动的过程。<br><img src="/media/binder5.jpeg" alt="binde"></p>
<ul>
<li>ServiceManager 分为 framework 层和 native 层，framework 层只是对 native 层进行了封装方便调用，图上展示的是 native 层的 ServiceManager 启动过程。</li>
</ul>
<ul>
<li><p>ServiceManager 的启动是系统在开机时，init 进程解析 init.rc 文件调用 service_manager.c 中的 main() 方法入口启动的。 native 层有一个 binder.c 封装了一些与 Binder 驱动交互的方法。</p>
</li>
<li><p>ServiceManager 的启动分为三步，首先打开驱动创建全局链表 binder_procs，然后将自己当前进程信息保存到 binder_procs 链表，最后开启 loop 不断的处理共享内存中的数据，并处理 BR_xxx 命令（ioctl 的命令，BR 可以理解为 binder reply 驱动处理完的响应）。</p>
</li>
</ul>
<h1 id="6-ServiceManager-注册服务"><a href="#6-ServiceManager-注册服务" class="headerlink" title="6. ServiceManager 注册服务"></a>6. ServiceManager 注册服务</h1><p><img src="/media/binder6.jpeg" alt="binde"></p>
<ul>
<li><p>注册 MediaPlayerService 服务端，我们通过 ServiceManager 的 addService() 方法来注册服务。</p>
</li>
<li><p>首先 ServiceManager 向 Binder 驱动发送 BC_TRANSACTION 命令（ioctl 的命令，BC 可以理解为 binder client 客户端发过来的请求命令）携带 ADD_SERVICE_TRANSACTION 命令，同时注册服务的线程进入等待状态 waitForResponse()。 Binder 驱动收到请求命令向 ServiceManager 的 todo 队列里面添加一条注册服务的事务。事务的任务就是创建服务端进程 binder_node 信息并插入到 binder_procs 链表中。</p>
</li>
<li><p>事务处理完之后发送 BR_TRANSACTION 命令，ServiceManager 收到命令后向 svcinfo 列表中添加已经注册的服务。最后发送 BR_REPLY 命令唤醒等待的线程，通知注册成功。</p>
</li>
</ul>
<h1 id="7-ServiceManager-获取服务"><a href="#7-ServiceManager-获取服务" class="headerlink" title="7. ServiceManager 获取服务"></a>7. ServiceManager 获取服务</h1><p><img src="/media/binder7.jpeg" alt="binde"></p>
<ul>
<li><p>获取服务的过程与注册类似，相反的过程。通过 ServiceManager 的 getService() 方法来注册服务。</p>
</li>
<li><p>首先 ServiceManager 向 Binder 驱动发送 BC_TRANSACTION 命令携带 CHECK_SERVICE_TRANSACTION 命令，同时获取服务的线程进入等待状态 waitForResponse()。</p>
</li>
<li><p>Binder 驱动收到请求命令向 ServiceManager 的发送 BC_TRANSACTION 查询已注册的服务，查询到直接响应 BR_REPLY 唤醒等待的线程。若查询不到将与 binder_procs 链表中的服务进行一次通讯再响应。</p>
</li>
<li><h1 id="8-进行一次完整通讯"><a href="#8-进行一次完整通讯" class="headerlink" title="8. 进行一次完整通讯"></a>8. 进行一次完整通讯</h1></li>
</ul>
<p><img src="/media/binder8.jpeg" alt="binde"></p>
<ul>
<li><p>我们在使用 Binder 时基本都是调用 framework 层封装好的方法，AIDL 就是 framework 层提供的傻瓜式是使用方式。假设服务已经注册完，我们来看看客户端怎么执行服务端的方法。</p>
</li>
<li><p>首先我们通过 ServiceManager 获取到服务端的 BinderProxy 代理对象，通过调用 BinderProxy 将参数，方法标识（例如：TRANSACTION_test，AIDL中自动生成）传给 ServiceManager，同时客户端线程进入等待状态。</p>
</li>
<li><p>ServiceManager 将用户空间的参数等请求数据复制到内核空间，并向服务端插入一条执行执行方法的事务。事务执行完通知 ServiceManager 将执行结果从内核空间复制到用户空间，并唤醒等待的线程，响应结果，通讯结束。</p>
</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>好了，这里只是从实现逻辑上简单介绍了下 Binder 机制的工作原理，想要深入理解 Binder 机制，还得自己下功夫，看源码，尽管这个过程很痛苦。一遍看不懂就再来一遍，说实话本人理解能力比较差，跟着博客思路看了不下十遍。努力总会有收获，好好欣赏 native 层各方法之间花式跳转的魅力吧。最后你将发现新世界的大门在向你敞开。</p>
<p>网上资料很多，个人觉得比较好的如下： </p>
<ol>
<li><a href="http://blog.csdn.net/universus/article/details/6211589" target="_blank" rel="noopener">Bander设计与实现</a> </li>
<li><a href="http://blog.csdn.net/luoshengyang/article/details/6618363" target="_blank" rel="noopener">老罗的 Android进程间通信（IPC）机制Binder简要介绍和学习计划 系列 </a></li>
<li>Innost的 <a href="http://blog.csdn.net/innost/article/details/47208049" target="_blank" rel="noopener">深入理解Binder</a> 系列 </li>
<li>Gityuan的 <a href="http://gityuan.com/2015/10/31/binder-prepare" target="_blank" rel="noopener">Binder系列</a> (基于 Android 6.0)<br>5.<a href="http://weishu.me/2016/01/12/binder-index-for-newer" target="_blank" rel="noopener"> Binder学习指南</a></li>
</ol>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://wenyiqingnian.xyz/2017/04/11/Binder 进程间通讯机制/" data-id="cjl3hswvm0003um8xe0ewwpj8" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    
        <a href="http://wenyiqingnian.xyz/2017/04/11/Binder 进程间通讯机制/#comments" class="article-comment-link">Comments</a>
    

        </footer>
    </div>
    
</article>



    <article id="post-编译系统环境初始化过程" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2017/04/05/编译系统环境初始化过程/">编译系统环境初始化过程</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2017/04/05/编译系统环境初始化过程/">
            <time datetime="2017-04-05T07:10:25.000Z" itemprop="datePublished">2017-04-05</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/AOSP/">AOSP</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/aosp/">aosp</a>, <a class="tag-link" href="/tags/编译/">编译</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p>对Android编译环境进行初始化很简单，分为两步。</p>
<h4 id="第一步是打开一个终端，并且将build-envsetup-sh加载到该终端中："><a href="#第一步是打开一个终端，并且将build-envsetup-sh加载到该终端中：" class="headerlink" title="第一步是打开一个终端，并且将build/envsetup.sh加载到该终端中："></a>第一步是打开一个终端，并且将build/envsetup.sh加载到该终端中：</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ . ./build/envsetup.sh   </span><br><span class="line">including device/asus/grouper/vendorsetup.sh  </span><br><span class="line">including device/asus/tilapia/vendorsetup.sh  </span><br><span class="line">including device/generic/armv7-a-neon/vendorsetup.sh  </span><br><span class="line">including device/generic/armv7-a/vendorsetup.sh  </span><br><span class="line">including device/generic/mips/vendorsetup.sh  </span><br><span class="line">including device/generic/x86/vendorsetup.sh  </span><br><span class="line">including device/lge/mako/vendorsetup.sh  </span><br><span class="line">including device/samsung/maguro/vendorsetup.sh  </span><br><span class="line">including device/samsung/manta/vendorsetup.sh  </span><br><span class="line">including device/samsung/toroplus/vendorsetup.sh  </span><br><span class="line">including device/samsung/toro/vendorsetup.sh  </span><br><span class="line">including device/ti/panda/vendorsetup.sh  </span><br><span class="line">including sdk/bash_completion/adb.bash  </span><br><span class="line">      从命令的输出可以知道，文件build/envsetup.sh在加载的过程中，又会在device目录中寻找那些名称为vendorsetup.sh的文件，并且也将它们加载到当前终端来。另外，在sdk/bash_completion目录下的adb.bash文件也会加载到当前终端来，它是用来实现adb命令的bash completion功能的。也就是说，加载了该文件之后，我们在运行adb相关的命令的时候，通过按tab键就可以帮助我们自动完成命令的输入。关于bash completion的知识，可以参考官方文档： http://www.gnu.org/s/bash/manual/bash.html<span class="comment">#Programmable-Completion。</span></span><br></pre></td></tr></table></figure>
<h4 id="第二步是执行命令lunch，如下所示："><a href="#第二步是执行命令lunch，如下所示：" class="headerlink" title="第二步是执行命令lunch，如下所示："></a>第二步是执行命令lunch，如下所示：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ lunch</span><br><span class="line"> </span><br><span class="line">You<span class="string">'re building on Linux  </span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">Lunch menu... pick a combo:  </span></span><br><span class="line"><span class="string">     1. full-eng  </span></span><br><span class="line"><span class="string">     2. full_x86-eng  </span></span><br><span class="line"><span class="string">     3. vbox_x86-eng  </span></span><br><span class="line"><span class="string">     4. full_mips-eng  </span></span><br><span class="line"><span class="string">     5. full_grouper-userdebug  </span></span><br><span class="line"><span class="string">     6. full_tilapia-userdebug  </span></span><br><span class="line"><span class="string">     7. mini_armv7a_neon-userdebug  </span></span><br><span class="line"><span class="string">     8. mini_armv7a-userdebug  </span></span><br><span class="line"><span class="string">     9. mini_mips-userdebug  </span></span><br><span class="line"><span class="string">     10. mini_x86-userdebug  </span></span><br><span class="line"><span class="string">     11. full_mako-userdebug  </span></span><br><span class="line"><span class="string">     12. full_maguro-userdebug  </span></span><br><span class="line"><span class="string">     13. full_manta-userdebug  </span></span><br><span class="line"><span class="string">     14. full_toroplus-userdebug  </span></span><br><span class="line"><span class="string">     15. full_toro-userdebug  </span></span><br><span class="line"><span class="string">     16. full_panda-userdebug  </span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">Which would you like? [full-eng]</span></span><br></pre></td></tr></table></figure>
<p>我们看到lunch命令输出了一个Lunch菜单，该菜单列出了当前Android源码支持的所有设备型号及其编译类型。例如，第一项“full-eng”表示的设备“full”即为模拟器，并且编译类型为“eng”即为工程机。<br>当我们选定了一个Lunch菜单项序号(1-16)之后，按回车键，就可以完成Android编译环境的初始化过程。例如，我们选择1，可以看到以下输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[html] view plain copy</span><br><span class="line">Which would you like? [full-eng] <span class="number">1</span>  </span><br><span class="line">  </span><br><span class="line">============================================  </span><br><span class="line">PLATFORM_VERSION_CODENAME=REL  </span><br><span class="line">PLATFORM_VERSION=<span class="number">4.2</span>  </span><br><span class="line">TARGET_PRODUCT=full  </span><br><span class="line">TARGET_BUILD_VARIANT=eng  </span><br><span class="line">TARGET_BUILD_TYPE=release  </span><br><span class="line">TARGET_BUILD_APPS=  </span><br><span class="line">TARGET_ARCH=arm  </span><br><span class="line">TARGET_ARCH_VARIANT=armv7-a  </span><br><span class="line">HOST_ARCH=x86  </span><br><span class="line">HOST_OS=linux  </span><br><span class="line">HOST_OS_EXTRA=Linux-<span class="number">3.8</span>.0-<span class="number">31</span>-generic-x86_64-with-Ubuntu-<span class="number">13.04</span>-raring  </span><br><span class="line">HOST_BUILD_TYPE=release  </span><br><span class="line">BUILD_ID=JOP40C  </span><br><span class="line">OUT_DIR=out  </span><br><span class="line">============================================</span><br></pre></td></tr></table></figure>
<p>我们可以看到，lunch命令帮我们设置好了很多环境变量。通过设置这些环境变量，就配置好了Android编译环境。<br>通过图1我们就可以直观地看到Android编译环境初始化完成后，我们所获得的东西：</p>
<p><img src="https://img-blog.csdn.net/20140208122926593?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTHVvc2hlbmd5YW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="image"></p>
<p>图1 Android编译环境初始化完成之后</p>
<p>总体来说，Android编译环境初始化完成之后，获得了以下三样东西：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 将vendor和device目录下的vendorsetup.sh文件加载到了当前终端；</span><br><span class="line"></span><br><span class="line">2. 新增了lunch、m、mm和mmm等命令；</span><br><span class="line"></span><br><span class="line">3. 通过执行lunch命令设置好了TARGET_PRODUCT、TARGET_BUILD_VARIANT、TARGET_BUILD_TYPE和TARGET_BUILD_APPS等环境变量。</span><br></pre></td></tr></table></figure>
<p>接下来我们就主要分析build/envsetup.sh文件的加载过程以及lunch命令的执行过程。</p>
<h4 id="一-文件build-envsetup-sh的加载过程"><a href="#一-文件build-envsetup-sh的加载过程" class="headerlink" title="一. 文件build/envsetup.sh的加载过程"></a>一. 文件build/envsetup.sh的加载过程</h4><p>文件build/envsetup.sh是一个bash shell脚本，从它里面定义的函数hmm可以知道，它提供了lunch、m、mm和mmm等命令供我们初始化编译环境或者编译Android源码。</p>
<p>函数hmm的实现如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[plain] view plain copy</span><br><span class="line">function hmm() &#123;  </span><br><span class="line">cat &lt;&lt;EOF  </span><br><span class="line">Invoke &quot;. build/envsetup.sh&quot; from your shell to add the following functions to your environment:  </span><br><span class="line">- lunch:   lunch &lt;product_name&gt;-&lt;build_variant&gt;  </span><br><span class="line">- tapas:   tapas [&lt;App1&gt; &lt;App2&gt; ...] [arm|x86|mips] [eng|userdebug|user]  </span><br><span class="line">- croot:   Changes directory to the top of the tree.  </span><br><span class="line">- m:       Makes from the top of the tree.  </span><br><span class="line">- mm:      Builds all of the modules in the current directory.  </span><br><span class="line">- mmm:     Builds all of the modules in the supplied directories.  </span><br><span class="line">- cgrep:   Greps on all local C/C++ files.  </span><br><span class="line">- jgrep:   Greps on all local Java files.  </span><br><span class="line">- resgrep: Greps on all local res/*.xml files.  </span><br><span class="line">- godir:   Go to the directory containing a file.  </span><br><span class="line">  </span><br><span class="line">Look at the source to view more functions. The complete list is:  </span><br><span class="line">EOF  </span><br><span class="line">    T=$(gettop)  </span><br><span class="line">    local A  </span><br><span class="line">    A=&quot;&quot;  </span><br><span class="line">    for i in `cat $T/build/envsetup.sh | sed -n &quot;/^function /s/function [a−z]∗.*/\1/p&quot; | sort`; do  </span><br><span class="line">      A=&quot;$A $i&quot;  </span><br><span class="line">    done  </span><br><span class="line">    echo $A  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在当前终端中执行hmm命令即可以看到函数hmm的完整输出。<br>函数hmm主要完成三个工作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 调用另外一个函数gettop获得Android源码的根目录T。 </span><br><span class="line"></span><br><span class="line">2. 通过cat命令显示一个Here Document，说明$T/build/envsetup.sh文件加载到当前终端后所提供的主要命令。</span><br><span class="line"></span><br><span class="line">3. 通过sed命令解析$T/build/envsetup.sh文件，并且获得在里面定义的所有函数的名称，这些函数名称就是$T/build/envsetup.sh文件加载到当前终端后提供的所有命令。</span><br><span class="line"></span><br><span class="line">       注意，sed命令是一个强大的文本分析工具，它以行为单位为执行文本替换、删除、新增和选取等操作。函数hmm通过执行以下的sed命令来获得在$T/build/envsetup.sh文件定义的函数的名称：</span><br></pre></td></tr></table></figure>
<p>[plain] view plain copy<br>sed -n “/^function /s/function [a−z]∗.*/\1/p”<br>       它表示对所有以“function ”开头的行，如果紧接在“function ”后面的字符串仅由字母a-z和下横线(_)组成，那么就将这个字符串提取出来。这正好就对应于shell脚本里面函数的定义。<br>       文件build/envsetup.sh除了定义一堆函数之外，还有一个重要的代码段，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[plain] view plain copy</span><br><span class="line"># Execute the contents of any vendorsetup.sh files we can find.  </span><br><span class="line">for f in `/bin/ls vendor/*/vendorsetup.sh vendor/*/*/vendorsetup.sh device/*/*/vendorsetup.sh 2&gt; /dev/null`  </span><br><span class="line">do  </span><br><span class="line">    echo &quot;including $f&quot;  </span><br><span class="line">    . $f  </span><br><span class="line">done  </span><br><span class="line">unset f</span><br></pre></td></tr></table></figure>
<p>这个for循环遍历vendor目录下的一级子目录和二级子目录以及device目录下的二级子目录中的vendorsetup.sh文件，并且通过source命令(.)将它们加载当前终端来。vendor和device相应子目录下的vendorsetup.sh文件的实现很简单，它们主要就是添加相应的设备型号及其编译类型支持到Lunch菜单中去。</p>
<p>例如，device/samsung/maguro目录下的vendorsetup.sh文件的实现如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[plain] view plain copy</span><br><span class="line">add_lunch_combo full_maguro-userdebug</span><br></pre></td></tr></table></figure>
<p> 它调用函数add_lunch_combo添加一个名称为“full_maguro-userdebug”的菜单项到Lunch菜单去。<br>函数add_lunch_combo定义在build/envsetup.sh文件中，它的实现如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[plain] view plain copy</span><br><span class="line">function add_lunch_combo()  </span><br><span class="line">&#123;  </span><br><span class="line">    local new_combo=$1  </span><br><span class="line">    local c  </span><br><span class="line">    for c in $&#123;LUNCH_MENU_CHOICES[@]&#125; ; do  </span><br><span class="line">        if [ &quot;$new_combo&quot; = &quot;$c&quot; ] ; then  </span><br><span class="line">            return  </span><br><span class="line">        fi  </span><br><span class="line">    done  </span><br><span class="line">    LUNCH_MENU_CHOICES=($&#123;LUNCH_MENU_CHOICES[@]&#125; $new_combo)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>传递给函数add_lunch_combo的参数保存在位置参数$1中，接着又保存在一个本地变量new_combo中，用来表示一个要即将要添加的Lunch菜单项。函数首先是在数组LUNCH_MENU_CHOICES中检查要添加的菜单项是否已经存在。只有在不存在的情况下，才会将它添加到数组LUNCH_MENU_CHOICES中去。注意，${LUNCH_MENU_CHOICES[@]}表示数组LUNCH_MENU_CHOICES的所有元素。<br>数组LUNCH_MENU_CHOICES是定义在文件build/envsetup.sh的一个全局变量，当文件build/envsetup.sh被加载的时候，这个数组会被初始化为化full-eng、full_x86-eng、vbox_x86-eng和full_mips-eng，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[plain] view plain copy</span><br><span class="line"># add the default one here  </span><br><span class="line">add_lunch_combo full-eng  </span><br><span class="line">add_lunch_combo full_x86-eng  </span><br><span class="line">add_lunch_combo vbox_x86-eng  </span><br><span class="line">add_lunch_combo full_mips-eng</span><br></pre></td></tr></table></figure>
<p>这样当文件build/envsetup.sh加载完成之后，数组LUNCH_MENU_CHOICES就包含了当前源码支持的所有设备型号及其编译类型，于是当接下来我们执行lunch命令的时候，就可以通过数组LUNCH_MENU_CHOICES看到一个完整的Lunch藤蔓。</p>
<h4 id="二-lunch命令的执行过程"><a href="#二-lunch命令的执行过程" class="headerlink" title="二. lunch命令的执行过程"></a>二. lunch命令的执行过程</h4><p>lunch命令实际上是定义在文件build/envsetup.sh的一个函数，它的实现如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">[plain] view plain copy</span><br><span class="line">function lunch()  </span><br><span class="line">&#123;  </span><br><span class="line">    local answer  </span><br><span class="line">  </span><br><span class="line">    if [ &quot;$1&quot; ] ; then  </span><br><span class="line">        answer=$1  </span><br><span class="line">    else  </span><br><span class="line">        print_lunch_menu  </span><br><span class="line">        echo -n &quot;Which would you like? [full-eng] &quot;  </span><br><span class="line">        read answer  </span><br><span class="line">    fi  </span><br><span class="line">  </span><br><span class="line">    local selection=  </span><br><span class="line">  </span><br><span class="line">    if [ -z &quot;$answer&quot; ]  </span><br><span class="line">    then  </span><br><span class="line">        selection=full-eng  </span><br><span class="line">    elif (echo -n $answer | grep -q -e &quot;^[0-9][0-9]*$&quot;)  </span><br><span class="line">    then  </span><br><span class="line">        if [ $answer -le $&#123;#LUNCH_MENU_CHOICES[@]&#125; ]  </span><br><span class="line">        then  </span><br><span class="line">            selection=$&#123;LUNCH_MENU_CHOICES[$(($answer-1))]&#125;  </span><br><span class="line">        fi  </span><br><span class="line">    elif (echo -n $answer | grep -q -e &quot;^[^\-][^\-]*-[^\-][^\-]*$&quot;)  </span><br><span class="line">    then  </span><br><span class="line">        selection=$answer  </span><br><span class="line">    fi  </span><br><span class="line">  </span><br><span class="line">    if [ -z &quot;$selection&quot; ]  </span><br><span class="line">    then  </span><br><span class="line">        echo  </span><br><span class="line">        echo &quot;Invalid lunch combo: $answer&quot;  </span><br><span class="line">        return 1  </span><br><span class="line">    fi  </span><br><span class="line">  </span><br><span class="line">    export TARGET_BUILD_APPS=  </span><br><span class="line">  </span><br><span class="line">    local product=$(echo -n $selection | sed -e &quot;s/-.*$//&quot;)  </span><br><span class="line">    check_product $product  </span><br><span class="line">    if [ $? -ne 0 ]  </span><br><span class="line">    then  </span><br><span class="line">        echo  </span><br><span class="line">        echo &quot;** Don&apos;t have a product spec for: &apos;$product&apos;&quot;  </span><br><span class="line">        echo &quot;** Do you have the right repo manifest?&quot;  </span><br><span class="line">        product=  </span><br><span class="line">    fi  </span><br><span class="line">  </span><br><span class="line">    local variant=$(echo -n $selection | sed -e &quot;s/^[^\-]*-//&quot;)  </span><br><span class="line">    check_variant $variant  </span><br><span class="line">    if [ $? -ne 0 ]  </span><br><span class="line">    then  </span><br><span class="line">        echo  </span><br><span class="line">        echo &quot;** Invalid variant: &apos;$variant&apos;&quot;  </span><br><span class="line">        echo &quot;** Must be one of $&#123;VARIANT_CHOICES[@]&#125;&quot;  </span><br><span class="line">        variant=  </span><br><span class="line">    fi  </span><br><span class="line">  </span><br><span class="line">    if [ -z &quot;$product&quot; -o -z &quot;$variant&quot; ]  </span><br><span class="line">    then  </span><br><span class="line">        echo  </span><br><span class="line">        return 1  </span><br><span class="line">    fi  </span><br><span class="line">  </span><br><span class="line">    export TARGET_PRODUCT=$product  </span><br><span class="line">    export TARGET_BUILD_VARIANT=$variant  </span><br><span class="line">    export TARGET_BUILD_TYPE=release  </span><br><span class="line">  </span><br><span class="line">    echo  </span><br><span class="line">  </span><br><span class="line">    set_stuff_for_environment  </span><br><span class="line">    printconfig  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数lunch的执行逻辑如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1. 检查是否带有参数，即位置参数$1是否等于空。如果不等于空的话，就表明带有参数，并且该参数是用来指定要编译的设备型号及其编译类型的。如果等于空的话，那么就调用另外一个函数print_lunch_menu来显示Lunch菜单项，并且通过调用read函数来等待用户输入。无论通过何种方式，最终变量answer的值就保存了用户所指定的备型号及其编译类型。</span><br><span class="line"></span><br><span class="line">        2. 对变量answer的值的合法性进行检查。如果等于空的话，就将它设置为默认值“full-eng”。如果不等于空的话，就分为三种情况考虑。第一种情况是值为数字，那么就需要确保该数字的大小不能超过Lunch菜单项的个数。在这种情况下，会将输入的数字索引到数组LUNCH_MENU_CHOICES中去，以便获得一个用来表示设备型号及其编译类型的文本。第二种情况是非数字文本，那么就需要确保该文本符合&lt;product&gt;-&lt;variant&gt;的形式，其中&lt;product&gt;表示设备型号，而&lt;variant&gt;表示编译类型 。第三种情况是除了前面两种情况之外的所有情况，这是非法的。经过合法性检查后，变量selection代表了用户所指定的备型号及其编译类型，如果它的值是非法的，即它的值等于空，那么函数lunch就不往下执行了。</span><br><span class="line"></span><br><span class="line">        3. 接下来是解析变量selection的值，也就是通过sed命令将它的&lt;product&gt;和&lt;variant&gt;值提取出来，并且分别保存在变量product和variant中。提取出来的product和variant值有可能是不合法的，因此需要进一步通过调用函数check_product和check_variant来检查。一旦检查失败，也就是函数check_product和check_variant的返回值$?等于非0，那么函数lunch就不往下执行了。</span><br><span class="line"></span><br><span class="line">        4. 通过以上合法性检查之后，就将变量product和variant的值保存在环境变量TARGET_PRODUCT和TARGET_BUILD_VARIANT中。此外，另外一个环境变量TARGET_BUILD_TYPE的值会被设置为&quot;release&quot;，表示此次编译是一个release版本的编译。另外，前面还有一个环境变量TARGET_BUILD_APPS，它的值被函数lunch设置为空，用来表示此次编译是对整个系统进行编译。如果环境变量TARGET_BUILD_APPS的值不等于空，那么就表示此次编译是只对某些APP模块进行编译，而这些APP模块就是由环境变量TARGET_BUILD_APPS来指定的。</span><br><span class="line"></span><br><span class="line">        5. 调用函数set_stuff_for_environment来配置环境，例如设置Java SDK路径和交叉编译工具路径等。</span><br><span class="line"></span><br><span class="line">        6. 调用函数printfconfig来显示已经配置好的编译环境参数。</span><br></pre></td></tr></table></figure>
<p>在上述执行过程中，函数check_product、check_variant和printconfig是比较关键的，因此接下来我们就继续分析它们的实现。</p>
<p> 函数check_product定义在文件build/envsetup.sh中，它的实现如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[plain] view plain copy</span><br><span class="line"># check to see if the supplied product is one we can build  </span><br><span class="line">function check_product()  </span><br><span class="line">&#123;  </span><br><span class="line">    T=$(gettop)  </span><br><span class="line">    if [ ! &quot;$T&quot; ]; then  </span><br><span class="line">        echo &quot;Couldn&apos;t locate the top of the tree.  Try setting TOP.&quot; &gt;&amp;2  </span><br><span class="line">        return  </span><br><span class="line">    fi  </span><br><span class="line">    CALLED_FROM_SETUP=true BUILD_SYSTEM=build/core \  </span><br><span class="line">        TARGET_PRODUCT=$1 \  </span><br><span class="line">        TARGET_BUILD_VARIANT= \  </span><br><span class="line">        TARGET_BUILD_TYPE= \  </span><br><span class="line">        TARGET_BUILD_APPS= \  </span><br><span class="line">        get_build_var TARGET_DEVICE &gt; /dev/null  </span><br><span class="line">    # hide successful answers, but allow the errors to show  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数gettop用来返回Android源代码工程的根目录。函数check_product需要在Android源代码工程根目录或者子目录下调用。否则的话，函数check_product就出错返回。<br>        接下来函数check_product设置几个环境变量，其中最重要的是前面三个CALLED_FROM_SETUP、BUILD_SYSTEM和TARGET_PRODUCT。环境变量CALLED_FROM_SETUP的值等于true表示接下来执行的make命令是用来初始化Android编译环境的。环境变量BUILD_SYSTEM用来指定Android编译系统的核心目录，它的值被设置为build/core。环境变量TARGET_PRODUCT用来表示要检查的产品名称（也就是我们前面说的设备型号），它的值被设置为$1，即函数check_product的调用参数。</p>
<p>最后函数check_product调用函数get_build_var来检查由环境变量TARGET_PRODUCT指定的产品名称是否合法，注意，它的调用参数为TARGET_DEVICE。</p>
<p>函数get_build_var定义在文件build/envsetup.sh中，它的实现如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[plain] view plain copy</span><br><span class="line"># Get the exact value of a build variable.  </span><br><span class="line">function get_build_var()  </span><br><span class="line">&#123;  </span><br><span class="line">    T=$(gettop)  </span><br><span class="line">    if [ ! &quot;$T&quot; ]; then  </span><br><span class="line">        echo &quot;Couldn&apos;t locate the top of the tree.  Try setting TOP.&quot; &gt;&amp;2  </span><br><span class="line">        return  </span><br><span class="line">    fi  </span><br><span class="line">    CALLED_FROM_SETUP=true BUILD_SYSTEM=build/core \  </span><br><span class="line">      make --no-print-directory -C &quot;$T&quot; -f build/core/config.mk dumpvar-$1  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就可以看到，函数get_build_var实际上就是通过make命令在Android源代码工程根目录中执行build/core/config.mk文件，并且将make目标设置为dumpvar-$1，也就是dumpvar-TARGET_DEVICE。<br>        文件build/core/config.mk的内容比较多，这里我们只关注与产品名称合法性检查相关的逻辑，这些逻辑也基本上涵盖了Android编译系统初始化的逻辑，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[plain] view plain copy</span><br><span class="line">......  </span><br><span class="line">  </span><br><span class="line"># ---------------------------------------------------------------  </span><br><span class="line"># Define most of the global variables.  These are the ones that  </span><br><span class="line"># are specific to the user&apos;s build configuration.  </span><br><span class="line">include $(BUILD_SYSTEM)/envsetup.mk  </span><br><span class="line">  </span><br><span class="line"># Boards may be defined under $(SRC_TARGET_DIR)/board/$(TARGET_DEVICE)  </span><br><span class="line"># or under vendor/*/$(TARGET_DEVICE).  Search in both places, but  </span><br><span class="line"># make sure only one exists.  </span><br><span class="line"># Real boards should always be associated with an OEM vendor.  </span><br><span class="line">board_config_mk := \  </span><br><span class="line">    $(strip $(wildcard \  </span><br><span class="line">        $(SRC_TARGET_DIR)/board/$(TARGET_DEVICE)/BoardConfig.mk \  </span><br><span class="line">        device/*/$(TARGET_DEVICE)/BoardConfig.mk \  </span><br><span class="line">        vendor/*/$(TARGET_DEVICE)/BoardConfig.mk \  </span><br><span class="line">    ))  </span><br><span class="line">ifeq ($(board_config_mk),)  </span><br><span class="line">  $(error No config file found for TARGET_DEVICE $(TARGET_DEVICE))  </span><br><span class="line">endif  </span><br><span class="line">ifneq ($(words $(board_config_mk)),1)  </span><br><span class="line">  $(error Multiple board config files for TARGET_DEVICE $(TARGET_DEVICE): $(board_config_mk))  </span><br><span class="line">endif  </span><br><span class="line">include $(board_config_mk)  </span><br><span class="line">  </span><br><span class="line">......</span><br><span class="line">include $(BUILD_SYSTEM)/dumpvar.mk</span><br></pre></td></tr></table></figure>
<p>上述代码主要就是将envsetup.mk、BoardConfig,mk和dumpvar.mk三个Makefile片段文件加载进来。其中，envsetup.mk文件位于$(BUILD_SYSTEM)目录中，也就是build/core目录中，BoardConfig.mk文件的位置主要就是由环境变量TARGET_DEVICE来确定，它是用来描述目标产品的硬件模块信息的，例如CPU体系结构。环境变量TARGET_DEVICE用来描述目标设备，它的值是在envsetup.mk文件加载的过程中确定的。一旦目标设备确定后，就可以在$(SRC_TARGET_DIR)/board/$(TARGET_DEVICE)、device/<em>/$(TARGET_DEVICE)和vendor/</em>/$(TARGET_DEVICE)目录中找到对应的BoradConfig.mk文件。注意，变量SRC_TARGET_DIR的值等于build/target。最后，dumpvar.mk文件也是位于build/core目录中，它用来打印已经配置好的编译环境信息。<br>        接下来我们就通过进入到build/core/envsetup.mk文件来分析变量TARGET_DEVICE的值是如何确定的：</p>
<p>[plain] view plain copy</p>
<h1 id="Read-the-product-specs-so-we-an-get-TARGET-DEVICE-and-other"><a href="#Read-the-product-specs-so-we-an-get-TARGET-DEVICE-and-other" class="headerlink" title="Read the product specs so we an get TARGET_DEVICE and other"></a>Read the product specs so we an get TARGET_DEVICE and other</h1><h1 id="variables-that-we-need-in-order-to-locate-the-output-files"><a href="#variables-that-we-need-in-order-to-locate-the-output-files" class="headerlink" title="variables that we need in order to locate the output files."></a>variables that we need in order to locate the output files.</h1><p>include $(BUILD_SYSTEM)/product_config.mk<br>       它通过加载另外一个文件build/core/product_config.mk文件来确定变量TARGET_DEVICE以及其它与目标产品相关的变量的值。<br>       文件build/core/product_config.mk的内容很多，这里我们只关注变量TARGET_DEVICE设置相关的逻辑，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">[plain] view plain copy</span><br><span class="line">......  </span><br><span class="line">  </span><br><span class="line">ifneq ($(strip $(TARGET_BUILD_APPS)),)  </span><br><span class="line"># An unbundled app build needs only the core product makefiles.  </span><br><span class="line">all_product_configs := $(call get-product-makefiles,\  </span><br><span class="line">    $(SRC_TARGET_DIR)/product/AndroidProducts.mk)  </span><br><span class="line">else  </span><br><span class="line"># Read in all of the product definitions specified by the AndroidProducts.mk  </span><br><span class="line"># files in the tree.  </span><br><span class="line">all_product_configs := $(get-all-product-makefiles)  </span><br><span class="line">endif  </span><br><span class="line">  </span><br><span class="line"># all_product_configs consists items like:  </span><br><span class="line"># &lt;product_name&gt;:&lt;path_to_the_product_makefile&gt;  </span><br><span class="line"># or just &lt;path_to_the_product_makefile&gt; in case the product name is the  </span><br><span class="line"># same as the base filename of the product config makefile.  </span><br><span class="line">current_product_makefile :=  </span><br><span class="line">all_product_makefiles :=  </span><br><span class="line">$(foreach f, $(all_product_configs),\  </span><br><span class="line">    $(eval _cpm_words := $(subst :,$(space),$(f)))\  </span><br><span class="line">    $(eval _cpm_word1 := $(word 1,$(_cpm_words)))\  </span><br><span class="line">    $(eval _cpm_word2 := $(word 2,$(_cpm_words)))\  </span><br><span class="line">    $(if $(_cpm_word2),\  </span><br><span class="line">        $(eval all_product_makefiles += $(_cpm_word2))\  </span><br><span class="line">        $(if $(filter $(TARGET_PRODUCT),$(_cpm_word1)),\  </span><br><span class="line">            $(eval current_product_makefile += $(_cpm_word2)),),\  </span><br><span class="line">        $(eval all_product_makefiles += $(f))\  </span><br><span class="line">        $(if $(filter $(TARGET_PRODUCT),$(basename $(notdir $(f)))),\  </span><br><span class="line">            $(eval current_product_makefile += $(f)),)))  </span><br><span class="line">_cpm_words :=  </span><br><span class="line">_cpm_word1 :=  </span><br><span class="line">_cpm_word2 :=  </span><br><span class="line">current_product_makefile := $(strip $(current_product_makefile))  </span><br><span class="line">all_product_makefiles := $(strip $(all_product_makefiles))  </span><br><span class="line">  </span><br><span class="line">ifneq (,$(filter product-graph dump-products, $(MAKECMDGOALS)))  </span><br><span class="line"># Import all product makefiles.  </span><br><span class="line">$(call import-products, $(all_product_makefiles))  </span><br><span class="line">else  </span><br><span class="line"># Import just the current product.  </span><br><span class="line">ifndef current_product_makefile  </span><br><span class="line">$(error Cannot locate config makefile for product &quot;$(TARGET_PRODUCT)&quot;)  </span><br><span class="line">endif  </span><br><span class="line">ifneq (1,$(words $(current_product_makefile)))  </span><br><span class="line">$(error Product &quot;$(TARGET_PRODUCT)&quot; ambiguous: matches $(current_product_makefile))  </span><br><span class="line">endif  </span><br><span class="line">$(call import-products, $(current_product_makefile))  </span><br><span class="line">endif  # Import all or just the current product makefile  </span><br><span class="line">  </span><br><span class="line">......  </span><br><span class="line">  </span><br><span class="line"># Convert a short name like &quot;sooner&quot; into the path to the product  </span><br><span class="line"># file defining that product.  </span><br><span class="line">#  </span><br><span class="line">INTERNAL_PRODUCT := $(call resolve-short-product-name, $(TARGET_PRODUCT))  </span><br><span class="line">ifneq ($(current_product_makefile),$(INTERNAL_PRODUCT))  </span><br><span class="line">$(error PRODUCT_NAME inconsistent in $(current_product_makefile) and $(INTERNAL_PRODUCT))  </span><br><span class="line">endif  </span><br><span class="line">current_product_makefile :=  </span><br><span class="line">all_product_makefiles :=  </span><br><span class="line">all_product_configs :=  </span><br><span class="line">  </span><br><span class="line"># Find the device that this product maps to.  </span><br><span class="line">TARGET_DEVICE := $(PRODUCTS.$(INTERNAL_PRODUCT).PRODUCT_DEVICE)  </span><br><span class="line">  </span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>上述代码的执行逻辑如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. 检查环境变量TARGET_BUILD_APPS的值是否等于空。如果不等于空，那么就说明此次编译不是针对整个系统，因此只要将核心的产品相关的Makefile文件加载进来就行了，否则的话，就要将所有与产品相关的Makefile文件加载进来的。核心产品Makefile文件在$(SRC_TARGET_DIR)/product/AndroidProducts.mk文件中指定，也就是在build/target/product/AndroidProducts.mk文件，通过调用函数get-product-makefiles可以获得。所有与产品相关的Makefile文件可以通过另外一个函数get-all-product-makefiles获得。无论如何，最终获得的产品Makefie文件列表保存在变量all_product_configs中。</span><br><span class="line"></span><br><span class="line">       2. 遍历变量all_product_configs所描述的产品Makefile列表，并且在这些Makefile文件中，找到名称与环境变量TARGET_PRODUCT的值相同的文件，保存在另外一个变量current_product_makefile中，作为需要为当前指定的产品所加载的Makefile文件列表。在这个过程当中，上一步找到的所有的产品Makefile文件也会保存在变量all_product_makefiles中。注意，环境变量TARGET_PRODUCT的值是在我们执行lunch命令的时候设置并且传递进来的。</span><br><span class="line"></span><br><span class="line">       3.  如果指定的make目标等于product-graph或者dump-products，那么就将所有的产品相关的Makefile文件加载进来，否则的话，只加载与目标产品相关的Makefile文件。从前面的分析可以知道，此时的make目标为dumpvar-TARGET_DEVICE，因此接下来只会加载与目标产品，即$(TARGET_PRODUCT)，相关的Makefile文件，这是通过调用另外一个函数import-products实现的。</span><br><span class="line"></span><br><span class="line">       4. 调用函数resolve-short-product-name解析环境变量TARGET_PRODUCT的值，将它变成一个Makefile文件路径。并且保存在变量INTERNAL_PRODUCT中。这里要求变量INTERNAL_PRODUCT和current_product_makefile的值相等，否则的话，就说明用户指定了一个非法的产品名称。</span><br><span class="line"></span><br><span class="line">       5. 找到一个名称为PRODUCTS.$(INTERNAL_PRODUCT).PRODUCT_DEVICE的变量，并且将它的值保存另外一个变量TARGET_DEVICE中。变量PRODUCTS.$(INTERNAL_PRODUCT).PRODUCT_DEVICE是在加载产品Makefile文件的过程中定义的，用来描述当前指定的产品的名称。</span><br></pre></td></tr></table></figure>
<p>上述过程主要涉及到了get-all-product-makefiles、import-products和resolve-short-product-name三个关键函数，理解它们的执行过程对理解Android编译系统的初始化过程很有帮助，接下来我们分别分析它们的实现。</p>
<p>函数get-all-product-makefiles定义在文件build/core/product.mk中，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[plain] view plain copy</span><br><span class="line">#  </span><br><span class="line"># Returns the sorted concatenation of all PRODUCT_MAKEFILES  </span><br><span class="line"># variables set in all AndroidProducts.mk files.  </span><br><span class="line"># $(call ) isn&apos;t necessary.  </span><br><span class="line">#  </span><br><span class="line">define get-all-product-makefiles  </span><br><span class="line">$(call get-product-makefiles,$(_find-android-products-files))  </span><br><span class="line">endef</span><br></pre></td></tr></table></figure>
<p>它首先是调用函数_find-android-products-files来找到Android源代码目录中定义的所有AndroidProducts.mk文件，然后再调用函数get-product-makefiles获得在这里AndroidProducts.mk文件里面定义的产品Makefile文件。<br>       函数_find-android-products-files也是定义在文件build/core/product.mk中，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[plain] view plain copy</span><br><span class="line">#  </span><br><span class="line"># Returns the list of all AndroidProducts.mk files.  </span><br><span class="line"># $(call ) isn&apos;t necessary.  </span><br><span class="line">#  </span><br><span class="line">define _find-android-products-files  </span><br><span class="line">$(shell test -d device &amp;&amp; find device -maxdepth 6 -name AndroidProducts.mk) \  </span><br><span class="line">  $(shell test -d vendor &amp;&amp; find vendor -maxdepth 6 -name AndroidProducts.mk) \  </span><br><span class="line">  $(SRC_TARGET_DIR)/product/AndroidProducts.mk  </span><br><span class="line">endef  </span><br><span class="line">      从这里就可以看出，Android源代码目录中定义的所有AndroidProducts.mk文件位于device、vendor或者build/target/product目录或者相应的子目录（最深是6层）中。</span><br><span class="line">      函数get-product-makefiles也是定义在文件build/core/product.mk中，如下所示：</span><br><span class="line"></span><br><span class="line">[plain] view plain copy</span><br><span class="line">#  </span><br><span class="line"># Returns the sorted concatenation of PRODUCT_MAKEFILES  </span><br><span class="line"># variables set in the given AndroidProducts.mk files.  </span><br><span class="line"># $(1): the list of AndroidProducts.mk files.  </span><br><span class="line">#  </span><br><span class="line">define get-product-makefiles  </span><br><span class="line">$(sort \  </span><br><span class="line">  $(foreach f,$(1), \  </span><br><span class="line">    $(eval PRODUCT_MAKEFILES :=) \  </span><br><span class="line">    $(eval LOCAL_DIR := $(patsubst %/,%,$(dir $(f)))) \  </span><br><span class="line">    $(eval include $(f)) \  </span><br><span class="line">    $(PRODUCT_MAKEFILES) \  </span><br><span class="line">   ) \  </span><br><span class="line">  $(eval PRODUCT_MAKEFILES :=) \  </span><br><span class="line">  $(eval LOCAL_DIR :=) \  </span><br><span class="line"> )  </span><br><span class="line">endef</span><br></pre></td></tr></table></figure>
<p>这个函数实际上就是遍历参数$1所描述的AndroidProucts.mk文件列表，并且将定义在这些AndroidProucts.mk文件中的变量PRODUCT_MAKEFILES的值提取出来，形成一个列表返回给调用者。<br>       例如，在build/target/product/AndroidProducts.mk文件中，变量PRODUCT_MAKEFILES的值如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[plain] view plain copy</span><br><span class="line"># Unbundled apps will be built with the most generic product config.  </span><br><span class="line">ifneq ($(TARGET_BUILD_APPS),)  </span><br><span class="line">PRODUCT_MAKEFILES := \  </span><br><span class="line">    $(LOCAL_DIR)/full.mk \  </span><br><span class="line">    $(LOCAL_DIR)/full_x86.mk \  </span><br><span class="line">    $(LOCAL_DIR)/full_mips.mk  </span><br><span class="line">else  </span><br><span class="line">PRODUCT_MAKEFILES := \  </span><br><span class="line">    $(LOCAL_DIR)/core.mk \  </span><br><span class="line">    $(LOCAL_DIR)/generic.mk \  </span><br><span class="line">    $(LOCAL_DIR)/generic_x86.mk \  </span><br><span class="line">    $(LOCAL_DIR)/generic_mips.mk \  </span><br><span class="line">    $(LOCAL_DIR)/full.mk \  </span><br><span class="line">    $(LOCAL_DIR)/full_x86.mk \  </span><br><span class="line">    $(LOCAL_DIR)/full_mips.mk \  </span><br><span class="line">    $(LOCAL_DIR)/vbox_x86.mk \  </span><br><span class="line">    $(LOCAL_DIR)/sdk.mk \  </span><br><span class="line">    $(LOCAL_DIR)/sdk_x86.mk \  </span><br><span class="line">    $(LOCAL_DIR)/sdk_mips.mk \  </span><br><span class="line">    $(LOCAL_DIR)/large_emu_hw.mk  </span><br><span class="line">endif</span><br></pre></td></tr></table></figure>
<p>里列出的每一个文件都对应于一个产品。<br>       我们再来看函数import-products的实现，它定义在文件build/core/product.mk中，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[plain] view plain copy</span><br><span class="line">#  </span><br><span class="line"># $(1): product makefile list  </span><br><span class="line">#  </span><br><span class="line">#TODO: check to make sure that products have all the necessary vars defined  </span><br><span class="line">define import-products  </span><br><span class="line">$(call import-nodes,PRODUCTS,$(1),$(_product_var_list))  </span><br><span class="line">endef</span><br></pre></td></tr></table></figure>
<p>它调用另外一个函数import-nodes来加载由参数$1所指定的产品Makefile文件，并且指定了另外两个参数PRODUCTS和$(_product_var_list)。其中，变量_product_var_list也是定义在文件build/core/product.mk中，它的值如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[plain] view plain copy</span><br><span class="line">_product_var_list := \  </span><br><span class="line">    PRODUCT_NAME \  </span><br><span class="line">    PRODUCT_MODEL \  </span><br><span class="line">    PRODUCT_LOCALES \  </span><br><span class="line">    PRODUCT_AAPT_CONFIG \  </span><br><span class="line">    PRODUCT_AAPT_PREF_CONFIG \  </span><br><span class="line">    PRODUCT_PACKAGES \  </span><br><span class="line">    PRODUCT_PACKAGES_DEBUG \  </span><br><span class="line">    PRODUCT_PACKAGES_ENG \  </span><br><span class="line">    PRODUCT_PACKAGES_TESTS \  </span><br><span class="line">    PRODUCT_DEVICE \  </span><br><span class="line">    PRODUCT_MANUFACTURER \  </span><br><span class="line">    PRODUCT_BRAND \  </span><br><span class="line">    PRODUCT_PROPERTY_OVERRIDES \  </span><br><span class="line">    PRODUCT_DEFAULT_PROPERTY_OVERRIDES \  </span><br><span class="line">    PRODUCT_CHARACTERISTICS \  </span><br><span class="line">    PRODUCT_COPY_FILES \  </span><br><span class="line">    PRODUCT_OTA_PUBLIC_KEYS \  </span><br><span class="line">    PRODUCT_EXTRA_RECOVERY_KEYS \  </span><br><span class="line">    PRODUCT_PACKAGE_OVERLAYS \  </span><br><span class="line">    DEVICE_PACKAGE_OVERLAYS \  </span><br><span class="line">    PRODUCT_TAGS \  </span><br><span class="line">    PRODUCT_SDK_ADDON_NAME \  </span><br><span class="line">    PRODUCT_SDK_ADDON_COPY_FILES \  </span><br><span class="line">    PRODUCT_SDK_ADDON_COPY_MODULES \  </span><br><span class="line">    PRODUCT_SDK_ADDON_DOC_MODULES \  </span><br><span class="line">    PRODUCT_DEFAULT_WIFI_CHANNELS \  </span><br><span class="line">    PRODUCT_DEFAULT_DEV_CERTIFICATE \  </span><br><span class="line">    PRODUCT_RESTRICT_VENDOR_FILES \  </span><br><span class="line">    PRODUCT_VENDOR_KERNEL_HEADERS \  </span><br><span class="line">    PRODUCT_FACTORY_RAMDISK_MODULES \  </span><br><span class="line">    PRODUCT_FACTORY_BUNDLE_MODULES</span><br></pre></td></tr></table></figure>
<p> 它描述的是在产品Makefile文件中定义在各种变量。<br>       函数import-nodes定义在文件build/core/node_fns.mk中，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[plain] view plain copy</span><br><span class="line">#  </span><br><span class="line"># $(1): output list variable name, like &quot;PRODUCTS&quot; or &quot;DEVICES&quot;  </span><br><span class="line"># $(2): list of makefiles representing nodes to import  </span><br><span class="line"># $(3): list of node variable names  </span><br><span class="line">#  </span><br><span class="line">define import-nodes  </span><br><span class="line">$(if \  </span><br><span class="line">  $(foreach _in,$(2), \  </span><br><span class="line">    $(eval _node_import_context := _nic.$(1).[[$(_in)]]) \  </span><br><span class="line">    $(if $(_include_stack),$(eval $(error ASSERTION FAILED: _include_stack \  </span><br><span class="line">                should be empty here: $(_include_stack))),) \  </span><br><span class="line">    $(eval _include_stack := ) \  </span><br><span class="line">    $(call _import-nodes-inner,$(_node_import_context),$(_in),$(3)) \  </span><br><span class="line">    $(call move-var-list,$(_node_import_context).$(_in),$(1).$(_in),$(3)) \  </span><br><span class="line">    $(eval _node_import_context :=) \  </span><br><span class="line">    $(eval $(1) := $($(1)) $(_in)) \  </span><br><span class="line">    $(if $(_include_stack),$(eval $(error ASSERTION FAILED: _include_stack \  </span><br><span class="line">                should be empty here: $(_include_stack))),) \  </span><br><span class="line">   ) \  </span><br><span class="line">,)  </span><br><span class="line">endef</span><br></pre></td></tr></table></figure>
<p>这个函数主要是做了三件事情：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 调用函数_import-nodes-inner将参数$2描述的每一个产品Makefile文件加载进来。</span><br><span class="line"></span><br><span class="line">       2. 调用函数move-var-list将定义在前面所加载的产品Makefile文件里面的由参数$3指定的变量的值分别拷贝到另外一组独立的变量中。</span><br><span class="line"></span><br><span class="line">       3. 将参数$2描述的每一个产品Makefile文件路径以空格分隔保存在参数$1所描述的变量中，也就是保存在变量PRODUCTS中。</span><br><span class="line"></span><br><span class="line">       上述第二件事情需要进一步解释一下。由于当前加载的每一个文件都会定义相同的变量，为了区分这些变量，我们需要在这些变量前面加一些前缀。例如，假设加载了build/target/product/full.mk这个产品Makefile文件，它里面定义了以下几个变量：</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[plain] view plain copy</span><br><span class="line"># Overrides  </span><br><span class="line">PRODUCT_NAME := full  </span><br><span class="line">PRODUCT_DEVICE := generic  </span><br><span class="line">PRODUCT_BRAND := Android  </span><br><span class="line">PRODUCT_MODEL := Full Android on Emulator  </span><br><span class="line">       当调用了函数move-var-list对它进行解析后，就会得到以下的新变量：</span><br><span class="line">[plain] view plain copy</span><br><span class="line">PRODUCTS.build/target/product/full.mk.PRODUCT_NAME := full  </span><br><span class="line">PRODUCTS.build/target/product/full.mk.PRODUCT_DEVICE := generic  </span><br><span class="line">PRODUCTS.build/target/product/full.mk.PRODUCT_BRAND := Android  </span><br><span class="line">PRODUCTS.build/target/product/full.mk.PRODUCT_MODEL := Full Android on Emulator</span><br></pre></td></tr></table></figure>
<p>正是由于调用了函数move-var-list，我们在build/core/product_config.mk文件中可以通过PRODUCTS.$(INTERNAL_PRODUCT).PRODUCT_DEVICE来设置变量TARGET_DEVICE的值。<br>       回到build/core/config.mk文件中，接下来我们再看BoardConfig.mk文件的加载过程。前面提到，当前要加载的BoardConfig.mk文件由变量TARGET_DEVICE来确定。例如，假设我们在运行lunch命令时，输入的文本为full-eng，那么build/target/product/full.mk就会被加载，并且我们得到TARGET_DEVICE的值就为generic，接下来加载的BoradConfig.mk文件就会在build/target/board/generic目录中找到。</p>
<p>BoardConfig.mk文件定义的信息可以参考build/target/board/generic/BoardConfig.mk文件的内容，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">[plain] view plain copy</span><br><span class="line"># config.mk  </span><br><span class="line">#  </span><br><span class="line"># Product-specific compile-time definitions.  </span><br><span class="line">#  </span><br><span class="line">  </span><br><span class="line"># The generic product target doesn&apos;t have any hardware-specific pieces.  </span><br><span class="line">TARGET_NO_BOOTLOADER := true  </span><br><span class="line">TARGET_NO_KERNEL := true  </span><br><span class="line">TARGET_ARCH := arm  </span><br><span class="line">  </span><br><span class="line"># Note: we build the platform images for ARMv7-A _without_ NEON.  </span><br><span class="line">#  </span><br><span class="line"># Technically, the emulator supports ARMv7-A _and_ NEON instructions, but  </span><br><span class="line"># emulated NEON code paths typically ends up 2x slower than the normal C code  </span><br><span class="line"># it is supposed to replace (unlike on real devices where it is 2x to 3x  </span><br><span class="line"># faster).  </span><br><span class="line">#  </span><br><span class="line"># What this means is that the platform image will not use NEON code paths  </span><br><span class="line"># that are slower to emulate. On the other hand, it is possible to emulate  </span><br><span class="line"># application code generated with the NDK that uses NEON in the emulator.  </span><br><span class="line">#  </span><br><span class="line">TARGET_ARCH_VARIANT := armv7-a  </span><br><span class="line">TARGET_CPU_ABI := armeabi-v7a  </span><br><span class="line">TARGET_CPU_ABI2 := armeabi  </span><br><span class="line">ARCH_ARM_HAVE_TLS_REGISTER := true  </span><br><span class="line">  </span><br><span class="line">HAVE_HTC_AUDIO_DRIVER := true  </span><br><span class="line">BOARD_USES_GENERIC_AUDIO := true  </span><br><span class="line">  </span><br><span class="line"># no hardware camera  </span><br><span class="line">USE_CAMERA_STUB := true  </span><br><span class="line">  </span><br><span class="line"># Enable dex-preoptimization to speed up the first boot sequence  </span><br><span class="line"># of an SDK AVD. Note that this operation only works on Linux for now  </span><br><span class="line">ifeq ($(HOST_OS),linux)  </span><br><span class="line">  ifeq ($(WITH_DEXPREOPT),)  </span><br><span class="line">    WITH_DEXPREOPT := true  </span><br><span class="line">  endif  </span><br><span class="line">endif  </span><br><span class="line">  </span><br><span class="line"># Build OpenGLES emulation guest and host libraries  </span><br><span class="line">BUILD_EMULATOR_OPENGL := true  </span><br><span class="line">  </span><br><span class="line"># Build and enable the OpenGL ES View renderer. When running on the emulator,  </span><br><span class="line"># the GLES renderer disables itself if host GL acceleration isn&apos;t available.  </span><br><span class="line">USE_OPENGL_RENDERER := true</span><br></pre></td></tr></table></figure>
<p>它描述了产品的Boot Loader、Kernel、CPU体系结构、CPU ABI和Opengl加速等信息。<br>       再回到build/core/config.mk文件中，它最后加载build/core/dumpvar.mk文件。加载build/core/dumpvar.mk文件是为了生成make目标，以便可以对这些目标进行操作。例如，在我们这个情景中，我们要执行的make目标是dumpvar-TARGET_DEVICE，因此在加载build/core/dumpvar.mk文件的过程中，就会生成dumpvar-TARGET_DEVICE目标。</p>
<p>文件build/core/dumpvar.mk的内容也比较多，这里我们只关注生成make目标相关的逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">[plain] view plain copy</span><br><span class="line">......  </span><br><span class="line">  </span><br><span class="line"># The &quot;dumpvar&quot; stuff lets you say something like  </span><br><span class="line">#  </span><br><span class="line">#     CALLED_FROM_SETUP=true \  </span><br><span class="line">#       make -f config/envsetup.make dumpvar-TARGET_OUT  </span><br><span class="line"># or  </span><br><span class="line">#     CALLED_FROM_SETUP=true \  </span><br><span class="line">#       make -f config/envsetup.make dumpvar-abs-HOST_OUT_EXECUTABLES  </span><br><span class="line">#  </span><br><span class="line"># The plain (non-abs) version just dumps the value of the named variable.  </span><br><span class="line"># The &quot;abs&quot; version will treat the variable as a path, and dumps an  </span><br><span class="line"># absolute path to it.  </span><br><span class="line">#  </span><br><span class="line">dumpvar_goals := \  </span><br><span class="line">    $(strip $(patsubst dumpvar-%,%,$(filter dumpvar-%,$(MAKECMDGOALS))))  </span><br><span class="line">ifdef dumpvar_goals  </span><br><span class="line">  </span><br><span class="line">  ifneq ($(words $(dumpvar_goals)),1)  </span><br><span class="line">    $(error Only one &quot;dumpvar-&quot; goal allowed. Saw &quot;$(MAKECMDGOALS)&quot;)  </span><br><span class="line">  endif  </span><br><span class="line">  </span><br><span class="line">  # If the goal is of the form &quot;dumpvar-abs-VARNAME&quot;, then  </span><br><span class="line">  # treat VARNAME as a path and return the absolute path to it.  </span><br><span class="line">  absolute_dumpvar := $(strip $(filter abs-%,$(dumpvar_goals)))  </span><br><span class="line">  ifdef absolute_dumpvar  </span><br><span class="line">    dumpvar_goals := $(patsubst abs-%,%,$(dumpvar_goals))  </span><br><span class="line">    ifneq ($(filter /%,$($(dumpvar_goals))),)  </span><br><span class="line">      DUMPVAR_VALUE := $($(dumpvar_goals))  </span><br><span class="line">    else  </span><br><span class="line">      DUMPVAR_VALUE := $(PWD)/$($(dumpvar_goals))  </span><br><span class="line">    endif  </span><br><span class="line">    dumpvar_target := dumpvar-abs-$(dumpvar_goals)  </span><br><span class="line">  else  </span><br><span class="line">    DUMPVAR_VALUE := $($(dumpvar_goals))  </span><br><span class="line">    dumpvar_target := dumpvar-$(dumpvar_goals)  </span><br><span class="line">  endif  </span><br><span class="line">  </span><br><span class="line">.PHONY: $(dumpvar_target)  </span><br><span class="line">$(dumpvar_target):  </span><br><span class="line">    @echo $(DUMPVAR_VALUE)  </span><br><span class="line">  </span><br><span class="line">endif # dumpvar_goals  </span><br><span class="line">  </span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p> 我们在执行make命令时，指定的目示会经由MAKECMDGOALS变量传递到Makefile中，因此通过变量MAKECMDGOALS可以获得make目标。<br>      上述代码的逻辑很简单，例如，在我们这个情景中，指定的make目标为dumpvar-TARGET_DEVICE，那么就会得到变量DUMPVAR_VALUE的值为$(TARGET_DEVICE)。TARGET_DEVICE的值在前面已经被设置为“generic”，因此变量DUMPVAR_VALUE的值就等于“generic”。此外，变量dumpvar_target的被设置为“dumpvar-TARGET_DEVICE”。最后我们就可以得到以下的make规则：</p>
<p>[plain] view plain copy<br>.PHONY dumpvar-TARGET_DEVICE<br>dumpvar-TARGET_DEVICE:<br>    @echo generic<br>       至此，在build/envsetup.sh文件中定义的函数check_product就分析完成了。看完了之后，小伙伴们可能会问，前面不是说这个函数是用来检查用户输入的产品名称是否合法的吗？但是这里没看出哪一段代码给出了true或者false的答案啊。实际上，在前面分析的build/core/config.mk和build/core/product_config.mk等文件的加载过程中，如果发现输入的产品名称是非法的，也就是找不到相应的产品Makefile文件，那么就会通过调用error函数来产生一个错误，这时候函数check_product的返回值$?就会等于非0值。<br>       接下来我们还要继续分析在build/envsetup.sh文件中定义的函数check_variant的实现，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[plain] view plain copy</span><br><span class="line">VARIANT_CHOICES=(user userdebug eng)  </span><br><span class="line">  </span><br><span class="line"># check to see if the supplied variant is valid  </span><br><span class="line">function check_variant()  </span><br><span class="line">&#123;  </span><br><span class="line">    for v in $&#123;VARIANT_CHOICES[@]&#125;  </span><br><span class="line">    do  </span><br><span class="line">        if [ &quot;$v&quot; = &quot;$1&quot; ]  </span><br><span class="line">        then  </span><br><span class="line">            return 0  </span><br><span class="line">        fi  </span><br><span class="line">    done  </span><br><span class="line">    return 1  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数的实现就简单多了。合法的编译类型定义在数组VARIANT_CHOICES中，并且它只有三个值user、userdebug和eng。其中，user表示发布版本，userdebug表示带调试信息的发布版本，而eng表标工程机版本。<br>       最后，我们再来分析在build/envsetup.sh文件中定义的函数printconfig的实现，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[plain] view plain copy</span><br><span class="line">function printconfig()  </span><br><span class="line">&#123;  </span><br><span class="line">    T=$(gettop)  </span><br><span class="line">    if [ ! &quot;$T&quot; ]; then  </span><br><span class="line">        echo &quot;Couldn&apos;t locate the top of the tree.  Try setting TOP.&quot; &gt;&amp;2  </span><br><span class="line">        return  </span><br><span class="line">    fi  </span><br><span class="line">    get_build_var report_config  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 对比我们前面对函数check_product的分析，就会发现函数printconfig的实现与这很相似，都是通过调用get_build_var来获得相关的信息，但是这里传递给函数get_build_var的参数为report_config。<br>       我们跳过前面build/core/config.mk和build/core/envsetup.mk等文件对目标产品Makefile文件的加载，直接跳到build/core/dumpvar.mk文件来查看与report_config这个make目标相关的逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">[plain] view plain copy</span><br><span class="line">......  </span><br><span class="line">  </span><br><span class="line">dumpvar_goals := \  </span><br><span class="line">    $(strip $(patsubst dumpvar-%,%,$(filter dumpvar-%,$(MAKECMDGOALS))))  </span><br><span class="line">.....  </span><br><span class="line">  </span><br><span class="line">ifneq ($(dumpvar_goals),report_config)  </span><br><span class="line">PRINT_BUILD_CONFIG:=  </span><br><span class="line">endif  </span><br><span class="line">  </span><br><span class="line">......  </span><br><span class="line">  </span><br><span class="line">ifneq ($(PRINT_BUILD_CONFIG),)  </span><br><span class="line">HOST_OS_EXTRA:=$(shell python -c &quot;import platform; print(platform.platform())&quot;)  </span><br><span class="line">$(info ============================================)  </span><br><span class="line">$(info   PLATFORM_VERSION_CODENAME=$(PLATFORM_VERSION_CODENAME))  </span><br><span class="line">$(info   PLATFORM_VERSION=$(PLATFORM_VERSION))  </span><br><span class="line">$(info   TARGET_PRODUCT=$(TARGET_PRODUCT))  </span><br><span class="line">$(info   TARGET_BUILD_VARIANT=$(TARGET_BUILD_VARIANT))  </span><br><span class="line">$(info   TARGET_BUILD_TYPE=$(TARGET_BUILD_TYPE))  </span><br><span class="line">$(info   TARGET_BUILD_APPS=$(TARGET_BUILD_APPS))  </span><br><span class="line">$(info   TARGET_ARCH=$(TARGET_ARCH))  </span><br><span class="line">$(info   TARGET_ARCH_VARIANT=$(TARGET_ARCH_VARIANT))  </span><br><span class="line">$(info   HOST_ARCH=$(HOST_ARCH))  </span><br><span class="line">$(info   HOST_OS=$(HOST_OS))  </span><br><span class="line">$(info   HOST_OS_EXTRA=$(HOST_OS_EXTRA))  </span><br><span class="line">$(info   HOST_BUILD_TYPE=$(HOST_BUILD_TYPE))  </span><br><span class="line">$(info   BUILD_ID=$(BUILD_ID))  </span><br><span class="line">$(info   OUT_DIR=$(OUT_DIR))  </span><br><span class="line">$(info ============================================)  </span><br><span class="line">endif</span><br></pre></td></tr></table></figure>
<p>变量PRINT_BUILD_CONFIG定义在文件build/core/envsetup.mk中，默认值设置为true。当make目标为report-config的时候，变量PRINT_BUILD_CONFIG的值就会被设置为空。因此，接下来就会打印一系列用来描述编译环境配置的变量的值，也就是我们执行lunch命令后看到的输出。注意，这些环境配置相关的变量量都是在加载build/core/config.mk和build/core/envsetup.mk文件的过程中设置的，就类似于前面我们分析的TARGET_DEVICE变量的值的设置过程。<br>       至此，我们就分析完成Android编译系统环境的初始化过程了。从分析的过程可以知道，Android编译系统环境是由build/core/config.mk、build/core/envsetup.mk、build/core/product_config.mk、AndroidProducts.mk和BoardConfig.mk等文件来完成的。这些mk文件涉及到非常多的细节，而我们这里只提供了一个大体的骨架和脉络，希望能够起到抛砖引玉的作用。</p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://wenyiqingnian.xyz/2017/04/05/编译系统环境初始化过程/" data-id="cjl3hswwq002aum8xe8tpu19u" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    
        <a href="http://wenyiqingnian.xyz/2017/04/05/编译系统环境初始化过程/#comments" class="article-comment-link">Comments</a>
    

        </footer>
    </div>
    
</article>



    <article id="post-添加SE安全策略" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2017/03/15/添加SE安全策略/">添加SE安全策略</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2017/03/15/添加SE安全策略/">
            <time datetime="2017-03-15T11:10:10.000Z" itemprop="datePublished">2017-03-15</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/AOSP/">AOSP</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/SEAndroid/">SEAndroid</a>, <a class="tag-link" href="/tags/编译/">编译</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <h2 id="一、-问题复现"><a href="#一、-问题复现" class="headerlink" title="一、 问题复现"></a>一、 问题复现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.service ro_isn /system/bin/isn.sh </span><br><span class="line">2.class late_start</span><br><span class="line">3.user root</span><br><span class="line">4.oneshot</span><br></pre></td></tr></table></figure>
<p>kernel log会打印以下log：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Warning!  Service ro_isn needs a SELinux domain defined; please fix!</span><br></pre></td></tr></table></figure>
<p>这是因为<strong>Service ro_isn</strong>没有在<strong>SELinux</strong>的监控之下，这种情况会提示你定义一个SELinux。<br>在这种情况下，你可以：<br>1.无视该条log，Service功能不受影响。各种权限不受限制。但是这样做会有风险。<br>2.为<strong>Service ro_isn</strong>定义一个<strong>SELinux</strong> <strong>domain</strong>，仅添加需要的权限，未允许的权限操作会被拒绝。具体方法请参照下节。</p>
<h2 id="二、解决方法"><a href="#二、解决方法" class="headerlink" title="二、解决方法"></a>二、解决方法</h2><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">devices/qcom/sepolicy/common/</span><br></pre></td></tr></table></figure>
<p>目录下新增<strong>ro_isn.te</strong>文件，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type ro_isn, domain; </span><br><span class="line">type ro_isn_exec, exec_type, file_type;</span><br></pre></td></tr></table></figure>
<h2 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h2><p>在<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">devices/qcom/sepolicy/Android.mk</span><br></pre></td></tr></table></figure></p>
<p>中添加<strong>ro_isn.te</strong>文件，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BOARD_SEPOLICY_UNION := \</span><br><span class="line">... \</span><br><span class="line">        hostapd.te \</span><br><span class="line">        ro_isn.te</span><br></pre></td></tr></table></figure>
<h2 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h2><p>在<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">devices/qcom/sepolicy/common/file_contexts</span><br></pre></td></tr></table></figure></p>
<p>中增加如下内容：</p>
<p>###################################</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># System files</span><br><span class="line">#</span><br><span class="line">...</span><br><span class="line">/system/vendor/bin/slim_ap_daemon</span><br><span class="line">u:object_r:location_exec:s0</span><br><span class="line">/system/bin/isn.sh</span><br><span class="line">u:object_r:ro_isn_exec:s0</span><br></pre></td></tr></table></figure>
<h2 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h2><p>在<strong>init.rc</strong>中<strong>service ro_isn</strong>下添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">secure context by seclabel </span><br><span class="line">service ro_isn /system/bin/isn.sh </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">class late_start </span><br><span class="line">user root </span><br><span class="line">oneshot </span><br><span class="line">seclabel u:r:ro_isn:s0</span><br></pre></td></tr></table></figure></p>
<h2 id="5"><a href="#5" class="headerlink" title="5."></a>5.</h2><p>编译并烧录bootimage</p>
<h2 id="6"><a href="#6" class="headerlink" title="6."></a>6.</h2><p>如果编译不成功，失败原因如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Error while expanding policy</span><br><span class="line">libsepol.check_assertion_helper: neverallow on line 233 of external/sepolicy/domain.te (or line 5194 of policy.conf) violated by allow ro_isn system_file:file &#123; entrypoint &#125;;</span><br><span class="line">make: *** [out/target/product/msm8226/obj/ETC/sepolicy_intermediates/sepolicy] 错误 1</span><br></pre></td></tr></table></figure>
<p>这是因为系统在<strong>domain.te</strong>中定义了全局的<strong>neverallow策略</strong>，与<strong>ro_isn.te</strong>中<strong>allow</strong>的策略有冲突：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">allow ro_isn system_file:file &#123; entrypoint &#125;;</span><br><span class="line">neverallow domain &#123; file_type -exec_type &#125;:file entrypoint;</span><br></pre></td></tr></table></figure>
<p>请确定自己的service有必要需要这个权限。如无必要，请在自己的code中删除掉相关操作；如必要，可以在<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">external/sepolicy/domain.te</span><br></pre></td></tr></table></figure></p>
<p>中冲突的<strong>neverallow</strong><br>语句中添加自己为例外：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">neverallow &#123;</span><br><span class="line">    domain</span><br><span class="line">    -ro_isn</span><br><span class="line">&#125; &#123; file_type -exec_type &#125;:file entrypoint;</span><br></pre></td></tr></table></figure>
<h2 id="7"><a href="#7" class="headerlink" title="7."></a>7.</h2><p>在<strong>service ro_isn</strong>运行时，搜索关于“<strong>ro_isn</strong>”的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">avc: denied log</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;6&gt;[ 13.547188](CPU:0-pid:320:logd.auditd) type=1400 audit(17468992.410:7): avc: denied &#123; entrypoint &#125; for pid=272 comm=&quot;init&quot; path=&quot;/system/bin/isn.sh </span><br><span class="line"></span><br><span class="line">&quot; dev=&quot;mmcblk0p38&quot; ino=631 scontext=u:r:ro_isn:s0 tcontext=u:object_r:system_file:s0 tclass=file</span><br></pre></td></tr></table></figure>
<h2 id="8"><a href="#8" class="headerlink" title="8."></a>8.</h2><p>按照如下规则在<strong>ro_isn.te</strong>添加权限<br><strong>SELinux</strong>规则语句一般如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">allow  A  B:C  D;</span><br></pre></td></tr></table></figure>
<p>可以从log中分别获取ABCD四个参数。<br>比如这行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">warning log：</span><br><span class="line">avc: denied &#123; entrypoint &#125; for pid=272 comm=&quot;init&quot; path=&quot;/system/bin/isn.sh </span><br><span class="line"></span><br><span class="line">&quot; dev=&quot;mmcblk0p38&quot; ino=631 scontext=u:r:ro_isn:s0 tcontext=u:object_r:system_file:s0 tclass=file</span><br><span class="line"></span><br><span class="line">avc:  denied  &#123; transition &#125; for  pid=320 comm=&quot;init&quot; path=&quot;/system/xbin/fcgiserver.sh </span><br><span class="line"></span><br><span class="line">&quot; dev=&quot;mmcblk0p21&quot; ino=7873 scontext=u:r:init:s0 tcontext=u:r:fcgiserver:s0 tclass=process permissive=1</span><br></pre></td></tr></table></figure></p>
<p>那么我们就得出最后的规则是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">allow qcomsysd  block_device:dir &#123; search &#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">allow ro_isn system_file:file &#123; entrypoint &#125;;</span><br></pre></td></tr></table></figure>
<p>重复步骤<strong>5-8</strong>,直到没有关于<strong>ro_isn</strong>的<strong>avc: denied log</strong></p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://wenyiqingnian.xyz/2017/03/15/添加SE安全策略/" data-id="cjl3hswwj001num8xdktqzj88" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    
        <a href="http://wenyiqingnian.xyz/2017/03/15/添加SE安全策略/#comments" class="article-comment-link">Comments</a>
    

        </footer>
    </div>
    
</article>



    <article id="post-抓包工具 - Fiddler（如何捕获Android数据包）" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2016/08/03/抓包工具 - Fiddler（如何捕获Android数据包）/">fiddler抓android数据包</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2016/08/03/抓包工具 - Fiddler（如何捕获Android数据包）/">
            <time datetime="2016-08-03T12:20:17.000Z" itemprop="datePublished">2016-08-03</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/Android/">Android</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/android/">android</a>, <a class="tag-link" href="/tags/抓包/">抓包</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <h2 id="抓包工具-Fiddler（如何捕获Android数据包）"><a href="#抓包工具-Fiddler（如何捕获Android数据包）" class="headerlink" title="抓包工具 - Fiddler（如何捕获Android数据包）"></a>抓包工具 - Fiddler（如何捕获Android数据包）</h2><p>移动设备访问网络原理</p>
<p>先看看移动设备是怎么去访问网络，如图所示，可以看到，移动端的数据包是从wifi出去的。<br><img src="http://i.imgur.com/88ZFpNh.png" alt=""><br>可以看得出，移动端的数据包，都是要走wifi出去，所以我们可以把自己的电脑开启热点，将手机连上电脑，Fiddler开启代理后，让这些数据通过Fiddler，Fiddler就可以抓到这些包，然后发给路由器（如图）：<br><img src="http://i.imgur.com/xpx7qof.png" alt=""></p>
<p>二、Fiddler抓取android数据包所需条件</p>
<p>　　1、电脑需要安装Fiddler</p>
<p>　　2、测试手机需要支持Wifi</p>
<p>　　3、测试手机与电脑需要同一网络</p>
<p>　　4、所测APP需支持代理</p>
<p>　　注：Iphone、Ipad、WinPhone等支持代理手机均适用</p>
<ol>
<li>打开Wifi热点，让手机连上（我这里用的360wifi，其实随意一个都行）<br><img src="http://i.imgur.com/lwCWyI7.png" alt=""></li>
<li>打开Fidder，点击菜单栏中的 [Tools] –&gt; [Fiddler Options]<br><img src="http://i.imgur.com/K87KQ8y.png" alt=""><br>Connections，设置代理端口：8888， 勾选 Allow remote computers to connect，即允许远程计算机连接Fiddler.<blockquote>
<p>注：8888为默认端口号，可修改，但需注意两点，一是本机空闲端口，二是手机代理设置时要与fiddler的端口一致。<br><img src="http://i.imgur.com/gwshRc7.png" alt=""></p>
</blockquote>
</li>
</ol>
<p>3、设置解密HTTPS的网络数据<br>　　Tools –&gt;  Options-&gt; Https，勾选”Decrypt HTTPS traffic”、”Ignore server certificate errors”，<br><img src="http://i.imgur.com/uEHa5dw.png" alt=""></p>
<p>4、查看本机的无线网卡IP<br>　　设置了上面的步骤后，就可以在 Fiddler看到自己本机无线网卡的IP了（要是没有的话，重启Fiddler，或者可以在cmd中ipconfig找到自己的网卡IP，注：一定要开启本机的wifi热点），</p>
<p><img src="http://i.imgur.com/JN06oW7.png" alt=""></p>
<p>也可以在CMD中查看本机网卡的IP，输入命令：ipconfig，<br><img src="http://i.imgur.com/vkKMXHN.png" alt=""></p>
<p>5、手机连接本机的Wifi，并设置代理<br>　　每个品牌的手机设置wifi的方式可能不一样，这里以华为手机为例，如图8所示，将手机连接至PC的wifi</p>
<p><img src="http://i.imgur.com/kkNUd7s.png" alt=""></p>
<p>勾选“显示高级选项”-&gt; 代理 选择“手动” -&gt;输入服务器主机名和服务器端口 -&gt;IP选择“DHCP”-&gt;连接，即完成手机端设置代理操作，如图9所示</p>
<blockquote>
<p>注：服务器主机名：Fiddler所在电脑IP（即开启wifi后，在fiddler或cmd中看到的无线网卡IP地址）<br>　　服务器端口： Fiddler使用的端口（即Options-Connections中设置的端口号）<br><img src="http://i.imgur.com/LxaVORC.png" alt=""></p>
</blockquote>
<p>6、手机下载安装Fiddler证书<br>　　连接上wifi后，手机打开浏览器输入代理IP+端口号（即是本机无线网卡IP，也是手机连接wifi时所设置的服务器主机名，这里的ip+端口号为192.168.191.1：8888），进入fiddler echo service页面，下载Fiddler的证书，如图10所示，点击FiddlerRoot certificate</p>
<p><img src="http://i.imgur.com/7OhLqhq.png" alt=""></p>
<p>下载完成后，进行安装证书</p>
<p><img src="http://i.imgur.com/DvxwP2J.png" alt=""></p>
<p>【注意】：如果打开浏览器碰到类似下面的报错，请打开Fiddler的证书解密模式（如上面的步骤3所示）：No root certificate was found. Have you enabled HTTPS traffic decryption in Fiddler yet?</p>
<p>设置完上面6个步骤后，即表明已设置完毕，此时用手机访问应用，就可以看到fiddler抓取到的数据包了.</p>
<p><img src="http://i.imgur.com/iSn6kTI.png" alt=""></p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://wenyiqingnian.xyz/2016/08/03/抓包工具 - Fiddler（如何捕获Android数据包）/" data-id="cjl3hswwi001mum8x46hedj68" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    
        <a href="http://wenyiqingnian.xyz/2016/08/03/抓包工具 - Fiddler（如何捕获Android数据包）/#comments" class="article-comment-link">Comments</a>
    

        </footer>
    </div>
    
</article>



    <article id="post-Linux vi命令使用方法" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2016/07/04/Linux vi命令使用方法/">Linux vi用法</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2016/07/04/Linux vi命令使用方法/">
            <time datetime="2016-07-04T13:11:15.000Z" itemprop="datePublished">2016-07-04</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/Linux/">Linux</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/linux命令/">linux命令</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p>vi编辑器支持编辑模式和命令模式，编辑模式下可以完成文本的编辑功能，命令模式下可以完成对文件的操作命令，要正确使用vi编辑器就必须熟练掌握着两种模式的切换。默认情况下，打开vi编辑器后自动进入命令模式。从编辑模式切换到命令模式使用“esc”键，从命令模式切换到编辑模式使用“A”、“a”、“O”、“o”、“I”、“i”键。</p>
<p>vi编辑器提供了丰富的内置命令，有些内置命令使用键盘组合键即可完成，有些内置命令则需要以冒号“：”开头输入。常用内置命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Ctrl+u：向文件首翻半屏；</span><br><span class="line">Ctrl+d：向文件尾翻半屏；</span><br><span class="line">Ctrl+f：向文件尾翻一屏；</span><br><span class="line">Ctrl+b：向文件首翻一屏；</span><br><span class="line">Esc：从编辑模式切换到命令模式；</span><br><span class="line">ZZ：命令模式下保存当前文件所做的修改后退出vi；</span><br><span class="line">:行号：光标跳转到指定行的行首；</span><br><span class="line">:$：光标跳转到最后一行的行首；</span><br><span class="line">x或X：删除一个字符，x删除光标后的，而X删除光标前的；</span><br><span class="line">D：删除从当前光标到光标所在行尾的全部字符；</span><br><span class="line">dd：删除光标行正行内容；</span><br><span class="line">ndd：删除当前行及其后n-1行；</span><br><span class="line">nyy：将当前行及其下n行的内容保存到寄存器？中，其中？为一个字母，n为一个数字；</span><br><span class="line">p：粘贴文本操作，用于将缓存区的内容粘贴到当前光标所在位置的下方；</span><br><span class="line">P：粘贴文本操作，用于将缓存区的内容粘贴到当前光标所在位置的上方；</span><br><span class="line">/字符串：文本查找操作，用于从当前光标所在位置开始向文件尾部查找指定字符串的内容，查找的字符串会被加亮显示；</span><br><span class="line">？name：文本查找操作，用于从当前光标所在位置开始向文件头部查找指定字符串的内容，查找的字符串会被加亮显示；</span><br><span class="line">a，bs/F/T：替换文本操作，用于在第a行到第b行之间，将F字符串换成T字符串。其中，“s/”表示进行替换操作；</span><br><span class="line">a：在当前字符后添加文本；</span><br><span class="line">A：在行末添加文本；</span><br><span class="line">i：在当前字符前插入文本；</span><br><span class="line">I：在行首插入文本；</span><br><span class="line">o：在当前行后面插入一空行；</span><br><span class="line">O：在当前行前面插入一空行；</span><br><span class="line">:wq：在命令模式下，执行存盘退出操作；</span><br><span class="line">:w：在命令模式下，执行存盘操作；</span><br><span class="line">:w！：在命令模式下，执行强制存盘操作；</span><br><span class="line">:q：在命令模式下，执行退出vi操作；</span><br><span class="line">:q！：在命令模式下，执行强制退出vi操作；</span><br><span class="line">:e文件名：在命令模式下，打开并编辑指定名称的文件；</span><br><span class="line">:n：在命令模式下，如果同时打开多个文件，则继续编辑下一个文件；</span><br><span class="line">:f：在命令模式下，用于显示当前的文件名、光标所在行的行号以及显示比例；</span><br><span class="line">:set number：在命令模式下，用于在最左端显示行号；</span><br><span class="line">:set nonumber：在命令模式下，用于在最左端不显示行号；</span><br></pre></td></tr></table></figure>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://wenyiqingnian.xyz/2016/07/04/Linux vi命令使用方法/" data-id="cjl3hswvr0007um8xso7sqwrw" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    
        <a href="http://wenyiqingnian.xyz/2016/07/04/Linux vi命令使用方法/#comments" class="article-comment-link">Comments</a>
    

        </footer>
    </div>
    
</article>



    <nav id="page-nav">
        <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span>
    </nav>
</section>
            
                
<aside id="sidebar">
   
        
    <div class="widget-wrap">
        <h3 class="widget-title">recent</h3>
        <div class="widget">
            <ul id="recent-post" class="">
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2018/08/21/八月份学习计划/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/学习计划/">学习计划</a></p>
                            <p class="item-title"><a href="/2018/08/21/八月份学习计划/" class="title">下个阶段的学习计划整理</a></p>
                            <p class="item-date"><time datetime="2018-08-21T09:12:50.000Z" itemprop="datePublished">2018-08-21</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2018/08/16/一些知识点总结/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/Android/">Android</a></p>
                            <p class="item-title"><a href="/2018/08/16/一些知识点总结/" class="title">一些知识点总结</a></p>
                            <p class="item-date"><time datetime="2018-08-16T11:00:50.000Z" itemprop="datePublished">2018-08-16</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2018/06/24/从一次native端的IPC流程理解binder/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/Android/">Android</a></p>
                            <p class="item-title"><a href="/2018/06/24/从一次native端的IPC流程理解binder/" class="title">从一次native端的IPC流程理解binder</a></p>
                            <p class="item-date"><time datetime="2018-06-24T11:00:50.000Z" itemprop="datePublished">2018-06-24</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2018/06/16/《现代艺术150年》未影印作品2/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/备忘录/">备忘录</a></p>
                            <p class="item-title"><a href="/2018/06/16/《现代艺术150年》未影印作品2/" class="title">《现代艺术150年》未影印作品2</a></p>
                            <p class="item-date"><time datetime="2018-06-16T06:00:50.000Z" itemprop="datePublished">2018-06-16</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2018/06/08/深度学习1-反向传播/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/机器学习/">机器学习</a></p>
                            <p class="item-title"><a href="/2018/06/08/深度学习1-反向传播/" class="title">深度学习1-反向传播</a></p>
                            <p class="item-date"><time datetime="2018-06-08T09:33:50.000Z" itemprop="datePublished">2018-06-08</time></p>
                        </div>
                    </li>
                
            </ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">categories</h3>
        <div class="widget">
            <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/AOSP/">AOSP</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/CoolUI/">CoolUI</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MQTT/">MQTT</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/bug记录/">bug记录</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java基础/">java基础</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/webrtc/">webrtc</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/备忘录/">备忘录</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/学习计划/">学习计划</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/容器技术/">容器技术</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/机器学习/">机器学习</a><span class="category-list-count">1</span></li></ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">archives</h3>
        <div class="widget">
            <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a><span class="archive-list-count">1</span></li></ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">tags</h3>
        <div class="widget">
            <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AnimatedVectorDrawable/">AnimatedVectorDrawable</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Binder/">Binder</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SEAndroid/">SEAndroid</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tensorflow/">Tensorflow</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android/">android</a><span class="tag-list-count">9</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/aosp/">aosp</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/bugs/">bugs</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/">docker</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/">linux</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux命令/">linux命令</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mk/">mk</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mqtt/">mqtt</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/">python</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/qt/">qt</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/rxjava2/">rxjava2</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webrtc/">webrtc</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/句柄animation/">句柄animation</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/句柄泄露/">句柄泄露</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/垃圾回收/">垃圾回收</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/备忘录/">备忘录</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/多线程/">多线程</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/学习计划/">学习计划</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/容器/">容器</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/开源框架/">开源框架</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/抓包/">抓包</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/机器学习/">机器学习</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/现代艺术150年/">现代艺术150年</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/编译/">编译</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/音视频/">音视频</a><span class="tag-list-count">1</span></li></ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">tag cloud</h3>
        <div class="widget tagcloud">
            <a href="/tags/AnimatedVectorDrawable/" style="font-size: 10px;">AnimatedVectorDrawable</a> <a href="/tags/Binder/" style="font-size: 17.5px;">Binder</a> <a href="/tags/SEAndroid/" style="font-size: 10px;">SEAndroid</a> <a href="/tags/Tensorflow/" style="font-size: 10px;">Tensorflow</a> <a href="/tags/android/" style="font-size: 20px;">android</a> <a href="/tags/aosp/" style="font-size: 10px;">aosp</a> <a href="/tags/bugs/" style="font-size: 10px;">bugs</a> <a href="/tags/docker/" style="font-size: 10px;">docker</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/java/" style="font-size: 17.5px;">java</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/linux命令/" style="font-size: 10px;">linux命令</a> <a href="/tags/mk/" style="font-size: 10px;">mk</a> <a href="/tags/mqtt/" style="font-size: 10px;">mqtt</a> <a href="/tags/python/" style="font-size: 10px;">python</a> <a href="/tags/qt/" style="font-size: 10px;">qt</a> <a href="/tags/rxjava2/" style="font-size: 10px;">rxjava2</a> <a href="/tags/webrtc/" style="font-size: 10px;">webrtc</a> <a href="/tags/句柄animation/" style="font-size: 10px;">句柄animation</a> <a href="/tags/句柄泄露/" style="font-size: 10px;">句柄泄露</a> <a href="/tags/垃圾回收/" style="font-size: 12.5px;">垃圾回收</a> <a href="/tags/备忘录/" style="font-size: 12.5px;">备忘录</a> <a href="/tags/多线程/" style="font-size: 10px;">多线程</a> <a href="/tags/学习计划/" style="font-size: 10px;">学习计划</a> <a href="/tags/容器/" style="font-size: 10px;">容器</a> <a href="/tags/开源框架/" style="font-size: 10px;">开源框架</a> <a href="/tags/抓包/" style="font-size: 10px;">抓包</a> <a href="/tags/机器学习/" style="font-size: 10px;">机器学习</a> <a href="/tags/现代艺术150年/" style="font-size: 12.5px;">现代艺术150年</a> <a href="/tags/编译/" style="font-size: 15px;">编译</a> <a href="/tags/设计模式/" style="font-size: 10px;">设计模式</a> <a href="/tags/音视频/" style="font-size: 10px;">音视频</a>
        </div>
    </div>

    
        
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">links</h3>
        <div class="widget">
            <ul>
                
                    <li>
                        <a href="https://github.com/QuincyJiang">github</a>
                    </li>
                
            </ul>
        </div>
    </div>


    
    <div id="toTop" class="fa fa-angle-up"></div>
</aside>

            
        </div>
        <footer id="footer">
<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <div class="outer">
        <div id="footer-info" class="inner">
            &copy; 2018 QuincyJiang<br>
            Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>. Theme by <a href="http://github.com/ppoffice">PPOffice</a>
            <br/>本站总访问量<span id="busuanzi_value_site_pv"></span>次，你是来本站的第<span id="busuanzi_value_site_uv"></span>位小伙伴，本文总阅读量<span id="busuanzi_value_page_pv"></span>次
        </div>
    </div>
</footer>
        
    
    
    <!-- 来必力City版安装代码 -->
    <script type="text/javascript">
     (function(d, s) {
         var j, e = d.getElementsByTagName(s)[0];

         if (typeof LivereTower === 'function') { return; }

         j = d.createElement(s);
         j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
         j.async = true;

         e.parentNode.insertBefore(j, e);
     })(document, 'script');
    </script>
  <noscript> 为正常使用来必力评论功能请激活JavaScript</noscript>
  <!-- City版安装代码已完成 -->





    
        <script src="/libs/lightgallery/js/lightgallery.min.js"></script>
        <script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script>
        <script src="/libs/lightgallery/js/lg-pager.min.js"></script>
        <script src="/libs/lightgallery/js/lg-autoplay.min.js"></script>
        <script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script>
        <script src="/libs/lightgallery/js/lg-zoom.min.js"></script>
        <script src="/libs/lightgallery/js/lg-hash.min.js"></script>
        <script src="/libs/lightgallery/js/lg-share.min.js"></script>
        <script src="/libs/lightgallery/js/lg-video.min.js"></script>
    
    
        <script src="/libs/justified-gallery/jquery.justifiedGallery.min.js"></script>
    
    



<!-- Custom Scripts -->
<script src="/js/main.js"></script>

    </div><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>
</html>