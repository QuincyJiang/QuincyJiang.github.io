<!DOCTYPE html>
<html lang=en>
<head>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
    
    <title>瘟疫青年</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta property="og:type" content="website">
<meta property="og:title" content="瘟疫青年">
<meta property="og:url" content="http://wenyiqingnian.xyz/index.html">
<meta property="og:site_name" content="瘟疫青年">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="瘟疫青年">
    

    

    
        <link rel="icon" href="/css/images/avatar.png" />
    

    <link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="/libs/open-sans/styles.css">
    <link rel="stylesheet" href="/libs/source-code-pro/styles.css">

    <link rel="stylesheet" href="/css/style.css">

    <script src="/libs/jquery/2.1.3/jquery.min.js"></script>
    
    
        <link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css">
    
    
        <link rel="stylesheet" href="/libs/justified-gallery/justifiedGallery.min.css"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
    
    
    
    


</head>

<body>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="container">
        <header id="header">
    <div id="header-main" class="header-inner">
        <div class="outer">
            <a href="/" id="logo">
                <i class="logo"></i>
                <span class="site-title">瘟疫青年</span>
            </a>
            <nav id="main-nav">
                
                    <a class="main-nav-link" href="/.">Home</a>
                
                    <a class="main-nav-link" href="/archives">Archives</a>
                
                    <a class="main-nav-link" href="/categories">Categories</a>
                
                    <a class="main-nav-link" href="/tags">Tags</a>
                
                    <a class="main-nav-link" href="/about">About</a>
                
            </nav>
            
                
                <nav id="sub-nav">
                    <div class="profile" id="profile-nav">
                        <a id="profile-anchor" href="javascript:;">
                            <img class="avatar" src="/css/images/avatar.png" />
                            <i class="fa fa-caret-down"></i>
                        </a>
                    </div>
                </nav>
            
            <div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="Search" />
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="Type something..." />
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: 'Posts',
            PAGES: 'Pages',
            CATEGORIES: 'Categories',
            TAGS: 'Tags',
            UNTITLED: '(Untitled)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div>
        </div>
    </div>
    <div id="main-nav-mobile" class="header-sub header-inner">
        <table class="menu outer">
            <tr>
                
                    <td><a class="main-nav-link" href="/.">Home</a></td>
                
                    <td><a class="main-nav-link" href="/archives">Archives</a></td>
                
                    <td><a class="main-nav-link" href="/categories">Categories</a></td>
                
                    <td><a class="main-nav-link" href="/tags">Tags</a></td>
                
                    <td><a class="main-nav-link" href="/about">About</a></td>
                
                <td>
                    
    <div class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="Search" />
    </div>

                </td>
            </tr>
        </table>
    </div>
</header>

        <div class="outer">
            
                

<aside id="profile" class="profile-fixed">
    <div class="inner profile-inner">
        <div class="base-info profile-block">
            <img id="avatar" src="/css/images/avatar.png" />
            <h2 id="name">QuincyJiang</h2>
            <h3 id="title">Coder &amp; FilmPlayer</h3>
            <span id="location"><i class="fa fa-map-marker"></i>Guangzhou, China</span>
            <a id="follow" target="_blank" href="https://github.com/QuincyJiang">FOLLOW</a>
        </div>
        <div class="article-info profile-block">
            <div class="article-info-block">
                33
                <span>posts</span>
            </div>
            <div class="article-info-block">
                32
                <span>tags</span>
            </div>
        </div>
        
        <div class="profile-block social-links">
            <table>
                <tr>
                    
                    
                    <td>
                        <a href="https://github.com/QuincyJiang" target="_blank" title="github" class=tooltip>
                            <i class="fa fa-github"></i>
                        </a>
                    </td>
                    
                    <td>
                        <a href="https://weibo.com/2425393311/" target="_blank" title="weibo" class=tooltip>
                            <i class="fa fa-weibo"></i>
                        </a>
                    </td>
                    
                    <td>
                        <a href="http://aquencyua11.lofter.com/" target="_blank" title="photo" class=tooltip>
                            <i class="fa fa-photo"></i>
                        </a>
                    </td>
                    
                </tr>
            </table>
        </div>
        
    </div>
</aside>

            
            <section id="main">
    <article id="post-深度学习课程笔记 第二周 优化算法" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2018/11/19/深度学习课程笔记 第二周 优化算法/">深度学习课程笔记 第二周 优化算法</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2018/11/19/深度学习课程笔记 第二周 优化算法/">
            <time datetime="2018-11-19T11:52:50.000Z" itemprop="datePublished">2018-11-19</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/机器学习/">机器学习</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/Tensorflow/">Tensorflow</a>, <a class="tag-link" href="/tags/机器学习/">机器学习</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p>本博是吴恩达DeepLearning.ai 的学习笔记</p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://wenyiqingnian.xyz/2018/11/19/深度学习课程笔记 第二周 优化算法/" data-id="cjqw00e000027vtfymevodcr7" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    
        <a href="http://wenyiqingnian.xyz/2018/11/19/深度学习课程笔记 第二周 优化算法/#comments" class="article-comment-link">Comments</a>
    

        </footer>
    </div>
    
</article>



    <article id="post-深度学习课程笔记 第一周 深度学习的实践层面" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2018/11/15/深度学习课程笔记 第一周 深度学习的实践层面/">深度学习课程笔记 第一周 深度学习的实践层面</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2018/11/15/深度学习课程笔记 第一周 深度学习的实践层面/">
            <time datetime="2018-11-15T03:52:50.000Z" itemprop="datePublished">2018-11-15</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/机器学习/">机器学习</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/Tensorflow/">Tensorflow</a>, <a class="tag-link" href="/tags/机器学习/">机器学习</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p>本博是吴恩达DeepLearning.ai 的学习笔记</p>
<h1 id="改善深层神经网络：-超参调试、正则化以及优化"><a href="#改善深层神经网络：-超参调试、正则化以及优化" class="headerlink" title="改善深层神经网络： 超参调试、正则化以及优化"></a>改善深层神经网络： 超参调试、正则化以及优化</h1><h2 id="训练集-开发集-测试集-的划分"><a href="#训练集-开发集-测试集-的划分" class="headerlink" title="训练集 开发集 测试集 的划分"></a>训练集 开发集 测试集 的划分</h2><p>假设所有的训练数据如下<br><img src="/media/15422471488916.jpg" alt=""><br>一个典型的数据划分：<br><img src="/media/15422472060092.jpg" alt=""></p>
<p>即：一部分作为 <strong>训练集</strong><br>一部分作为 <strong>简单交叉验证集/验证集</strong><br>一部分作为 <strong>测试集</strong></p>
<p>具体的流程是 在<strong>训练集</strong>上 对<strong>各模型运行训练算法</strong> 将训练<strong>完成的模型</strong> 带入 <strong>交叉验证集</strong> 选择出最佳模型<br>然后带入<strong>测试集</strong>对神经网络做出<strong>无偏评估</strong></p>
<p>小数据量的时候，一般会将数据划分为 <strong>训练集（70%）</strong> <strong>测试集（30%）</strong>或者<strong>训练集（60%）、验证集（20%、测试集（20%）</strong>。<br>在大数据量（百万级）时，验证集 测试集的数据量和小数据量的情况差不多，仍然可能需要成千上万，但是相比百万级的训练集来说，测试集所占的比例理所当然的变小了。比如我们拥有1000000，这么多的数据，<strong>训练集：验证集：测试集=98:1:1</strong>。</p>
<h2 id="保证-验证集合测试集具有相同的分布"><a href="#保证-验证集合测试集具有相同的分布" class="headerlink" title="保证 验证集合测试集具有相同的分布"></a>保证 验证集合测试集具有相同的分布</h2><p>有时候 训练集和测试集的数据来源往往不同，比如说 训练集可能是通过爬虫爬取的网页图片，但是测试集是来自用户通过app上传的图片，这些图片的质量和对齐方式参差不齐，这种情况 最好能保证 <strong>测试集和交叉验证集具有相同的分布。</strong><br><img src="/media/15422532146088.jpg" alt=""></p>
<h2 id="为什么要保证分布相同"><a href="#为什么要保证分布相同" class="headerlink" title="为什么要保证分布相同"></a>为什么要保证分布相同</h2><p>我们先从测试集和验证集的作用开始说起<br>当我们在拿到数据后，会把数据划分为三部分，将训练集丢给模型，这个步骤是为了进行梯度下降，以期得到模型参数。<br>然后拿到训练完成的模型，带入验证集，这个部分是为了检查模型是否能够很好的拟合验证数据，因为这部分数据是没有经过梯度下降的，可以说验证集和测试集没有交<br>集，测试的准确率是可靠的。</p>
<p>但是模型除了<strong>普通参数（w和b）</strong>之外，还有<strong>超参数</strong>的存在，当不引入强化学习的情况下，普通参数可以被梯度下降更新，也就是可以被训练集更新，但是为了提高模型性能，我们往往会对 <strong>神经网络层数、网络节点数、迭代次数、学习步长</strong>等进行调整，这些参数不受梯度下降的影响，一般都是根据验证集的表现情况进行人为调整。</p>
<p>所以可以说，验证集也对学习结果产生了影响，所以需要一份完全没有经过学习影响的数据，来评估最终模型的表现情况，这个就是测试集存在的意义。</p>
<p><strong>为什么要保证测试集和验证集有相同的分布呢？</strong></p>
<p>因为一旦定义好了测试集和验证集，开发人员的目的就是专注提高验证集的表现，这便要求验证集的选取可以分布均匀，可以体现核心任务。如果验证集和测试集分布不同，就可能导致 <strong>系统在验证集上表现良好，在测试集表现不好。</strong>这种情况可能会有多种原因：</p>
<ul>
<li>算法在开发集上过拟合了。</li>
<li>测试集比开发集更难进行预测，尽管算法做得足够好了，却很难有进一步的提升空间。</li>
<li>测试集不一定更难预测，但它与开发集性质并不相同（分布不同）。<br>因此在开发集上表现良好的算法不一定在测试集上也能够取得出色表现。<br>这样就引入了新的不确定性–<strong>提高算法在验证集的表现，是否能提高其在测试集的表现？</strong>如果是这种情况，大量针对开发集性能的改进工作将会是徒劳的。</li>
</ul>
<h2 id="如何评估模型表现？-偏差、方差"><a href="#如何评估模型表现？-偏差、方差" class="headerlink" title="如何评估模型表现？ 偏差、方差"></a>如何评估模型表现？ 偏差、方差</h2><p><strong>偏差(<em>bias</em>)：</strong>可以理解为 模型在训练集的表现不佳 也就是模型无法很好的拟合数据  称之为欠拟合<br><strong>方差(<em>variance</em>)：</strong>模型在训练集表现良好，但在测试集表现差，模型过于拟合了训练集数据导致无法正确反映数据规律，称之为 过拟合</p>
<p><img src="/media/15422574024898.jpg" alt=""></p>
<p>在实际中，判断偏差和方差一般会通过 训练集和测试集误差来判断</p>
<p><img src="/media/15422578079564.jpg" alt=""></p>
<p>从左到右:</p>
<ul>
<li><strong>高方差</strong>：模型过拟合了</li>
<li><strong>高偏差</strong>：模型没有被很好的训练 但是貌似没有过拟合 </li>
<li><strong>高方差 高偏差：</strong> 模型没有很好拟合数据 同时在测试集表现也不佳 有时有些高维数据中会出现这种情况，就是在某些区域的偏差高，有些区域的方差高</li>
<li><strong>低方差 低偏差：</strong> 模型可以很好表现数据特征</li>
</ul>
<p>即：<br><strong>训练集误差高 表示 偏差大<br>测试集误差高 表示 方差大</strong></p>
<p><strong>关于方差和偏差的数学原理 ，见文章附录[1]。</strong></p>
<h2 id="一个基本流程"><a href="#一个基本流程" class="headerlink" title="一个基本流程"></a>一个基本流程</h2><p><img src="/media/15422648475258.jpg" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: 获取数据</span><br><span class="line">e=&gt;end: 训练结束</span><br><span class="line">op=&gt;operation: 评估训练集误差（偏差值）</span><br><span class="line">op1=&gt;operation: 评估测试集误差（方差值）</span><br><span class="line">op2=&gt;operation: 选择更深层的神经网络或花费更多时间训练算法，或尝试更先进算法</span><br><span class="line">op3=&gt;operation: 获取更多数据，或者通过正则化减少过拟合</span><br><span class="line">cond=&gt;condition: 偏差正常?</span><br><span class="line">cond2=&gt;condition: 方差偏高?</span><br><span class="line"></span><br><span class="line">st-&gt;op</span><br><span class="line">op-&gt;cond</span><br><span class="line">cond(yes)-&gt;op1</span><br><span class="line">cond(no)-&gt;op2</span><br><span class="line">op2-&gt;cond</span><br><span class="line">op1-&gt;cond2</span><br><span class="line">cond2(yes)-&gt;op3</span><br><span class="line">cond2(no)-&gt;e</span><br><span class="line">op3-&gt;cond2</span><br></pre></td></tr></table></figure>
<p>在早期机器学习的时代，我们没有太多工具可以只影响偏差或者方差的一种而不对另一种造成影响，所以往往需要在两者间权衡。<br>现在在大数据时代，我们有了一些工具，比如只要对数据进行适当正则，再构建一个更大的神经网络，就可以在几乎不影响方差的情况下，减少偏差。而采用更多数据，或者对数据正则化，可以在不过多影响偏差的情况下，减少方差</p>
<h2 id="降低方差的手段：正则化"><a href="#降低方差的手段：正则化" class="headerlink" title="降低方差的手段：正则化"></a>降低方差的手段：正则化</h2><p>出现高方差往往就表示，模型对数据过拟合了。<br>前面讲到 降低方差的手段，可以通过获取更多数据或者对数据进行正则来实现。</p>
<p>更多数据的获取，实现起来成本比较高，那正则化又为什么可以减少方差呢？</p>
<h3 id="如何实施正则化"><a href="#如何实施正则化" class="headerlink" title="如何实施正则化"></a>如何实施正则化</h3><h4 id="logistic-回归"><a href="#logistic-回归" class="headerlink" title="logistic 回归"></a>logistic 回归</h4><p>我们之前定义的损失函数为<br><img src="/media/15422655692214.jpg" alt=""></p>
<p>现在在其基础上加上正则化参数 也就是向量w的二范数（也有使用一范数的，但目前更多倾向于使用二范数）</p>
<p><img src="/media/15422656218635.jpg" alt=""></p>
<p>至于b的正则化参数，可加可不加，因为w通常是一个高维度的矩阵，它已经包含很多参数了，b只是众多参数的其中之一，加不加影响也不是很大。<br><img src="/media/15422656880309.jpg" alt=""></p>
<p>其中 λ是正则化参数。这个参数需要我们在验证集经过多次调试来选择最佳取值，λ属于超参数的一种。</p>
<h4 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h4><p>神经网络和logistic回归的差别在于，神经网络是有多层隐藏神经元的数学模型。</p>
<p>它的正则化参数则是将所有层的w向量写成一个矩阵后 矩阵W的二范数，<strong>在DL中，习惯将矩阵的二范数称之为 F范数，或者弗罗贝尼乌斯范数</strong><br><img src="/media/15422662423114.jpg" alt=""></p>
<p>在之前的梯度下降过程中，我们通过反向传播 计算出了原始J对w[l]的导数：<br><img src="/media/15422667161032.jpg" alt="-w234"><br>现在代价函数J增加了一项正则化参数<br>对正则化参数求导<br><img src="/media/15422666818228.jpg" alt="-w252"></p>
<p>为<img src="/media/15422667406636.jpg" alt="-w136"></p>
<p>则新的dw[l]为</p>
<p><img src="/media/15422668045079.jpg" alt="-w428"></p>
<p>带入<br><code>w[l] = w[l]-α*dw[l]</code><br>得到<br><img src="/media/15422668622209.jpg" alt="-w531"></p>
<p><img src="/media/15422669165717.jpg" alt="-w569"></p>
<p>可以看到，如果将w[l]提取出来，每次反向传播后，更新的权重值相当于在其前面乘上了这么一个参数：<br><img src="/media/15422670345410.jpg" alt="-w170"></p>
<p>显而易见这个参数是小于1的。</p>
<p>所以L2正则化也被称之为 <strong>权重衰减</strong></p>
<p>所以 对神经网络 应用L2 正则化的过程 其实相当于在每次反向传播更新梯度的过程中，对w[l]乘上了一个小于1的参数<br><code>1-αλ/m</code><br>这个参数是小于1的，所以 L2正则化 也被称之为 <strong>权重衰减</strong>。</p>
<h3 id="为什么正则化可以减少过拟合"><a href="#为什么正则化可以减少过拟合" class="headerlink" title="为什么正则化可以减少过拟合"></a>为什么正则化可以减少过拟合</h3><p>从直观上理解，因为我们的代价函数加上了对权重矩阵W的正则化参数，也就是W的F范数，在训练过程中，为了降低代价函数J，必然会压缩正则化参数，当λ设置的足够大，会导致矩阵W的F范数接近于0，也就意味着W中的很多元素变为了0，<br>等于原始神经网络中的很多神经元失去了作用，模型也被精简了。</p>
<p><img src="/media/15422676113907.jpg" alt="-w401"></p>
<p>此时模型越来越趋近于logistic回归<br>模型过于简单的时候，会导致偏差变高，模型甚至无法很好的拟合数据。<br>但这种W中参数变为0的情况在现实情况下一般不会发生，往往是某些w会变得很小，等于在训练过程中，这些神经元没有消失，只不过权重值变得很小而已。这样来看，貌似神经网络变得更简单了，这样更不容易出现过拟合。</p>
<p>下面举一个直观一些的例子。</p>
<p>假设每一层的激活函数都是tanh(),tanh()函数具有一个特殊性质，就是当x范围比较小的时候，tanh()接近y=x。<br><img src="/media/15422686564038.jpg" alt="-w675"></p>
<p>当我们对神经网络施加L2正则化，在训练中会导致w变小，又因为g(z)中的z 等于<br><img src="/media/15422687425629.jpg" alt="-w391"></p>
<p>当w[l]变小，会导致z[l]变小，当z落在tanh的中间那一小部分范围时，整个神经网络只利用到了tanh的线性部分，模型也会趋近于线性回归。这样会有效降低过拟合出现的情况</p>
<h2 id="另一种正则化方式：-Dropout正则化"><a href="#另一种正则化方式：-Dropout正则化" class="headerlink" title="另一种正则化方式： Dropout正则化"></a>另一种正则化方式： Dropout正则化</h2><p>Dropout，也被称之为随机失活。<br>其实就是 令神经网络的每一层的每个神经元，按照一定的概率失活。<br>我们将原始训练集分为若干子集，对每一个子集，都利用一次dropout<br><img src="/media/15422763982130.jpg" alt="-w451"></p>
<p>假设在这个神经网络中，我们设置每个元素的失活概率为0.5，那么在这个子集中，我们便会得到一个精简的神经网络<br><img src="/media/15422764818132.jpg" alt="-w449"></p>
<p>对每一个训练子集机型dropout，便会得到很多精简的神经网络，我们对每一个神经网络进行训练。其实这里也能看出来，为什么dropout可以有效防止过拟合，以为实施过dropout的神经网络变小了。</p>
<p>下面以python代码示例 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 假设当前为layer3</span></span><br><span class="line"><span class="comment"># 意味每个单元的保留概率是0.8 </span></span><br><span class="line">keep-prop = <span class="number">0.8</span> </span><br><span class="line"><span class="comment"># 生成一个随机矩阵，该矩阵和a3具有相同的行列数，且矩阵中 任一元素 d3[i,j] = 0的概率是0.2，等于1的概率是0.8</span></span><br><span class="line">d3 = np.random.rand(a3.shape[<span class="number">0</span>],a3.shape[<span class="number">1</span>])&lt;keep-prop</span><br><span class="line"><span class="comment"># 重新计算a3</span></span><br><span class="line">a3 = np.multiply(a3,d3)</span><br><span class="line"><span class="comment"># 除以keep-prop的目的是为了不减少a3的期望</span></span><br><span class="line">a3 /= keep-prop</span><br></pre></td></tr></table></figure>
<p>关于为什么a3要除以<strong>keep-prop</strong></p>
<p>这被称为<strong>inverted dropout</strong>。当模型使用了<strong>dropout layer</strong>，训练的时候只有占比为<strong><em>P</em></strong> 的隐藏层单元参与训练，那么在预测的时候，如果所有的隐藏层单元都需要参与进来，则得到的结果相比训练时平均要大<strong><em>1/p</em></strong> ，为了避免这种情况，就需要测试的时候将输出结果乘以  <strong><em>p</em></strong> 使下一层的输入规模保持不变。而利用<strong>inverted dropout</strong>，我们可以在训练的时候直接将<strong>dropout</strong>后留下的权重扩大<strong><em>1/p</em></strong>  倍，这样就可以使结果的<strong>scale</strong>保持不变，而在预测的时候也不用做额外的操作了，更方便一些。</p>
<p>或者更直观的解释</p>
<p>10个人拉一个10吨车，第一次（训练时），只有5个人出力（有p=0.5的人被dropout了），那么这5个人每个人出力拉2吨。第二次（预测时），10个人都被要求出力，这次每个人出的力就是2*（1-0.5）=1吨了 <a href="https://www.zhihu.com/question/61751133" target="_blank" rel="noopener">该解释转自知乎</a></p>
<p><strong>keep-prop</strong>的数值，对于不同的层，可以根据需要设置不同大小</p>
<p><img src="/media/15425968372625.jpg" alt=""></p>
<p>第二层的权重矩阵w[7×7]，占比最多，为了减少过拟合，可以将第二层<strong>的keep-prop</strong>设置的低一些，在4，5层 可以将<strong>keep_props</strong>设置的高一些。</p>
<p><strong>总结一下：</strong><br>如果你觉得 某一层相比其它层更容易出现过拟合，那么可以将该层的<strong>keep-prop</strong>设置的低一些，一般不会输入层施加<strong>drop-out</strong>，就算是施加，也尽量是<strong>keep-prop</strong>接近1。</p>
<p><strong>drop-out</strong>是对神经网络施加正则化的一种手段，它强迫模型不过度依赖于某一个神经元，使得权重在神经元之间平均分散，它可以使权重矩阵的<strong>F范数</strong>变小，但是会导致我们无法debug，因为施加<strong>drop-out</strong>之后，代价函数<strong><em>J</em></strong>便没有了一个确切的定义，我们无法得到一个单调递减的代价函数<strong><em>J</em></strong>，如果在某次迭代中出现了问题，也无法定位，因为每次的模型都是随机产生的。</p>
<p><strong>drop-out</strong>的作用是为了解决过拟合，所以如果模型不存在过拟合情况，可以不用，一般来说 在计算机视觉领域，<strong>drop-out</strong>会适用的比较频繁，因为CV的输入一般都是图片像素，因为输入太大了，导致数据量相比输入而言总显得过小，很容易出现过拟合的情况，所以<strong>drop-out</strong>在CV领域，基本是一个默认选项。</p>
<h2 id="dropout的优缺点"><a href="#dropout的优缺点" class="headerlink" title="dropout的优缺点"></a>dropout的优缺点</h2><h3 id="Dropout优点"><a href="#Dropout优点" class="headerlink" title="Dropout优点"></a>Dropout优点</h3><p><strong>计算方便</strong>。训练过程中使用<strong>Dropout</strong>产生 <strong>n</strong> 个随机二进制数与状态相乘即可。每个样本每次更新的时间复杂度： <strong><em>O(n)</em></strong>，空间复杂度： <strong><em>O(n)</em></strong>。<br><strong>适用广</strong>。<strong>Dropout</strong>不怎么限制适用的模型或训练过程，几乎在所有使用分布式表示且可以用随机梯度下降训练的模型上都表现很好。包括：前馈神经网络、概率模型、受限波尔兹曼机、循环神经网络等。<br>相比其他正则化方法（如权重衰减、过滤器约束和稀疏激活）更有效。也可与其他形式的正则化合并，得到进一步提升。</p>
<h3 id="Dropout缺点"><a href="#Dropout缺点" class="headerlink" title="Dropout缺点"></a>Dropout缺点</h3><p><strong>不适合宽度太窄的网络</strong>。否则大部分网络没有输入到输出的路径。<br><strong>不适合训练数据太小（如小于5000）的网络</strong>。训练数据太小时，Dropout没有其他方法表现好。<br><strong>不适合非常大的数据集</strong>。数据集大的时候正则化效果有限（大数据集本身的泛化误差就很小），使用Dropout的代价可能超过正则化的好处</p>
<h2 id="其他的正则化方法"><a href="#其他的正则化方法" class="headerlink" title="其他的正则化方法"></a>其他的正则化方法</h2><h3 id="通过处理输入-比如对输入图片进行-翻转-剪裁-对数字进行扭曲-来人为增大数据集-减少误差"><a href="#通过处理输入-比如对输入图片进行-翻转-剪裁-对数字进行扭曲-来人为增大数据集-减少误差" class="headerlink" title="通过处理输入 比如对输入图片进行 翻转 剪裁 对数字进行扭曲 来人为增大数据集 减少误差"></a>通过处理输入 比如对输入图片进行 翻转 剪裁 对数字进行扭曲 来人为增大数据集 减少误差</h3><h3 id="early-stop"><a href="#early-stop" class="headerlink" title="early-stop"></a>early-stop</h3><p>在 testSet的误差开始变大的时候，及时停止</p>
<h2 id="正则化输入"><a href="#正则化输入" class="headerlink" title="正则化输入"></a>正则化输入</h2><p>假设输入的数据集，每一个输入有两个特征，则输入的散点图如下</p>
<p><img src="/media/15426027650538.jpg" alt=""></p>
<p>归一化输入 则需要两部</p>
<ol>
<li>零均值化： 计算输入的均值μ，则<br>X = X-μ<br>这样的目的是让输入值的均值为0<br><img src="/media/15426029182235.jpg" alt=""></li>
</ol>
<ol start="2">
<li>归一化方差<br>可以看到 零均值化后的输入 x1 和x2方向的方差差距还是挺大的</li>
</ol>
<p>通过计算所有数据的方差σ² = 1/m*Σ（x(i)^2）<br>再将所有向量除以σ,x1和 x2的方差就都变为1了</p>
<p><img src="/media/15426031977047.jpg" alt=""></p>
<p><img src="/media/15426032845833.jpg" alt=""></p>
<p>注意： 测试集和训练集请使用同样的归一化参数</p>
<h3 id="为什么要归一化输入"><a href="#为什么要归一化输入" class="headerlink" title="为什么要归一化输入"></a>为什么要归一化输入</h3><p>假设没有对参数做归一化处理</p>
<p>那么x1 和x2的输入范围可能差距非常大，假设x1取值[0,10000] 而x2 取值[0,1] 这样导致的结果是参数w1 和 w2 的范围差距同样非常大，这样会导致J[W,B] 的图像变得狭长，会导致梯度下降的速度变慢[注2]<br><img src="/media/15426035904351.jpg" alt=""></p>
<p>当对输入进行归一化处理后，图像更偏向与均匀的碗形。<br><img src="/media/15426036134992.jpg" alt=""></p>
<p>这样对代价函数J进行梯度下降时，会使得梯度下降的速度更快。</p>
<blockquote>
<p><strong>[注2]:</strong><br>梯度下降的原理是让<strong><em>w</em></strong>和<strong><em>b</em></strong> 沿着 <strong><em>j</em></strong>对<strong><em>w</em></strong>和<strong><em>b</em></strong> 的负梯度方向前进，知道接近全局最小值。<br>让图像形状狭长的时候，梯度的前进方向会更容易偏离最优值的方向，那么在梯度下降过程中，前进方向难免会有很多折线，这样会使的前进速度变慢。 当图像偏向更均匀的圆形时，前进方向更平缓，也更容易找到最优解。</p>
</blockquote>
<h2 id="梯度消失与梯度爆炸"><a href="#梯度消失与梯度爆炸" class="headerlink" title="梯度消失与梯度爆炸"></a>梯度消失与梯度爆炸</h2><p>深层网络由许多非线性层堆叠而来，每一层非线性层都可以视为是一个非线性函数 <strong><em>f(x)···f(x)f(x)</em></strong>(非线性来自于非线性激活函数），因此整个深度网络可以视为是一个复合的非线性多元函数<br><img src="/media/15426057015192.jpg" alt=""></p>
<p>我们最终的目的是希望这个多元函数可以很好的完成输入到输出之间的映射，假设不同的输入，输出的最优解是<strong><em>g(x) g(x)g(x)</em></strong> ，那么，优化深度网络就是为了寻找到合适的权值，满足<strong><em>Loss=L(g(x),F(x)) Loss = L(g(x),F(x))Loss=L(g(x),F(x))</em></strong>取得极小值点，比如最简单的损失函数<br><img src="/media/15426057167589.jpg" alt=""></p>
<p>​    发生梯度爆炸、梯度消失的原因有两个<br>​<em> 网络层级太深<br>​</em> 采用了不合适的激活函数</p>
<p>例如，对于下图所示的含有3个隐藏层的神经网络，梯度消失问题发生时，接近于输出层的<strong><em>hidden layer 3</em></strong>等的权值更新相对正常，但前面的<strong><em>hidden layer 1</em></strong>的权值更新会变得很慢，导致前面的层权值几乎不变，仍接近于初始化的权值，这就导致<strong><em>hidden layer 1</em></strong>相当于只是一个映射层，对所有的输入做了一个同一映射，这是此深层网络的学习就等价于只有后几层的浅层网络的学习了。</p>
<p><img src="/media/15426066208782.jpg" alt=""></p>
<p>以下图的反向传播为例（假设每一层只有一个神经元且对于每一层<img src="/media/15426066801029.jpg" alt=""></p>
<p>可以推导出<br><img src="/media/15426066951424.jpg" alt=""><br>而sigmod的导数<br><img src="/media/15426067183425.jpg" alt=""></p>
<p>最大值为1/4 ，而初始化网络权值的时候，<strong><em>w</em></strong>通常小于1 ，导致<img src="/media/15426068404619.jpg" alt=""><br> 因此对于上面的链式求导，层数越多，求导结果越小，因而导致梯度消失的情况出现。梯度爆炸的原因正好相反，<br><img src="/media/15426068576215.jpg" alt=""></p>
<p>其实梯度爆炸和梯度消失问题都是因为网络太深，网络权值更新不稳定造成的，本质上是因为梯度反向传播中的连乘效应</p>
<h2 id="合理初始化神经网络的权重值-Xavier初始化"><a href="#合理初始化神经网络的权重值-Xavier初始化" class="headerlink" title="合理初始化神经网络的权重值(Xavier初始化)"></a>合理初始化神经网络的权重值(<strong><em>Xavier</em></strong>初始化)</h2><p>使用不同的激活函数，对于参数矩阵w的初始化方法也不相同<br><a href="https://zhuanlan.zhihu.com/p/27919794" target="_blank" rel="noopener">具体可以看这篇文章</a>，详细阐述了<strong><em>Xavier</em></strong>的初始化原理。</p>
<h2 id="梯度逼近"><a href="#梯度逼近" class="headerlink" title="梯度逼近"></a>梯度逼近</h2><p><img src="/media/15426119280417.jpg" alt=""></p>
<p>使用双边公差来计算梯度，可以有效减少误差</p>
<h2 id="梯度检验"><a href="#梯度检验" class="headerlink" title="梯度检验"></a>梯度检验</h2><p>将所有<strong><em>w</em></strong>和<strong><em>b</em></strong> 排列为一个超级大的向量<strong><em>θ</em></strong>，对<strong><em>θ</em></strong>的每一项<strong><em>θi</em></strong>，依次执行梯度逼近，计算出每一项<strong><em>dθiapprox</em></strong></p>
<p><img src="/media/15426128355674.jpg" alt=""></p>
<p>检查<br><img src="/media/15426128643069.jpg" alt=""></p>
<p>是否在合理范围内。<br>比如 如果<strong><em>ξ</em></strong>取值为10^-7, 梯度检验的结果和该标准相差几个数量级，就要考虑算法中是不是出现了bug。</p>
<p>具体到例子中，代价函数关于参数的梯度的定义:<br><img src="/media/15426144971309.jpg" alt=""><br>【这里<strong><em>wi</em></strong> 和 <strong><em>θi</em></strong>是 一一对应的】<br>我们想要确保 <strong><em>∂J/∂wi</em></strong> 的计算是正确的，只需要取 <strong><em>ε</em></strong> 为一个很小的数 (例如 10^−7)，然后计算 <strong><em>(J(wi+ε)−J(wi−ε))/2ε</em></strong> 是否约等于<strong><em> ∂J/∂wi</em></strong>，实际操作中判断两个参数向量的欧氏距离是否足够小。</p>
<p><strong>对于每个参数 wi，实施梯度检验的步骤一般是：</strong></p>
<p>1 . 使用前向传播计算代价函数 <strong><em>J(wi+ε)</em></strong><br>2 . 使用前向传播计算代价函数 <strong><em>J(wi−ε)</em></strong><br>3 . 计算梯度的近似值 (数值微分) <strong><em>gradapprox[i]=(J(wi+ε)−J(wi−ε))/2ε</em></strong></p>
<ol start="4">
<li>使用链式法则计算反向传播梯度，缓存到变量 <strong><em>grad</em></strong> 中<br>使用以下公式计算梯度 <strong><em>grad</em></strong> 和梯度的近似值 <strong><em>gradapprox</em></strong> 的欧氏距离：<br><strong><em>difference=∣∣grad−gradapprox∣∣2 / ∣∣grad∣∣2+∣∣gradapprox||2</em></strong></li>
</ol>
<p>实施梯度检验，有是哪个基本原则：</p>
<h3 id="不要再训练中使用梯度检验"><a href="#不要再训练中使用梯度检验" class="headerlink" title="不要再训练中使用梯度检验"></a>不要再训练中使用梯度检验</h3><p>梯度检验只适用于调试，不要在训练中打开它<br>因为对每一个θ做数值逼近是非常消耗时间的，只在调试bug的时候打开它，在训练的时候关闭。</p>
<h3 id="如果梯度检验失败，要检查每一项dθiapprox的值。"><a href="#如果梯度检验失败，要检查每一项dθiapprox的值。" class="headerlink" title="如果梯度检验失败，要检查每一项dθiapprox的值。"></a>如果梯度检验失败，要检查每一项dθiapprox的值。</h3><p>这样可以发现，是在求导哪一个参数的过程中出了问题</p>
<h3 id="如果代价函数有正则化项，求解dθ的时候不要漏掉这个正则化项"><a href="#如果代价函数有正则化项，求解dθ的时候不要漏掉这个正则化项" class="headerlink" title="如果代价函数有正则化项，求解dθ的时候不要漏掉这个正则化项"></a>如果代价函数有正则化项，求解dθ的时候不要漏掉这个正则化项</h3><h3 id="dropout不可以和梯度检验同时使用"><a href="#dropout不可以和梯度检验同时使用" class="headerlink" title="dropout不可以和梯度检验同时使用"></a>dropout不可以和梯度检验同时使用</h3><p>因为每次迭代过程中 Dropout 会使神经元结点随机失活，难以计算 Dropout 在梯度下降上的代价函数 J。</p>
<p>实施梯度检验的python代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gradient_check_n</span><span class="params">(parameters, gradients, X, Y, epsilon=<span class="number">1e-7</span>)</span>:</span></span><br><span class="line">    <span class="comment"># Set-up variables</span></span><br><span class="line">    parameters_values, _ = dictionary_to_vector(parameters)</span><br><span class="line">    grad = gradients_to_vector(gradients)</span><br><span class="line">    num_parameters = parameters_values.shape[<span class="number">0</span>]</span><br><span class="line">    J_plus = np.zeros((num_parameters, <span class="number">1</span>))</span><br><span class="line">    J_minus = np.zeros((num_parameters, <span class="number">1</span>))</span><br><span class="line">    gradapprox = np.zeros((num_parameters, <span class="number">1</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Compute gradapprox</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num_parameters):</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Compute J_plus[i]. Inputs: "parameters_values, epsilon". Output = "J_plus[i]".</span></span><br><span class="line">        thetaplus =  np.copy(parameters_values)                                       <span class="comment"># Step 1</span></span><br><span class="line">        thetaplus[i][<span class="number">0</span>] = thetaplus[i][<span class="number">0</span>] + epsilon                                   <span class="comment"># Step 2</span></span><br><span class="line">        J_plus[i], _ =  forward_propagation_n(X, Y, vector_to_dictionary(thetaplus))  <span class="comment"># Step 3</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Compute J_minus[i]. Inputs: "parameters_values, epsilon". Output = "J_minus[i]".</span></span><br><span class="line">        thetaminus = np.copy(parameters_values)                                       <span class="comment"># Step 1</span></span><br><span class="line">        thetaminus[i][<span class="number">0</span>] = thetaminus[i][<span class="number">0</span>] - epsilon                                 <span class="comment"># Step 2        </span></span><br><span class="line">        J_minus[i], _ = forward_propagation_n(X, Y, vector_to_dictionary(thetaminus)) <span class="comment"># Step 3</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Compute gradapprox[i]</span></span><br><span class="line">        gradapprox[i] = (J_plus[i] - J_minus[i]) / (<span class="number">2</span> * epsilon)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Compare gradapprox to backward propagation gradients by computing difference.</span></span><br><span class="line">    numerator = np.linalg.norm(grad - gradapprox)                                     <span class="comment"># Step 1'</span></span><br><span class="line">    denominator = np.linalg.norm(grad) + np.linalg.norm(gradapprox)                   <span class="comment"># Step 2'</span></span><br><span class="line">    difference = numerator / denominator                                              <span class="comment"># Step 3'</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> difference &gt; <span class="number">1e-7</span>:</span><br><span class="line">        print(<span class="string">"\033[93m"</span> + <span class="string">"There is a mistake in the backward propagation! difference = "</span> + str(difference) + <span class="string">"\033[0m"</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"\033[92m"</span> + <span class="string">"Your backward propagation works perfectly fine! difference = "</span> + str(difference) + <span class="string">"\033[0m"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> difference</span><br></pre></td></tr></table></figure>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://wenyiqingnian.xyz/2018/11/15/深度学习课程笔记 第一周 深度学习的实践层面/" data-id="cjqw00dzz0023vtfyrwqottay" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    
        <a href="http://wenyiqingnian.xyz/2018/11/15/深度学习课程笔记 第一周 深度学习的实践层面/#comments" class="article-comment-link">Comments</a>
    

        </footer>
    </div>
    
</article>



    <article id="post-机器学习算法的演进" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2018/11/11/机器学习算法的演进/">机器学习算法的演进</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2018/11/11/机器学习算法的演进/">
            <time datetime="2018-11-11T11:33:50.000Z" itemprop="datePublished">2018-11-11</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/机器学习/">机器学习</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/Tensorflow/">Tensorflow</a>, <a class="tag-link" href="/tags/机器学习/">机器学习</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <h2 id="人工智能、机器学习、深度学习三者的关系："><a href="#人工智能、机器学习、深度学习三者的关系：" class="headerlink" title="人工智能、机器学习、深度学习三者的关系："></a>人工智能、机器学习、深度学习三者的关系：</h2><p><strong>人工智能/AI：</strong>这是对高级计算智能的最宽泛的说法。<br>1956年，在达特茅斯人工智能大会上，该技术被描述为：“原则上，学习的每一个方面或任何其他智能特征都可以精确描述，并且一台机器可以模拟它。”。<br>AI 可以分为大致三个种类： 狭义AI、通用AI、超AI。<br>狭义AI 就类比与深蓝计算机以及AlphaGO，只在特定领域表现出色，而通用AI则彼此更高一层，成为与人类大脑具有相同本质的智慧体从而具有解决一系列问题的能力。<br>超AI则是目前人工智能科学家的终极梦想，此时的机器具备观察和感知的能力，具备超越人类的创造力。</p>
<p><strong>机器学习/ML：</strong> 一种实现人工智能的方法机器学习最基本的做法，是使用算法来解析数据、从中学习，然后对真实世界中的事件做出决策和预测。与传统的为解决特定任务、硬编码的软件程序不同，机器学习是用大量的数据来“训练”，通过各种算法从数据中学习如何完成任务。举个简单的例子，当我们浏览网上商城时，经常会出现商品推荐的信息。这是商城根据你往期的购物记录和冗长的收藏清单，识别出这其中哪些是你真正感兴趣，并且愿意购买的产品。这样的决策模型，可以帮助商城为客户提供建议并鼓励产品消费。</p>
<p>机器学习直接来源于早期的人工智能领域，传统的算法包括<a href="https://www.jiqizhixin.com/articles/a-tour-of-the-top-10-algorithms-for-machine-learning-newbies" target="_blank" rel="noopener">决策树、聚类、贝叶斯分类、支持向量机、EM、Adaboost等等</a>。</p>
<p>从学习方法上来分，机器学习算法可以分为<a href="https://www.jianshu.com/p/d1c97a4d2e70" target="_blank" rel="noopener">监督学习（如分类问题）、无监督学习（如聚类问题）、半监督学习、集成学习、深度学习和强化学习</a>。</p>
<p>传统的机器学习算法在指纹识别、基于Haar的人脸检测、基于HoG特征的物体检测等领域的应用基本达到了商业化的要求或者特定场景的商业化水平，但每前进一步都异常艰难，直到深度学习算法的出现。</p>
<p>所谓深度学习的深度，指的是<strong>神经网络的层数</strong>，机器学习算法经过：</p>
<ul>
<li>单层感知机：心理学家Rosenblatt提出，对复杂函数无能为力</li>
<li>多层感知机：多层感知机可以摆脱早期离散传输函数的束缚，使用<code>sigmoid</code>或<code>tanh</code>等连续函数模拟神经元对激励的响应，在训练算法上则使用<em>Werbos</em>发明的反向传播BP算法。这就是我们现在所说的<strong>神经网络</strong>，但多层感知机面临的致命问题是：<strong>随着神经网络层数的加深：一是优化函数越来越容易陷入局部最优解，并且这个“陷阱”越来越偏离真正的全局最优。利用有限数据训练的深层网络，性能还不如较浅层网络。二：“梯度消失”现象更加严重</strong></li>
<li>深度学习：2006年，<em>Hinton</em>利用预训练方法缓解了局部最优解问题，将隐含层推动到了7层，神经网络真正意义上有了“深度”，由此揭开了深度学习的热潮，随后的<code>DBN</code>、<code>CNN</code>、<code>RNN</code>、<code>LSTM</code>等才逐渐出现。 这里的“深度”并没有固定的定义——在语音识别中4层网络就能够被认为是“较深的”，而在图像识别中20层以上的网络屡见不鲜。 为了克服梯度消失，<code>ReLU</code>、<code>maxout</code>等传输函数代替了<code>sigmoid</code>，形成了如今<code>DNN</code>的基本形式。单从结构上来说，全链接的多层感知机是没有任何区别的。</li>
</ul>
<p><strong>深度学习/DL：</strong> 如上所言，深度学习是机器学习算法演进过程中诞生的一种。深度学习本来并不是一种独立的学习方法，其本身也会用到有监督和无监督的学习方法来训练深度神经网络。但由于近几年该领域发展迅猛，一些特有的学习手段相继被提出（如<a href="https://my.oschina.net/u/876354/blog/1622896" target="_blank" rel="noopener">残差网络</a>），因此越来越多的人将其单独看作一种学习的方法。</p>
<h2 id="深度神经网络的三个致命问题："><a href="#深度神经网络的三个致命问题：" class="headerlink" title="深度神经网络的三个致命问题："></a>深度神经网络的三个致命问题：</h2><p>深度神经网络有三个致命问题：</p>
<h3 id="非凸优化问题，即优化函数越来越容易陷入局部最优解；"><a href="#非凸优化问题，即优化函数越来越容易陷入局部最优解；" class="headerlink" title="非凸优化问题，即优化函数越来越容易陷入局部最优解；"></a>非凸优化问题，即优化函数越来越容易陷入局部最优解；</h3><p>线性回归，本质是一个多元一次函数的优化问题，设f(x,y)=x+y<br>多层神经网络，本质是一个多元K次函数优化问题，设f(x,y)=xy<br>在线性回归当中，从任意一个点出发搜索，最终必然是下降到全局最小值附近的。所以置0也无妨（这也是为什么我们往往解线性回归方程时初值为0）。<br>而在多层神经网络中，从不同点出发，可能最终困在局部最小值。局部最小值是神经网络结构带来的挥之不去的阴影，随着隐层层数的增加，非凸的目标函数越来越复杂，局部最小值点成倍增长，利用有限数据训练的深层网络，性能还不如较浅层网络。。避免的方法一般是权值初始化。为了统一初始化方案，通常将输入缩放到[−1,1]，但是仍然无法保证能够达到全局最优，其实这也是科学家们一直在研究而未解决的问题。<br>所以，从本质上来看，深度结构带来的非凸优化仍然不能解决（包括现在的各类深度学习算法和其他非凸优化问题都是如此），这限制着深度结构的发展。</p>
<h3 id="（Gradient-Vanish）梯度消失问题；"><a href="#（Gradient-Vanish）梯度消失问题；" class="headerlink" title="（Gradient Vanish）梯度消失问题；"></a>（Gradient Vanish）梯度消失问题；</h3><p>梯度爆炸和梯度消失问题都是因为网络太深，网络权值更新不稳定造成的，本质上是因为梯度反向传播中的连乘效应。<br>对于更普遍的梯度消失问题，可以考虑用ReLU激活函数取代sigmoid激活函数。另外，LSTM的结构设计也可以改善RNN中的梯度消失问题</p>
<h3 id="过拟合问题"><a href="#过拟合问题" class="headerlink" title="过拟合问题"></a>过拟合问题</h3><p>过拟合，庞大的结构和参数使得，尽管训练error降的很低，但是test error却高的离谱。<br>当出现梯度消失时，上层神经元的梯度变化非常小，几乎相当于把原始输入信息，没有经过任何非线性变换，或者错误变换推到高层去，使得高层解离特征压力太大。<br>如果特征无法解离，强制性的误差监督训练就会使得模型对输入数据直接做拟合，就会出现训练方差大的问题</p>
<h2 id="深度学习的常见模型："><a href="#深度学习的常见模型：" class="headerlink" title="深度学习的常见模型："></a>深度学习的常见模型：</h2><p><a href="https://towardsdatascience.com/the-mostly-complete-chart-of-neural-networks-explained-3fb6f2367464" target="_blank" rel="noopener">这张图基本囊括了目前常见的主流神经网络模型</a><br><img src="/media/15419350474031.jpg" alt=""></p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://wenyiqingnian.xyz/2018/11/11/机器学习算法的演进/" data-id="cjqw00dzx001vvtfydgxoubwu" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    
        <a href="http://wenyiqingnian.xyz/2018/11/11/机器学习算法的演进/#comments" class="article-comment-link">Comments</a>
    

        </footer>
    </div>
    
</article>



    <article id="post-八月份学习计划" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2018/08/21/八月份学习计划/">下个阶段的学习计划整理</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2018/08/21/八月份学习计划/">
            <time datetime="2018-08-21T09:12:50.000Z" itemprop="datePublished">2018-08-21</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/学习计划/">学习计划</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/android/">android</a>, <a class="tag-link" href="/tags/学习计划/">学习计划</a>, <a class="tag-link" href="/tags/音视频/">音视频</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <h1 id="下个阶段的学习计划整理"><a href="#下个阶段的学习计划整理" class="headerlink" title="下个阶段的学习计划整理"></a>下个阶段的学习计划整理</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><ol>
<li><strong>YUV</strong> <strong>RGB</strong>的图像表示方式</li>
<li><strong>PCM</strong>音频数据处理</li>
<li><strong>H.264</strong> 编码格式</li>
<li>android平台的<strong>MediaCodec</strong> </li>
<li><strong>AAC</strong>音频流</li>
<li>视频的几种封装格式</li>
</ol>
<h2 id="传输协议"><a href="#传输协议" class="headerlink" title="传输协议"></a>传输协议</h2><ol>
<li>UDP/RTP 协议</li>
</ol>
<h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><ol>
<li>FFmpeg</li>
</ol>
<h2 id="要看的书"><a href="#要看的书" class="headerlink" title="要看的书"></a>要看的书</h2><ol>
<li>音视频开发进阶指南</li>
</ol>
<blockquote>
<p>机械工程出版社 展晓凯 著</p>
</blockquote>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://wenyiqingnian.xyz/2018/08/21/八月份学习计划/" data-id="cjqw00dzt001lvtfy9punkm1q" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    
        <a href="http://wenyiqingnian.xyz/2018/08/21/八月份学习计划/#comments" class="article-comment-link">Comments</a>
    

        </footer>
    </div>
    
</article>



    <article id="post-一些知识点总结" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2018/08/16/一些知识点总结/">一些知识点总结</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2018/08/16/一些知识点总结/">
            <time datetime="2018-08-16T11:00:50.000Z" itemprop="datePublished">2018-08-16</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/Android/">Android</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/android/">android</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p>博客好久没更新了，把最近总结的一些零星知识点汇总一下吧。</p>
<h1 id="view-绘制流程相关："><a href="#view-绘制流程相关：" class="headerlink" title="view 绘制流程相关："></a>view 绘制流程相关：</h1><h3 id="如何在activity中正确获取view的宽高："><a href="#如何在activity中正确获取view的宽高：" class="headerlink" title="如何在activity中正确获取view的宽高："></a>如何在activity中正确获取view的宽高：</h3><ol>
<li><code>activity/view</code> <code>onwindowFocusChanged()</code></li>
<li><code>view.post(new Runnable{})</code></li>
<li><code>ViewTreeObserver.addOnGlobalLayoutListener();</code></li>
<li>手动调用<code>view.measure()</code>;</li>
</ol>
<h3 id="setWillNotDraw"><a href="#setWillNotDraw" class="headerlink" title="setWillNotDraw()"></a>setWillNotDraw()</h3><p>如果view不需要绘制任何内容，设置这个标记为true后系统会对其进行优化，默认View是没有启用的，但是viewGroup会默认启用，当我们开发的自定义控件继承viewGroup且本身不具备绘制功能，就可以开启该标记位便于系统优化。如果需要绘制内容，要显示关闭。</p>
<h3 id="当子view的measureSpec的type是unspecified时"><a href="#当子view的measureSpec的type是unspecified时" class="headerlink" title="当子view的measureSpec的type是unspecified时"></a>当子view的<code>measureSpec</code>的type是<code>unspecified</code>时</h3><p>子view的宽高是getSuggestMinWidth/Height 来获取的，如果有背景图，为背景图宽高，否则为布局制定的android:minWidth属性 （默认为0）</p>
<h3 id="layout过程"><a href="#layout过程" class="headerlink" title="layout过程"></a>layout过程</h3><p>自己的位置是由layout()方法决定，layout()中首先会调用setFrame() 来决定自己的上下左右位置，其次调用onLayout() 来确定子view的位置，不<em>**</em>同的viewGroup需要继承并自己实现其逻辑。</p>
<h3 id="MotionEvent"><a href="#MotionEvent" class="headerlink" title="MotionEvent()"></a>MotionEvent()</h3><p><code>getX/getY</code> <code>getRawX getRawY</code> 返回的分别为 相对于当前view左上角的x 和 y 以及相对于屏幕左上角的 x 和 y坐标。</p>
<h3 id="view-的事件分发"><a href="#view-的事件分发" class="headerlink" title="view 的事件分发"></a>view 的事件分发</h3><ol>
<li>当事件走到view这一层级的时候，首先会回调<code>dispatchTouchEvent()</code> –&gt; 是否设置了<code>onTouchListener</code>? 设置了 –&gt; 回调 <code>onTouch()</code> 并看<code>onTouch</code>的返回值  如果返回true -&gt; 回调 <code>onTouchEvent()</code> 否则 不回调<code>onTouchEvent()</code></li>
<li>view 的<code>onTouchEvent()</code>，先判断是否可用，如果不可用，当view可点击（长按 短按都行）会默认消费掉事件，当view可用，通过<code>event.getAction（）</code>判断当前事件类型，在<code>actionUP</code>的时候，调用<code>performClick(),</code>会判断是否调用<code>OnClick()</code> 和 <code>onLongClick()</code>.</li>
<li>当<code>viewGroup</code>决定拦截事件后，后续的事件都会交给她处理，不会再走<code>onInterceptTouchEvent</code>()方法，因为在调用<code>onInterceptTouchEvent</code>（）之前会判断<code>mFirstTouchTarget</code>是否为空，如果<code>viewGroup</code>自己拦截处理，<code>onInterceptTouchEvent = null</code> 就进不到判断里，也就不走<code>onInterceptTouchEvent（）</code>了。</li>
<li>当子view设<code>disallowInterceptTouchEvent()</code>之后，会修改父view的<code>FLAG_DISALLOW_INTERCEPT</code> 这个标记位，一旦设置之后，viewGroup就无法拦截down以后的事件了，但下次是还是可以收到<code>down</code>事件，因为在<code>down</code>事件来临的时候，viewGroup会重置这个标志位。也就是shi<code>disallowInterceptTouchEvent()</code>无法阻止父view 对down事件的处理。</li>
<li>当viewGroup不打算拦截，会将事件分发给子view，首先先判断哪些在触摸范围的子view，然后依次调用他们的<code>dispatchTouchEvent</code></li>
<li>一般处理滑动冲突，最好用外部拦截法<br>a. 重写父view的<code>OnInterceptTouchEvent</code>()<br>b. 父容器的<code>ACTION_DOWN</code>必须返回<code>false</code> 如果返回<code>true</code> 后续事件将都有他处理，子<code>view</code>是收不到其他事件的<br>c. <code>ACTION_MOVE</code> 要根据业务需求决定是否拦截<br>d. <code>ACTION_UP</code> 必须返回<code>false</code> 因为这个事件作为事件结尾本身没有什么意义，而且如果返回<code>true</code>，子view将收不到<code>up</code>事件，<code>onclick</code>方法将无法触发。</li>
</ol>
<h3 id="requestLayout、invalidate与postInvalidate"><a href="#requestLayout、invalidate与postInvalidate" class="headerlink" title="requestLayout、invalidate与postInvalidate"></a>requestLayout、invalidate与postInvalidate</h3><h4 id="requestLayout："><a href="#requestLayout：" class="headerlink" title="requestLayout："></a>requestLayout：</h4><p>当前view将自己设置一个flag  同时调用父view的requestLayout，父view会设置一个标志位：PFLAG_FORCE_LAYOUT，这样逐级上调，直到decorView，decorView会吧view上报到viewRootImpl上，viewRootImp会调用 requestLayout(),依次触发子view的measure layout draw方法。 </p>
<h4 id="invalidata"><a href="#invalidata" class="headerlink" title="invalidata"></a>invalidata</h4><p>invalidate有多个重载方法，但最终都会调用invalidateInternal方法，在这个方法内部，进行了一系列的判断，判断View是否需要重绘，接着为该View设置标记位，然后把需要重绘的区域传递给父容器，即调用父容器的invalidateChild方法。 </p>
<p>在该方法内部，先设置当前视图的标记位，接着有一个do…while…循环，该循环的作用主要是不断向上回溯父容器，求得父容器和子View需要重绘的区域的并集(dirty)。当父容器不是ViewRootImpl的时候，调用的是ViewGroup的invalidateChildInParent方法，我们来看看这个方法，ViewGroup#invalidateChildInParent:</p>
<p>这个方法做的工作主要有：调用offset方法，把当前dirty区域的坐标转化为父容器中的坐标，接着调用union方法，把子dirty区域与父容器的区域求并集，换句话说，dirty区域变成父容器区域。最后返回当前视图的父容器，以便进行下一次循环。</p>
<p>回到上面所说的do…while…循环，由于不断向上调用父容器的方法，到最后会调用到ViewRootImpl的invalidateChildInParent方法<br>该方法所做的工作与上面的差不多，都进行了offset和union对坐标的调整，然后把dirty区域的信息保存在mDirty中，最后调用了scheduleTraversals方法，触发View的工作流程，由于没有添加measure和layout的标记位，因此measure、layout流程不会执行，而是直接从draw流程开始。</p>
<p>好了，现在总结一下invalidate方法，当子View调用了invalidate方法后，会为该View添加一个标记位，同时不断向父容器请求刷新，父容器通过计算得出自身需要重绘的区域，直到传递到ViewRootImpl中，最终触发performTraversals方法，进行开始View树重绘流程(只绘制需要重绘的视图)。</p>
<h4 id="postinvalidata"><a href="#postinvalidata" class="headerlink" title="postinvalidata"></a>postinvalidata</h4><p>发送了一个异步消息到主线程，显然这里发送的是MSG_INVALIDATE，即通知主线程刷新视图</p>
<p><img src="/media/15323197924804.jpg" alt=""></p>
<h1 id="activity的启动流程"><a href="#activity的启动流程" class="headerlink" title="activity的启动流程"></a>activity的启动流程</h1><ol>
<li>A activity启动B activity </li>
<li>A 最终调用<code>startActivityForResult()</code></li>
<li><code>Instrumentation.exeStartActivity()</code></li>
<li><code>ActivityManagerNative.getDefault()</code> 通过<code>binder</code>机制 获得远端<code>AMS</code>的引用，在创建这个<code>Binder</code>对象时，传入了一个<code>IBinder</code>，其实是<code>ServiceManager</code>获得的，这个<code>IBinder</code>持有远端<code>AMS</code>服务的<code>handle</code>值，作为跟远<code>AMS</code>交流的信使。</li>
<li><code>AMS.startActivity</code>【此处有个分水岭 如果应用没有启动过 任务战中尚无待启动的应用程序 会走下面的流程 当应用是首次启动 会走22】</li>
<li><code>ActivityStackSupervisor.startActivityMayWait</code>()</li>
<li><code>ActivityStackSupervisor.startActivityMayWait().startActivityLocked()</code></li>
<li><code>startActivityLocked().startActivityUncheckedLocked()</code></li>
<li><code>ActivityStack.resumeTopActivitiesLocked</code></li>
<li>回到<code>ActivityStackSupervisor</code>，调用到<code>realStartActivityLocked</code>()</li>
<li>通过<code>binder</code>机制 调用会<code>ApplicationThread</code>(本身是个binder类型，被<code>AMS</code>远程访问)的<code>scheduleLaunchActivity()</code></li>
<li>发送一个启动<code>activity</code>的消息给<code>handler H</code>处理。</li>
<li><code>H</code> 收到之后，调用<code>ActivityThread</code> 的<code>handleLaunchActivity（）</code></li>
<li>在<code>handleLaunchActivity()</code> 中，调用<code>performLaunchActivity</code> 完成<code>activity</code>的创建</li>
<li>在<code>performLaunchActivity</code>中，通过<code>ActivityClientRecord</code> 获取启动的<code>activity</code>信息，通过<code>Instrumentation</code>的<code>newActivity</code> 使用类加载器创建<code>activity</code>，通过<code>LoadApk</code> 创建<code>Application</code>对象，其实还是通过<code>Instrumentation</code>通过类加载器创建的，随后会调用<code>application</code>类的<code>onCreate</code>方法。创建<code>ContextImp</code>对象，并调用<code>activity</code>的<code>attach</code>方法，在<code>attach</code>方法中完成对<code>window</code>的创建，调用<code>activity</code>的<code>onCreate</code>方法。</li>
<li>在<code>attach</code>中，创建了<code>window</code>接口的唯一实现类<code>PhoneWindow</code>对象，并将<code>activity</code>设置为<code>window</code>的回调接口（<code>activity</code>默认是实现了这些接口的），也就是我们在<code>activity</code>中可以复写的<code>onAttachedToWindow,onDetachedToWindow</code>之类。</li>
<li>回调<code>activity</code>的<code>onCreate（）</code>方法 执行<code>setContentView（）</code></li>
<li><code>setContentView()</code>实际是<code>PhoneWindow</code>执行的，首先创建顶级视图<code>decorView</code> 并把自定义布局添加到<code>decorView</code>中，此时该视图还没被添加到window中</li>
<li>handleLaunchActivity之后会立刻回调<code>onResume</code>方法 会回调<code>activity</code>的<code>makeVisible()</code> 此时<code>decorView</code> 才真正被添加到<code>PhoneWindow</code>中，也就是执行了<code>window.addView</code>方法</li>
<li><code>addView</code>方法中，会创建<code>viewRootImp</code> 并将<code>view</code>添加到列表中，将<code>viewRootImp</code>添加到<code>mRoots</code>列表中</li>
<li>调用<code>viewRootImp</code>的<code>setView（）</code> 在该方法内部会调用 <code>requestLayout()</code>开启异步刷新请求，通过<code>scheduleTraversals()</code>开始一次调用view的 <code>onMeasure</code> <code>onLayout</code> <code>onDraw</code></li>
<li>注意viewRootImp的绘制方法 都是通过WMS 通过binder机制完成的。</li>
<li>如果应用尚未启动过，AMS的startActivity() 会调用zygoteSendAndGetResult() , 通过socket方式通知zygote进程为待启动应用fork一个新进程。</li>
<li>fork新进程，其实就是创建了一个ActivityThread，并执行main()方法。</li>
<li>在目标activity的ActivityThread的main() 方法中，首先创建ActivityThread对象实例。</li>
<li>调用thread.attach() ，通过binder机制 通过AMS最终调用到ApplicationThread的bindApplication()方法。通过H handler发送了一H.BIND_APPLICATION的消息。</li>
<li>在attach方法内部 初始化了一个叫做H的handler 并开始looper.loop 轮训获取消息。</li>
<li>当H收到bindApplication的消息后，调用handleBindApplication()方法，通过loadAPK.makeApplication()来创建Application对象，此时application还是通过instrument对象通过反射创建的，创建完成之后调用application的oncreate，并创建ContextImp对象。</li>
<li><p>回到14</p>
<p>A 的activity 中 <code>通过Instrumentation.checkStartActivityResult</code>() 检查启动是否正常，不正常会抛出相应异常</p>
<p><img src="/media/15320710123212.jpg" alt=""></p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Application 构造函数</span><br><span class="line">-&gt; Application.attachBaseContext()</span><br><span class="line">-&gt; Application.onCreate()</span><br><span class="line">-&gt; Activity 构造函数</span><br><span class="line">-&gt; Activity.setTheme()</span><br><span class="line">-&gt; Activity.onCreate()</span><br><span class="line">-&gt; Activity.onStart</span><br><span class="line">-&gt; Activity.onResume</span><br><span class="line">-&gt; Activity.onAttachedToWindow</span><br><span class="line">-&gt; Activity.onWindowFocusChanged</span><br></pre></td></tr></table></figure>
<p>如果要记录应用启动时间 在attachBaseContext()中打log 为启动开始时间<br>在activity的onWindoewFocusChanged() 打log记录结束时间，</p>
<h2 id="热更新"><a href="#热更新" class="headerlink" title="热更新"></a>热更新</h2><ol>
<li><code>PathClassloader</code> 和 <code>DexClassLoader</code>均继承自<code>BaseDexClassLoader</code></li>
<li><code>pathClassLoader</code>只能加载安装包安装后解压路径下的dex文件，而<code>DexClassLoader</code>可以加载jar包,zip文件，APK文件中的dex文件，所以DexClassLoader肯定有一步解压操作，将压缩包的dex文件解压到制定目录，所以再构造函数中需要传入一个解压目录</li>
<li><p>在父类<code>BaseDexClassLoader</code>的<code>loadClass()</code>方法中，实际是通过<code>dexPathList</code>的<code>findClass</code> 来查找class的<br><img src="/media/15318960466725.jpg" alt=""></p>
</li>
<li><p><code>DexPathList</code>的构造函数中，保存了当前的类加载器，同时将一个个的apk，dex，zip、jar之类的文件封装为一个个的<code>Element</code>，添加到<code>Elements</code>集合中，每个<code>Element</code>元素中都保存着对应的dex文件<code>dexFile</code>。</p>
</li>
<li><p>封装Element的过程调用的<code>makeDexElements</code>()方法，用<code>loadDexFile</code>() 来装载dex文件</p>
</li>
<li><p>调用DexPathlist的findClass(),其实就是遍历Elements集合，对每个Element，<code>DexFile dex = element.dexFile</code> 取出dexFile，并调用<code>loadClassBinaryName</code>()来加载class<br><img src="/media/15318967737089.jpg" alt=""></p>
</li>
<li><p>热修复的原理<br><img src="/media/15318968450411.jpg" alt=""></p>
</li>
<li><p>热修复步骤：<br>a. 定义好要修复的java文件，先编译为class，再编译为dex<br>b. 也可以创建个压缩包或者apk文件或者jar包，但要求是apk文件解压后里面必须有一个<code>class.dex</code> 的文件，因为<code>DexPathList</code>类中的<code>loadDexFile</code>方法中会对这个做判断，如果没有就会报异常。<br>c. </p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. PathClassLoader pathLoader = (PathClassLoader) appContext.getClassLoader();</span><br><span class="line"><span class="number">2</span>. DexClassLoader dexLoader = <span class="keyword">new</span> DexClassLoader(</span><br><span class="line">                        dex.getAbsolutePath(),<span class="comment">// 修复好的dex（补丁）所在目录</span></span><br><span class="line">                        fopt.getAbsolutePath(),<span class="comment">// 存放dex的解压目录（用于jar、zip、apk格式的补丁）</span></span><br><span class="line">                        <span class="keyword">null</span>,<span class="comment">// 加载dex时需要的库</span></span><br><span class="line">                        pathLoader<span class="comment">// 父类加载器</span></span><br><span class="line"><span class="number">3</span>.合并 Object dexPathList = getPathList(dexLoader);</span><br><span class="line">                Object pathPathList = getPathList(pathLoader);</span><br><span class="line">                Object leftDexElements = getDexElements(dexPathList);</span><br><span class="line">                Object rightDexElements = getDexElements(pathPathList);</span><br><span class="line"><span class="number">4</span>. 合并完成 Object dexElements = combineArray(leftDexElements, rightDexElements);</span><br><span class="line"><span class="number">5</span>. 重写给PathList里面的Element[] dexElements;赋值 Object pathList = getPathList(pathLoader);<span class="comment">// 一定要重新获取，不要用pathPathList，会报错</span></span><br><span class="line"><span class="number">6</span>. setField(pathList, pathList.getClass(), <span class="string">"dexElements"</span>, dexElements);</span><br></pre></td></tr></table></figure>
<p> 9 . 各热更新框架的差异</p>
<p>阿里andFix  hook 方法在native的具体字段。art虚拟机上是一个叫ArtMethod的结构体。通过修改该结构体上有bug的字段来达到修复bug方法的目的，但这个artMethod是根据安卓原生的结构写死的，国内很多第三方厂家会改写ArtMethod结构，导致替换失效。</p>
<p>qq的dex插装就类似上面分析的那种。通过将修复的dex文件插入到app的dexFileList的前面，达到更新bug的效果，但是不能及时生效，需要重启。但虚拟机在安装期间会为类打上CLASS_ISPREVERIFIED标志，是为了提高性能的，我们强制防止类被打上标志是否会有些影响性能</p>
<p>美团robust 是在编译器为每个方法插入了一段逻辑代码，并为每个类创建了一个ChangeQuickRedirect静态成员变量，当它不为空会转入新的代码逻辑达到修复bug的目的。有点是兼容性高,但是会增加应用体积</p>
<h2 id="网络请求框架："><a href="#网络请求框架：" class="headerlink" title="网络请求框架："></a>网络请求框架：</h2><p><strong>volley</strong><br>适合轻量 频率快的网络请求<br>因为volley的异步任务 其实用的是一个默认数量为4的固定数量线城池，超过4个线程会排在等待队列中阻塞。<br>volley为了提高速度 做了一些优化：</p>
<ol>
<li>请求是用队列维护的 而且可以设置队列的出入方式</li>
<li>对response做了缓存，如果下次请求的内容没变会优先从缓存中获取</li>
<li>网络请求的数据 是在工作线程中进行解析并分发到主线程，所以volley的回调是在主线程中，可以直接操作ui，okhttp是回调在工作线程的。</li>
<li>重要】：volley为了提高访问速度，会将整个response加载在内存中，所以如果下载的文件太大 会引发oom，但是它存储在内存中又是一个缓冲池实现的，ByteArrayPool，每次需要保存数据 先看缓冲池中有无可用空间，有的话就可以直接复用，减少了内存分配的次数，所以比较适合小数据量 但是频繁访问的场景。</li>
</ol>
<h2 id="换肤"><a href="#换肤" class="headerlink" title="换肤"></a>换肤</h2><ol>
<li>主要是反射获取AssetManager 然后反射调用<br>AssetManager的addAssetPath() 方法</li>
<li><p>将自定义的资源文件（可以是zip 或者apk的路径）加入AssetManager之后，重新构造一个Resource对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Resources(assetManager,context.getResources().getDisplayMetrics(),context.getResources().getConfiguration());</span><br></pre></td></tr></table></figure>
</li>
<li><p>layoutInflator.Factory()对象是一个会根据布局树来依次生成对应view的类，我们可以hook这个类的方法，对其生成相关view的逻辑做修改，比如就可以通过下面的方式，将id = R.id.text的一个TextView 改为一个button</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">LayoutInflater.from(<span class="keyword">this</span>).setFactory(<span class="keyword">new</span> LayoutInflater.Factory() &#123;</span><br><span class="line"></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(String name, Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">               <span class="keyword">if</span> (<span class="string">"TextView"</span>.equals(name)) &#123;</span><br><span class="line">                   Log.e(TAG, <span class="string">"name = "</span> + name);</span><br><span class="line">                   <span class="keyword">int</span> n = attrs.getAttributeCount();</span><br><span class="line">                   <span class="comment">//打印所有属性标签</span></span><br><span class="line">                   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                       Log.e(TAG, attrs.getAttributeName(i) + <span class="string">" , "</span> + attrs.getAttributeValue(i));</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                       <span class="keyword">if</span> (attrs.getAttributeName(i).equals(<span class="string">"id"</span>)) &#123;</span><br><span class="line">                           String attributeValue = attrs.getAttributeValue(i);</span><br><span class="line">                           String id = attributeValue.substring(<span class="number">1</span>, attributeValue.length());</span><br><span class="line">                           <span class="keyword">if</span> (R.id.text == Integer.valueOf(id)) &#123;</span><br><span class="line">                               Button button = <span class="keyword">new</span> Button(context, attrs);</span><br><span class="line">                               button.setBackgroundColor(Color.RED);</span><br><span class="line">                               <span class="keyword">return</span> button;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       setContentView(R.layout.activity_main);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="4">
<li>为所有activity写好基类，在基类的onCreate()方法中，将我们自定义的LayoutInflator.Factory设置给当前activity的LayoutInflator。</li>
<li>在自定义的LayoutInflator中，首先根据我们自己定义的tag来判断是否需要换肤，如果需要，先通过layoutInflate将当前view创建出来，然后将需要换肤的view的属性值去除一些带“@”符号的资源引用的，做成一个集合，集合的每个成员里都带有当前需要换肤的view 以及view需要更换的属性（比如 字体颜色，背景色之类的）</li>
<li><p>通过前面创建的皮肤资源Resource 来获取需要婚换肤的资源，比如对应的夜间模式的颜色，drawable之类。<br><code>mResources.getIdentifier(resName, &quot;color&quot;, skinPackageName);</code></p>
<h2 id="lrucache的实现原理"><a href="#lrucache的实现原理" class="headerlink" title="lrucache的实现原理"></a>lrucache的实现原理</h2><p>Lrucache在初始化的时候 需要指定缓存大小 以及缓存文件大小的计算方法 sizeof()<br>内部实现其实是用了一个LinkedHashMapL&lt;k,v&gt; 来实现保存缓存文件的。</p>
<p>每次添加缓存文件到缓存中时，都会调用trimToSize()方法。先计算当前缓存文件大小，与已使用缓存大小做比较，当缓存文件不够用的时候会调用LinkedHashMap 的eldest查找到最久未使用的文件，将其从hashMap中删除，将缓存文件加入hashMap中同时更新已使用缓存大小。</p>
</li>
</ol>
<h2 id="crash的相关处理："><a href="#crash的相关处理：" class="headerlink" title="crash的相关处理："></a>crash的相关处理：</h2><h3 id="java-crash"><a href="#java-crash" class="headerlink" title="java crash"></a>java crash</h3><ol>
<li>查看崩溃类型 是否是哪几种特定类型比如badTokenException 一般是activity正在销毁但是Fragment要弹吐司或者dialog导致的。一般是异步请求会出现这种情况</li>
<li>查看是否进行过异常处理，有些方法的执行过程出错了，但是因为在代码层进行了trycatch，导致应用并没有崩溃，但是传递了错误的执行结果导致后面的方法出现crash</li>
<li>查看崩溃机型，有些rom厂商会对rom进行深度定制导致部分方法会crash。尤其国产厂商会对权限做更严格的限制，稍有不慎就会导致意料之外的结果，比如华为手机7.0之后申请牌照权限 除了要申请camera之外，还要申请读写外部存储。</li>
<li>注意异步操作，可能会内存泄漏导致溢出。</li>
<li>自定义一个UncaughtExceptionHandler 因为当appcrash的时候，系统会恢复activitiy栈的的第一个activity，有时候会导致不停崩溃，最好在handler中将应用任务栈中的activity清空，并调用System.exit(0)</li>
<li>还是使用uncaughtExceptionHandler来捕获crash堆栈信息并上传服务器。</li>
<li>通过替换ActivityThread的H handler对象来达到统一处理异常，并处理异常Activity的声明周期，减少不必要crash的发生。通过</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Looper.getMainLooper.post(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">           <span class="keyword">try</span>&#123;</span><br><span class="line">               Looper.loop();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">catch</span>&#123;</span><br><span class="line">           handleException();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="native-crash"><a href="#native-crash" class="headerlink" title="native crash"></a>native crash</h3></li>
<li><p>检查对应abi 版本 使用对应的工具</p>
</li>
<li>查看错误地址，判断是不是空指针异常</li>
<li>用add2line还原堆栈，看调用方法信息</li>
<li><p>如果还分析不出为什么出错，就要还原当时的寄存器现场和内存现场</p>
<h2 id="JNI技术相关"><a href="#JNI技术相关" class="headerlink" title="JNI技术相关"></a>JNI技术相关</h2></li>
<li><p>jni的方法可以动态注册 也就可以静态注册 在java层写好native 方法名，如果是 动态注册 将方法的全路径名写上 将点 换成下划线 比如 `JNIEXPORT void JNICALLJava_android_media_MediaScanner_processFile</p>
<pre><code>(JNIEnv *, jobject, jstring,jstring, jobject);
</code></pre><p><code>， 动态注册 通过</code>JniNativeMethod<code>结构体列表来实现，</code>static JNINativeMethod gMethods<code>构建一个</code>JniNativeMethod<code>结构体 需要传入方法名，方法签名（根据传入参数和返回值类型来生成的一定格式的字符串）以及一个jni层对应的函数指针
然后调用</code>AndroidRuntime::registerNativeMethods`来动态注册jni方法</p>
</li>
<li><p>动态注册 是当调用 <code>system.loadLibrary（）</code>时，系统会在<code>native</code>层寻找<code>JNI_OnLoad</code>函数 在这里要完成动态注册的工作</p>
</li>
<li><code>JNIEnv</code>是线程相关的，每个线程独一份儿，当我们要手动从一个<code>native</code>方法回调java层方法时，需要手动传入一个<code>JNIEnv</code>，这个<code>JNIEnv</code>需要从<code>JavaVM</code>构造，<code>JavaVM</code>会在 <code>JNI_OnLoad</code>方法中由jvm传递给native，<code>JNIEnv.AttachCurrentThread</code> 来获取一个当前线程的jniEnv。当然退出的时候还要<code>DetachCurrentThread</code> 来释放资源</li>
<li>通过<code>JniEnv</code>调用方法 <code>NativeType Call&lt;type&gt;Method(JNIEnv *env,jobject obj,jmethodID methodID, ...)。</code></li>
<li>操作成员变量 </li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> NativeType Get&lt;type&gt;Field(JNIEnv *env,jobject obj,jfieldID fieldID)</span><br><span class="line"><span class="comment">//或者调用Set&lt;type&gt;Field系列函数来设置jobject对应成员变量的值。</span></span><br><span class="line"><span class="keyword">void</span> Set&lt;type&gt;Field(JNIEnv *env,jobject obj,jfieldID fieldID,NativeType value)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="并发相关"><a href="#并发相关" class="headerlink" title="并发相关"></a>并发相关</h2><ul>
<li>启动一个新线程  继承thread 对象复写run方法 或者创建一个runnable对象，其实这两种方式没有太大区别，本质上Thread 对象就是一个runnable接口的实现类，网上很多人说 头一种方式不面向对象，不能复用资源是由继承 这种创建方式导致的，其实你完全可以new 一个thrad对象 把它像runable一样交给一个thread 同样可以达到复用资源的目的（本质上会吧这个thread 赋值给Thread中的target）</li>
<li>新建线程 使用start（） 如果调用run() 实际是在调用线程去执行Thread 中run方法的内容</li>
<li>线程挂起有两种方式：sleep() 不释放锁，wait() 会释放锁</li>
<li>终止线程不要使用stop()  因为该方法过于暴力，会直接终止当前线程并释放锁，可能造成数据不一致 导致安全隐患。</li>
<li>如何实现多线程通讯：通过共享对象，或者使用wait notify，但是要注意假唤醒和唤醒型号丢失，唤醒信号丢失是指 当a线程调用notify时，等待池中尚无等待锁对象的线程，此时信号就丢失了，当b线程再调用wait的时候就永远不会被唤醒，解决办法是b线程调用wait的时候，先判断一下有无线程调用过notify。 假唤醒是指有时候线程会因为一些莫名其妙的原因在没有notify的时候被jvm唤醒，解决办法是使用while循环轮训判断是否有线程调用过nofity，这种类似于java的自旋，但是比较消耗cpu。记住不要对字符串常亮或者全局对象中使用wait和notify。</li>
<li>如何停止一个正在运行的线程？ 设置一个判断标识。通常是一个volentaile类型的变量。如果标识被设置为false 就停止运行，不要直接调用stop。</li>
<li>suspend 和 resume 方法已经过时了，因为这两个方法使用时序不当会非常容易造成死锁。 因为suspend 会让线程挂起吗，但是却不会释放锁。只有当该线程被其他线程调用了resume() 之后 才会继续执行。但如果其他线程调用t1的resume时要获得锁，这时候死锁就产生了 t2始终无法获得锁，t1永远无法被唤醒。</li>
<li><p>reentranLock 可重入锁和syncornoized的比较：<br>首先 reentranLock 的设计并不是为了替代syncornized。只是为了在syncornized不能满足使用需求时，为加锁增加一些新的特性。<br>syncornized 的缺点：无法中断一个正在等待锁的线程，当多个线程争夺某个锁时，未获得的对象只能不断等待锁对象的释放而不能终端这个过程。对于大量线程争夺锁的情况性能比较低。<br>reentranLock 是对固有锁的补充，提供了可中断lockInterruptibly()，可等待tryLock，超时中断 tryLock(long, TimeUnit)，公平和非公平锁的实现。而且在某些jvm版本上提供了比固有锁更好的性能。 但是不会自动释放锁，需要在final块中 手动实行释放操作。</p>
<p>新的jdk已经对固有锁做了很多优化，尤其是针对固有锁无法中断导致多线程争夺场景下性能低的情况。比如增加了偏向锁，轻量级锁和重量级锁的特性。<br>当多线程的执行过程类似于顺序执行时，jvm会默认使用偏向锁来提高并发性能，当一旦出现多线程争夺，便会膨胀为重量级锁。</p>
<p>相同点：都是可重入锁 </p>
</li>
<li><p>多线程协作： 主要是解决同步互斥、资源互斥、协调竞争的问题。可以使用syncnornized lock wait notify 以及信号量Semaphore、CountdownLatch来解决互斥同步问题。 注意 sleep会抛出InteruptException异常。</p>
</li>
<li>乐观锁：每次操作时不加锁，而是假设没有冲突去完成某项操作，如果因为冲突失败，就去重试知道成功为止。 可以使用volatile 和 cas原语实现（a.compateAndSet(oldValue,newValue)）;<br>在操作前每次先读取这个volatile修饰的字段，判断与旧值是否相等，相等则操作，否则重试。可以避免阻塞。</li>
<li>悲观锁：每次操作前先尝试获取锁，获取不到就等待，直到某个线程释放了锁为止。可以使用syncornize和lock实现。 悲观锁会频繁的导致线程挂起和恢复执行，这个开销非常重量级，会导致时间代价比较大</li>
<li>判断线程是否拥有锁： Thread.holdsLock() 返回true表示拥有一个具体锁</li>
<li><p>如果你提交任务时，线程池队列已满。会时发会生什么？<br>这个问题问得很狡猾，许多程序员会认为该任务会阻塞直到线程池队列有空位。事实上如果一个任务不能被调度执行那么ThreadPoolExecutor’s submit()方法将会抛出一个RejectedExecutionException异常</p>
</li>
<li><p>Interupt()方法会将isInterupt置为false。 但是不可以对一个已经调用了sleep() 的方法执行interupt，会抛异常，而且在异常块里，会将isInterupt的值置为true。</p>
</li>
<li>为什么进行指令重排序：为了提高效率，现代cpu都是采用流水线来执行指令。一个操作会被分为：取指令，译码，访存，执行，写回等若干阶段，多条指令可以同时存在在流水线中并行执行，为了避免一条指令的执行过程太长导致后续指令都卡在执行之前，cpu会对令重拍以提高效率。</li>
<li><p>Condition 是与lock配合使用的，也称为条件队列 或条件变量，主要作用是 a: 以原子方式 释放相关的锁，并挂起当前线程 b: 唤醒相关等待队列的线程，是为了解决Object.wait/notify/notifyAll 不好用而出来的。 wait 和 notify 只有一个阻塞队列，如果在生产者和消费者模型中，想当产品满了唤醒一个消费者线程 如果使用wait，无法保证唤醒的一定是消费者线程，因为只有一个阻塞队列，队列中可能会有生产者线程 也可能会有消费者线程，wait会从等待队列中随机唤醒一个 所以wait 是有局限性的。 我们可以实现两个Condition 条件队列，生产者线程一个 消费者线程一个  当我们想唤醒对应线程 只需要调用对应的条件队列就可以了。如果是用syncornized 对应的就是wait 和 nofity。 如果是用并发包的lock reentranlock 对用的就是await signal signalAll。</p>
</li>
<li><p>Semaphore 等于是个共享锁 和Lock类似 可以为他设置值，如果设为1 就等于lock </p>
</li>
<li>ThreadLocal的实现： ThreadLocal set的时候，会传入一个Thread对象。通过Thread对象获取其中的成员变量ThreadLocalMap  threadLocals ，如果没有就创建，有就往里面写值。 可以看到 ThreadLocal真正存储数据其实是放在Thread对象中的，这就是为什么ThreadLocal可以做到线程隔离的原因，但是ThreadLocalMaps其实是ThreadLocal的内部类，所以Thread对象应该会持有ThreadLocal才对，但是因为ThreadLocalMap 中的key 其实是Threadlocal的弱引用。所以并不会出现内存泄漏的问题。使用ThreadLocal 也可以做到被其他线程访问，比如InheritableThreadLocal对象中的 数据就可以被其他线程访问。 子线程访问父线程的InheritableThreadLocal的值时，使用了浅拷贝。</li>
<li>Java中long和double赋值不是原子操作，因为先写32位，再写后32位，分两步操作,这样就线程不安全了。如果改成下面的就线程安全了</li>
</ul>
<h2 id="并发相关的集合："><a href="#并发相关的集合：" class="headerlink" title="并发相关的集合："></a>并发相关的集合：</h2><ul>
<li><p>currentHashMap ：通过锁分段技术保证并发环境下的写操作；</p>
<p>通过 HashEntry的不变性、Volatile变量的内存可见性和加锁重读机制保证高效、安全的读操作；</p>
<p>通过不加锁和加锁两种方案控制跨段操作的的安全性。</p>
<p>HashMap 当在并发情况下进行扩容重哈希的时候，可能在链表中形成闭环，这样在进行查找 插入 删除操作的时候会陷入死循环。CorrentHashMap 解决了这个问题。<br><img src="/media/15320606495605.jpg" alt=""></p>
<p>分段锁的实现依赖于Segment ，继承ReentranLock，里面有一个计数器变量mCount表示自己管理的table中hashEntry数量，每次插入删除元素都会更新这个值。成员变量table，表示自己管理的HashEntry链表。当写操作发生在不同的segment段时，可以允许多个写线程并发执行。<br>HashEnrty是个四元组，key，hash和next域都被声明为final的，value域被volatile所修饰，因此HashEntry对象几乎是不可变的，这是ConcurrentHashmap读操作并不需要加锁的一个重要原因。<br>这意味着，我们不能把节点添加到链表的中间和尾部，也不能在链表的中间和尾部删除节点。这个特性可以保证：在访问某个节点时，这个节点之后的链接不会被改变，这个特性可以大大降低处理链表时的复杂性<br>注意 ：CorrentHashMap 不允许插入null的key 和value 而HashMap是可以的。<br>CorrentHashMap 初始化的时候 默认大小是2的n此方。<br>jdk 1.8以后，已经将segment的同步机制更改为了Syncornized和CAS操作。 说明Syncornized的性能已经优化到不比ReentranLock差了。</p>
</li>
<li><p>JDK对Syncnonized的优化 ： 引入偏向锁，轻量级锁和重量级锁。<br>synchronized的执行过程： </p>
</li>
</ul>
<ol>
<li>检测Mark Word里面是不是当前线程的ID，如果是，表示当前线程处于偏向锁 </li>
<li>如果不是，则使用CAS将当前线程的ID替换Mard Word，如果成功则表示当前线程获得偏向锁，置偏向标志位1 </li>
<li>如果失败，则说明发生竞争，撤销偏向锁，进而升级为轻量级锁。 </li>
<li>当前线程使用CAS将对象头的Mark Word替换为锁记录指针，如果成功，当前线程获得锁 </li>
<li>如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。 </li>
<li>如果自旋成功则依然处于轻量级状态。 </li>
<li>如果自旋失败，则升级为重量级锁</li>
</ol>
<ul>
<li><p>copyOnArrayList 写时复制机制。<br>add元素的时候，先加锁，然后拷贝一份相同的数组，在新数组上操作，写完之后将对原数组的引用修改为对新数组的引用。 读可以不用加锁读。<br>1、如果写操作未完成，那么直接读取原数组的数据；<br>2、如果写操作完成，但是引用还未指向新数组，那么也是读取原数组数据；<br>3、如果写操作完成，并且引用已经指向了新的数组，那么直接从新数组中读取数据<br>缺点：写会拷贝数组，如果容量很大容易频繁触发gc<br>不能实时读，但保证最终一致性。<br>适合都多写少的场景，但要慎用，因为容易oom</p>
</li>
<li><p>CopyOnWriteHashSet</p>
</li>
<li>HashTable 解决hash冲突：链地址法</li>
<li>BlockQuene 阻塞队列：一般用来解决生产者消费者问题。提供了四组方法，分别产生四种结果，抛异常，返回特定值，阻塞，超时。无参构造方法默认是误解队列，也可以创建时默认设置一个缓冲区大小。<br>linkedBlockedQuene 本质还是一个单向链表，为了提高生产和消费的效率，使用了两个锁分别对表头和表尾数据进行同步，如果take() 方法执行时队列为空，线程会阻塞在await上。只有等put()方法执行之后，会唤醒一个线程取一条数据。</li>
<li><img src="/media/15320721556989.jpg" alt=""></li>
</ul>
<h2 id="并发包中-锁机制的实现"><a href="#并发包中-锁机制的实现" class="headerlink" title="并发包中 锁机制的实现"></a>并发包中 锁机制的实现</h2><p>其实就是通过CAS机制  在lock的时候 CAS 在unlock的时候讲atom值设置回去，如果CAS失败 就enquene 将当前线程记录在链表中，然后挂起线程 LockSupport.park()， LockSupport.park()会调Unsafe.park()的native方法，虚拟机在linux中执行pthread_mutex_lock函数 实现阻塞线程的操作。用当其他占有锁的线程 释放锁的时候，会调用Usafe.unpark唤醒阻塞队列的对头线程，线程继续递归调用lock()方法尝试获取锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// step 1. cas 尝试 检查当前是否有其他线程改写了值 </span></span><br><span class="line">    <span class="keyword">boolean</span> ok = state.compareAndSet(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// step 2. 如果没有  线程将值改写为1 同时独占该方法 </span></span><br><span class="line">  <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">    setExclusiveThread(Thread.current()); <span class="comment">// 这只是个标志位，不用太介意</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// step 3. 如果cas失败 就进不去步骤2 当前线程要被阻塞 此时执行入队 用队列记录被阻塞的线程 </span></span><br><span class="line">  enqueue();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// step 4. park方法将当前线程挂起 停止调度 线程就执行到这里阻塞  当其他独占线程释放锁的时候 会调用unsafa.Unpark() 会将阻塞队列对头线程唤醒 此时线程可以往下执行到step5  尝试递归获取锁</span></span><br><span class="line">  Unsafe.park();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// step 5. retry </span></span><br><span class="line">  lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些步骤可以提取出共有的特性 dogue lee 就写了一个框架 叫AbstractQueuedSynchronizer 简称AQS框架 是通用的锁框架<br>AQS 伪代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>步骤分为四步:</p>
<ul>
<li>tryAcquire，抽象方法，由子类实现，子类通过控制原子变量来表示是否获取锁成功，类似于上文代码的<br>Step1、Step2</li>
<li>addWaiter，已经实现的方法，表示将当前线程加入等待队列，类似于上文的Step3acquireQueued()，*</li>
<li>挂起线程，唤醒后重试，类似于上文的Step4、Step5</li>
<li>处理线程中断标志位。</li>
</ul>
<p>如果需要自定义一个锁 只需要复写tryAqcuire方法 根据具体逻辑来由子类控制原子变量是否成功获取锁</p>
<p>可重入与不可重入锁 其实就是tryAcquire这地方的逻辑不一样，不可重入锁 一旦cas失败直接就返回了<br>可重入锁内部会有一个持有锁的线程信息，并在cas失败的时候判断，如果线程信息是一致的 将原子变量+1就好。当然 解锁的时候还要对应-1 重入了几次 就要解锁几次，不然原子变量的值无法恢复为原始值。</p>
<h2 id="并发的底层实现："><a href="#并发的底层实现：" class="headerlink" title="并发的底层实现："></a>并发的底层实现：</h2><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><ol>
<li>禁止指令重拍（保证访问次序）</li>
<li>对线程强制可见（存强制刷新回主存，读强制从主存读取）</li>
</ol>
<p>class Singleton{<br>    private volatile static Singleton instance = null;</p>
<pre><code>private Singleton() {

}

public static Singleton getInstance() {
    if(instance == null) {
        synchronized (Singleton.class) {
            if(instance == null)
                instance = new Singleton();
        }
    }
    return instance;
}
</code></pre><p>}</p>
<p>这里为什么要使用volatile修饰instance？主要在于instance = new Singleton()这句，这并非是一个原子操作，事实上在JVM中这句话大概做了下面3件事情:</p>
<p>（1）给instance分配内存</p>
<p>（2）调用Singleton的构造函数来初始化成员变量</p>
<p>（3）将instance对象指向分配的内存空间（执行完这步instance就为非null了）。</p>
<p>但是在JVM的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在3执行完毕、2未执行之前，被线程二抢占了，这时instance已经是非null了（但却没有初始化），所以线程二会直接返回instance，然后使用，然后顺理成章地报错。</p>
<h4 id="1-可见性的保证："><a href="#1-可见性的保证：" class="headerlink" title="1.可见性的保证："></a>1.可见性的保证：</h4><p>算机在运行程序时，每条指令都是在CPU中执行的，在执行过程中势必会涉及到数据的读写。我们知道程序运行的数据是存储在主存中，这时就会有一个问题，读写主存中的数据没有CPU中执行指令的速度快，如果任何的交互都需要与主存打交道则会大大影响效率，所以就有了CPU高速缓存。CPU高速缓存为某个CPU独有，只与在该CPU运行的线程有关。</p>
<p>有了CPU高速缓存虽然解决了效率问题，但是它会带来一个新的问题：数据一致性。在程序运行中，会将运行所需要的数据复制一份到CPU高速缓存中，在进行运算时CPU不再也主存打交道，而是直接从高速缓存中读写数据，只有当运行结束后才会将数据刷新到主存中。</p>
<p>volatile 使用了缓存一致性协议：<br>缓存一致性协议（MESI协议）它确保每个缓存中使用的共享变量的副本是一致的。其核心思想如下：当某个CPU在写数据时，如果发现操作的变量是共享变量，则会通知其他CPU告知该变量的缓存行是无效的，就是在cpu缓存中写入一个缓存状态标记位：Invalid，因此其他CPU在读取该变量时，先读取标记位。发现其无效会重新从主存中加载数据（汇编代码会在指令前+LOCK字段。）</p>
<h4 id="2-访问一致性：（禁止指令重拍）"><a href="#2-访问一致性：（禁止指令重拍）" class="headerlink" title="2 访问一致性：（禁止指令重拍）"></a>2 访问一致性：（禁止指令重拍）</h4><p>lock 指令会保证 在lock指令前的指令 在lock前执行 在lock指令后的 在lock执行完执行。<br>lock汇编指令就是所谓的内存屏障。</p>
<h3 id="syncornized"><a href="#syncornized" class="headerlink" title="syncornized"></a>syncornized</h3><p>实现原理：<br>对当前对象和引用对象加锁：<br>syncornized(this)<br>syncornized(object.class)<br>system.out.println()<br>都是sync方法</p>
<p>反编译classa字节码 会发现在方法执行前有两个指令</p>
<p>monitorenter<br>monitorExist<br>如果修饰的是方法 在常量池中 方法对应的访问标记位 会添加一个ACC_SYNCHRONIZED访问标记<br>在执行该方法时，原理还是一样 操作monitor监视器对象来实现的。</p>
<p>Monitor 是线程私有的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联（对象头的MarkWord中的LockWord指向monitor的起始地址），同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。其结构如下<br><img src="/media/15337178518315.jpg" alt="-w173"><br>Owner：初始时为NULL表示当前没有任何线程拥有该monitor record，当线程成功拥有该锁后保存线程唯一标识，当锁被释放时又设置为NULL；<br>EntryQ:关联一个系统互斥锁（semaphore），阻塞所有试图锁住monitor record失败的线程。<br>RcThis:表示blocked或waiting在该monitor record上的所有线程的个数。<br>Nest:用来实现重入锁的计数。<br>HashCode:保存从对象头拷贝过来的HashCode值（可能还包含GC age）。<br>Candidate:用来避免不必要的阻塞或等待线程唤醒，因为每一次只有一个线程能够成功拥有锁，如果每次前一个释放锁的线程唤醒所有正在阻塞或等待的线程，会引起不必要的上下文切换（从阻塞到就绪然后因为竞争锁失败又被阻塞）从而导致性能严重下降。Candidate只有两种可能的值0表示没有需要唤醒的线程1表示要唤醒一个继任线程来竞争锁。 </p>
<h3 id="Unsafe对象"><a href="#Unsafe对象" class="headerlink" title="Unsafe对象"></a>Unsafe对象</h3><p>是java与native交互的中间者<br>Unsafe.park() 阻塞线程<br>Unsafe.unPark() 回复线程<br>Unsafe.compareAndSwapInt() CAS操作</p>
<h3 id="CAS原理："><a href="#CAS原理：" class="headerlink" title="CAS原理："></a>CAS原理：</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>CAS（比较与交换，Compare and swap） 是一种有名的无锁算法。CAS, CPU指令，在大多数处理器架构，包括IA32、Space中采用的都是CAS指令，CAS的语义是“我认为V的值应该为A，如果是，那么将V的值更新为B，否则不修改并告诉V的值实际为多少”，CAS是项 乐观锁 技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。 </p>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;   </span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>设置之前先比对 值是否与预期一致，一致就设置为预期值，不一致就重试直到一致为止。（注意 是一直重试，不是阻塞式，当cas失败 线程并不会被阻塞。）</p>
<p>因为cas的对象是被volatile关键子修饰的，它保证可见性和禁止指令重拍</p>
<h4 id="CAS缺点"><a href="#CAS缺点" class="headerlink" title="CAS缺点"></a>CAS缺点</h4><p> CAS虽然很高效的解决原子操作，但是CAS仍然存在三大问题。ABA问题，循环时间长开销大和只能保证一个共享变量的原子操作</p>
<ol>
<li>ABA问题。因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A。</li>
</ol>
<p>从Java1.5开始JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p>
<p>关于ABA问题参考文档: <a href="http://blog.hesey.net/2011/09/resolve-aba-by-atomicstampedreference.html" target="_blank" rel="noopener">http://blog.hesey.net/2011/09/resolve-aba-by-atomicstampedreference.html</a></p>
<ol start="2">
<li>循环时间长开销大。自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。</li>
</ol>
<ol start="3">
<li>只能保证一个共享变量的原子操作。当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量i＝2,j=a，合并一下ij=2a，然后用CAS来操作ij。从Java1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作。</li>
</ol>
<h3 id="SAQ模型"><a href="#SAQ模型" class="headerlink" title="SAQ模型"></a>SAQ模型</h3><h2 id="并发的实战问题"><a href="#并发的实战问题" class="headerlink" title="并发的实战问题"></a>并发的实战问题</h2><ol>
<li><p>如何让一段程序并发执行，并最终汇总结果<br>目前想到两种实现方式：</p>
<ol>
<li>采用fork/join实现方式<br>定义一个RecurisiveTask 这种Task继承Future，可以返回一个结果。<br>在该Task中定义一个阈值，复写compute()方法，在该方法里不超过阈值就不fork新线程，直接计算并返回 ，超过就将任务分割 再创建两个task 并调用fork方法。 调用join等待两个线程执行完将结果合并。伪代码如下：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     CountTask t = <span class="keyword">new</span> CountTask(<span class="number">1</span>,<span class="number">7</span>);</span><br><span class="line">     ForkJoinPool pool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">     Future&lt;Integer&gt; future = pool.submit(t);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CountTask</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">util</span>.<span class="title">concurrent</span>.<span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">int</span> threadhold = <span class="number">2</span>;</span><br><span class="line">     <span class="keyword">int</span> start;</span><br><span class="line">     <span class="keyword">int</span> end;</span><br><span class="line">    CountTask(<span class="keyword">int</span> start,<span class="keyword">int</span> end)&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span>((end -start)&gt;threadhold)&#123;</span><br><span class="line">             <span class="keyword">return</span> start +end;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="keyword">int</span> mid = (<span class="keyword">int</span>) ((end-start)/<span class="number">2</span>+start);</span><br><span class="line">             CountTask t1 = <span class="keyword">new</span> CountTask(start,mid);</span><br><span class="line">             CountTask t2 = <span class="keyword">new</span> CountTask(mid,end);</span><br><span class="line">             t1.fork();</span><br><span class="line">             t2.fork();</span><br><span class="line">             <span class="keyword">int</span> result1 = t1.join();</span><br><span class="line">             <span class="keyword">int</span> result2 = t2.join();</span><br><span class="line">             <span class="keyword">return</span> result1+result2;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>2.使用线程池 创建多个futureTask 并阻塞等待get()方法返回值。</p>
<ol start="2">
<li>如何合理的配置java线程池？如CPU密集型的任务，基本线程池应该配置多大？（少配置一些核心线程数，一般和cpu核心数一致， 为了使所有线程都能使用到cpu。）IO密集型的任务，基本线程池应该配置多大？（大部分线程都阻塞，所以要多配置核心线程数，一般使用cpu核心的两倍）用有界队列好还是无界队列好？（没有好坏之分，要分业务场景，一般配置有界队列。当有可能会出现爆发式增长的场景，使用无线队列，会不断增长直到内存耗尽。）任务非常多的时候，使用什么阻塞队列能获取最好的吞吐量？（使用非阻塞队列并结合cas操作以获得更好的吞吐量）</li>
<li>什么场景使用可重入锁：syncornized无法满足需要的情况，包括可中断，可超时，公平，非公平等高级特性时使用ReentranLock</li>
<li>什么场景下可以使用volatile替换synchronized？只需要可见性，不需要保证原子性时可以代替。volatile不适用那种新值依赖旧值的场景</li>
<li>CountDownLaunch 一般这么用：主任务等待n个子任务完成，创建一个CountDownLaunch(n)，子任务执行一次，CountDownLaunch.countDown()一次。主任务调用CountDownLaunch.await（）阻塞等待， 只有CountDownLaunch倒数完成，主任务才会继续执行。</li>
<li>使用阻塞队列实现生产者消费者模型：<br>伪代码</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LinkedBlockedQueue queue = <span class="keyword">new</span> LinkedBlockedQueue(<span class="number">10</span>);</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">producer</span> <span class="keyword">extends</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        Producer(BlockedQueue queue)&#123;</span><br><span class="line">            <span class="keyword">this</span>.queue = queue;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">                queue.put()</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (InteruptException e)&#123;&#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    clase Consumer extends Runnable&#123;</span><br><span class="line">        BlockedQueue queue;</span><br><span class="line">        Consumer(BlockedQueue queue)&#123;</span><br><span class="line">            <span class="keyword">this</span>.queue = queue;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            queue.take();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e)&#123;...&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Producer(queue)).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Consumer(queue)).start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Rxjava相关"><a href="#Rxjava相关" class="headerlink" title="Rxjava相关"></a>Rxjava相关</h2><ol>
<li>什么时候将订阅者和被订阅者关联起来的。<br>在subscribe()方法调用的时候。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等于是日程表，告诉订阅者要依次做什么</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OnSubscribe</span>(<span class="title">Subscriber</span> <span class="title">subscriber</span>)</span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">(subscriber)</span></span>&#123;</span><br><span class="line">    subscriber.onNext();</span><br><span class="line">    subscriber.onNext();</span><br><span class="line">    subscriber.onComplete();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observable</span></span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">public</span> Subscription <span class="title">subscribe</span><span class="params">(Subscriber subscriber)</span></span>&#123;</span><br><span class="line">    subscriber.onStart();<span class="comment">//先执行onStart() 做些准备工作 注意这个方法无法切换线程只能在事件发送端的线程执行。</span></span><br><span class="line">    <span class="keyword">if</span>（!subscriber instance of SafeSubscriber）&#123;</span><br><span class="line">        subscriber = <span class="keyword">new</span> SafeSubscriber(subscriber);<span class="comment">// 将传入的subscriber包装为safeSubscriber 为了保证onComplete onError 只被执行一次。</span></span><br><span class="line">    &#125;</span><br><span class="line">    onSubscribe.call(subscriber);<span class="comment">// 手动调了上面日程表的call方法。开始发送时间序列</span></span><br><span class="line">    <span class="keyword">return</span> subscriber;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>flatMap observerOn() subscribeOn() 切换线程的原理：lift()变换</li>
</ol>
<p>可以这么理解：<br><img src="/media/15320775444847.jpg" alt=""></p>
<p>每次lift() 都会创建一个新的Observable，因为链式调用的缘故，最终subscribe()将观察者和被观察着绑定关系的时候，都会绑定到最后一次lift()变换生成的新的Observable上，当调用subscribe()方法的时候，会先调用最终那个subscriber的onStart(),然后调用新Observable() 的OnObservable()方法，在新Observable（）中，它的onObservable被lift操作很机智的修改了，它首先创建了一个新的subsciber 这个subscriber持有原来那个订阅着的引用，然后它会调用上一级的那个obServable ,也就是调用lift()方法那个被观察者的call()方法，让自己创建的新的观察者来观察原来那被观察者发送的序列。 在这个心的被观察者中 它可以将原来观察者发送的消息处理一下，然后再发给最终的观察者。</p>
<p><img src="/media/15320810464695.jpg" alt=""></p>
<p>说的非常绕口，用一个形象的例子来说明一下：</p>
<p>建立简单的观察者被观察者并建立关联关系。</p>
<p>假设一个场景是部队操练表演。 我们是军官A(最原始的那个Observable)表演动作的流程由我们制定，基地里所有的士兵(Subscriber)都可以主动申请参加表演（订阅）。我们制定了一个动作流程表（OnObservable对象），表里我们制定好了 “先左转（onNext），然后右转（onNext），然后稍息（onNext），然后立正，最后敬礼，结束（onComplete）！”这套表演流程。这个表上有个签名栏，谁说要表演，就要在签名栏签上自己的大名。（OnSubscribe的 call方法 会传入一个观察者）。当然我们基地的士兵还是新人，只能执行一些比较简单的动作，复杂的动作不会做。</p>
<p>现在有一个士兵主动请缨要表演了(Observable.subscribe(new Subscriber())，军官会告诉他你可以先准备一下，（subscribe 方法会在里面先调用一下 Suscriber的onStart(),观察者可以先做些准备工作），然后士兵在流程表上签上了自己的名字(调用Onsubscribe.call(subscriber)，将观察者自己传入call（）方法中)。</p>
<p>要开始表演了，军官开始依次按照流程表的动作开始喊口号“士兵A,左转！”(被观察着会等subscribe方法调用之后才开始发送事件序列。)士兵A完成了一次左转动作。军官一个口号一个口号的喊完了，士兵也完整执行了所有的动作，并敬礼(onComplete()调用了)。</p>
<p>使用Lift变换</p>
<p>上面说过 士兵只可以执行简单的操作，复杂的操作还不会，如果我们要他做一个托马斯回旋，他不明白什么意思，但是你要是跟他说，就是先转一圈，再转一圈，他就明白了。</p>
<p>这时候可以这么做： 我们还是按照名单上的流程念，但是这时候名单变为了”先转体360度，再立正敬礼结束！”，士兵A不懂转体360是什么意思，这时候军官B 出来了，他有个手下士兵B 跟表演的士兵关系很好(士兵B 是 新构建的Subscriber，他存在在lift变换新创建出来的观察者内)。士兵b比较有文化，知道360转体就是“转一圈再转一圈的意思”。为了帮助士兵A顺利完成任务，他决定，将军官A的名单上名字改成自己的，现在士兵B现在直接面向军官A。他收到军官A的消息后 处理之后再告诉士兵A怎么做。</p>
<p>现在准备表演了。士兵A对军官B说 “我准备好了”，（Observable.subscribe()）,军官B 收到了(在lift方法创建的新的Observable的subscibe()方法中，先创建了一个新的Subscriber(old subscriber),然后调用上一个Observable中的OnSubscribe()方法，开始发送原始观察者中的事件，不过这些时间都被新的观察者接收了)，通知军官A开始喊口号（调用旧的OnSubscribe对象中的call方法，此时call传入的是新的观察者）。  </p>
<p>军官A 叫到“士兵B ， 转体360”，士兵B收到，翻译了一下“士兵A，转体360 就是 转一圈，再转一圈”的意思。<br> 士兵A 按照B 说的 ，顺利完成了这次表演。</p>
<h4 id="rxjava-的线程切换"><a href="#rxjava-的线程切换" class="headerlink" title="rxjava 的线程切换"></a>rxjava 的线程切换</h4><p>subscribeOn() 和 observeOn() 都做了线程切换的工作（图中的 “schedule…” 部位）。不同的是， subscribeOn() 的线程切换发生在 OnSubscribe 中，即在它通知上一级 OnSubscribe 时，这时事件还没有开始发送，因此 subscribeOn() 的线程控制可以从事件发出的开端就造成影响；而 observeOn() 的线程切换则发生在它内建的 Subscriber 中，即发生在它即将给下一级 Subscriber 发送事件时，因此 observeOn() 控制的是它后面的线程<br><img src="/media/15320818863358.jpg" alt=""><br>图中共有 5 处含有对事件的操作。由图中可以看出，①和②两处受第一个 subscribeOn() 影响，运行在红色线程；③和④处受第一个 observeOn() 的影响，运行在绿色线程；⑤处受第二个 onserveOn() 影响，运行在紫色线程；而第二个 subscribeOn() ，由于在通知过程中线程就被第一个 subscribeOn() 截断，因此对整个流程并没有任何影响。这里也就回答了前面的问题：当使用了多个 subscribeOn() 的时候，只有第一个 subscribeOn() 起作用。</p>
<h4 id="关键成员"><a href="#关键成员" class="headerlink" title="关键成员"></a>关键成员</h4><h5 id="Subscriber："><a href="#Subscriber：" class="headerlink" title="Subscriber："></a>Subscriber：</h5><p> 继承Observable 比它多了几个方法<br>onStart()<br>unSubscribe() 用来接触绑定 因为在 subscribe() 之后， Observable 会持有 Subscriber 的引用，这个引用如果不能及时被释放，将有内存泄露的风险</p>
<p>里面有个成员Producer 用来处理跟Observable的背压问题<br>toRequest 为请求数 Producer用的 用来请求数据源发送的数据数<br>可以调用setProducer() 为subscriber 设置Producer<br>调用request() 为其设置请求数</p>
<p>首先，如果在设置请求数时还没有初始化Producer，就进行累加保存。直到Producer被设置时，如果当前Subscriber未设置请求数且内部Subscriber不为空就把Producer赋值给内部的Subscriber，否则就会赋值给当前的Subscriber。要是当前Subscriber至今未设置请求数，就请求Long.MAX_VALUE数量的数据,多余部分就会忽略。 </p>
<h5 id="Scheduler-线程调度"><a href="#Scheduler-线程调度" class="headerlink" title="Scheduler 线程调度"></a>Scheduler 线程调度</h5><p>Scheduler 线程调度器  其中真正实现线程切换的是Worker </p>
<p>Worker实现了Subscription接口 所以Worker具有取消订阅的功能。</p>
<ul>
<li>当调用SubscriberOn(Scheduler.newThread())时，创建了一个新的OperatorSubscribeOn对象，并将我们的Scheduler作为参数传递了进。 OperatorSubscribeOn本身也是一个Observable，在它的OnSubScribe()的call方法中，其实可以猜到，它一定会通过某种手段，将我们原始的Observable的发送线程切换到目标线程。 那RxJava是怎么做的呢？</li>
</ul>
<ol>
<li>重写 OperatorSubscribeOn的onSubscribe()的call()方法</li>
<li>根据传入的Scheduler 对象 创建了一个worker对象</li>
<li>执行worker的schedule()方法 传入了一个Action()</li>
<li>worker 的schedule()方法会保证在目标线程中执行Action0的call()方法</li>
<li>在Action0的call()方法中 创建了一个新的Subscriber</li>
<li>这个新的Subscriber是原观察者和被观察者之间的中间人 </li>
<li>我们在worker线程中 将原被观察者与新的Subscriber订阅，此时原观察者会在Worker线程中开始发射数据</li>
<li>数据被我们的新Subscriber转发给原Suscriber</li>
<li>这样数据就转到我们自定义的线程中发送了 就完成SubscribeOn的目的</li>
</ol>
<h5 id="map-函数："><a href="#map-函数：" class="headerlink" title="map()函数："></a>map()函数：</h5><p>创建了一个新的Observable 返回<br><code>new OnSubscribeMap&lt;T, R&gt;(this, func)</code><br>当被订阅时，会调用新Observable的call方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(<span class="keyword">final</span> Subscriber&lt;? <span class="keyword">super</span> R&gt; o)</span> </span>&#123;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// 对传入的 Subscriber 进行再次封装成 MapSubscriber</span></span><br><span class="line">       <span class="comment">// 具体 Observable.map() 的逻辑是在 MapSubscriber 中</span></span><br><span class="line">       MapSubscriber&lt;T, R&gt; parent = <span class="keyword">new</span> MapSubscriber&lt;T, R&gt;(o, transformer); </span><br><span class="line">       o.add(parent); <span class="comment">// 加入到 SubscriptionList 中，为之后取消订阅</span></span><br><span class="line">       </span><br><span class="line">       <span class="comment">// Observable.interval() 返回的 Observable 进行订阅(关键点)</span></span><br><span class="line">       source.unsafeSubscribe(parent);</span><br></pre></td></tr></table></figure>
<p>创建了一个新的Subsriber对象。他会对原来发送的消息进行处理</p>
<p>看一下它的onNext方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        R result;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        result = mapper.call(t); <span class="comment">// 数据进行了变换</span></span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        actual.onNext(result); <span class="comment">// 往下流传</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h5 id="interval（）函数"><a href="#interval（）函数" class="headerlink" title="interval（）函数"></a>interval（）函数</h5><p>构建流程几乎类似 唯一的区别是新创建的Subscriber对象的call方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(<span class="keyword">final</span> Subscriber&lt;? <span class="keyword">super</span> Long&gt; child)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Worker worker = scheduler.createWorker();</span><br><span class="line">       child.add(worker);</span><br><span class="line">       worker.schedulePeriodically(<span class="keyword">new</span> Action0() &#123;</span><br><span class="line">           <span class="keyword">long</span> counter;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               ...</span><br><span class="line"></span><br><span class="line">               child.onNext(counter++);</span><br><span class="line"></span><br><span class="line">               ...</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;, initialDelay, period, unit);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h5 id="rxjava-如何保证串行发射的"><a href="#rxjava-如何保证串行发射的" class="headerlink" title="rxjava 如何保证串行发射的"></a>rxjava 如何保证串行发射的</h5><p>发送者循环 和队列漏</p>
<h4 id="高级方法：-backPressure-背压"><a href="#高级方法：-backPressure-背压" class="headerlink" title="高级方法： backPressure 背压"></a>高级方法： backPressure 背压</h4><p>所谓背压 其实就是在异步任务过程中，发送者的事件流太快，接收方来不及处理，告诉上游发送者降低时间发送速率的一种策略。<br>其实就是被观察者支不支持观察者通过调用request(int length) 来手动通知被观察者发送length数量的数据。</p>
<p>这个需要rxjava的被观察者支持才行，1.x版本的有部分是不支持的比如interval，timer等操作符创建的Observable。而类似range创建的Observable 是支持request这样的背压请求的。</p>
<p>不支持背压的Observable 该如何做到流程控制呢：</p>
<ol>
<li>抛弃部分数据</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这个操作符简单理解就是每隔<span class="number">200</span>ms发送里时间点最近那个事件，</span><br><span class="line">                <span class="comment">//其他的事件浪费掉</span></span><br><span class="line">                  .sample(<span class="number">200</span>,TimeUnit.MILLISECONDS)</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>缓存数据 处理不过来可以先缓存一部分 buffer（包装为list） window（包装为新Observable）操作符</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个操作符简单理解就是把100毫秒内的事件打包成list发送</span></span><br><span class="line">                .buffer(<span class="number">100</span>,TimeUnit.MILLISECONDS)</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>使用特殊的两个操作符，使其可以相应request请求</li>
</ol>
<ul>
<li>onBackpressurebuffer(int buffersize)：把observable发送出来的事件做缓存，当request方法被调用的时候，给下层流发送一个item(如果给这个缓存区设置了大小，那么超过了这个大小就会抛出异常)。</li>
<li>onBackpressureDrop：将observable发送的事件抛弃掉，直到subscriber再次调用request（n）方法的时候，就发送给它这之后的n个事件。</li>
</ul>
<blockquote>
<p>小细节： range 默认缓冲是16个事件。zip 128个事件缓冲区</p>
</blockquote>
<h5 id="rxjava2"><a href="#rxjava2" class="headerlink" title="rxjava2"></a>rxjava2</h5><p>将支持背压和不支持背压分开<br>不支持背压的：Observable/Observer<br>支持背压:Flowable/Subscriber<br>Flowable 可以通过range这样的操作符创建，也可以通过create方法创建，但是create需要手动制定背压规则 <code>BackpressureStrategy.BUFFER</code>。</p>
<blockquote>
<p>注意： 在观察者调用了request之后，会立刻回调到onNext，而不一定等onSubsbcribe方法走完<br>其实就是流程控制  为了解决发送端速率与接收端速率不一致的问题</p>
</blockquote>
<h5 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap()"></a>flatMap()</h5><p>在调用flatMap() 会传入一个Funx(){<br>},它会根据原始数据源创建一个新的Observable。 猜也能猜出来实现的原理是什么，还是用的lift()变换。比较适合用在需要嵌套请求的情形。比如 先获取token，然后携带token去请求数据，再返回一个新的Observable。</p>
<h5 id="线程池："><a href="#线程池：" class="headerlink" title="线程池："></a>线程池：</h5><p>当线程数小于核心线程数时，创建线程。<br>当线程数大于等于核心线程数，且任务队列未满时，将任务放入任务队列。<br>当线程数大于等于核心线程数，且任务队列已满<br>若线程数小于最大线程数，创建线程<br>若线程数等于最大线程数，抛出异常，拒绝任务</p>
<h2 id="Retrofit"><a href="#Retrofit" class="headerlink" title="Retrofit"></a>Retrofit</h2><h3 id="1-首先构造Retrofit对象"><a href="#1-首先构造Retrofit对象" class="headerlink" title="1. 首先构造Retrofit对象"></a>1. 首先构造Retrofit对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">    .baseUrl(<span class="string">"https://api.github.com/"</span>)</span><br><span class="line">    .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>
<p>使用的建造者模式。<br>在调用build()方法之后，已经传入了结果转换器还有baseUrl，此时会根据当前平台类型 Platform.get()来进行一系列初始化操作。 如果是android，就会创建一个Android类。</p>
<p>在Android类中，定义一个call转换器工厂。我们可以添加自己的call转换器。callAdapter其实是为了将OkHttp3的call对象进行我们需要的定制化包装。 同时会创建一个默认线程池MainThreadExecutor。</p>
<p>现在Retrofit对象构建完成，有了一个ExecutorCallAdapterFactory,这个factory的get()方法会返回一个CallAdapter。</p>
<h3 id="2-通过注解定义网络请求的Api，并且创建了请求服务的实体对象。"><a href="#2-通过注解定义网络请求的Api，并且创建了请求服务的实体对象。" class="headerlink" title="2. 通过注解定义网络请求的Api，并且创建了请求服务的实体对象。"></a>2. 通过注解定义网络请求的Api，并且创建了请求服务的实体对象。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GitHubService</span> </span>&#123;</span><br><span class="line">  <span class="meta">@GET</span>(<span class="string">"users/&#123;user&#125;/repos"</span>)</span><br><span class="line">  Call&lt;List&lt;Repo&gt;&gt; listRepos(<span class="meta">@Path</span>(<span class="string">"user"</span>) String user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GitHubService github = retrofit.create(GitHubService.class);</span><br></pre></td></tr></table></figure>
<p> 这里使用的是动态代理innovationHandler</p>
<p> create 方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; service)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 省略非关键代码</span></span><br><span class="line">  <span class="keyword">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(), </span><br><span class="line">      <span class="keyword">new</span> Class&lt;?&gt;[] &#123; service &#125;,</span><br><span class="line">      <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">        <span class="meta">@Override</span> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object... args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">          <span class="comment">// 先省略实现</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由我们传入的interface 动态代理出一个对象，代理对象就是service实体。它实现了请求api的接口。</p>
<h3 id="3-调用请求接口："><a href="#3-调用请求接口：" class="headerlink" title="3. 调用请求接口："></a>3. 调用请求接口：</h3><p>实际就干了这三件事：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ServiceMethod serviceMethod = loadServiceMethod(method);</span><br><span class="line">OkHttpCall okHttpCall = <span class="keyword">new</span> OkHttpCall&lt;&gt;(serviceMethod, args);</span><br><span class="line"><span class="keyword">return</span> serviceMethod.callAdapter.adapt(okHttpCall);</span><br></pre></td></tr></table></figure>
<h4 id="1-创建ServiceMethod"><a href="#1-创建ServiceMethod" class="headerlink" title="1. 创建ServiceMethod"></a>1. 创建ServiceMethod</h4><p>使用了单例模式+缓存的方式，每一个api接口都对应的一个单例ServiceMethod。注意，构建的时候传入的是class对象。<br>ServiceMethod的成员包括：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ServiceMethod(Builder&lt;T&gt; builder) &#123;</span><br><span class="line">  <span class="keyword">this</span>.callFactory = builder.retrofit.callFactory();</span><br><span class="line">  <span class="keyword">this</span>.callAdapter = builder.callAdapter;</span><br><span class="line">  <span class="keyword">this</span>.baseUrl = builder.retrofit.baseUrl();</span><br><span class="line">  <span class="keyword">this</span>.responseConverter = builder.responseConverter;</span><br><span class="line">  <span class="keyword">this</span>.httpMethod = builder.httpMethod;</span><br><span class="line">  <span class="keyword">this</span>.relativeUrl = builder.relativeUrl;</span><br><span class="line">  <span class="keyword">this</span>.headers = builder.headers;</span><br><span class="line">  <span class="keyword">this</span>.contentType = builder.contentType;</span><br><span class="line">  <span class="keyword">this</span>.hasBody = builder.hasBody;</span><br><span class="line">  <span class="keyword">this</span>.isFormEncoded = builder.isFormEncoded;</span><br><span class="line">  <span class="keyword">this</span>.isMultipart = builder.isMultipart;</span><br><span class="line">  <span class="keyword">this</span>.parameterHandlers = builder.parameterHandlers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>callFactory：创建网络请求的客户端，不指定默认为okhttp3.okHttpClient<br>也可以在创建时指定。<br>callAdapter： 负责吧okhttp3的call<br>适配为我们的retrofit的call 也就是默认的ExecutorCallBackCall<br>responseConverter: 将返回结果转化为我们想要的javabean<br>parameterHandlers: 负责解析api定义时的参数，并在构造http请求的时候填入参数。</p>
<h4 id="2-创建okHttpCall"><a href="#2-创建okHttpCall" class="headerlink" title="2. 创建okHttpCall"></a>2. 创建okHttpCall</h4><p> 同步 execute<br> 异步 enqueue（callBack<t> callback）</t></p>
<h5 id="a-创建okhttp3-call"><a href="#a-创建okhttp3-call" class="headerlink" title="a 创建okhttp3.call"></a>a 创建okhttp3.call</h5><p>由parameterHandlers 构建请求体request<br>由callFactory.newCall(request)构建okhttp3请求（当然也可以由过时的HttpUrlConnection构建）</p>
<h5 id="b-同步请求网络并转换结果"><a href="#b-同步请求网络并转换结果" class="headerlink" title="b 同步请求网络并转换结果"></a>b 同步请求网络并转换结果</h5><p>okhttp3.Call.execute()来同步执行网络请求<br>将结果用responseConventer转换为javabean</p>
<h5 id="c-异步请求"><a href="#c-异步请求" class="headerlink" title="c 异步请求"></a>c 异步请求</h5><p>okhttp3.call.enqueue(callback<t> callback)来异步执行网络请求<br>回调callback接口</t></p>
<h4 id="3-callAdapter-将okhttpCall-转换为我们想要的call类型"><a href="#3-callAdapter-将okhttpCall-转换为我们想要的call类型" class="headerlink" title="3. callAdapter 将okhttpCall 转换为我们想要的call类型"></a>3. callAdapter 将okhttpCall 转换为我们想要的call类型</h4><p>比如我们常用的RxJavaCallAdapter 会吧请求转化为一个Observable</p>
<p>看一下RxjavaCallAdapter</p>
<p>会将OkhttpCall 适配为Observable</p>
<ol>
<li>根据同步还是异步(默认是异步请求 isAs = false) 创建了两个OnSubscribe</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OnSubscribe&lt;Response&lt;R&gt;&gt; callFunc = isAsync</span><br><span class="line">      ? <span class="keyword">new</span> CallEnqueueOnSubscribe&lt;&gt;(call)</span><br><span class="line">      : <span class="keyword">new</span> CallExecuteOnSubscribe&lt;&gt;(call);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>以这个OnSubscribe对象来构建Observable</li>
<li>当被订阅时，Onsubscribe对象开始发送事件，call方法会被调用</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    Response&lt;T&gt; response;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      response = call.execute();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      Exceptions.throwIfFatal(t);</span><br><span class="line">      arbiter.emitError(t);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    arbiter.emitResponse(response);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>里面阻塞调用了okhttp3.call 的execute()方法获取网络请求结果</p>
<ol start="4">
<li><h3 id="开始网路请求"><a href="#开始网路请求" class="headerlink" title="开始网路请求"></a>开始网路请求</h3><p>调用了请求接口，经过转换器 将call转换为了我们要的被观察者。<br>当调用了subscribe()方法的时候，开始触发网络请求</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Observable.subscribe//触发 API 调用的执行；</span><br><span class="line">CallOnSubscribe(call)，//clone call，创建并设置 producer；</span><br><span class="line">RequestArbiter(request)//subscriber 被设置了 producer 之后最终调用 request，在 request 中发起请求，把结果发给下游；</span><br><span class="line">OperatorMapResponseToBodyOrError$1(onNext)//把 response 的 body 发给下游；</span><br><span class="line">最终就到了我们 subscribe 时传入的回调里面了；</span><br></pre></td></tr></table></figure>
<p><img src="/media/15320873913342.png" alt=""></p>
<h3 id="retrofit里丰富的设计模式："><a href="#retrofit里丰富的设计模式：" class="headerlink" title="retrofit里丰富的设计模式："></a>retrofit里丰富的设计模式：</h3><ol>
<li>建造者模式:  在创建Retrofit客户端的时候，通过builder()构建者模式将需要的一些适配器创建并赋值。</li>
<li>适配器模式： retrofit在Android版本上默认是用okhttp3来请求网络的，okhttp3的网络请求okhttp3.call被转换为OkHttpCall，这个call.enqueue 是在子线程调用，callback的回调也是在子线程，为了在主线程操作这些回调我们势必要Handler来切换线程，但是这个okHttpCall 肯定是不适用java1.8 或者ios 等平台的，而且我们如果想使用RXjava的流式调用，okhttpCall肯定还要做进一步的适配，为了隔离网络请求接口的平台不一致性，retrofit将一些共有属性抽取出来，通过我们自定义的CallAdapter 隔离各种平台和网络请求框架的具体实现差异，适配成我们想要的方式。</li>
<li>静态代理：默认的CallAdapter是AndroidCallAdapter，为了把okhttp3.call 封装为子线程请求，主线程回调，使用了静态代理方式 ExecutorCallbackEnqueue() 将okhttp3.call 代理为OkHttpCall。</li>
<li>动态代理： 在我们调用对应的网络请求接口的时候，使用了动态代理，在调用方法的地方，动态的获取注解信息，拼装为完整的请求体，同时将返回的数据适通过我们自定义的转换器，比如讲xml 或者json转为javabean，同时将请求call 通过callAdapter适配为我们想要的格式，比如如果是RxJavaAdapter 就适配为Observable<t> 如果不定义，就适配为OkhttpCall。 </t></li>
</ol>
<h2 id="OkHttp3"><a href="#OkHttp3" class="headerlink" title="OkHttp3"></a>OkHttp3</h2><p><img src="/media/15324382430319.png" alt="-w500"></p>
<h3 id="1-创建HttpClient对象"><a href="#1-创建HttpClient对象" class="headerlink" title="1. 创建HttpClient对象"></a>1. 创建HttpClient对象</h3><p>OkHttpClient client = new OkHttpClient(){<br>new Builder();}</p>
<h3 id="2-Builder里做了什么"><a href="#2-Builder里做了什么" class="headerlink" title="2. Builder里做了什么"></a>2. Builder里做了什么</h3><p>1 构造了Dispacher<br>2 设置了链接超时时间和读写超时时间</p>
<h3 id="3-创建request"><a href="#3-创建request" class="headerlink" title="3. 创建request"></a>3. 创建request</h3><pre><code>通过url method body header 构建Request对象
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">      .url(url)</span><br><span class="line">      .build();</span><br></pre></td></tr></table></figure>
<h3 id="创建RealCall对象"><a href="#创建RealCall对象" class="headerlink" title="创建RealCall对象"></a>创建RealCall对象</h3><p>client.newCall(request)<br>根据request构建一个RealCall对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> RealCall(<span class="keyword">this</span>, request);</span><br></pre></td></tr></table></figure>
<h3 id="同步请求网络-call-execute"><a href="#同步请求网络-call-execute" class="headerlink" title="同步请求网络 call.execute()"></a>同步请求网络 call.execute()</h3><p>call.execute()<br>其实调用的RealCall.execute()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already Executed"</span>);  <span class="comment">// (1)</span></span><br><span class="line">    executed = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    client.dispatcher().executed(<span class="keyword">this</span>);                                 <span class="comment">// (2)</span></span><br><span class="line">    Response result = getResponseWithInterceptorChain();                <span class="comment">// (3)</span></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    client.dispatcher().finished(<span class="keyword">this</span>);                                 <span class="comment">// (4)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先判断call 是否执行过，每个call、只能执行一次<br>其次 会调用dispatcher.executed(this); 这个dispatcher是个请求分发器，<br>同步调用的时候没起到什么特殊作用，只是通知一下 请求开始了（executed），请求结束了（finished），<br>它更多的是用在异步调用的时候，处理多个请求的异步调度。</p>
<p>然后getResponseWithInterceptorChain（） 是真正开始网路请求并处理结果的方法</p>
<p>最后 调用dispatcher 通知其已经完成请求。</p>
<p>Dispatcher是网络请求任务的分发器。 当决定异步请求时，Dispatcher会调用enquene(new AysncCall()) 将网络请求任务添加到请求队列中。</p>
<p>Dispatcher中使用了一个核心线程为0 超时时间为60s的无上限线程池。<br>任务队列是一个FIFO的阻塞队列来实现。<br>在Dispatcher中有三个链表，</p>
<blockquote>
<p>readyAsyncCalls记录等待执行的异步请求。<br>  runningAsyncCalls记录正在执行的异步请求<br>  RunningSyncCalls记录正在执行的同步请求。</p>
</blockquote>
<p>dispatcher的线程池配置 只有一个核心线程，而且任务队列长度只有0，那就是每次有请求，就先看有无空闲线程，有就交给线程执行，否则创建新的线程。</p>
<p>当执行call.enqueue()方法准备发起网路请求的时候，<br>首先判断 runningAsyncCalls队列中是不是没有超过最大请求数64 且同一个请Host下的请求不超过5，如果满足，加入runningAsyncCalls队列，否则加入readyAsyncCalls队列。</p>
<p>依次从runningAsyncCalls队列表头取出call任务，加入线程池执行。<br>通过getResponseFromInterceptorChain()去发起网络请求并获取response，这个方法被trycatch包裹，成功就回调callback的onResponse，注意此时并没有切换线程，所以okhttp的回调是在线程池中执行的。</p>
<p>如果失败，进入catch块，并回调onFailure();</p>
<p>在finally块中，移除当前的runningCalls，并扫描runningCalls链表，取出下一个等待执行的call加入线程池执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">syncornized(<span class="keyword">this</span>)&#123;</span><br><span class="line">    promoteCalls();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到 不管是同步 还是异步，都是调用ResponseWithIntercepotionChain()去真正开始网络请求并获取response </p>
<h3 id="getResponseWithInterceptorChain-请求网并处理数据"><a href="#getResponseWithInterceptorChain-请求网并处理数据" class="headerlink" title="getResponseWithInterceptorChain 请求网并处理数据"></a>getResponseWithInterceptorChain 请求网并处理数据</h3><p>责任链模式 每个拦截器被串联在一起 各自处理各自能处理的工作，并将工作流向下传递。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Response <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="comment">// Build a full stack of interceptors.</span></span><br><span class="line">  List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  interceptors.addAll(client.interceptors());</span><br><span class="line">  interceptors.add(retryAndFollowUpInterceptor);</span><br><span class="line">  interceptors.add(<span class="keyword">new</span> BridgeInterceptor(client.cookieJar()));</span><br><span class="line">  interceptors.add(<span class="keyword">new</span> CacheInterceptor(client.internalCache()));</span><br><span class="line">  interceptors.add(<span class="keyword">new</span> ConnectInterceptor(client));</span><br><span class="line">  <span class="keyword">if</span> (!retryAndFollowUpInterceptor.isForWebSocket()) &#123;</span><br><span class="line">    interceptors.addAll(client.networkInterceptors());</span><br><span class="line">  &#125;</span><br><span class="line">  interceptors.add(<span class="keyword">new</span> CallServerInterceptor(</span><br><span class="line">      retryAndFollowUpInterceptor.isForWebSocket()));</span><br><span class="line"></span><br><span class="line">  Interceptor.Chain chain = <span class="keyword">new</span> RealInterceptorChain(</span><br><span class="line">      interceptors, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>, originalRequest);</span><br><span class="line">  <span class="keyword">return</span> chain.proceed(originalRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它把实际的网络请求、缓存、透明压缩等功能都统一了起来，每一个功能都只是一个 Interceptor，它们再连接成一个 Interceptor.Chain，环环相扣，最终圆满完成一次网络请求。</p>
<p><img src="/media/15324469306001.png" alt="-w350"></p>
<p>这个责任链机制非常巧妙</p>
<p>先是定义了一串的Interceptor，每个Interceptor处理特定任务。Interceptor是一个接口 看代码就明白了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">    <span class="function">Response <span class="title">intercept</span><span class="params">(Interceptor.Chain var1)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Chain</span> </span>&#123;</span><br><span class="line">        <span class="function">Request <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function">Response <span class="title">proceed</span><span class="params">(Request var1)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Nullable</span></span><br><span class="line">        <span class="function">Connection <span class="title">connection</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function">Call <span class="title">call</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">connectTimeoutMillis</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        Interceptor.<span class="function">Chain <span class="title">withConnectTimeout</span><span class="params">(<span class="keyword">int</span> var1, TimeUnit var2)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">readTimeoutMillis</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        Interceptor.<span class="function">Chain <span class="title">withReadTimeout</span><span class="params">(<span class="keyword">int</span> var1, TimeUnit var2)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">writeTimeoutMillis</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        Interceptor.<span class="function">Chain <span class="title">withWriteTimeout</span><span class="params">(<span class="keyword">int</span> var1, TimeUnit var2)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>chain里提供了我们创建一个网络请求所需要的所有方法。它的唯一实现类是Realchain<br>还记得上面我们开始获取response的方法吗：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Interceptor.Chain chain = <span class="keyword">new</span> RealInterceptorChain(</span><br><span class="line">      interceptors, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>, originalRequest);</span><br><span class="line">chain&gt;processed(originRequest)</span><br></pre></td></tr></table></figure>
<p>这里我们构造chain的时候，传入的初始index是0。<br>当调用到processed方法时，会创建一个新的chain并将index+1 取出传入的interceptor列表的第一项。将chain传递给它处理。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">proceed</span><span class="params">(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec, RealConnection connection)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">this</span>.index &gt;= <span class="keyword">this</span>.interceptors.size()) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           ++<span class="keyword">this</span>.calls;</span><br><span class="line">           <span class="keyword">if</span> (<span class="keyword">this</span>.httpCodec != <span class="keyword">null</span> &amp;&amp; !<span class="keyword">this</span>.connection.supportsUrl(request.url())) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"network interceptor "</span> + <span class="keyword">this</span>.interceptors.get(<span class="keyword">this</span>.index - <span class="number">1</span>) + <span class="string">" must retain the same host and port"</span>);</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.httpCodec != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.calls &gt; <span class="number">1</span>) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"network interceptor "</span> + <span class="keyword">this</span>.interceptors.get(<span class="keyword">this</span>.index - <span class="number">1</span>) + <span class="string">" must call proceed() exactly once"</span>);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               RealInterceptorChain next = <span class="keyword">new</span> RealInterceptorChain(<span class="keyword">this</span>.interceptors, streamAllocation, httpCodec, connection, <span class="keyword">this</span>.index + <span class="number">1</span>, request, <span class="keyword">this</span>.call, <span class="keyword">this</span>.eventListener, <span class="keyword">this</span>.connectTimeout, <span class="keyword">this</span>.readTimeout, <span class="keyword">this</span>.writeTimeout);</span><br><span class="line">               Interceptor interceptor = (Interceptor)<span class="keyword">this</span>.interceptors.get(<span class="keyword">this</span>.index);</span><br><span class="line">               Response response = interceptor.intercept(next);</span><br><span class="line">               <span class="keyword">if</span> (httpCodec != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.index + <span class="number">1</span> &lt; <span class="keyword">this</span>.interceptors.size() &amp;&amp; next.calls != <span class="number">1</span>) &#123;</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"network interceptor "</span> + interceptor + <span class="string">" must call proceed() exactly once"</span>);</span><br><span class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (response == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"interceptor "</span> + interceptor + <span class="string">" returned null"</span>);</span><br><span class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (response.body() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"interceptor "</span> + interceptor + <span class="string">" returned a response with no body"</span>);</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="keyword">return</span> response;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>在interceptor的intercept方法中，又会调用这个chain的processed方法</p>
<p>processed方法又会以旧参数和index+1 再创建新chain。并取出interceptpor链表的第二项来处理chain。<br>一次类推直到链表中没有新的interceptor为止。</p>
<p>这样就串联成了一个调用链。</p>
<p>最终返回response给我们。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="构造OkHttpClient-并初始化分发器"><a href="#构造OkHttpClient-并初始化分发器" class="headerlink" title="构造OkHttpClient 并初始化分发器"></a>构造OkHttpClient 并初始化分发器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient()&#123;</span><br><span class="line">    Dispatcher dispatcher = <span class="keyword">new</span> Dispatcher();构建dispatcher分发器 </span><br><span class="line">    Long mConnectionTimeout = CONNECTION_TIME_OUT 设置链接超时时间之类的</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="构造Request对象"><a href="#构造Request对象" class="headerlink" title="构造Request对象"></a>构造Request对象</h4><p>使用建造者模式 构建一个Request对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Request request = Requset.Builder().url(<span class="string">"https://baidu.com"</span>).build();</span><br></pre></td></tr></table></figure>
<h4 id="分发器决定同步还是异步执行"><a href="#分发器决定同步还是异步执行" class="headerlink" title="分发器决定同步还是异步执行"></a>分发器决定同步还是异步执行</h4><ol>
<li>同步</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">client.newCall(request).execute();</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>异步</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">client.newCall(request).enqueue(<span class="keyword">new</span> Callback&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call call,IoException e)</span></span>&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call call,Response response)</span></span>&#123;&#125;)</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<p>可以看到 首先 构建了一个请求RealCall对象。<br>通过RealCall的execute() 和enqueue(callback)分别实现了同步请求和异步请求。</p>
<p>同步请求和异步请求是由dispatcher实现的。<br>分发器分发见上文。最终是通过<br>getResponseFromInterceptorChain(Request,0,0);来实现网络请求和获取response的。</p>
<h4 id="自定义拦截器请求网络并获取response"><a href="#自定义拦截器请求网络并获取response" class="headerlink" title="自定义拦截器请求网络并获取response"></a>自定义拦截器请求网络并获取response</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Response <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="comment">// Build a full stack of interceptors.</span></span><br><span class="line">  List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  interceptors.addAll(client.interceptors()); </span><br><span class="line">  interceptors.add(retryAndFollowUpInterceptor);</span><br><span class="line">  interceptors.add(<span class="keyword">new</span> BridgeInterceptor(client.cookieJar()));</span><br><span class="line">  interceptors.add(<span class="keyword">new</span> CacheInterceptor(client.internalCache()));</span><br><span class="line">  interceptors.add(<span class="keyword">new</span> ConnectInterceptor(client));</span><br><span class="line">  <span class="keyword">if</span> (!retryAndFollowUpInterceptor.isForWebSocket()) &#123;</span><br><span class="line">    interceptors.addAll(client.networkInterceptors());</span><br><span class="line">  &#125;</span><br><span class="line">  interceptors.add(<span class="keyword">new</span> CallServerInterceptor(</span><br><span class="line">      retryAndFollowUpInterceptor.isForWebSocket()));</span><br><span class="line"></span><br><span class="line">  Interceptor.Chain chain = <span class="keyword">new</span> RealInterceptorChain(</span><br><span class="line">      interceptors, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>, originalRequest);</span><br><span class="line">  <span class="keyword">return</span> chain.proceed(originalRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>先把我们创建client的时候，自定义的拦截器加载到拦截器列表中</li>
<li>添加各种必要拦截器</li>
<li>构建RealInterceptorChain()</li>
<li>通过责任链机制，链式处理请求并返回response</li>
</ol>
<h4 id="Interceptors"><a href="#Interceptors" class="headerlink" title="Interceptors"></a>Interceptors</h4><h4 id="HttpCodec"><a href="#HttpCodec" class="headerlink" title="HttpCodec"></a>HttpCodec</h4><p>对http请求过程中的数据流进行读写操作</p>
<h5 id="StreamAllocation"><a href="#StreamAllocation" class="headerlink" title="StreamAllocation"></a>StreamAllocation</h5><p>newStream 创建httpCodec<br>realStream.connection 开启socket链接，返回Connection对象。</p>
<blockquote>
<p>注: HttpCodec  用来读写网络请求的输入输出流、<br>   RealCall  代表一次网络请求 对一次网络请求的封装 其实就是请求了一个特定的api<br>   StreamAllocation 一次真实网络请求的开销 与RealCall对应 要知道 我们访问一个特定api的时候 可能会出现域名重定向，一次请求会发生多次跳转，每次跳转都对应着一次真实的网络请求的开销。 StreamAllocation就是描述这个开销的。<br>  Connection 对应一个连接。 我们知道http请求 是基于TCP协议的，TCP是面向连接的协议，就是每次请求网络 都必须先建立连接，而建立连接需要三次握手，如果同时请求次数很多，每次都要先建立连接 再去请求网络 会造成很大的网罗开销。 为了复用连接，在Http1.1 协议中 默认打开了keep-alive，这样服务器收到这种请求之后，返回完数据并不会直接关闭连接，而是会等待一段时间，在此之间的请求 可以直接复用这个连接，就达到请求复用的效果。但是http1.1 对同时请求的数量有个最大值限制，超过这个限制的请求会被阻塞。<br>而且 http1.1 并不会对请求首部（请求头）进行压缩，有时候带有多个cookie的情况下 头的大小甚至可以达到kb级，流量开销还是挺大的。 为了解决多路复用和节省流量 出现了新的http2.0协议。<br>Http2.0的主要目标：<br>降低延迟，客户端的单连接单请求，server的FIFO响应队列都是延迟的大头。http最初设计都是客户端发起请求，然后server响应，server无法主动push内容到客户端。压缩http header，http1.x的header越来越膨胀，cookie和user agent很容易让header的size增至1kb大小，甚至更多。而且由于http的无状态特性，header必须每次request都重复携带，很浪费流量。</p>
</blockquote>
<p>Okhttp使用链接池  实现了链接的多路复用机制。</p>
<h5 id="RetryAndFollowUpInterceptor"><a href="#RetryAndFollowUpInterceptor" class="headerlink" title="RetryAndFollowUpInterceptor"></a>RetryAndFollowUpInterceptor</h5><p>获取ConnectPool 连接池 连接池内使用一个双端队列描述链接Deque<realconnection>，同时维护了一个路由黑名单表。<br>每个链接 是一个RealConnect对象，RealConnection对象是对socket链接的封装。<br>链接池主要提供了 </realconnection></p>
<ol>
<li>提供一个可复用的链接</li>
<li>将链接加入连接池</li>
<li>清除无用链接</li>
<li>清除重复链接<br>等方法。</li>
</ol>
<p>在重定向拦截器中，我们将请求url封装为一个Address对象。Address对象描述的是服务器地址，将这个Address对象作为参数 构造StreamAllocation对象。</p>
<p>要记住，StreamAllocation代表一次网络请求开销，是一次call的数据流动，他可以复用一个已经建立的链接。</p>
<p>重定向拦截器 构造了一个StreamAllocation，但是并没有开始网络请求。主要是为了创建一个StreamAllocation供后面的拦截器使用。<br>在创建了StreamAllocation之后，调用了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((RealInterceptChain)chain).proceed(request,streamAllocation,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure></p>
<p>将request和streamAllocation传递给下一个Inrerceptor去处理了。</p>
<p>后面的拦截器会判断缓存策略，发起网络请求，获取response。</p>
<p>获取response之后，重定向拦截器判断是否需要重新请求或者重定向到其他地址，最大重定向层级30</p>
<h5 id="BridgeInterceptor"><a href="#BridgeInterceptor" class="headerlink" title="BridgeInterceptor"></a>BridgeInterceptor</h5><p>重定向拦截器下面的拦截器。<br>请求会被发送到BridgeInterceptor。这个拦截器<br>主要是为了完善请求头，如果调用者没有写，就自动帮我们加上对应的Content-Type Content-Length<br>User-Agent之类的</p>
<h5 id="CacheInterceptor"><a href="#CacheInterceptor" class="headerlink" title="CacheInterceptor"></a>CacheInterceptor</h5><p>由桥接拦截器传递过来。主要是实现相应的缓存策略。</p>
<ol>
<li>根据request的请求头 判断是强制缓存还是对比缓存<br>如果带有max-age = *** 表示使用的是强制缓存<br>如果带有的if-none-match(etag)或者 if-modify-since(last-modify)表示是对比缓存</li>
<li>根据缓存策略 创建 networkRequest 和 cachedResponse对象。</li>
<li><p>如果是强制缓存，networkRequest就为null 此时分两种情况： </p>
<p>a. 无缓存可用 cachedResponse为null  直接构建新的response 返回码是504 报错<br>b. 有缓存 直接返回cacheResponse</p>
</li>
<li><p>如果是非强制缓存 将request交给下游的interceptor去处理 请求网络并获取服务器的返回结果，由服务器的返回结果来判断 是使用缓存 还是再次请求网络从服务器中获取</p>
</li>
<li>将服务器返回的数据 赋值给networkResponse 判断返回码是否为304 </li>
<li>如果是304  使用cachedResponse  获取缓存的response并返回</li>
<li>否则 再次请求网络 获取数据 </li>
<li>将完整的response 缓存在cache文件中 返回此次的response。</li>
<li>cacheWritingResponse（）写入缓存 通过Okio以及DiskLruCache来实现</li>
<li>删除无效缓存。</li>
</ol>
<h4 id="connectInterceptor"><a href="#connectInterceptor" class="headerlink" title="connectInterceptor"></a>connectInterceptor</h4><p>由缓存拦截器判断之后，如果缓存失效，则将重新请求网络，此时会将request往下传递给connectInterceptor。</p>
<p>链接拦截器只完成了从连接池中查找是否有可以复用的链接，如果没有 就创建链接并添加到连接池的作用。</p>
<p>查找可用链接的真正实现是有上文的重定向拦截器创建的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RealConnection connection = streamAllocation.findConnection(connectionPool,address,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>
<p>StreamAllocation.findConnection()，使用address来从连接池中获取一个可复用的链接，如果没有就构造一个新的并加入到链接池中，</p>
<p>connection描述了请求的地址</p>
<ol>
<li>Internal.getInstance.get(connectionPool,address)直接根据地址匹配，如果address跟连接池中的adderss完美匹配，直接返回这个链接对象。</li>
<li>地址不匹配，查看有无设置过路由，有的话再尝试从链接池中获取链接对象 Internal.getInstance.get(connectionPool, address,route)。</li>
<li>如果还没有找到可以复用的链接，就直接创建一个新的链接。并将链接的stream计数器+1，添加到连接池。 这里涉及到连接池如何判断链接是否失效的问题。因为每个StreamAllication对应链接上的一个数据流动，如果链接上没有数据流了，那表明当前链接是闲置状态，当闲置超过5分钟，就会被回收。</li>
<li>查看链接池中有无多余重复链接result.isMultiplexed()，有就删除Internal.instance.deduplicate。</li>
</ol>
<p>connectionInterceptor 获取可用的链接之后，往下传递给CallServerInterceptor</p>
<h5 id="CallServerInterceptor"><a href="#CallServerInterceptor" class="headerlink" title="CallServerInterceptor"></a>CallServerInterceptor</h5><p>这是一个真正发起网络请求的拦截器。所以他也是在拦截器链表的对尾。</p>
<p>建立连接 ConnectInterceptor<br>找到一个可用的 RealConnection，再利用 RealConnection 的输入输出（BufferedSource 和 BufferedSink）创建 HttpCodec 对象，供后续步骤使用。这个HttpCodec 其实使用Okio包 对 Socket 的读写操作进行封装。是对http的抽象。</p>
<p>发送和接收数据：CallServerInterceptor<br>使用上面创建的httpcodec来发起和接收数据：<br>向服务器发送 request header；<br>如果有 request body，就向服务器发送；<br>读取 response header，先构造一个 Response 对象；<br>如果有 response body，就在 3 的基础上加上 body 构造一个新的 Response 对象；</p>
<h4 id="okhttp-使用websocket"><a href="#okhttp-使用websocket" class="headerlink" title="okhttp 使用websocket"></a>okhttp 使用websocket</h4><p>websocket 是基于tcp协议基础上的，和http协议类似，是一种新的网络通信协议，是全双工信道，就是服务器可以推数据给客户端，客户端可以发数据给服务器。<br>websocket是按照数据帧来传递数据的</p>
<p><img src="/media/15337076010017.jpg" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">OkhttpClinet client = <span class="keyword">new</span> OkhttpClient();</span><br><span class="line">Request request = Request.builder.url(<span class="string">"ws://fdedee"</span>).build;</span><br><span class="line">client.newWebsocket(request,<span class="keyword">new</span> WebsocketListener&#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="apk前签名机制："><a href="#apk前签名机制：" class="headerlink" title="apk前签名机制："></a>apk前签名机制：</h2><h3 id="apk签名"><a href="#apk签名" class="headerlink" title="apk签名"></a>apk签名</h3><p>签名之后 会生成三个文件<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MANIFEST.MF</span><br><span class="line">CERT.SF</span><br><span class="line">CERT.RSA</span><br></pre></td></tr></table></figure></p>
<h4 id="1-MAINFEST-MF"><a href="#1-MAINFEST-MF" class="headerlink" title="1.MAINFEST.MF"></a>1.MAINFEST.MF</h4><p>逐一遍历里面apk项目中的所有条目，如果是目录就跳过，如果是一个文件，就用SHA1（或者SHA256）消息摘要算法提取出该文件的摘要然后进行BASE64编码后，作为“SHA1-Digest”属性的值写入到MANIFEST.MF文件中的一个块中。该块有一个“Name”属性，其值就是该文件在apk包中的路径。<br><img src="/media/15322438162973.jpg" alt=""></p>
<h4 id="2-CERT-SF"><a href="#2-CERT-SF" class="headerlink" title="2. CERT.SF"></a>2. CERT.SF</h4><ol>
<li>计算上面MANIFEST.MF文件的整体SHA1值，再经过BASE64编码后，记录在CERT.SF主属性块（在文件头上）的“SHA1-Digest-Manifest”属性值值下</li>
</ol>
<p>【校验上面文件整体的完整性】</p>
<ol start="2">
<li>逐条计算MANIFEST.MF文件中每一个块的SHA1，并经过BASE64编码后，记录在CERT.SF中的同名块中，属性的名字是“SHA1-Digest<br>【校验上面文件每个条目的完整性】</li>
</ol>
<p>主要是为了教研上面生成的CERT.SF 文件的合法性</p>
<h4 id="3-CERT-RSA"><a href="#3-CERT-RSA" class="headerlink" title="3. CERT.RSA"></a>3. CERT.RSA</h4><p>这里会把之前生成的 CERT.SF文件， 用私钥计算出签名（算出cret.sf 的sha1值，然后用私钥进行非对称加密）, 然后将签名以及包含公钥信息的数字证书一同写入  CERT.RSA  中保存。CERT.RSA是一个满足PKCS7格式的文件。</p>
<p>首先，如果你改变了apk包中的任何文件，那么在apk安装校验时，改变后的文件摘要信息与MANIFEST.MF的检验信息不同，于是验证失败，程序就不能成功安装。<br>其次，如果你对更改的过的文件相应的算出新的摘要值，然后更改MANIFEST.MF文件里面对应的属性值，那么必定与CERT.SF文件中算出的摘要值不一样，照样验证失败。<br>最后，如果你还不死心，继续计算MANIFEST.MF的摘要值，相应的更改CERT.SF里面的值，那么数字签名值必定与CERT.RSA文件中记录的不一样，还是失败。<br>那么能不能继续伪造数字签名呢？不可能，因为没有数字证书对应的私钥。<br>所以，如果要重新打包后的应用程序能再Android设备上安装，必须对其进行重签名。</p>
<h3 id="安装验证"><a href="#安装验证" class="headerlink" title="安装验证"></a>安装验证</h3><p>主要看PackageParser.java 负责解析apk文件的签名信息</p>
<ol>
<li><p>验证Apk中的每个文件的算法(数据摘要+Base64编码)和MANIFEST.MF文件中的对应属性块内容是否配对<br>依次遍历每个文件，算出其数据指纹（会先读取MAINFEST.MF文件中的头字段 这里是”SHA1-Digest“），根据对应的加密方法使用对应的加密算法算出数据指纹，并进行base64转换，与MANIFEST.MF 的各个字段值进行验证。如果不通过，会抛出”INSTALL_PARSE_FAILED_NO_CERTIFICATION“异常，应用安装会终止。</p>
</li>
<li><p>验证CERT.SF文件的签名信息和CERT.RSA中的内容是否一致</p>
</li>
</ol>
<p>主要调用JarUtils.verifySignature()方法，从rsa文件中获取签名信息，保存在证书数组里，（安卓apk允许对应用进行多次签名）并且验证CERT.SF文件的签名信息和CERT.RSA中的内容是否一致。这个主要是为了保证CERT.SF文件的有效性，好继续进行下一步的动作</p>
<ol start="3">
<li>MANIFEST.MF整个文件签名在CERT.SF文件中头属性中的值是否匹配以及验证MANIFEST.MF文件中的各个属性块的签名在CERT.SF文件中是否匹配</li>
<li>上面的三个方法 主要是为了保证安装的应用是未经过篡改的，在安装之前，还会再检验一下 已安装应用于即将安装的应用中的签名是否一致。如果不一致 会报错”INSTALL_PARSE_FAILED_INCONSTENT_CERTIFICATIONS“，所谓比对签名，就是比对证书中的公钥信息是否一致</li>
<li>我们的应用安装白名单机制，是需要sdk使用商将签名公钥提供，我们会再次使用一次rsa算法，将公钥信息进行加密后保存在系统证书白名单数据库中，私钥信息我们会写死在packageParser里，因为使用者无法拿到我们的源码，是不可能知道我们的私钥信息的，在第5步插入了自己的判断逻辑，首先获取白名单数据库中的加密签名，用私钥解密，验证应用的签名文件是否与白名单中一致，如果不是就抛出异常。”INSTALL_PARSE_FAILED_BAD_MANIFEST“ </li>
</ol>
<h2 id="java基础："><a href="#java基础：" class="headerlink" title="java基础："></a>java基础：</h2><h3 id="类的初始化-（主动引用-被动引用）"><a href="#类的初始化-（主动引用-被动引用）" class="headerlink" title="类的初始化 （主动引用 被动引用）"></a>类的初始化 （主动引用 被动引用）</h3><p>什么时候会触发类的初始化：</p>
<ol>
<li>使用new 关键字创建了一个类的实例</li>
<li>访问类的静态变量 注意 静态常量不会导致类的初始化，是因为jvm将常量当做值而不是域来看待，当用到了静态常量，jvm并不会为此生成字节码从对象中载入域的值，而是直接将该值插入字节码中。这是一种很有用的优化。但是静态常量一旦变化了，所有用到它的地方都需要重新编译。</li>
<li>调用了类的静态方法</li>
<li>反射</li>
<li>当初始化一个类发现父类还没初始化 会先初始化父类</li>
<li>虚拟机启动时，定义了main方法的类会先初始化<br>以上被称之为 主动引用 除上述几种情况外，都属于被动引用<br>被动引用不会触发类的初始化</li>
<li>子类调用父类的静态变量 子类不会初始化 </li>
<li>通过数组定义来引用类，不会初始化 SuperClass[] classes = new SupercClass[1];不会触发初始化</li>
<li>访问类的常量（final），不会初始化<h3 id="初始化次序："><a href="#初始化次序：" class="headerlink" title="初始化次序："></a>初始化次序：</h3>父类–静态变量<br>父类–静态初始化块<br>子类–静态变量<br>子类–静态初始化块<br>子类main方法<br>父类–变量<br>父类–初始化块<br>父类–构造器<br>i=9, j=0<br>子类–变量<br>子类–初始化块<br>子类–构造器<br>i=9,j=20</li>
</ol>
<h3 id="class文件从解析到生成对象的全过程："><a href="#class文件从解析到生成对象的全过程：" class="headerlink" title="class文件从解析到生成对象的全过程："></a>class文件从解析到生成对象的全过程：</h3><h4 id="1-java编译器将java文件编译为class文件"><a href="#1-java编译器将java文件编译为class文件" class="headerlink" title="1. java编译器将java文件编译为class文件"></a>1. java编译器将java文件编译为class文件</h4><p>class文件是一组以8位字节为基础的二进制流，各个数据项严格按照一定的次序和规则排列在class文件中，没有任何的分隔符，所有的内容都是java程序运行时的必要数据项。由上到下依次为：</p>
<ol>
<li>头四个字节： 魔数 + class文件版本</li>
<li>常量池：字面量（各种字符串，final修饰符修饰的常量值。）和符号引用（类和接口的全限定名，字段的名称和描述符，方法的名称和描述符）</li>
<li>访问标识， 常量池之后的两个字节。标识当前是类还是接口 声明的是public 还是private abstract final之类</li>
<li>类索引（当前类的全限定名） 父类索引（父类的全限定名，除了object没有父类 其他都有） 接口索引（可以多继承接口，所以这是一个数组）</li>
<li>字段表集合： 是类字段还是实例字段（static），public 还是static  是不是volatile 是不是final。</li>
<li>方法表集合</li>
<li>属性表集合</li>
<li>指令码集合<h4 id="2-jvm运行时数据区"><a href="#2-jvm运行时数据区" class="headerlink" title="2. jvm运行时数据区"></a>2. jvm运行时数据区</h4><img src="/media/15323327291563.jpg" alt=""></li>
</ol>
<p>java程序运行的时候，jvm会把它管理的内存划分为以下几种数据区</p>
<ol>
<li>java堆 所有线程共享，所有实例化的对象和数组都会被放在堆中。<br>对象中的内存布局：<br>a. 对象头：<br>对象本身的信息：锁信息 根据是偏向锁 轻量级 重量级锁在该区域存储的数据不同。 <pre><code>gc分代年龄、
哈希码
</code></pre>类型信息： 指向该对象对应的唯一class对象指针。<br>b. 对象数据<br>程序中定义的各种类型的字段内容  指向的是方法区中对应的信息</li>
</ol>
<p>c. 对其区域<br>不够8个字节要对齐成8个字节。</p>
<ol start="2">
<li>方法区：类信息，常量，静态变量，jit编译器编译后的代码 常量池也是在方法区中的。对象头和方法区是线程共享的。<br>下面是每创建一个线程 都会创建的数据区</li>
<li><p>vm栈 每个线程都会创建自己的vm栈。每调用一个方法 都会创建一个方法栈帧加入到vm栈中<br>一个栈帧的数据结构：<br>a. 局部变量表 方法中定义的局部变量数据<br>b. 操作数栈 存放方法执行过程的中间变量<br>c. 动态链接 指向该栈帧对应的常量池地址<br>d. 返回地址 方法调用完需要返回时，需要回到调用它的方法的地址。这个就是存储这种信息的。</p>
</li>
<li><p>native方法栈</p>
</li>
<li>程序计数器： 记录下个指令的位置。</li>
</ol>
<h2 id="java-集合相关："><a href="#java-集合相关：" class="headerlink" title="java 集合相关："></a>java 集合相关：</h2><h3 id="hashMap"><a href="#hashMap" class="headerlink" title="hashMap"></a>hashMap</h3><p>线程不安全的集合。fail-fast机制，内部有一个volitile类型的变量记录被修改次数，当进行插入操作发现该数据与当前不一致会抛出异常。<br>采用数组+Entry链表实现。默认初始化长度是16，扩容因子是0.75 每次扩容按照2的倍数进行扩容，而且数组长度也是2的倍数。 当查找数据的时候，首先计算插入数据key的hash值，然通过hash值与（length-1）进行与运算，求得在数组中的位置。这样比直接对数组长度求模要高效很多<br> <code>index = h &amp;(length-1)</code><br> 当插入数据已存在 直接覆盖插入，否则插入在entry链表表头</p>
<p> 注： jdk1.8中  hashMap有了重大更新</p>
<p> 为了解决hash碰撞导致的Entry链表过长的情况导致查询效率低，jdk1.8 引入了红黑树。</p>
<ol>
<li>没有冲突，数据存储在数组中</li>
<li>有冲突 且Entry链表长度不超过8  将数据存储在单链表中</li>
<li>当Entry长度超过8 将吧Enrty单链表转化为 红黑数</li>
<li>红黑树 的查找和插入时间复杂度均为o(ln n) 单链表是n </li>
</ol>
<h3 id="concurrentHashMap"><a href="#concurrentHashMap" class="headerlink" title="concurrentHashMap"></a>concurrentHashMap</h3><p>线程安全的hashMap 数组部分改由Segment实现，继承自并发包的ReentrainLock，实现了分段锁机制。<br>每个segment维护一个特殊的HashEntry链表，读可以并发读取无需加锁，写是加锁的。</p>
<ol>
<li>HashEnrty的next是final类型，不能在中间操作成员，每次put只能放在表头。hashEnrty对象的不变性，降低了读对锁的要求</li>
<li>value字段是volitine修饰，是线程可见，每次读取都是最新值。</li>
<li>如果父读的过程中发生了指令重拍现象，则加锁重读。</li>
</ol>
<p>理想状态的并发级别是16个线程，每个Segment守护大约为总桶数的1/16</p>
<h3 id="hashSet"><a href="#hashSet" class="headerlink" title="hashSet"></a>hashSet</h3><p>和hashMap基本一样 只不过存的时候我们只需要传key就可以，默认会放一个object对象作为value，本质还是hashMap 实现的，初始还是16 扩容系数0.75. 如果传入的key已经存在 直接返回false。</p>
<h3 id="hashTable"><a href="#hashTable" class="headerlink" title="hashTable"></a>hashTable</h3><p>线程安全的hashMap 已经淘汰，推荐使用concurrentHashMap。默认长度11 扩容因子0.75 每次扩容 长度为2倍+1。所有的public方法用syncornized包裹，所以线程安全。<br>不推荐使用。</p>
<h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p>非线程安全。排序的HashMap，Entry链表用的是双向链表，每个节点增加了before和after成员，构成双向链。单独增加了一个Header节点，记录链表头。是根据时间排序的。可以设置为 是插入时排序 还是取值时排序。 会将最近使用的元素放在Header节点的后一个节点，这种特性使得linkedHashMap可以作为LruCache的存储数据结构来使用，并且提供了一个eldest()方法获取最不常用的元素。</p>
<h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h3><p>同上</p>
<h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>数组实现的列表，自动扩容，可被扩容，支持序列化。无参构造方法默认长度为10，扩容倍数为原来一半+1个。</p>
<h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p>和ArrayList类似 也是基于数组实现的动态可扩容列表=，是线程安全的，每次扩容数据增大为原来的1倍</p>
<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>双向链表实现的动态列表，插入 删除比ArrayList快，但是随机访问比Arraylist慢，因为Arraylist是基于数组的，</p>
<h3 id="SparseArray"><a href="#SparseArray" class="headerlink" title="SparseArray"></a>SparseArray</h3><p>用双数组实现，key只能存int类型，key用一个数组存放，value也用一个数组存放，每次put元素都会进行二分法查找，将其排好序再插入，查找的时候，也会使用二分法查找，但是因为其插入，查找 删除都需要进行二分法查找，当数据量很大的时候，效率将低50% 。 因为hasMap每次扩容的时候，都需要将容量扩大一倍，同时对所有数据再hash，这个开销非常大，所以当 数据量低于1000，且key为int类型时，使用SparseArray将获得很好的性能。</p>
<h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><p>读写锁，读不加锁 写加锁 适合多度少写的使用情况。</p>
<h2 id="虚拟机相关-JVM–-gt-Divalk-虚拟机-–-gt-ART虚拟机"><a href="#虚拟机相关-JVM–-gt-Divalk-虚拟机-–-gt-ART虚拟机" class="headerlink" title="虚拟机相关 JVM–&gt; Divalk 虚拟机 –&gt; ART虚拟机"></a>虚拟机相关 JVM–&gt; Divalk 虚拟机 –&gt; ART虚拟机</h2><h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><p>一个java虚拟机 必须包括 类加载器，解释执行，垃圾回收 三个部分。</p>
<h4 id="1-编译java代码"><a href="#1-编译java代码" class="headerlink" title="1. 编译java代码"></a>1. 编译java代码</h4><p>首先是通过javac java编译器 将java代码编译为信息密度高的java字节码 变成class文件<br>class文件的文件格式:</p>
<table>
<thead>
<tr>
<th>位</th>
<th>名称</th>
<th>数量</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>U4</td>
<td>Magic</td>
<td>1</td>
<td>魔数 标识该文件为class文件</td>
</tr>
<tr>
<td>U2</td>
<td>minor_version</td>
<td>1</td>
<td>次版本</td>
</tr>
<tr>
<td>U2</td>
<td>Major_version</td>
<td>1</td>
<td>主版本</td>
</tr>
<tr>
<td>U2</td>
<td>constant_pool_count</td>
<td>1</td>
<td>常量池数量（一个class文件只有一个常量池）</td>
</tr>
<tr>
<td>cp_info</td>
<td>Constant_pool</td>
<td>上面-1</td>
<td>常量池（数据类型有11种，真正只有utf8，其他都是对其的引用）</td>
</tr>
<tr>
<td>u2</td>
<td>Access_flags</td>
<td>1</td>
<td>类的访问标记</td>
</tr>
<tr>
<td>u2</td>
<td>This_class</td>
<td>1</td>
<td>记录当前类的全限定名</td>
</tr>
<tr>
<td>u2</td>
<td>super_class</td>
<td>1</td>
<td>父类的全限定名</td>
</tr>
<tr>
<td>u2</td>
<td>Interface_count</td>
<td>interface_count</td>
<td>接口数量</td>
</tr>
<tr>
<td>u2</td>
<td>Interfaces</td>
<td>1</td>
<td>接口全限定名</td>
</tr>
<tr>
<td>u2</td>
<td>Fields_count</td>
<td>1</td>
<td>成员数量</td>
</tr>
<tr>
<td>field_info</td>
<td>Fields</td>
<td>fields_count</td>
<td>成员信息</td>
</tr>
<tr>
<td>U2</td>
<td>Methods_count</td>
<td>1</td>
<td>方法数量</td>
</tr>
<tr>
<td>Methods_info</td>
<td>Methods</td>
<td>methods_count</td>
<td>方法信息</td>
</tr>
<tr>
<td>U2</td>
<td>Attrtibutes_count</td>
<td>1</td>
<td>属性数量</td>
</tr>
<tr>
<td>Attrtibutes_info</td>
<td>Attrtibutes</td>
<td>attr_counts</td>
<td>属性信息</td>
</tr>
</tbody>
</table>
<h4 id="a-常量池的类型包括："><a href="#a-常量池的类型包括：" class="headerlink" title="a: 常量池的类型包括："></a>a: 常量池的类型包括：</h4><table>
<thead>
<tr>
<th>数据类型</th>
<th>标记</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>CONSTANT_Utf8</td>
<td>1</td>
<td>UTF-8编码的Unicode字符串</td>
</tr>
<tr>
<td>CONSTANT_Integer</td>
<td>3</td>
<td>int类型字面值</td>
</tr>
<tr>
<td>CONSTANT_Float</td>
<td>4</td>
<td>float类型字面值</td>
</tr>
<tr>
<td>CONSTANT_Long</td>
<td>5</td>
<td>long类型字面值</td>
</tr>
<tr>
<td>CONSTANT_Double</td>
<td>6</td>
<td>double类型字面值</td>
</tr>
<tr>
<td>CONSTANT_Class</td>
<td>7</td>
<td>对一个类或接口的符号引用</td>
</tr>
<tr>
<td>CONSTANT_String</td>
<td>8</td>
<td>String类型字面值</td>
</tr>
<tr>
<td>CONSTANT_Fieldref</td>
<td>9</td>
<td>对一个字段的符号引用</td>
</tr>
<tr>
<td>CONSTANT_Methodref</td>
<td>10</td>
<td>对一个类中声明的方法的符号引用</td>
</tr>
<tr>
<td>CONSTANT_InterfaceMethodref</td>
<td>11</td>
<td>对一个接口中声明的方法的符号引用</td>
</tr>
<tr>
<td>CONSTANT_NameAndType</td>
<td>12</td>
<td>对一个字段或方法的部分符号引用</td>
</tr>
</tbody>
</table>
<p>其中 constant_uft8_info 是最基础的类型 会被其他引用 </p>
<p>这个类型的数据是utf8格式的字符串常量 基本一个类的全部信息 都可以由字符串常量来表述了：</p>
<ul>
<li>程序中的字符串常量</li>
<li>常量池所在当前类（包括接口和枚举）的全限定名</li>
<li>常量池所在当前类的直接父类的全限定名</li>
<li>常量池所在当前类型所实现或继承的所有接口的全限定名</li>
<li>常量池所在当前类型中所定义的字段的名称和描述符</li>
<li>常量池所在当前类型中所定义的方法的名称和描述符</li>
<li>由当前类所引用的类型的全限定名</li>
<li>由当前类所引用的其他类中的字段的名称和描述符</li>
<li>由当前类所引用的其他类中的方法的名称和描述符</li>
<li>与当前class文件中的属性相关的字符串， 如属性名等</li>
</ul>
<h5 id="b-访问标记："><a href="#b-访问标记：" class="headerlink" title="b:访问标记："></a>b:访问标记：</h5><p>总共7项 标记当前类 是 class 是接口 是枚举 还是注解类型  是不是public 是不是final的<br>注意 这是描述类层面的  不是描述方法和字段的访问类型</p>
<h5 id="c：fields-counts-和field"><a href="#c：fields-counts-和field" class="headerlink" title="c：fields counts 和field"></a>c：fields counts 和field</h5><p>字段和字段信息<br>字段只包括当前类中定义的字段 不包括父类的字段。<br>字段信息是一个数组 每个字段信息都是一个field_info结构 信息都是对常量池中的数据的引用<br>包括了字段名，字段访问表示 字段类型 指向常量池的索引  以及字段的属性(标识字段是否是静态的 constant，是否过时 deprecated 以及Synthetic)</p>
<h5 id="d-：methods"><a href="#d-：methods" class="headerlink" title="d ：methods"></a>d ：methods</h5><p>存放的是method_info 数组 标识方法信息的<br><img src="/media/15331024431425.jpg" alt="-w78"></p>
<p>access_flags ， name_index， descriptor_index 。 他们分别描述方法的访问修饰符， 方法名和方法描述符。<br> method_info中还有attributes_count和attributes<br> 其中attritubes 包括方法执行过程中的所有指令：<br> <img src="/media/15331025295887.jpg" alt="-w184"></p>
<ul>
<li><p>attribute_name_index指向常量池中的一个CONSTANT_Utf8_info ， 这个CONSTANT_Utf8_info 中存放的是当前属性的名字 “Code” 。</p>
</li>
<li><p>attribute_length给出了当前Code属性的长度（不包括前六字节）。</p>
</li>
<li><p>max_stack 指定当前方法被执行引擎执行的时候， 在栈帧中需要分配的操作数栈的大小。</p>
</li>
<li><p>max_locals指定当前方法被执行引擎执行的时候， 在栈帧中需要分配的局部表量表的大小。注意， 这个数字并不是局部变量的个数， 因为根据局部变量的作用域不同， 在执行到一个局部变量以外时， 下一个局部变量可以重用上一个局部变量的空间（每个局部变量在局部变量表中占用一个或两个Slot）。 方法中的局部变量包括方法的参数， 方法的默认参数this， 方法体中定义的变量， catch语句中的异常对象。 关于执行引擎的相关内容会在后面的博客中讲到。</p>
</li>
<li><p>code_length指定该方法的字节码的长度， class文件中每条字节码占一个字节。</p>
</li>
<li><p>code存放字节码指令本身， 它的长度是code_length个字节。</p>
</li>
<li><p>exception_table_length 指定异常表的大小</p>
</li>
<li><p>exception_table就是所谓的异常表， 它是对方法体中try-catch_finally的描述。 exception_table可以看做是一个数组， 每个数组项是一个exception_info结构， 一般来说每个catch块对应一个exception_info，编译器也可能会为当前方法生成一些exception_info。 exception_info的结构如下（为了直观的显示exception_info， exception_table和Code属性的关系， 画出了Code属性，的话读者就会更清楚各个数据项之间的位置关系和包含关系）：</p>
</li>
</ul>
<h4 id="加载class字节码"><a href="#加载class字节码" class="headerlink" title="加载class字节码"></a>加载class字节码</h4><p>jvm的内存结构<br><img src="/media/15331055632752.jpg" alt="-w321"></p>
<ul>
<li>通过一个类的全限定名来获取其定义的二进制字节流。</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>
<li>在 Java 堆中生成一个代表这个类的 java.lang.Class 对象，作为对方法区中这些数据的访问入</li>
</ul>
<p>为什么用Class.forName(“Test”).getMethod(“void”,int.class) 这样的写法被称之为反射呢。</p>
<p>因为一个类被加载之后，比如上文的Test类，Test.class文件中的常量池 会被加载在运行时数据结构中的方法区中，这些数据是线程共享的。 当类被加载之后，会生成一个Class类型对象，该对象存放在堆中，他对方法区中该类的数据做了映射，就像是一面镜子，反射着这个类的所有信息。 所以通过class对象来获取类信息的方式，被形象的称之为反射。</p>
<h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p>验证<br>准别 为静态类变量分配默认值<br>解析 将符号引用替换为直接引用 （会发生在初始化前 也可能发生在初始化之后）比如静态类变量的引用 会在类被加载的时候就去查找 本类 父类 父接口是否存在 如果存在就将该静态类变量的引用替换为其在内存中的真正地址 与当前类其实已经没有关系了。</p>
<p>所以乳 如果子类引用了父类的静态类变量 并不会触发子类的初始化。 此时链接发生在初始化之前。</p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>开始对成员变量进行初始化并赋值</p>
<p>方法的执行时序</p>
<h3 id="JIT-AOT-JAVAC-编译器区别"><a href="#JIT-AOT-JAVAC-编译器区别" class="headerlink" title="JIT AOT JAVAC 编译器区别"></a>JIT AOT JAVAC 编译器区别</h3><p>javac就是我们常用的将java文件编译为class字节码的</p>
<p>之前的java程序在运行过程中 都是由解释器 一行行解析class字节码  一行行执行 但是这势必会存在效率问题  因为解释运行的速度不高。<br>后来为了优化执行速度，出现了JIT 编译器。<br>JIT  JUST in time. 顾名思义 执行器编译。<br>JIT编译器会判断 在程序执行过程中 哪些代码是高频执行的，并将改代码直接翻译成与当前平台相关的机器码。下次再执行到该代码时 会直接执行机器码 速度就快了很多。</p>
<p>在5.0以前 divlik虚拟机 就是JIT 编译器</p>
<p>这个高频代码的判断 被称之为 热点探测 包括 基于采样点探测 基于计数器探测。</p>
<h3 id="AOT"><a href="#AOT" class="headerlink" title="AOT"></a>AOT</h3><p>AOT ahead of time<br>在程序运行之前 就将class文件直接翻译成对应平台的字节码  这样会加快应用的启动时间，因为直接从字节码开始读取的。但是会带来内存增大的问题。而且在android平台上 还会带来意想不到的坑，比如如果在so文件中引用了libs目录下的其他so库，会爆找不到路径的错误，是因为aot编译器直接将so库与java文件直接打包成了平台对应的机器码文件aot文件。</p>
<h3 id="android-历史各版本的编译器演进："><a href="#android-历史各版本的编译器演进：" class="headerlink" title="android 历史各版本的编译器演进："></a>android 历史各版本的编译器演进：</h3><ul>
<li>Android 4.x(Interpreter + JIT)原理：平时代码走解释器，但热点trace会执行JIT进行即时编译优点：占用内存少缺点：耗电(退出App下次启动还会重复编译)，卡顿(JIT编译时)Android </li>
<li>5.0/5.1/6.0(interpreter + AOT)原理: 在AOT模式下，App在安装过程时， 就会完成所有编译。优点: 性能好缺点: App安装时间长，占用存储空间多。】</li>
<li>Android 7.0/7.1的ART引入了全新的Hybrid模式(Interpreter + JIT + AOT)原理: App在安装时不编译， 所以安装速度快。在运行App时， 先走解释器， 然后热点函数会被识别，并被JIT进行编译， 存储在jit code cache， 并产生profile文件(记录热点函数信息)。 等手机进入charging和idle状态下， 系统会每隔一段时间扫描App目录下profile文件，并执行AOT编译(Google官方称之为profile-guided compilation)。不论是jit编译的binary code, 还是AOT编译的binary code, 它们之间的性能差别不大， 因为它们使用同一个optimizing compiler进行编译。优点: App安装速度快，占用存储少(只编译热点函数)。缺点: 前几次运行会较慢， 只有用户操作得次数越多，jit 和AOT编译后， 性能才会跟上来<h3 id="dv虚拟机-对比jvm虚拟机"><a href="#dv虚拟机-对比jvm虚拟机" class="headerlink" title="dv虚拟机 对比jvm虚拟机"></a>dv虚拟机 对比jvm虚拟机</h3>jvm 的每一个class文件都对应一个常量池。 但是很多常量池中的信息其实是重复的，dv虚拟机在将class文件编译为dex文件时，将所有class文件的常量池合并为一个，减少了apk的体积。</li>
</ul>
<p>其次 jvm是基于求职栈的  dvm的指令比jvm长，是基于虚拟寄存器的。<br>dvm的方法栈帧中不存在 求值栈和临时变量，替代的是虚拟寄存器、常用的是v0 -v15 </p>
<p>dvm的虚拟寄存器 每个线程都有一个  不用担心多线程 保护寄存器问题。</p>
<h4 id="手画一下Android系统架构图，描述一下各个层次的作用？"><a href="#手画一下Android系统架构图，描述一下各个层次的作用？" class="headerlink" title="手画一下Android系统架构图，描述一下各个层次的作用？"></a>手画一下Android系统架构图，描述一下各个层次的作用？</h4><p>Android系统架构图</p>
<p><img src="/media/15344137407090.png" alt=""></p>
<p>从上到下依次分为六层：</p>
<ul>
<li>应用框架层</li>
<li>进程通信层</li>
<li>系统服务层</li>
<li>Android运行时层</li>
<li>硬件抽象层</li>
<li>Linux内核层</li>
</ul>
<h3 id="Activity如与Service通信？"><a href="#Activity如与Service通信？" class="headerlink" title="Activity如与Service通信？"></a>Activity如与Service通信？</h3><p>可以通过bindService的方式，先在Activity里实现一个ServiceConnection接口，并将该接口传递给bindService()方法，在ServiceConnection接口的onServiceConnected()方法<br>里执行相关操作。</p>
<h3 id="Service的生命周期与启动方法由什么区别？"><a href="#Service的生命周期与启动方法由什么区别？" class="headerlink" title="Service的生命周期与启动方法由什么区别？"></a>Service的生命周期与启动方法由什么区别？</h3><ul>
<li>startService()：开启Service，调用者退出后Service仍然存在。</li>
<li>bindService()：开启Service，调用者退出后Service也随即退出。</li>
</ul>
<p>Service生命周期：</p>
<ul>
<li>只是用startService()启动服务：onCreate() -&gt; onStartCommand() -&gt; onDestory</li>
<li>只是用bindService()绑定服务：onCreate() -&gt; onBind() -&gt; onUnBind() -&gt; onDestory</li>
<li>同时使用startService()启动服务与bindService()绑定服务：onCreate() -&gt; onStartCommnad() -&gt; onBind() -&gt; onUnBind() -&gt; onDestory</li>
</ul>
<h3 id="Service先start再bind如何关闭service，为什么bindService可以跟Activity生命周期联动？"><a href="#Service先start再bind如何关闭service，为什么bindService可以跟Activity生命周期联动？" class="headerlink" title="Service先start再bind如何关闭service，为什么bindService可以跟Activity生命周期联动？"></a>Service先start再bind如何关闭service，为什么bindService可以跟Activity生命周期联动？</h3><h3 id="广播分为哪几种，应用场景是什么？"><a href="#广播分为哪几种，应用场景是什么？" class="headerlink" title="广播分为哪几种，应用场景是什么？"></a>广播分为哪几种，应用场景是什么？</h3><ul>
<li>普通广播：调用sendBroadcast()发送，最常用的广播。</li>
<li>有序广播：调用sendOrderedBroadcast()，发出去的广播会被广播接受者按照顺序接收，广播接收者按照Priority属性值从大-小排序，Priority属性相同者，动态注册的广播优先，广播接收者还可以<br>选择对广播进行截断和修改。</li>
</ul>
<h3 id="广播的两种注册方式有什么区别？"><a href="#广播的两种注册方式有什么区别？" class="headerlink" title="广播的两种注册方式有什么区别？"></a>广播的两种注册方式有什么区别？</h3><ul>
<li>静态注册：常驻系统，不受组件生命周期影响，即便应用退出，广播还是可以被接收，耗电、占内存。</li>
<li>动态注册：非常驻，跟随组件的生命变化，组件结束，广播结束。在组件结束前，需要先移除广播，否则容易造成内存泄漏。</li>
</ul>
<h3 id="广播发送和接收的原理了解吗？"><a href="#广播发送和接收的原理了解吗？" class="headerlink" title="广播发送和接收的原理了解吗？"></a>广播发送和接收的原理了解吗？</h3><ol>
<li>继承BroadcastReceiver，重写onReceive()方法。</li>
<li>通过Binder机制向ActivityManagerService注册广播。</li>
<li>通过Binder机制向ActivityMangerService发送广播。</li>
<li>ActivityManagerService查找符合相应条件的广播（IntentFilter/Permission）的BroadcastReceiver，将广播发送到BroadcastReceiver所在的消息队列中。</li>
<li>BroadcastReceiver所在消息队列拿到此广播后，回调它的onReceive()方法。</li>
</ol>
<h3 id="广播传输的数据是否有限制，是多少，为什么要限制？"><a href="#广播传输的数据是否有限制，是多少，为什么要限制？" class="headerlink" title="广播传输的数据是否有限制，是多少，为什么要限制？"></a>广播传输的数据是否有限制，是多少，为什么要限制？</h3><h3 id="ContentProvider、ContentResolver与ContentObserver之间的关系是什么？"><a href="#ContentProvider、ContentResolver与ContentObserver之间的关系是什么？" class="headerlink" title="ContentProvider、ContentResolver与ContentObserver之间的关系是什么？"></a>ContentProvider、ContentResolver与ContentObserver之间的关系是什么？</h3><ul>
<li>ContentProvider：管理数据，提供数据的增删改查操作，数据源可以是数据库、文件、XML、网络等，ContentProvider为这些数据的访问提供了统一的接口，可以用来做进程间数据共享。</li>
<li>ContentResolver：ContentResolver可以不同URI操作不同的ContentProvider中的数据，外部进程可以通过ContentResolver与ContentProvider进行交互。</li>
<li>ContentObserver：观察ContentProvider中的数据变化，并将变化通知给外界。</li>
</ul>
<h3 id="遇到过哪些关于Fragment的问题，如何处理的？"><a href="#遇到过哪些关于Fragment的问题，如何处理的？" class="headerlink" title="遇到过哪些关于Fragment的问题，如何处理的？"></a>遇到过哪些关于Fragment的问题，如何处理的？</h3><ul>
<li><p>getActivity()空指针：这种情况一般发生在在异步任务里调用getActivity()，而Fragment已经onDetach()，此时就会有空指针，解决方案是在Fragment里使用<br>一个全局变量mActivity，在onAttach()方法里赋值，这样可能会引起内存泄漏，但是异步任务没有停止的情况下本身就已经可能内存泄漏，相比直接crash，这种方式<br>显得更妥当一些。</p>
</li>
<li><p>Fragment视图重叠：在类onCreate()的方法加载Fragment，并且没有判断saveInstanceState==null或if(findFragmentByTag(mFragmentTag) == null)，导致重复加载了同一个Fragment导致重叠。（PS：replace情况下，如果没有加入回退栈，则不判断也不会造成重叠，但建议还是统一判断下）</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 在页面重启时，Fragment会被保存恢复，而此时再加载Fragment会重复加载，导致重叠 ;</span></span><br><span class="line">    <span class="keyword">if</span>(saveInstanceState == <span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="comment">// 或者 if(findFragmentByTag(mFragmentTag) == null)</span></span><br><span class="line">       <span class="comment">// 正常情况下去 加载根Fragment </span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Android里的Intent传递的数据有大小限制吗，如何解决？"><a href="#Android里的Intent传递的数据有大小限制吗，如何解决？" class="headerlink" title="Android里的Intent传递的数据有大小限制吗，如何解决？"></a>Android里的Intent传递的数据有大小限制吗，如何解决？</h3><p>Intent传递数据大小的限制大概在1M左右，超过这个限制就会静默崩溃。处理方式如下：<br>因为binder给用户进程就是1m 给系统核心进程是4m 给serviceMnager是128kb</p>
<ul>
<li>进程内：EventBus，文件缓存、磁盘缓存。</li>
<li>进程间：通过ContentProvider进行款进程数据共享和传递。</li>
</ul>
<h3 id="描述一下Android的事件分发机制？"><a href="#描述一下Android的事件分发机制？" class="headerlink" title="描述一下Android的事件分发机制？"></a>描述一下Android的事件分发机制？</h3><p>Android事件分发机制的本质：事件从哪个对象发出，经过哪些对象，最终由哪个对象处理了该事件。此处对象指的是Activity、Window与View。</p>
<p>Android事件的分发顺序：Activity（Window） -&gt; ViewGroup -&gt; View</p>
<p>Android事件的分发主要由三个方法来完成，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父View调用dispatchTouchEvent()开始分发事件</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span></span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> consume = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 父View决定是否拦截事件</span></span><br><span class="line">    <span class="keyword">if</span>(onInterceptTouchEvent(event))&#123;</span><br><span class="line">        <span class="comment">// 父View调用onTouchEvent(event)消费事件，如果该方法返回true，表示</span></span><br><span class="line">        <span class="comment">// 该View消费了该事件，后续该事件序列的事件（Down、Move、Up）将不会在传递</span></span><br><span class="line">        <span class="comment">// 该其他View。</span></span><br><span class="line">        consume = onTouchEvent(event);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 调用子View的dispatchTouchEvent(event)方法继续分发事件</span></span><br><span class="line">        consume = child.dispatchTouchEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> consume;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/944365-eeebede55f55b040.png" alt="image"></p>
<hr>
<p><img src="https://upload-images.jianshu.io/upload_images/944365-faaf73d0f3eb870f.png" alt="image"></p>
<p>伪代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * 点击事件产生后</span><br><span class="line">  */ </span><br><span class="line">  // 步骤1：调用dispatchTouchEvent（）</span><br><span class="line">  public boolean dispatchTouchEvent(MotionEvent ev) &#123;</span><br><span class="line"></span><br><span class="line">    boolean consume = false; //代表 是否会消费事件</span><br><span class="line">    </span><br><span class="line">    // 步骤2：判断是否拦截事件</span><br><span class="line">    if (onInterceptTouchEvent(ev)) &#123;</span><br><span class="line">      // a. 若拦截，则将该事件交给当前View进行处理</span><br><span class="line">      // 即调用onTouchEvent (）方法去处理点击事件</span><br><span class="line">        consume = onTouchEvent (ev) ;</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line"></span><br><span class="line">      // b. 若不拦截，则将该事件传递到下层</span><br><span class="line">      // 即 下层元素的dispatchTouchEvent（）就会被调用，重复上述过程</span><br><span class="line">      // 直到点击事件被最终处理为止</span><br><span class="line">      consume = child.dispatchTouchEvent (ev) ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 步骤3：最终返回通知 该事件是否被消费（接收 &amp; 处理）</span><br><span class="line">    return consume;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="描述一下View的绘制原理？"><a href="#描述一下View的绘制原理？" class="headerlink" title="描述一下View的绘制原理？"></a>描述一下View的绘制原理？</h3><p>View的绘制流程主要分为三步：</p>
<ol>
<li>onMeasure：测量视图的大小，从顶层父View到子View递归调用measure()方法，measure()调用onMeasure()方法，onMeasure()方法完成绘制工作。</li>
<li>onLayout：确定视图的位置，从顶层父View到子View递归调用layout()方法，父View将上一步measure()方法得到的子View的布局大小和布局参数，将子View放在合适的位置上。</li>
<li>onDraw：绘制最终的视图，首先ViewRoot创建一个Canvas对象，然后调用onDraw()方法进行绘制。onDraw()方法的绘制流程为：① 绘制视图背景。② 绘制画布的图层。 ③ 绘制View内容。<br>④ 绘制子视图，如果有的话。⑤ 还原图层。⑥ 绘制滚动条。</li>
</ol>
<h3 id="requestLayout-、invalidate-与postInvalidate-有什么区别？"><a href="#requestLayout-、invalidate-与postInvalidate-有什么区别？" class="headerlink" title="requestLayout()、invalidate()与postInvalidate()有什么区别？"></a>requestLayout()、invalidate()与postInvalidate()有什么区别？</h3><ul>
<li>requestLayout()：该方法会递归调用父窗口的requestLayout()方法，直到触发ViewRootImpl的performTraversals()方法，此时mLayoutRequestede为true，会触发onMesaure()与onLayout()方法，不一定<br>会触发onDraw()方法。</li>
<li>invalidate()：该方法递归调用父View的invalidateChildInParent()方法，直到调用ViewRootImpl的invalidateChildInParent()方法，最终触发ViewRootImpl的performTraversals()方法，此时mLayoutRequestede为false，不会<br>触发onMesaure()与onLayout()方法，当时会触发onDraw()方法。</li>
<li>postInvalidate()：该方法功能和invalidate()一样，只是它可以在非UI线程中调用。</li>
</ul>
<p>一般说来需要重新布局就调用requestLayout()方法，需要重新绘制就调用invalidate()方法。</p>
<h3 id="Scroller用过吗，了解它的原理吗？"><a href="#Scroller用过吗，了解它的原理吗？" class="headerlink" title="Scroller用过吗，了解它的原理吗？"></a>Scroller用过吗，了解它的原理吗？</h3><h3 id="了解APK的打包流程吗，描述一下？"><a href="#了解APK的打包流程吗，描述一下？" class="headerlink" title="了解APK的打包流程吗，描述一下？"></a>了解APK的打包流程吗，描述一下？</h3><p>Android的包文件APK分为两个部分：代码和资源，所以打包方面也分为资源打包和代码打包两个方面，这篇文章就来分析资源和代码的编译打包原理。</p>
<p>APK整体的的打包流程如下图所示：<br><img src="https://github.com/guoxiaoxing/android-open-source-project-analysis/raw/master/art/native/vm/apk_package_flow.png" alt="image"><br>具体说来：</p>
<ol>
<li>通过AAPT工具进行资源文件（包括AndroidManifest.xml、布局文件、各种xml资源等）的打包，生成R.java文件。</li>
<li>通过AIDL工具处理AIDL文件，生成相应的Java文件。</li>
<li>通过Javac工具编译项目源码，生成Class文件。</li>
<li>通过DX工具将所有的Class文件转换成DEX文件，该过程主要完成Java字节码转换成Dalvik字节码，压缩常量池以及清除冗余信息等工作。</li>
<li>通过ApkBuilder工具将资源文件、DEX文件打包生成APK文件。</li>
<li>利用KeyStore对生成的APK文件进行签名。</li>
<li>如果是正式版的APK，还会利用ZipAlign工具进行对齐处理，对齐的过程就是将APK文件中所有的资源文件举例文件的起始距离都偏移4字节的整数倍，这样通过内存映射访问APK文件<br>的速度会更快。</li>
</ol>
<h3 id="了解APK的安装流程吗，描述一下？"><a href="#了解APK的安装流程吗，描述一下？" class="headerlink" title="了解APK的安装流程吗，描述一下？"></a>了解APK的安装流程吗，描述一下？</h3><p>APK的安装流程如下所示：<br><img src="https://github.com/guoxiaoxing/android-open-source-project-analysis/raw/master/art/app/package/apk_install_structure.png" alt="image"></p>
<ol>
<li>复制APK到/data/app目录下，解压并扫描安装包。</li>
<li>资源管理器解析APK里的资源文件。</li>
<li>解析AndroidManifest文件，并在/data/data/目录下创建对应的应用数据目录。</li>
<li>然后对dex文件进行优化，并保存在dalvik-cache目录下。</li>
<li>将AndroidManifest文件解析出的四大组件信息注册到PackageManagerService中。</li>
<li>安装完成后，发送广播。</li>
</ol>
<h3 id="当点击一个应用图标以后，都发生了什么，描述一下这个过程？"><a href="#当点击一个应用图标以后，都发生了什么，描述一下这个过程？" class="headerlink" title="当点击一个应用图标以后，都发生了什么，描述一下这个过程？"></a>当点击一个应用图标以后，都发生了什么，描述一下这个过程？</h3><p>点击应用图标后会去启动应用的LauncherActivity，如果LancerActivity所在的进程没有创建，还会创建新进程，整体的流程就是一个Activity的启动流程。</p>
<p>Activity的启动流程图（放大可查看）如下所示：<br><img src="https://github.com/guoxiaoxing/android-open-source-project-analysis/raw/master/art/app/component/activity_start_flow.png" alt="image"></p>
<p>整个流程涉及的主要角色有：</p>
<ul>
<li>Instrumentation: 监控应用与系统相关的交互行为。</li>
<li>AMS：组件管理调度中心，什么都不干，但是什么都管。</li>
<li>ActivityStarter：Activity启动的控制器，处理Intent与Flag对Activity启动的影响，具体说来有：1 寻找符合启动条件的Activity，如果有多个，让用户选择；2 校验启动参数的合法性；3 返回int参数，代表Activity是否启动成功。</li>
<li>ActivityStackSupervisior：这个类的作用你从它的名字就可以看出来，它用来管理任务栈。</li>
<li>ActivityStack：用来管理任务栈里的Activity。</li>
<li>ActivityThread：最终干活的人，是ActivityThread的内部类，Activity、Service、BroadcastReceiver的启动、切换、调度等各种操作都在这个类里完成。</li>
</ul>
<p>注：这里单独提一下ActivityStackSupervisior，这是高版本才有的类，它用来管理多个ActivityStack，早期的版本只有一个ActivityStack对应着手机屏幕，后来高版本支持多屏以后，就<br>有了多个ActivityStack，于是就引入了ActivityStackSupervisior用来管理多个ActivityStack。</p>
<p>整个流程主要涉及四个进程：</p>
<ul>
<li>调用者进程，如果是在桌面启动应用就是Launcher应用进程。</li>
<li>ActivityManagerService等所在的System Server进程，该进程主要运行着系统服务组件。</li>
<li>Zygote进程，该进程主要用来fork新进程。</li>
<li>新启动的应用进程，该进程就是用来承载应用运行的进程了，它也是应用的主线程（新创建的进程就是主线程），处理组件生命周期、界面绘制等相关事情。</li>
</ul>
<p>有了以上的理解，整个流程可以概括如下：</p>
<ol>
<li>点击桌面应用图标，Launcher进程将启动Activity（MainActivity）的请求以Binder的方式发送给了AMS。</li>
<li>AMS接收到启动请求后，交付ActivityStarter处理Intent和Flag等信息，然后再交给ActivityStackSupervisior/ActivityStack<br>处理Activity进栈相关流程。同时以Socket方式请求Zygote进程fork新进程。</li>
<li>Zygote接收到新进程创建请求后fork出新进程。</li>
<li>在新进程里创建ActivityThread对象，新创建的进程就是应用的主线程，在主线程里开启Looper消息循环，开始处理创建Activity。</li>
<li>ActivityThread利用ClassLoader去加载Activity、创建Activity实例，并回调Activity的onCreate()方法。这样便完成了Activity的启动。</li>
</ol>
<h3 id="BroadcastReceiver与LocalBroadcastReceiver有什么区别？"><a href="#BroadcastReceiver与LocalBroadcastReceiver有什么区别？" class="headerlink" title="BroadcastReceiver与LocalBroadcastReceiver有什么区别？"></a>BroadcastReceiver与LocalBroadcastReceiver有什么区别？</h3><ul>
<li>BroadcastReceiver 是跨应用广播，利用Binder机制实现。</li>
<li>LocalBroadcastReceiver 是应用内广播，利用Handler实现，利用了IntentFilter的match功能，提供消息的发布与接收功能，实现应用内通信，效率比较高。</li>
</ul>
<h3 id="Android-Handler机制是做什么的，原理了解吗？"><a href="#Android-Handler机制是做什么的，原理了解吗？" class="headerlink" title="Android Handler机制是做什么的，原理了解吗？"></a>Android Handler机制是做什么的，原理了解吗？</h3><p>Android消息循环流程图如下所示：<br><img src="https://github.com/guoxiaoxing/android-open-source-project-analysis/raw/master/art/native/process/android_handler_structure.png" alt="image"></p>
<p>主要涉及的角色如下所示：</p>
<ul>
<li>Message：消息，分为硬件产生的消息（例如：按钮、触摸）和软件产生的消息。</li>
<li>MessageQueue：消息队列，主要用来向消息池添加消息和取走消息。</li>
<li>Looper：消息循环器，主要用来把消息分发给相应的处理者。</li>
<li>Handler：消息处理器，主要向消息队列发送各种消息以及处理各种消息。</li>
</ul>
<p>整个消息的循环流程还是比较清晰的，具体说来：</p>
<ol>
<li>Handler通过sendMessage()发送消息Message到消息队列MessageQueue。</li>
<li>Looper通过loop()不断提取触发条件的Message，并将Message交给对应的target handler来处理。</li>
<li>target handler调用自身的handleMessage()方法来处理Message。</li>
</ol>
<p>事实上，在整个消息循环的流程中，并不只有Java层参与，很多重要的工作都是在C++层来完成的。我们来看下这些类的调用关系。<br><img src="https://github.com/guoxiaoxing/android-open-source-project-analysis/raw/master/art/native/process/android_handler_class.png" alt="image"></p>
<p>注：虚线表示关联关系，实线表示调用关系。</p>
<p>在这些类中MessageQueue是Java层与C++层维系的桥梁，MessageQueue与Looper相关功能都通过MessageQueue的Native方法来完成，而其他虚线连接的类只有关联关系，并没有<br>直接调用的关系，它们发生关联的桥梁是MessageQueue。</p>
<h3 id="Android-Binder机制是做什么的，为什么选用Binder，原理了解吗？"><a href="#Android-Binder机制是做什么的，为什么选用Binder，原理了解吗？" class="headerlink" title="Android Binder机制是做什么的，为什么选用Binder，原理了解吗？"></a>Android Binder机制是做什么的，为什么选用Binder，原理了解吗？</h3><p>Android Binder是用来做进程通信的，Android的各个应用以及系统服务都运行在独立的进程中，它们的通信都依赖于Binder。</p>
<p>为什么选用Binder，在讨论这个问题之前，我们知道Android也是基于Linux内核，Linux现有的进程通信手段有以下几种：</p>
<ol>
<li>管道：在创建时分配一个page大小的内存，缓存区大小比较有限；</li>
<li>消息队列：信息复制两次，额外的CPU消耗；不合适频繁或信息量大的通信；</li>
<li>共享内存：无须复制，共享缓冲区直接付附加到进程虚拟地址空间，速度快；但进程间的同步问题操作系统无法实现，必须各进程利用同步工具解决；</li>
<li>套接字：作为更通用的接口，传输效率低，主要用于不通机器或跨网络的通信；</li>
<li>信号量：常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。6. 信号: 不适用于信息交换，更适用于进程中断控制，比如非法内存访问，杀死某个进程等；</li>
</ol>
<p>既然有现有的IPC方式，为什么重新设计一套Binder机制呢。主要是出于以上三个方面的考量：</p>
<ul>
<li>高性能：从数据拷贝次数来看Binder只需要进行一次内存拷贝，而管道、消息队列、Socket都需要两次，共享内存不需要拷贝，Binder的性能仅次于共享内存。</li>
<li>稳定性：上面说到共享内存的性能优于Binder，那为什么不适用共享内存呢，因为共享内存需要处理并发同步问题，控制负责，容易出现死锁和资源竞争，稳定性较差。而Binder基于C/S架构，客户端与服务端彼此独立，稳定性较好。</li>
<li>安全性：我们知道Android为每个应用分配了UID，用来作为鉴别进程的重要标志，Android内部也依赖这个UID进行权限管理，包括6.0以前的固定权限和6.0以后的动态权限，传荣IPC只能由用户在数据包里填入UID/PID，这个标记完全<br>是在用户空间控制的，没有放在内核空间，因此有被恶意篡改的可能，因此Binder的安全性更高。</li>
</ul>
<h3 id="描述一下Activity的生命周期，这些生命周期是如何管理的？"><a href="#描述一下Activity的生命周期，这些生命周期是如何管理的？" class="headerlink" title="描述一下Activity的生命周期，这些生命周期是如何管理的？"></a>描述一下Activity的生命周期，这些生命周期是如何管理的？</h3><p>Activity与Fragment生命周期如下所示：<br><img src="https://github.com/guoxiaoxing/android-open-source-project-analysis/raw/master/art/app/component/complete_android_fragment_lifecycle.png" alt="image"></p>
<p>读者可以从上图看出，Activity有很多种状态，状态之间的变化也比较复杂，在众多状态中，只有三种是常驻状态：</p>
<ul>
<li>Resumed（运行状态）：Activity处于前台，用户可以与其交互。</li>
<li>Paused（暂停状态）：Activity被其他Activity部分遮挡，无法接受用户的输入。</li>
<li>Stopped（停止状态）：Activity被完全隐藏，对用户不可见，进入后台。</li>
</ul>
<p>其他的状态都是中间状态。</p>
<p>我们再来看看生命周期变化时的整个调度流程，生命周期调度流程图如下所示：<br><img src="https://github.com/guoxiaoxing/android-open-source-project-analysis/raw/master/art/app/component/activity_lifecycle_structure.png" alt="image"></p>
<p>所以你可以看到，整个流程是这样的：</p>
<ol>
<li>比方说我们点击跳转一个新Activity，这个时候Activity会入栈，同时它的生命周期也会从onCreate()到onResume()开始变换，这个过程是在ActivityStack里完成的，ActivityStack<br>是运行在Server进程里的，这个时候Server进程就通过ApplicationThread的代理对象ApplicationThreadProxy向运行在app进程ApplicationThread发起操作请求。</li>
<li>ApplicationThread接收到操作请求后，因为它是运行在app进程里的其他线程里，所以ApplicationThread需要通过Handler向主线程ActivityThread发送操作消息。</li>
<li>主线程接收到ApplicationThread发出的消息后，调用主线程ActivityThread执行响应的操作，并回调Activity相应的周期方法。</li>
</ol>
<p>注：这里提到了主线程ActivityThread，更准确来说ActivityThread不是线程，因为它没有继承Thread类或者实现Runnable接口，它是运行在应用主线程里的对象，那么应用的主线程<br>到底是什么呢？从本质上来讲启动启动时创建的进程就是主线程，线程和进程处理是否共享资源外，没有其他的区别，对于Linux来说，它们都只是一个struct结构体。</p>
<h3 id="Activity的通信方式有哪些？"><a href="#Activity的通信方式有哪些？" class="headerlink" title="Activity的通信方式有哪些？"></a>Activity的通信方式有哪些？</h3><ul>
<li>startActivityForResult</li>
<li>EventBus</li>
<li>LocalBroadcastReceiver</li>
</ul>
<h3 id="Android应用里有几种Context对象，"><a href="#Android应用里有几种Context对象，" class="headerlink" title="Android应用里有几种Context对象，"></a>Android应用里有几种Context对象，</h3><p>Context类图如下所示：<br><img src="https://github.com/guoxiaoxing/android-open-source-project-analysis/raw/master/art/app/component/context_uml.png" alt="image"></p>
<p>可以发现Context是个抽象类，它的具体实现类是ContextImpl，ContextWrapper是个包装类，内部的成员变量mBase指向的也是个ContextImpl对象，ContextImpl完成了<br>实际的功能，Activity、Service与Application都直接或者间接的继承ContextWrapper。</p>
<h3 id="描述一下进程和Application的生命周期？"><a href="#描述一下进程和Application的生命周期？" class="headerlink" title="描述一下进程和Application的生命周期？"></a>描述一下进程和Application的生命周期？</h3><p>一个安装的应用对应一个LoadedApk对象，对应一个Application对象，对于四大组件，Application的创建和获取方式也是不尽相同的，具体说来：</p>
<ul>
<li>Activity：通过LoadedApk的makeApplication()方法创建。</li>
<li>Service：通过LoadedApk的makeApplication()方法创建。</li>
<li>静态广播：通过其回调方法onReceive()方法的第一个参数指向Application。</li>
<li>ContentProvider：无法获取Application，因此此时Application不一定已经初始化。</li>
</ul>
<h3 id="Android哪些情况会导致内存泄漏，如何分析内存泄漏？"><a href="#Android哪些情况会导致内存泄漏，如何分析内存泄漏？" class="headerlink" title="Android哪些情况会导致内存泄漏，如何分析内存泄漏？"></a>Android哪些情况会导致内存泄漏，如何分析内存泄漏？</h3><p>常见的产生内存泄漏的情况如下所示：</p>
<ul>
<li>持有静态的Context（Activity）引用。</li>
<li>持有静态的View引用，</li>
<li>内部类&amp;匿名内部类实例无法释放（有延迟时间等等），而内部类又持有外部类的强引用，导致外部类无法释放，这种匿名内部类常见于监听器、Handler、Thread、TimerTask</li>
<li>资源使用完成后没有关闭，例如：BraodcastReceiver，ContentObserver，File，Cursor，Stream，Bitmap。</li>
<li>不正确的单例模式，比如单例持有Activity。</li>
<li>集合类内存泄漏，如果一个集合类是静态的（缓存HashMap），只有添加方法，没有对应的删除方法，会导致引用无法被释放，引发内存泄漏。</li>
<li>错误的覆写了finalize()方法，finalize()方法执行执行不确定，可能会导致引用无法被释放。</li>
</ul>
<p>查找内存泄漏可以使用Android Profiler工具或者利用LeakCanary工具。</p>
<h3 id="Android有哪几种进程，是如何管理的？"><a href="#Android有哪几种进程，是如何管理的？" class="headerlink" title="Android有哪几种进程，是如何管理的？"></a>Android有哪几种进程，是如何管理的？</h3><p>Android的进程主要分为以下几种：</p>
<p><strong>前台进程</strong></p>
<p>用户当前操作所必需的进程。如果一个进程满足以下任一条件，即视为前台进程：</p>
<ul>
<li>托管用户正在交互的 Activity（已调用 Activity 的 onResume() 方法）</li>
<li>托管某个 Service，后者绑定到用户正在交互的 Activity</li>
<li>托管正在“前台”运行的 Service（服务已调用 startForeground()）</li>
<li>托管正执行一个生命周期回调的 Service（onCreate()、onStart() 或 onDestroy()）</li>
<li>托管正执行其 onReceive() 方法的 BroadcastReceiver</li>
</ul>
<p>通常，在任意给定时间前台进程都为数不多。只有在内存不足以支持它们同时继续运行这一万不得已的情况下，系统才会终止它们。 此时，设备往往已达到内存分页状态，因此需要终止一些前台进程来确保用户界面正常响应。</p>
<p><strong>可见进程</strong></p>
<p>没有任何前台组件、但仍会影响用户在屏幕上所见内容的进程。 如果一个进程满足以下任一条件，即视为可见进程：</p>
<ul>
<li>托管不在前台、但仍对用户可见的 Activity（已调用其 onPause() 方法）。例如，如果前台 Activity 启动了一个对话框，允许在其后显示上一 Activity，则有可能会发生这种情况。</li>
<li>托管绑定到可见（或前台）Activity 的 Service。</li>
</ul>
<p>可见进程被视为是极其重要的进程，除非为了维持所有前台进程同时运行而必须终止，否则系统不会终止这些进程。</p>
<p><strong>服务进程</strong></p>
<p>正在运行已使用 startService() 方法启动的服务且不属于上述两个更高类别进程的进程。尽管服务进程与用户所见内容没有直接关联，但是它们通常在执行一些用户关<br>心的操作（例如，在后台播放音乐或从网络下载数据）。因此，除非内存不足以维持所有前台进程和可见进程同时运行，否则系统会让服务进程保持运行状态。</p>
<p><strong>后台进程</strong></p>
<p>包含目前对用户不可见的 Activity 的进程（已调用 Activity 的 onStop() 方法）。这些进程对用户体验没有直接影响，系统可能随时终止它们，以回收内存供前台进程、可见进程或服务进程使用。 通常会有很多后台进程在运行，因此它们会保存在 LRU （最近最少使用）列表中，以确保包含用户最近查看的 Activity 的进程最后一个被终止。如果某个 Activity 正确实现了生命周期方法，并保存了其当前状态，则终止其进程不会对用户体验产生明显影响，因为当用户导航回该 Activity 时，Activity 会恢复其所有可见状态。</p>
<p><strong>空进程</strong></p>
<p>不含任何活动应用组件的进程。保留这种进程的的唯一目的是用作缓存，以缩短下次在其中运行组件所需的启动时间。 为使总体系统资源在进程缓存和底层内核缓存之间保持平衡，系统往往会终止这些进程。</p>
<p>ActivityManagerService负责根据各种策略算法计算进程的adj值，然后交由系统内核进行进程的管理。</p>
<h3 id="SharePreference性能优化，可以做进程同步吗？"><a href="#SharePreference性能优化，可以做进程同步吗？" class="headerlink" title="SharePreference性能优化，可以做进程同步吗？"></a>SharePreference性能优化，可以做进程同步吗？</h3><p>在Android中, SharePreferences是一个轻量级的存储类，特别适合用于保存软件配置参数。使用SharedPreferences保存数据，其背后是用xml文件存放数据，文件<br>存放在/data/data/ &lt; package name &gt; /shared_prefs目录下.</p>
<p>之所以说SharedPreference是一种轻量级的存储方式，是因为它在创建的时候会把整个文件全部加载进内存，如果SharedPreference文件比较大，会带来以下问题：</p>
<ol>
<li>第一次从sp中获取值的时候，有可能阻塞主线程，使界面卡顿、掉帧。</li>
<li>解析sp的时候会产生大量的临时对象，导致频繁GC，引起界面卡顿。</li>
<li>这些key和value会永远存在于内存之中，占用大量内存。</li>
</ol>
<p>优化建议</p>
<ol>
<li>不要存放大的key和value，会引起界面卡、频繁GC、占用内存等等。</li>
<li>毫不相关的配置项就不要放在在一起，文件越大读取越慢。</li>
<li>读取频繁的key和不易变动的key尽量不要放在一起，影响速度，如果整个文件很小，那么忽略吧，为了这点性能添加维护成本得不偿失。</li>
<li>不要乱edit和apply，尽量批量修改一次提交，多次apply会阻塞主线程。</li>
<li>尽量不要存放JSON和HTML，这种场景请直接使用JSON。</li>
<li>SharedPreference无法进行跨进程通信，MODE_MULTI_PROCESS只是保证了在API 11以前的系统上，如果sp已经被读取进内存，再次获取这个SharedPreference的时候，如果有这个flag，会重新读一遍文件，仅此而已。</li>
</ol>
<h3 id="如何做SQLite升级？"><a href="#如何做SQLite升级？" class="headerlink" title="如何做SQLite升级？"></a>如何做SQLite升级？</h3><p>数据库升级增加表和删除表都不涉及数据迁移，但是修改表涉及到对原有数据进行迁移。升级的方法如下所示：</p>
<ol>
<li>将现有表命名为临时表。</li>
<li>创建新表。</li>
<li>将临时表的数据导入新表。</li>
<li>删除临时表。</li>
</ol>
<p>重写</p>
<p>如果是跨版本数据库升级，可以由两种方式，如下所示：</p>
<ol>
<li>逐级升级，确定相邻版本与现在版本的差别，V1升级到V2,V2升级到V3，依次类推。</li>
<li>跨级升级，确定每个版本与现在数据库的差别，为每个case编写专门升级大代码。</li>
</ol>
<h3 id="进程保护如何做，如何唤醒其他进程？"><a href="#进程保护如何做，如何唤醒其他进程？" class="headerlink" title="进程保护如何做，如何唤醒其他进程？"></a>进程保护如何做，如何唤醒其他进程？</h3><p>进程保活主要有两个思路：</p>
<ol>
<li>提升进程的优先级，降低进程被杀死的概率。</li>
<li>拉活已经被杀死的进程。</li>
</ol>
<p>如何提升优先级，如下所示：</p>
<p>监控手机锁屏事件，在屏幕锁屏时启动一个像素的Activity，在用户解锁时将Activity销毁掉，前台Activity可以将进程变成前台进程，优先级升级到最高。</p>
<p>如果拉活</p>
<p>利用广播拉活Activity。</p>
<h3 id="理解序列化吗，Android为什么引入Parcelable？"><a href="#理解序列化吗，Android为什么引入Parcelable？" class="headerlink" title="理解序列化吗，Android为什么引入Parcelable？"></a>理解序列化吗，Android为什么引入Parcelable？</h3><p>所谓序列化就是将对象变成二进制流，便于存储和传输。</p>
<ul>
<li>Serializable是java实现的一套序列化方式，可能会触发频繁的IO操作，效率比较低，适合将对象存储到磁盘上的情况。</li>
<li>Parcelable是Android提供一套序列化机制，它将序列化后的字节流写入到一个共性内存中，其他对象可以从这块共享内存中读出字节流，并反序列化成对象。因此效率比较高，适合在对象间或者进程间传递信息。</li>
</ul>
<h3 id="如何计算一个Bitmap占用内存的大小，怎么保证加载Bitmap不产生内存溢出？"><a href="#如何计算一个Bitmap占用内存的大小，怎么保证加载Bitmap不产生内存溢出？" class="headerlink" title="如何计算一个Bitmap占用内存的大小，怎么保证加载Bitmap不产生内存溢出？"></a>如何计算一个Bitmap占用内存的大小，怎么保证加载Bitmap不产生内存溢出？</h3><p>Bitamp 占用内存大小 = 宽度像素 x （inTargetDensity / inDensity） x 高度像素 x （inTargetDensity / inDensity）x 一个像素所占的内存</p>
<p>注：这里inDensity表示目标图片的dpi（放在哪个资源文件夹下），inTargetDensity表示目标屏幕的dpi，所以你可以发现inDensity和inTargetDensity会对Bitmap的宽高<br>进行拉伸，进而改变Bitmap占用内存的大小。</p>
<p>在Bitmap里有两个获取内存占用大小的方法。</p>
<ul>
<li>getByteCount()：API12 加入，代表存储 Bitmap 的像素需要的最少内存。</li>
<li>getAllocationByteCount()：API19 加入，代表在内存中为 Bitmap 分配的内存大小，代替了 getByteCount() 方法。</li>
</ul>
<p>在不复用 Bitmap 时，getByteCount() 和 getAllocationByteCount 返回的结果是一样的。在通过复用 Bitmap 来解码图片时，那么 getByteCount() 表示新解码图片占用内存的大<br>小，getAllocationByteCount() 表示被复用 Bitmap真实占用的内存大小（即 mBuffer 的长度）。</p>
<p>为了保证在加载Bitmap的时候不产生内存溢出，可以受用BitmapFactory进行图片压缩，主要有以下几个参数：</p>
<ul>
<li>BitmapFactory.Options.inPreferredConfig：将ARGB_8888改为RGB_565，改变编码方式，节约内存。</li>
<li>BitmapFactory.Options.inSampleSize：缩放比例，可以参考Luban那个库，根据图片宽高计算出合适的缩放比例。</li>
<li>BitmapFactory.Options.inPurgeable：让系统可以内存不足时回收内存。</li>
</ul>
<h3 id="Android如何在不压缩的情况下加载高清大图？"><a href="#Android如何在不压缩的情况下加载高清大图？" class="headerlink" title="Android如何在不压缩的情况下加载高清大图？"></a>Android如何在不压缩的情况下加载高清大图？</h3><p>使用BitmapRegionDecoder进行布局加载。</p>
<h3 id="Android里的内存缓存和磁盘缓存是怎么实现的。"><a href="#Android里的内存缓存和磁盘缓存是怎么实现的。" class="headerlink" title="Android里的内存缓存和磁盘缓存是怎么实现的。"></a>Android里的内存缓存和磁盘缓存是怎么实现的。</h3><p>内存缓存基于LruCache实现，磁盘缓存基于DiskLruCache实现。这两个类都基于Lru算法和LinkedHashMap来实现。</p>
<p>LRU算法可以用一句话来描述，如下所示：</p>
<blockquote>
<p>LRU是Least Recently Used的缩写，最近最久未使用算法，从它的名字就可以看出，它的核心原则是如果一个数据在最近一段时间没有使用到，那么它在将来被<br>访问到的可能性也很小，则这类数据项会被优先淘汰掉。</p>
</blockquote>
<p>LruCache的原理是利用LinkedHashMap持有对象的强引用，按照Lru算法进行对象淘汰。具体说来假设我们从表尾访问数据，在表头删除数据，当访问的数据项在链表中存在时，则将该数据项移动到表尾，否则在表尾新建一个数据项。当链表容量超过一定阈值，则移除表头的数据。</p>
<p>为什么会选择LinkedHashMap呢？</p>
<p>这跟LinkedHashMap的特性有关，LinkedHashMap的构造函数里有个布尔参数accessOrder，当它为true时，LinkedHashMap会以访问顺序为序排列元素，否则以插入顺序为序排序元素。</p>
<p>DiskLruCache与LruCache原理相似，只是多了一个journal文件来做磁盘文件的管理和迎神，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">libcore.io.DiskLruCache</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">DIRTY 1517126350519</span><br><span class="line">CLEAN 1517126350519 5325928</span><br><span class="line">REMOVE 1517126350519</span><br></pre></td></tr></table></figure>
<p>注：这里的缓存目录是应用的缓存目录/data/data/pckagename/cache，未root的手机可以通过以下命令进入到该目录中或者将该目录整体拷贝出来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//进入/data/data/pckagename/cache目录</span></span><br><span class="line">adb shell</span><br><span class="line">run-as com.your.packagename </span><br><span class="line">cp /data/data/com.your.packagename/</span><br><span class="line"></span><br><span class="line"><span class="comment">//将/data/data/pckagename目录拷贝出来</span></span><br><span class="line">adb backup -noapk com.your.packagename</span><br></pre></td></tr></table></figure>
<p>我们来分析下这个文件的内容：</p>
<ul>
<li>第一行：libcore.io.DiskLruCache，固定字符串。</li>
<li>第二行：1，DiskLruCache源码版本号。</li>
<li>第三行：1，App的版本号，通过open()方法传入进去的。</li>
<li>第四行：1，每个key对应几个文件，一般为1.</li>
<li>第五行：空行</li>
<li>第六行及后续行：缓存操作记录。</li>
</ul>
<p>第六行及后续行表示缓存操作记录，关于操作记录，我们需要了解以下三点：</p>
<ol>
<li>DIRTY 表示一个entry正在被写入。写入分两种情况，如果成功会紧接着写入一行CLEAN的记录；如果失败，会增加一行REMOVE记录。注意单独只有DIRTY状态的记录是非法的。</li>
<li>当手动调用remove(key)方法的时候也会写入一条REMOVE记录。</li>
<li>READ就是说明有一次读取的记录。</li>
<li>CLEAN的后面还记录了文件的长度，注意可能会一个key对应多个文件，那么就会有多个数字。</li>
</ol>
<h3 id="PathClassLoader与DexClassLoader有什么区别？"><a href="#PathClassLoader与DexClassLoader有什么区别？" class="headerlink" title="PathClassLoader与DexClassLoader有什么区别？"></a>PathClassLoader与DexClassLoader有什么区别？</h3><ul>
<li>PathClassLoader：只能加载已经安装到Android系统的APK文件，即/data/app目录，Android默认的类加载器。</li>
<li>DexClassLoader：可以加载任意目录下的dex、jar、apk、zip文件。</li>
</ul>
<h3 id="WebView优化了解吗，如何提高WebView的加载速度？"><a href="#WebView优化了解吗，如何提高WebView的加载速度？" class="headerlink" title="WebView优化了解吗，如何提高WebView的加载速度？"></a>WebView优化了解吗，如何提高WebView的加载速度？</h3><p>为什么WebView加载会慢呢？</p>
<blockquote>
<p>这是因为在客户端中，加载H5页面之前，需要先初始化WebView，在WebView完全初始化完成之前，后续的界面加载过程都是被阻塞的。</p>
</blockquote>
<p>优化手段围绕着以下两个点进行：</p>
<ol>
<li>预加载WebView。</li>
<li>加载WebView的同时，请求H5页面数据。</li>
</ol>
<p>因此常见的方法是：</p>
<ol>
<li>全局WebView。</li>
<li>客户端代理页面请求。WebView初始化完成后向客户端请求数据。</li>
<li>asset存放离线包。</li>
</ol>
<p>除此之外还有一些其他的优化手段：</p>
<ul>
<li>脚本执行慢，可以让脚本最后运行，不阻塞页面解析。</li>
<li>DNS与链接慢，可以让客户端复用使用的域名与链接。</li>
<li>React框架代码执行慢，可以将这部分代码拆分出来，提前进行解析。</li>
</ul>
<h3 id="Java和JS的相互调用怎么实现，有做过什么优化吗？"><a href="#Java和JS的相互调用怎么实现，有做过什么优化吗？" class="headerlink" title="Java和JS的相互调用怎么实现，有做过什么优化吗？"></a>Java和JS的相互调用怎么实现，有做过什么优化吗？</h3><p>jockeyjs：<a href="https://github.com/tcoulter/jockeyjs" target="_blank" rel="noopener">https://github.com/tcoulter/jockeyjs</a></p>
<p>对协议进行统一的封装和处理。</p>
<h3 id="JNI了解吗，Java与C-如何相互调用？"><a href="#JNI了解吗，Java与C-如何相互调用？" class="headerlink" title="JNI了解吗，Java与C++如何相互调用？"></a>JNI了解吗，Java与C++如何相互调用？</h3><p>Java调用C++</p>
<ol>
<li>在Java中声明Native方法（即需要调用的本地方法）</li>
<li>编译上述 Java源文件javac（得到 .class文件）<br>3。 通过 javah 命令导出JNI的头文件（.h文件）</li>
<li>使用 Java需要交互的本地代码 实现在 Java中声明的Native方法 </li>
<li>编译.so库文件</li>
<li>通过Java命令执行 Java程序，最终实现Java调用本地代码</li>
</ol>
<p>C++调用Java</p>
<ol>
<li>从classpath路径下搜索ClassMethod这个类，并返回该类的Class对象。</li>
<li>获取类的默认构造方法ID。</li>
<li>查找实例方法的ID。</li>
<li>创建该类的实例。</li>
<li>调用对象的实例方法。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL Java_com_study_jnilearn_AccessMethod_callJavaInstaceMethod  </span><br><span class="line">(JNIEnv *env, jclass cls)  </span><br><span class="line">&#123;  </span><br><span class="line">    jclass clazz = <span class="literal">NULL</span>;  </span><br><span class="line">    jobject jobj = <span class="literal">NULL</span>;  </span><br><span class="line">    jmethodID mid_construct = <span class="literal">NULL</span>;  </span><br><span class="line">    jmethodID mid_instance = <span class="literal">NULL</span>;  </span><br><span class="line">    jstring str_arg = <span class="literal">NULL</span>;  </span><br><span class="line">    <span class="comment">// 1、从classpath路径下搜索ClassMethod这个类，并返回该类的Class对象  </span></span><br><span class="line">    clazz = (*env)-&gt;FindClass(env, <span class="string">"com/study/jnilearn/ClassMethod"</span>);  </span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="literal">NULL</span>) &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"找不到'com.study.jnilearn.ClassMethod'这个类"</span>);  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、获取类的默认构造方法ID  </span></span><br><span class="line">    mid_construct = (*env)-&gt;GetMethodID(env,clazz, <span class="string">"&lt;init&gt;"</span>,<span class="string">"()V"</span>);  </span><br><span class="line">    <span class="keyword">if</span> (mid_construct == <span class="literal">NULL</span>) &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"找不到默认的构造方法"</span>);  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、查找实例方法的ID  </span></span><br><span class="line">    mid_instance = (*env)-&gt;GetMethodID(env, clazz, <span class="string">"callInstanceMethod"</span>, <span class="string">"(Ljava/lang/String;I)V"</span>);  </span><br><span class="line">    <span class="keyword">if</span> (mid_instance == <span class="literal">NULL</span>) &#123;  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4、创建该类的实例  </span></span><br><span class="line">    jobj = (*env)-&gt;NewObject(env,clazz,mid_construct);  </span><br><span class="line">    <span class="keyword">if</span> (jobj == <span class="literal">NULL</span>) &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"在com.study.jnilearn.ClassMethod类中找不到callInstanceMethod方法"</span>);  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5、调用对象的实例方法  </span></span><br><span class="line">    str_arg = (*env)-&gt;NewStringUTF(env,<span class="string">"我是实例方法"</span>);  </span><br><span class="line">    (*env)-&gt;CallVoidMethod(env,jobj,mid_instance,str_arg,<span class="number">200</span>);  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除局部引用  </span></span><br><span class="line">    (*env)-&gt;DeleteLocalRef(env,clazz);  </span><br><span class="line">    (*env)-&gt;DeleteLocalRef(env,jobj);  </span><br><span class="line">    (*env)-&gt;DeleteLocalRef(env,str_arg);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="了解插件化和热修复吗，它们有什么区别，理解它们的原理吗？"><a href="#了解插件化和热修复吗，它们有什么区别，理解它们的原理吗？" class="headerlink" title="了解插件化和热修复吗，它们有什么区别，理解它们的原理吗？"></a>了解插件化和热修复吗，它们有什么区别，理解它们的原理吗？</h3><ul>
<li>插件化：插件化是体现在功能拆分方面的，它将某个功能独立提取出来，独立开发，独立测试，再插入到主应用中。依次来较少主应用的规模。</li>
<li>热修复：热修复是体现在bug修复方面的，它实现的是不需要重新发版和重新安装，就可以去修复已知的bug。</li>
</ul>
<p>利用PathClassLoader和DexClassLoader去加载与bug类同名的类，替换掉bug类，进而达到修复bug的目的，原理是在app打包的时候阻止类打上CLASS_ISPREVERIFIED标志，然后在<br>热修复的时候动态改变BaseDexClassLoader对象间接引用的dexElements，替换掉旧的类。</p>
<p>目前热修复框架主要分为两大类：</p>
<ul>
<li>Sophix：修改方法指针。</li>
<li>Tinker：修改dex数组元素。</li>
</ul>
<h3 id="如何做性能优化？"><a href="#如何做性能优化？" class="headerlink" title="如何做性能优化？"></a>如何做性能优化？</h3><ol>
<li>节制的使用Service，当启动一个Service时，系统总是倾向于保留这个Service依赖的进程，这样会造成系统资源的浪费，可以使用IntentService，执行完成任务后会自动停止。</li>
<li>当界面不可见时释放内存，可以重写Activity的onTrimMemory()方法，然后监听TRIM_MEMORY_UI_HIDDEN这个级别，这个级别说明用户离开了页面，可以考虑释放内存和资源。</li>
<li>避免在Bitmap浪费过多的内存，使用压缩过的图片，也可以使用Fresco等库来优化对Bitmap显示的管理。</li>
<li>使用优化过的数据集合SparseArray代替HashMap，HashMap为每个键值都提供一个对象入口，使用SparseArray可以免去基本对象类型转换为引用数据类想的时间。</li>
</ol>
<h3 id="如果防止过度绘制，如何做布局优化？"><a href="#如果防止过度绘制，如何做布局优化？" class="headerlink" title="如果防止过度绘制，如何做布局优化？"></a>如果防止过度绘制，如何做布局优化？</h3><ol>
<li>使用include复用布局文件。</li>
<li>使用merge标签避免嵌套布局。</li>
<li>使用stub标签仅在需要的时候在展示出来。</li>
</ol>
<h3 id="如何提交代码质量？"><a href="#如何提交代码质量？" class="headerlink" title="如何提交代码质量？"></a>如何提交代码质量？</h3><ol>
<li>避免创建不必要的对象，尽可能避免频繁的创建临时对象，例如在for循环内，减少GC的次数。</li>
<li>尽量使用基本数据类型代替引用数据类型。</li>
<li>静态方法调用效率高于动态方法，也可以避免创建额外对象。</li>
<li>对于基本数据类型和String类型的常量要使用static final修饰，这样常量会在dex文件的初始化器中进行初始化，使用的时候可以直接使用。</li>
<li>多使用系统API，例如数组拷贝System.arrayCopy()方法，要比我们用for循环效率快9倍以上，因为系统API很多都是通过底层的汇编模式执行的，效率比较高。</li>
</ol>
<h3 id="有没有遇到64k问题，为什么，如何解决？"><a href="#有没有遇到64k问题，为什么，如何解决？" class="headerlink" title="有没有遇到64k问题，为什么，如何解决？"></a>有没有遇到64k问题，为什么，如何解决？</h3><ul>
<li>在DEX文件中，method、field、class等的个数使用short类型来做索引，即两个字节（65535），method、field、class等均有此限制。</li>
<li>APK在安装过程中会调用dexopt将DEX文件优化成ODEX文件，dexopt使用LinearAlloc来存储应用信息，关于LinearAlloc缓冲区大小，不同的版本经历了4M/8M/16M的限制，超出<br>缓冲区时就会抛出INSTALL_FAILED_DEXOPT错误。</li>
</ul>
<p>解决方案是Google的MultiDex方案，具体参见：<a href="https://developer.android.com/studio/build/multidex.html?hl=zh-cn" target="_blank" rel="noopener">配置方法数超过 64K 的应用</a>。</p>
<h3 id="MVC、MVP与MVVM之间的对比分析？"><a href="#MVC、MVP与MVVM之间的对比分析？" class="headerlink" title="MVC、MVP与MVVM之间的对比分析？"></a>MVC、MVP与MVVM之间的对比分析？</h3><p><img src="/media/15344137666593.png" alt=""></p>
<ul>
<li>MVC：PC时代就有的架构方案，在Android上也是最早的方案，Activity/Fragment这些上帝角色既承担了V的角色，也承担了C的角色，小项目开发起来十分顺手，大项目就会遇到<br>耦合过重，Activity/Fragment类过大等问题。</li>
<li>MVP：为了解决MVC耦合过重的问题，MVP的核心思想就是提供一个Presenter将视图逻辑I和业务逻辑相分离，达到解耦的目的。</li>
<li>MVVM：使用ViewModel代替Presenter，实现数据与View的双向绑定，这套框架最早使用的data-binding将数据绑定到xml里，这么做在大规模应用的时候是不行的，不过数据绑定是<br>一个很有用的概念，后续Google又推出了ViewModel组件与LiveData组件。ViewModel组件规范了ViewModel所处的地位、生命周期、生产方式以及一个Activity下多个Fragment共享View<br>Model数据的问题。LiveData组件则提供了在Java层面View订阅ViewModel数据源的实现方案。</li>
</ul>
<h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><h3 id="TCP与UDP有什么区别？"><a href="#TCP与UDP有什么区别？" class="headerlink" title="TCP与UDP有什么区别？"></a>TCP与UDP有什么区别？</h3><ol>
<li>TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接</li>
<li>TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付</li>
<li>TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）</li>
<li>每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信</li>
<li>TCP首部开销20字节;UDP的首部开销小，只有8个字节</li>
<li>TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道</li>
</ol>
<h3 id="简单介绍一下TCP三次握手与四次分手过程？"><a href="#简单介绍一下TCP三次握手与四次分手过程？" class="headerlink" title="简单介绍一下TCP三次握手与四次分手过程？"></a>简单介绍一下TCP三次握手与四次分手过程？</h3><p>TCP用<a href="https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE#建立通路" target="_blank" rel="noopener">三次握手</a>（three-way handshake）过程创建一个连接，使用四次分手<br>关闭一个连接。</p>
<p>三次握手与四次分手的流程如下所示：<br><img src="/media/15344126249396.jpg" alt=""></p>
<p>三次握手</p>
<ul>
<li>第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；</li>
<li>第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；</li>
<li>第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。<br>完成了三次握手，客户端和服务器端就可以开始传送数据。以上就是TCP三次握手的总体介绍。</li>
</ul>
<p>四次分手</p>
<ul>
<li>第一次分手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；</li>
<li>第二次分手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求；</li>
<li>第三次分手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；</li>
<li>第四次分手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。</li>
</ul>
<p>三次握手与四次分手也是个老生常谈的概念，举个简单的例子说明一下。</p>
<p>三次握手</p>
<blockquote>
<p>例如你小时候出去玩，经常玩忘了回家吃饭。你妈妈也经常过来喊你。如果你没有走远，在门口的小土堆上玩泥巴，你妈妈会喊：”小新，回家吃饭了”。你听到后会回应：”知道了，一会就回去”。妈妈听<br>到你的回应后又说：”快点回来，饭要凉了”。这样你妈妈和你就完成了三次握手的过程。😁说到这里你也可以理解三次握手的必要性，少了其中一个环节，另一方就会陷入等待之中。</p>
</blockquote>
<p>三次握手的目的是为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误.</p>
<p>四次分手</p>
<blockquote>
<p>例如偶像言情剧干净利落的分手，女主对男主说：我们分手吧🙄，男主说：分就分吧😰。女主说：你果然是不爱我了，你只知道让我多喝热水🙄。男主说：事到如今也没什么好说的了，祝你幸福🙃。四次分手完成。说到这里你可以理解<br>了四次分手的必要性，第一次是女方（客户端）提出分手，第二次是男主（服务端）同意女主分手，第三次是女主确定男主不再爱她，也同意男主分手。第四次两人彻底拜拜（断开连接）。</p>
</blockquote>
<p>因为TCP是全双工模式，所以四次分手的目的就是为了可靠地关闭连接。</p>
<h3 id="TCP如何保证数据传输的可靠性？"><a href="#TCP如何保证数据传输的可靠性？" class="headerlink" title="TCP如何保证数据传输的可靠性？"></a>TCP如何保证数据传输的可靠性？</h3><ol>
<li>确认和重传：接收方收到报文后就会进行确认，发送方一段时间没有收到确认就会重传。</li>
<li>数据校验。</li>
<li>数据合理分片与排序，TCP会对数据进行分片，接收方会缓存为按序到达的数据，重新排序后再提交给应用层。</li>
<li>流程控制：当接收方来不及接收发送的数据时，则会提示发送方降低发送的速度，防止包丢失。发送者的发送速度与接收者的接收能力相关。接收者会把它能接收的最大字节数（未使用的缓冲区大小，又叫接收窗口，receive window）告知发送者。发送者发送的最大字节数与接收者的接收窗口大小一致。</li>
<li>拥塞控制：当网络发生拥塞时，减少数据的发送。<br>阻塞窗口是不同于接收窗口的另一个概念，它通过限制网络中的数据流的体积来防止网络阻塞。类似于接收窗口，发送者通过通过一些算法（例如TCP Vegas，Westwood，BIC，CUBIC）来计算发送对应的接收者的阻塞窗口能容纳的最多的数据。和流量控制不同，阻塞控制只在发送方实现。（译注：发送者类似于通过ack时间之类的算法判断当前网络是否阻塞，从而调节发送速度<br>）<h3 id="HTTP与HTTPS有什么区别？"><a href="#HTTP与HTTPS有什么区别？" class="headerlink" title="HTTP与HTTPS有什么区别？"></a>HTTP与HTTPS有什么区别？</h3></li>
</ol>
<blockquote>
<p><a href="https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">HTTPS</a>是一种通过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，但利用SSL/TLS来加密数据包。HTTPS开发的主要目的，是提供对网站服务器的身份<br>认证，保护交换数据的隐私与完整性。</p>
</blockquote>
<p>如下图所示，可以很明显的看出两个的区别：<br><img src="https://github.com/guoxiaoxing/android-open-source-project-analysis/raw/master/art/practice/network/http_https.png" alt="image"></p>
<p>注：TLS是SSL的升级替代版，具体发展历史可以参考<a href="https://zh.wikipedia.org/wiki/%E5%82%B3%E8%BC%B8%E5%B1%A4%E5%AE%89%E5%85%A8%E6%80%A7%E5%8D%94%E5%AE%9A" target="_blank" rel="noopener">传输层安全性协议</a>。</p>
<p>HTTP与HTTPS在写法上的区别也是前缀的不同，客户端处理的方式也不同，具体说来：</p>
<ul>
<li>如果URL的协议是HTTP，则客户端会打开一条到服务端端口80（默认）的连接，并向其发送老的HTTP请求。</li>
<li>如果URL的协议是HTTPS，则客户端会打开一条到服务端端口443（默认）的连接，然后与服务器握手，以二进制格式与服务器交换一些SSL的安全参数，附上加密的<br>HTTP请求。</li>
</ul>
<p>所以你可以看到，HTTPS比HTTP多了一层与SSL的连接，这也就是客户端与服务端SSL握手的过程，整个过程主要完成以下工作：</p>
<ul>
<li>交换协议版本号</li>
<li>选择一个两端都了解的密码</li>
<li>对两端的身份进行认证</li>
<li>生成临时的会话密钥，以便加密信道。</li>
</ul>
<p>SSL握手是一个相对比较复杂的过程，更多关于SSL握手的过程细节可以参考<a href="https://www.wosign.com/faq/faq2016-0309-04.htm" target="_blank" rel="noopener">TLS/SSL握手过程</a></p>
<p>SSL/TSL的常见开源实现是OpenSSL，OpenSSL是一个开放源代码的软件库包，应用程序可以使用这个包来进行安全通信，避免窃听，同时确认另一端连接者的身份。这个包广泛被应用在互联网的网页服务器上。<br>更多源于OpenSSL的技术细节可以参考<a href="https://www.openssl.org/" target="_blank" rel="noopener">OpenSSL</a>。</p>
<p>caflow：<br><img src="/media/15322505795247.png" alt=""></p>
<p>https flow<br><img src="/media/15322505545935.png" alt=""></p>
<p>认证服务器。浏览器内置一个受信任的CA机构列表，并保存了这些CA机构的证书。第一阶段服务器会提供经CA机构认证颁发的服务器证书，如果认证该服务器证书的CA机构，存在于浏览器的受信任CA机构列表中，并且服务器证书中的信息与当前正在访问的网站（域名等）一致，那么浏览器就认为服务端是可信的，并从服务器证书中取得服务器公钥，用于后续流程。否则，浏览器将提示用户，根据用户的选择，决定是否继续。当然，我们可以管理这个受信任CA机构列表，添加我们想要信任的CA机构，或者移除我们不信任的CA机构。</p>
<p>协商会话密钥。客户端在认证完服务器，获得服务器的公钥之后，利用该公钥与服务器进行加密通信，协商出两个会话密钥，分别是用于加密客户端往服务端发送数据的客户端会话密钥，用于加密服务端往客户端发送数据的服务端会话密钥。在已有服务器公钥，可以加密通讯的前提下，还要协商两个对称密钥的原因，是因为非对称加密相对复杂度更高，在数据传输过程中，使用对称加密，可以节省计算资源。另外，会话密钥是随机生成，每次协商都会有不一样的结果，所以安全性也比较高。</p>
<p>加密通讯。此时客户端服务器双方都有了本次通讯的会话密钥，之后传输的所有Http数据，都通过会话密钥加密。这样网路上的其它用户，将很难窃取和篡改客户端和服务端之间传输的数据，从而保证了数据的私密性和完整性。</p>
<h3 id="谈一谈对HTTP缓存的理解？"><a href="#谈一谈对HTTP缓存的理解？" class="headerlink" title="谈一谈对HTTP缓存的理解？"></a>谈一谈对HTTP缓存的理解？</h3><p>HTTP的缓存机制也是依赖于请求和响应header里的参数类实现的，最终响应式从缓存中去，还是从服务端重新拉取，HTTP的缓存机制的流程如下所示：</p>
<p><img src="/media/15344126555791.jpg" alt=""></p>
<p>HTTP的缓存可以分为两种：</p>
<ul>
<li>强制缓存：需要服务端参与判断是否继续使用缓存，当客户端第一次请求数据是，服务端返回了缓存的过期时间（Expires与Cache-Control），没有过期就可以继续使用缓存，否则则不适用，无需再向服务端询问。</li>
<li>对比缓存：需要服务端参与判断是否继续使用缓存，当客户端第一次请求数据时，服务端会将缓存标识（Last-Modified/If-Modified-Since与Etag/If-None-Match）与数据一起返回给客户端，客户端将两者都备份到缓存中 ，再次请求数据时，客户端将上次备份的缓存<br>标识发送给服务端，服务端根据缓存标识进行判断，如果返回304，则表示通知客户端可以继续使用缓存。</li>
</ul>
<p>强制缓存优先于对比缓存。</p>
<p>上面提到强制缓存使用的的两个标识：</p>
<ul>
<li>Expires：Expires的值为服务端返回的到期时间，即下一次请求时，请求时间小于服务端返回的到期时间，直接使用缓存数据。到期时间是服务端生成的，客户端和服务端的时间可能有误差。</li>
<li>Cache-Control：Expires有个时间校验的问题，所有HTTP1.1采用Cache-Control替代Expires。</li>
</ul>
<p>Cache-Control的取值有以下几种：</p>
<ul>
<li>private:             客户端可以缓存。</li>
<li>public:              客户端和代理服务器都可缓存。</li>
<li>max-age=xxx:   缓存的内容将在 xxx 秒后失效</li>
<li>no-cache:          需要使用对比缓存来验证缓存数据。</li>
<li>no-store:           所有内容都不会缓存，强制缓存，对比缓存都不会触发。</li>
</ul>
<p>我们再来看看对比缓存的两个标识：</p>
<p><strong>Last-Modified/If-Modified-Since</strong></p>
<p>Last-Modified 表示资源上次修改的时间。</p>
<p>当客户端发送第一次请求时，服务端返回资源上次修改的时间：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Last-Modified: Tue, <span class="number">12</span> Jan <span class="number">2016</span> <span class="number">09</span>:<span class="number">31</span>:<span class="number">27</span> GMT</span><br></pre></td></tr></table></figure>
<p>客户端再次发送，会在header里携带If-Modified-Since。将上次服务端返回的资源时间上传给服务端。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-Modified-Since: Tue, <span class="number">12</span> Jan <span class="number">2016</span> <span class="number">09</span>:<span class="number">31</span>:<span class="number">27</span> GMT</span><br></pre></td></tr></table></figure>
<p>服务端接收到客户端发来的资源修改时间，与自己当前的资源修改时间进行对比，如果自己的资源修改时间大于客户端发来的资源修改时间，则说明资源做过修改，<br>则返回200表示需要重新请求资源，否则返回304表示资源没有被修改，可以继续使用缓存。</p>
<p>上面是一种时间戳标记资源是否修改的方法，还有一种资源标识码ETag的方式来标记是否修改，如果标识码发生改变，则说明资源已经被修改，ETag优先级高于Last-Modified。</p>
<p><strong>Etag/If-None-Match</strong></p>
<p>ETag是资源文件的一种标识码，当客户端发送第一次请求时，服务端会返回当前资源的标识码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ETag: <span class="string">"5694c7ef-24dc"</span></span><br></pre></td></tr></table></figure>
<p>客户端再次发送，会在header里携带上次服务端返回的资源标识码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-None-Match:<span class="string">"5694c7ef-24dc"</span></span><br></pre></td></tr></table></figure>
<p>服务端接收到客户端发来的资源标识码，则会与自己当前的资源吗进行比较，如果不同，则说明资源已经被修改，则返回200，如果相同则说明资源没有被修改，返回<br>304，客户端可以继续使用缓存。</p>
<h3 id="HTTPS是如何保证安全的，证书如何校验？"><a href="#HTTPS是如何保证安全的，证书如何校验？" class="headerlink" title="HTTPS是如何保证安全的，证书如何校验？"></a>HTTPS是如何保证安全的，证书如何校验？</h3><p><img src="/media/15344129031923.jpg" alt=""></p>
<h3 id="HTTP如何实现长连接？"><a href="#HTTP如何实现长连接？" class="headerlink" title="HTTP如何实现长连接？"></a>HTTP如何实现长连接？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection:keep-alive</span><br></pre></td></tr></table></figure>
<p>http1.1 之后 默认都是打开长连接的</p>
<h3 id="tcp可靠连接的精髓："><a href="#tcp可靠连接的精髓：" class="headerlink" title="tcp可靠连接的精髓："></a>tcp可靠连接的精髓：</h3><p>TCP连接的一方A，由操作系统动态随机选取一个32位长的序列号（Initial+Sequence+Number），假设A的初始序列号为1000，以该序列号为原点，对自己将要发送的每个字节的数据进行编号，1001，1002，1003…，并把自己的初始序列号ISN告诉B，让B有一个思想准备，什么样编号的数据是合法的，什么编号是非法的，比如编号900就是非法的，同时B还可以对A每一个编号的字节数据进行确认。如果A收到B确认编号为2001，则意味着字节编号为1001-2000，共1000个字节已经安全到达。+同理B也是类似的操作，假设B的初始序列号ISN为2000，以该序列号为原点，对自己将要发送的每个字节的数据进行编号，2001，2002，2003…，并把自己的初始序列号ISN告诉A，以便A可以确认B发送的每一个字节。如果B收到A确认编号为4001，则意味着字节编号为2001-4000，共2000个字节已经安全到达。</p>
<p>一句话概括，TCP连接握手，握的是啥？<strong>通信双方数据原点的序列号！</strong>以此核心思想我们来分析二、三、四次握手的过程。</p>
<h4 id="AB四次握手的过程："><a href="#AB四次握手的过程：" class="headerlink" title="AB四次握手的过程："></a>A<------->B四次握手的过程：</-------></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. A 发送同步信号SYN A’s Initial sequence number </span><br><span class="line">2. B 确认收到A的同步信号，并记录 A‘s ISN 到本地，命名 B’s ACK sequence number</span><br><span class="line">3. B发送同步信号SYN B‘s Initial sequence number </span><br><span class="line">4. A确认收到B的同步信号，并记录 B’s ISN 到本地，命名 A‘s ACK sequence number 很显然1.2和1.3 这两个步骤可以合并，只需要三次握手，可以提高连接的速度与效率。</span><br></pre></td></tr></table></figure>
<h4 id="二次握手的过程："><a href="#二次握手的过程：" class="headerlink" title="二次握手的过程："></a>二次握手的过程：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. A 发送同步信号SYN A’s Initial sequence number</span><br><span class="line">2. B发送同步信号SYN B‘s Initial sequence number  B’s ACK</span><br></pre></td></tr></table></figure>
<p><strong>sequence number</strong> 这里有一个问题，A与B就A的初始序列号达成了一致，这里是1000。但是B无法知道A是否已经接收到自己的同步信号，如果这个同步信号丢失了，A和B就B的初始序列号将无法达成一致。<br>于是TCP的设计者将SYN这个同步标志位SYN设计成占用一个字节的编号（FIN标志位也是），既然是一个字节的数据，按照TCP对有数据的TCP+segment+必须确认的原则，所以在这里A必须给B一个确认，以确认A已经接收到B的同步信号。 有童鞋会说，如果A发给B的确认丢了，该如何？</p>
<p>A会超时重传这个ACK吗？不会！<strong>TCP不会为没有数据的ACK超时重传</strong>。<br>那该如何是好？B如果没有收到A的ACK，会超时重传自己的SYN同步信号，一直到收到A的ACK为止。</p>
<hr>
<p>补充阅读：<br>第一个包，</p>
<p>即A发给B的SYN 中途被丢，没有到达B A会周期性超时重传，直到收到B的确认</p>
<p>第二个包，即B发给A的SYN BACK 中途被丢，没有到达A B会周期性超时重传，直到收到A的确认 </p>
<p>第三个包，即A发给B的ACK 中途被丢，没有到达B A发完ACK，单方面认为TCP为 Established状态，而B显然认为TCP为Active状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a. 假定此时双方都没有数据发送，B会周期性超时重传，直到收到A的确认，收到之后B的TCP 连接也为 Established状态，双向可以发包。</span><br><span class="line"></span><br><span class="line">b. 假定此时A有数据发送，B收到A的 Data+ACK，自然会切换为established 状态，并接受A的 Data。</span><br><span class="line"></span><br><span class="line">C. 假定b有数据发送，数据发送不了，会一直周期性超时重传SYN +ACK，直到收到A的确认才可以发送数据。</span><br></pre></td></tr></table></figure>
<p><img src="/media/15337062521498.png" alt=""></p>
<p> 应用层的数据不是直接发送给网卡的，</p>
<ol>
<li>linux系统有一个socket缓冲区，是一块物理内存，kernel将该物理地址的fd文件句柄透给用户空间，用户通过write（fd，stream）将二进制数字节流写入到socket缓冲区中，此时该数据片会被插入socket缓冲区的末尾，以保证数据的发送数据是先入先出的。</li>
<li>socket缓冲区会关联一个叫做TCB的结构体，该结构体中存放了TCP链接所需要的全部数据，包括接受窗口，阻塞窗口，发送序号，重发计数器等。</li>
<li>在tcp层，如果满足发射条件，就会创建tcp 分段，（tcp segment）发送出去，但也有可能因为流量控制策略，系统决定不发包，调用就此停止。</li>
<li>进入IP层，在TCP分段中加入了IP信息，并进行IP路由，IP路由的目的是查找为了到达目的IP的要跳转的下一级IP地址。</li>
<li>IP层增加了IP地址信息并进行IP路由之后，将数据发送到数据链路层，此时进行ARP获取目的地的mac地址信息。然后在数据端增加链路头信息。至此 tcp段的数据便是完整的了。<ol start="6">
<li>在接收到数据包传输请求之后，NIC把数据包从系统内存中拷贝到它自己的内存中，之后把数据包发送到网络上。在此时，由于要遵守以太网标准（Ethernet standard），NIC会向数据包中增加帧间隙（Inter-Frame Gap，IFG），同步码（preamble）和crc校验</li>
</ol>
</li>
</ol>
<h4 id="所谓的长连接和短连接"><a href="#所谓的长连接和短连接" class="headerlink" title="所谓的长连接和短连接"></a>所谓的长连接和短连接</h4><p> 对于HTTP 1.0的http标准而言，默认连接是短连接，啥叫短连接？就是服务器当发送完最后一个字节的数据之后将关闭连接，也就是回收tcp_sock结构，这样，如果客户端再发送数据给服务器，将直接丢弃。即使此时客户端还有这样的结构，但是我们说连接已经关闭或者已经断了。<br>那客户端知不知道啥时候服务器的连接关闭？不知道，双方可以在任何时候来关闭自己的连接而没有必要通知对方。不过，对于短连接而言，通知不通知也没有意义了。</p>
<p>那短连接的弊端，大家可能都已经知道了，如果对一个服务器要连续发送多个请求，还需要为每次请求建立新的连接。</p>
<p>为了降低建立连接的时间，HTTP 1.1引入了长连接的概念，并把它搞成了默认的连接方式。啥叫长连接？就是当完成一个业务之后，socket结构并不回收。这样，只要在socket结构还存在的时候，客户端发送的任何数据，服务器都可以收到，这就是所谓的长连接。</p>
<p>相比短连接而言，长连接并没有什么特别的新的技术，只是维护socket结构时间长了。因为，说http长连接更不如说是tcp长连接。 网卡会自动从该缓冲区取数据，在tcp层，首先通过write函数，</p>
<h4 id="websocket"><a href="#websocket" class="headerlink" title="websocket"></a>websocket</h4><p>2、数据帧格式详解<br>针对前面的格式概览图，这里逐个字段进行讲解，如有不清楚之处，可参考协议规范，或留言交流。</p>
<p><strong>FIN：1个比特。</strong></p>
<p>如果是1，表示这是消息（message）的最后一个分片（fragment），如果是0，表示不是是消息（message）的最后一个分片（fragment）。</p>
<p><strong>RSV1, RSV2, RSV3：各占1个比特。</strong></p>
<p>一般情况下全为0。当客户端、服务端协商采用WebSocket扩展时，这三个标志位可以非0，且值的含义由扩展进行定义。如果出现非零的值，且并没有采用WebSocket扩展，连接出错。</p>
<p><strong>Opcode: 4个比特。</strong></p>
<p>操作代码，Opcode的值决定了应该如何解析后续的数据载荷（data payload）。如果操作代码是不认识的，那么接收端应该断开连接（fail the connection）。可选的操作代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">%x0：表示一个延续帧。当Opcode为0时，表示本次数据传输采用了数据分片，当前收到的数据帧为其中一个数据分片。</span><br><span class="line">%x1：表示这是一个文本帧（frame）</span><br><span class="line">%x2：表示这是一个二进制帧（frame）</span><br><span class="line">%x3-7：保留的操作代码，用于后续定义的非控制帧。</span><br><span class="line">%x8：表示连接断开。</span><br><span class="line">%x9：表示这是一个ping操作。</span><br><span class="line">%xA：表示这是一个pong操作。</span><br><span class="line">%xB-F：保留的操作代码，用于后续定义的控制帧。</span><br><span class="line">Mask: 1个比特。</span><br></pre></td></tr></table></figure>
<p>表示是否要对数据载荷进行掩码操作。从客户端向服务端发送数据时，需要对数据进行掩码操作；从服务端向客户端发送数据时，不需要对数据进行掩码操作。</p>
<p>如果服务端接收到的数据没有进行过掩码操作，服务端需要断开连接。</p>
<p>如果Mask是1，那么在Masking-key中会定义一个掩码键（masking key），并用这个掩码键来对数据载荷进行反掩码。所有客户端发送到服务端的数据帧，Mask都是1。</p>
<p>掩码的算法、用途在下一小节讲解。</p>
<p><strong>Payload length</strong>：数据载荷的长度，单位是字节。为7位，或7+16位，或1+64位。</p>
<p>假设数Payload length === x，如果</p>
<p>x为0~126：数据的长度为x字节。<br>x为126：后续2个字节代表一个16位的无符号整数，该无符号整数的值为数据的长度。<br>x为127：后续8个字节代表一个64位的无符号整数（最高位为0），该无符号整数的值为数据的长度。<br>此外，如果payload length占用了多个字节的话，payload length的二进制表达采用网络序（big endian，重要的位在前）。</p>
<p><strong>Masking-key</strong>：0或4字节（32位）</p>
<p>所有从客户端传送到服务端的数据帧，数据载荷都进行了掩码操作，Mask为1，且携带了4字节的Masking-key。如果Mask为0，则没有Masking-key。</p>
<p>备注：载荷数据的长度，不包括mask key的长度。</p>
<p><strong>Payload data</strong>：(x+y) 字节</p>
<p>载荷数据：包括了扩展数据、应用数据。其中，扩展数据x字节，应用数据y字节。</p>
<p>扩展数据：如果没有协商使用扩展的话，扩展数据数据为0字节。所有的扩展都必须声明扩展数据的长度，或者可以如何计算出扩展数据的长度。此外，扩展如何使用必须在握手阶段就协商好。如果扩展数据存在，那么载荷数据长度必须将扩展数据的长度包含在内。</p>
<p>应用数据：任意的应用数据，在扩展数据之后（如果存在扩展数据），占据了数据帧剩余的位置。载荷数据长度 减去 扩展数据长度，就得到应用数据的长度。</p>
<h4 id="3、掩码算法"><a href="#3、掩码算法" class="headerlink" title="3、掩码算法"></a>3、掩码算法</h4><p>掩码键（Masking-key）是由客户端挑选出来的32位的随机数。掩码操作不会影响数据载荷的长度。掩码、反掩码操作都采用如下算法：</p>
<p>首先，假设：</p>
<p>original-octet-i：为原始数据的第i字节。<br>transformed-octet-i：为转换后的数据的第i字节。<br>j：为i mod 4的结果。<br>masking-key-octet-j：为mask key第j字节。<br>算法描述为： original-octet-i 与 masking-key-octet-j 异或后，得到 transformed-octet-i。</p>
<p>j = i MOD 4<br>transformed-octet-i = original-octet-i XOR masking-key-octet-j</p>
<h4 id="六、数据传递"><a href="#六、数据传递" class="headerlink" title="六、数据传递"></a>六、数据传递</h4><p>一旦WebSocket客户端、服务端建立连接后，后续的操作都是基于数据帧的传递。</p>
<p>WebSocket根据opcode来区分操作的类型。比如0x8表示断开连接，0x0-0x2表示数据交互。</p>
<p>1、数据分片<br>WebSocket的每条消息可能被切分成多个数据帧。当WebSocket的接收方收到一个数据帧时，会根据FIN的值来判断，是否已经收到消息的最后一个数据帧。</p>
<p>FIN=1表示当前数据帧为消息的最后一个数据帧，此时接收方已经收到完整的消息，可以对消息进行处理。FIN=0，则接收方还需要继续监听接收其余的数据帧。</p>
<p>此外，opcode在数据交换的场景下，表示的是数据的类型。0x01表示文本，0x02表示二进制。而0x00比较特殊，表示延续帧（continuation frame），顾名思义，就是完整消息对应的数据帧还没接收完。</p>
<p>2、数据分片例子<br>直接看例子更形象些。下面例子来自MDN，可以很好地演示数据的分片。客户端向服务端两次发送消息，服务端收到消息后回应客户端，这里主要看客户端往服务端发送的消息。</p>
<p>第一条消息</p>
<p>FIN=1, 表示是当前消息的最后一个数据帧。服务端收到当前数据帧后，可以处理消息。opcode=0x1，表示客户端发送的是文本类型。</p>
<p>第二条消息</p>
<p>FIN=0，opcode=0x1，表示发送的是文本类型，且消息还没发送完成，还有后续的数据帧。<br>FIN=0，opcode=0x0，表示消息还没发送完成，还有后续的数据帧，当前的数据帧需要接在上一条数据帧之后。<br>FIN=1，opcode=0x0，表示消息已经发送完成，没有后续的数据帧，当前的数据帧需要接在上一条数据帧之后。服务端可以将关联的数据帧组装成完整的消息。<br>Client: FIN=1, opcode=0x1, msg=”hello”<br>Server: (process complete message immediately) Hi.<br>Client: FIN=0, opcode=0x1, msg=”and a”<br>Server: (listening, new message containing text started)<br>Client: FIN=0, opcode=0x0, msg=”happy new”<br>Server: (listening, payload concatenated to previous message)<br>Client: FIN=1, opcode=0x0, msg=”year!”<br>Server: (process complete message) Happy new year to you too!</p>
<h5 id="七、连接保持-心跳"><a href="#七、连接保持-心跳" class="headerlink" title="七、连接保持+心跳"></a>七、连接保持+心跳</h5><p>WebSocket为了保持客户端、服务端的实时双向通信，需要确保客户端、服务端之间的TCP通道保持连接没有断开。然而，对于长时间没有数据往来的连接，如果依旧长时间保持着，可能会浪费包括的连接资源。</p>
<p>但不排除有些场景，客户端、服务端虽然长时间没有数据往来，但仍需要保持连接。这个时候，可以采用心跳来实现。</p>
<p>发送方-&gt;接收方：ping<br>接收方-&gt;发送方：pong<br>ping、pong的操作，对应的是WebSocket的两个控制帧，opcode分别是0x9、0xA。</p>
<p>举例，WebSocket服务端向客户端发送ping，只需要如下代码（采用ws模块）</p>
<p>ws.ping(‘’, false, true);</p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://wenyiqingnian.xyz/2018/08/16/一些知识点总结/" data-id="cjqw00e1q005fvtfyewd3s8n7" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    
        <a href="http://wenyiqingnian.xyz/2018/08/16/一些知识点总结/#comments" class="article-comment-link">Comments</a>
    

        </footer>
    </div>
    
</article>



    <article id="post-从一次native端的IPC流程理解binder" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2018/06/24/从一次native端的IPC流程理解binder/">从一次native端的IPC流程理解binder</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2018/06/24/从一次native端的IPC流程理解binder/">
            <time datetime="2018-06-24T11:00:50.000Z" itemprop="datePublished">2018-06-24</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/Android/">Android</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/Binder/">Binder</a>, <a class="tag-link" href="/tags/android/">android</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>本文是看完邓凡平的《深入理解android卷1》第六章的binder篇后，在此基础上的一些个人理解。<br>上文从驱动角度解释了<code>binder</code>通讯机制的底层运行原理，我们知道android系统中，<code>binder</code>是采用CS架构来设计的，除了<code>binderDriver</code>之外，还需要<code>client</code> <code>server</code> 以及<code>serviceManager</code> 三个角色，才能完整实现一套CS架构的跨进程通讯机制。<br><img src="/media/15298368998935.jpg" alt=""></p>
<p>从上图可以看到，一次完整的IPC 至少需要这么几个步骤</p>
<ol>
<li><code>Server</code> 通过<code>serviceManager</code> 注册服务</li>
<li><code>Client</code> 通过<code>ServiceManager</code> 查询服务</li>
<li><code>Client</code> 获取到<code>Server</code>端的服务后，通过<code>binder</code>驱动，完成跨进程对<code>Server</code>端的引用。<br>下面以native层的一次IPC请求流程为例，通过client对MediaServer的调用，了解一下<code>client</code>、<code>server</code>、<code>serviceManager</code>三者之间的通讯过程。</li>
</ol>
<h1 id="server端：MediaServer"><a href="#server端：MediaServer" class="headerlink" title="server端：MediaServer"></a>server端：MediaServer</h1><p><code>MediaServer</code> 是系统主要<code>server</code>之一，它提供了</p>
<ol>
<li>AudioFlinger</li>
<li>AudioPolicyService</li>
<li>MediaplayerService</li>
<li>CamerService<br>四个重量级服务，查看<code>MediaServer</code>的源码：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//①获得一个ProcessState实例</span></span><br><span class="line"> sp&lt;ProcessState&gt;proc(ProcessState::self());</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//②MS作为ServiceManager的客户端，需要向ServiceManger注册服务</span></span><br><span class="line"> <span class="comment">//调用defaultServiceManager，得到一个IServiceManager。</span></span><br><span class="line"> sp&lt;IServiceManager&gt;sm = defaultServiceManager();</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//初始化音频系统的AudioFlinger服务</span></span><br><span class="line"> AudioFlinger::instantiate();</span><br><span class="line"> <span class="comment">//③多媒体系统的MediaPlayer服务，我们将以它作为主切入点</span></span><br><span class="line"> MediaPlayerService::instantiate();</span><br><span class="line"> <span class="comment">//CameraService服务</span></span><br><span class="line"> CameraService::instantiate();</span><br><span class="line"> <span class="comment">//音频系统的AudioPolicy服务</span></span><br><span class="line"> AudioPolicyService::instantiate();</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//④新建一个用以处理binder请求的线程</span></span><br><span class="line"> ProcessState::self()-&gt;startThreadPool();</span><br><span class="line"> <span class="comment">//⑤将主线程也用来处理binder请求</span></span><br><span class="line"> IPCThreadState::self()-&gt;joinThreadPool();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以代码中标注的1，2，3，4，5为次序，依次讲解每个部分的具体内容。</p>
<h2 id="一、创建ProcessState"><a href="#一、创建ProcessState" class="headerlink" title="一、创建ProcessState"></a>一、创建ProcessState</h2><p>还是先看代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//①获得一个ProcessState实例</span></span><br><span class="line">sp&lt;ProcessState&gt;proc(ProcessState::self());</span><br></pre></td></tr></table></figure>
<p>创建ProcessState实例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;ProcessState&gt; ProcessState::self()</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//gProcess是在Static.cpp中定义的一个全局变量</span></span><br><span class="line">   <span class="comment">//程序刚开始执行，gProcess一定为空</span></span><br><span class="line">    <span class="keyword">if</span>(gProcess != <span class="literal">NULL</span>) <span class="keyword">return</span> gProcess;</span><br><span class="line">        AutoMutex_l(gProcessMutex);</span><br><span class="line">     <span class="comment">//创建一个ProcessState对象，并赋值给gProcess</span></span><br><span class="line">    <span class="keyword">if</span>(gProcess == <span class="literal">NULL</span>) gProcess = <span class="keyword">new</span> ProcessState;</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">return</span> gProcess;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-processState-的构造函数"><a href="#1-processState-的构造函数" class="headerlink" title="1 processState 的构造函数"></a>1 processState 的构造函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">ProcessState::ProcessState()</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    【笔记一：】</span></span><br><span class="line"><span class="comment">    注意 在构造ProcessState时，通过open_driver()函数 打开了binder驱动，并将binder驱动的</span></span><br><span class="line"><span class="comment">    fd赋值给了ProcessState的mDriverFD 成员变量。后面我们可以看到一个与ProcessState对应的</span></span><br><span class="line"><span class="comment">    IPCThreadState对象（它是线程单例），它的构造函数会以ProcessState做参数，ProcessState持</span></span><br><span class="line"><span class="comment">    有Binder驱动的句柄，所以IPCThreadState可以操作Binder驱动，事实上，IPCThread也就是循环</span></span><br><span class="line"><span class="comment">    读写binder驱动，从中拿消息并处理消息的。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    :mDriverFD(open_driver())</span><br><span class="line">    ,mVMStart(MAP_FAILED)<span class="comment">//映射内存的起始地址</span></span><br><span class="line">    ,mManagesContexts(<span class="literal">false</span>)</span><br><span class="line">    ,mBinderContextCheckFunc(<span class="literal">NULL</span>)</span><br><span class="line">    , mBinderContextUserData(<span class="literal">NULL</span>)</span><br><span class="line">    ,mThreadPoolStarted(<span class="literal">false</span>)</span><br><span class="line">    ,mThreadPoolSeq(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(mDriverFD &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    BIDNER_VM_SIZE定义为(1*1024*1024) - (4096 *2) = 1M-8K</span></span><br><span class="line"><span class="comment">    【笔记二：】</span></span><br><span class="line"><span class="comment">    上文驱动篇讲过，用户空间调用驱动的mmap，实际对应驱动层的binder_mmap()方法，</span></span><br><span class="line"><span class="comment">    在该方法里，binder驱动会申请一块用来存储通信数据的内存区域，其实就是binder驱动中一个叫做</span></span><br><span class="line"><span class="comment">    binder_buff的结构体。同时会在server进程的用户空间和内核空间做一次虚拟地址映射。这是为什么 </span></span><br><span class="line"><span class="comment">    binder通讯只进行一次拷贝的原因，上文已讲过这里不再详述。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  mVMStart = mmap(<span class="number">0</span>, BINDER_VM_SIZE, PROT_READ,MAP_PRIVATE | MAP_NORESERVE,</span><br><span class="line">                     mDriverFD, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>processState</code> 是个单例对象，因为它是在程序运行时只初始化一次，所以每个进程只有一个<code>ProcessState</code>对象。在创建<code>ProcessState</code>时，做了这么几件事情</p>
<ol>
<li>打开<code>binder</code>驱动</li>
<li>映射内存起始地址</li>
<li>为<code>binder</code>驱动分配内存用以接受请求数据<h3 id="2-打开binder驱动（open-driver-）"><a href="#2-打开binder驱动（open-driver-）" class="headerlink" title="2 打开binder驱动（open_driver()）"></a>2 打开binder驱动（open_driver()）</h3><strong>ProcessState.cpp</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">open_driver</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd =open(<span class="string">"/dev/binder"</span>, O_RDWR);<span class="comment">//打开/dev/binder设备</span></span><br><span class="line">    <span class="keyword">if</span> (fd&gt;= <span class="number">0</span>) &#123;</span><br><span class="line">         ......</span><br><span class="line">       <span class="keyword">size_t</span> maxThreads = <span class="number">15</span>;</span><br><span class="line">       <span class="comment">//通过ioctl方式告诉binder驱动，这个fd支持的最大线程数是15个</span></span><br><span class="line">       result = ioctl(fd, BINDER_SET_MAX_THREADS, &amp;maxThreads);  </span><br><span class="line">   &#125;</span><br><span class="line"><span class="keyword">return</span> fd;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【笔记三：】<br>上文已经说过，<code>open(&#39;dev/binder&#39;,O_RDWR)</code> 其实对应了内核中<code>binder</code>驱动的<code>binder_open（）</code>方法，<br><code>binder_open()</code>的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_open</span><span class="params">(struct inode *nodp, struct file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span>;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 创建进程对应的binder_proc对象 </span></span><br><span class="line">	proc = kzalloc(<span class="keyword">sizeof</span>(*proc), GFP_KERNEL); </span><br><span class="line">	<span class="keyword">if</span> (proc == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	get_task_struct(current);</span><br><span class="line">	proc-&gt;tsk = current;</span><br><span class="line">	<span class="comment">// 初始化binder_proc</span></span><br><span class="line">	INIT_LIST_HEAD(&amp;proc-&gt;todo);</span><br><span class="line">	init_waitqueue_head(&amp;proc-&gt;wait);</span><br><span class="line">	proc-&gt;default_priority = task_nice(current);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 锁保护</span></span><br><span class="line">	binder_lock(__func__);</span><br><span class="line"></span><br><span class="line">	binder_stats_created(BINDER_STAT_PROC);</span><br><span class="line">	<span class="comment">// 添加到全局列表binder_procs中</span></span><br><span class="line">	hlist_add_head(&amp;proc-&gt;proc_node, &amp;binder_procs);</span><br><span class="line">	proc-&gt;pid = current-&gt;group_leader-&gt;pid;</span><br><span class="line">	INIT_LIST_HEAD(&amp;proc-&gt;delivered_death);</span><br><span class="line">	filp-&gt;private_data = proc;</span><br><span class="line"></span><br><span class="line">	binder_unlock(__func__);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在打开<code>binder</code>驱动时，<code>binder_procs</code>会将所有打开<code>binder</code>驱动的进程加入到该列表中。<br>同时，通过<code>ioctrl</code> 的方式 告诉了<code>binder</code> 驱动 当前<code>server</code>端线程池支持的最大线程数是15.</p>
<p>所以创建<code>processState</code>的过程 其实做了这么几件事：</p>
<ol>
<li>打开<code>binder</code>驱动 同时驱动为该进程创建对应的<code>binder_proc</code> 节点 </li>
<li>对返回的<code>fd</code> 使用<code>mmap</code>方法，操作<code>binder</code>驱动，<code>binder</code>驱动申请了一块内存来接受通讯数据</li>
<li>因为<code>ProcessState</code>是进程单例的，每个进程只会开启<code>binder</code>驱动一次。</li>
</ol>
<h2 id="二、-获取servicManager"><a href="#二、-获取servicManager" class="headerlink" title="二、 获取servicManager"></a>二、 获取servicManager</h2><p><code>defaultServiceManager()</code>方法在<code>IServiceManager.cpp</code>中定义，返回<code>IServiceManager</code>对象，先看一下这个方法的具体实现<br><strong>IServiceManager.cpp</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> sp&lt;IServiceManager&gt; defaultServiceManager()</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 单例实现</span></span><br><span class="line">    <span class="keyword">if</span>(gDefaultServiceManager != <span class="literal">NULL</span>) <span class="keyword">return</span> gDefaultServiceManager;</span><br><span class="line">     &#123;</span><br><span class="line">       AutoMutex _l(gDefaultServiceManagerLock);</span><br><span class="line">        <span class="keyword">if</span>(gDefaultServiceManager == <span class="literal">NULL</span>) &#123;</span><br><span class="line">          <span class="comment">//真正的gDefaultServiceManager是在这里创建的。</span></span><br><span class="line">           gDefaultServiceManager = interface_cast&lt;IServiceManager&gt;(</span><br><span class="line">                                   ProcessState::self()-&gt;getContextObject(<span class="literal">NULL</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   returngDefaultServiceManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到 真正的<code>IServiceManager</code> 是由方法 <code>interface_cast&lt;IServiceManager&gt;（）</code> 传入一个 <code>ProcessState::self()-&gt;getContextObject(NULL)</code>对象实现的。<br>先看一下<code>ProcessState::self()</code>的<code>getContextObject()</code>函数<br><strong>ProcessState.cpp</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;IBinder&gt;ProcessState::getContextObject(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; caller)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    caller的值为0！注意，该函数返回的是IBinder。它是什么？我们后面再说。</span></span><br><span class="line"><span class="comment">    supportsProcesses函数根据openDriver函数打开设备是否成功来判断是否支持process</span></span><br><span class="line"><span class="comment">    真实设备肯定支持process。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span>(supportsProcesses()) &#123;</span><br><span class="line">   <span class="comment">//真实设备上肯定是支持进程的，所以会调用下面这个函数</span></span><br><span class="line">   <span class="comment">//【笔记三：传的参数是null 所以handle号是0】</span></span><br><span class="line">       <span class="keyword">return</span> getStrongProxyForHandle(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> getContextObject(String16(<span class="string">"default"</span>), caller);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续看<code>getStrongProxyForHandle()</code></p>
<p><strong>ProcessState.cpp</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;IBinder&gt;ProcessState::getStrongProxyForHandle(<span class="keyword">int32_t</span> handle)</span><br><span class="line">&#123;</span><br><span class="line">   sp&lt;IBinder&gt; result;</span><br><span class="line"> AutoMutex_l(mLock);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    根据索引查找对应资源。如果lookupHandleLocked发现没有对应的资源项，则会创建一个新的项并返   </span></span><br><span class="line"><span class="comment">    回。</span></span><br><span class="line"><span class="comment">    这个新项的内容需要填充。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   handle_entry* e = lookupHandleLocked(handle);</span><br><span class="line">    <span class="keyword">if</span> (e !=<span class="literal">NULL</span>) &#123;</span><br><span class="line">       IBinder* b = e-&gt;binder;</span><br><span class="line">        <span class="keyword">if</span> (b== <span class="literal">NULL</span> || !e-&gt;refs-&gt;attemptIncWeak(<span class="keyword">this</span>)) &#123;</span><br><span class="line">           <span class="comment">//对于新创建的资源项，它的binder为空，所以走这个分支。注意，handle的值为0</span></span><br><span class="line">            b= <span class="keyword">new</span> BpBinder(handle); <span class="comment">//创建一个BpBinder</span></span><br><span class="line">           e-&gt;binder = b; <span class="comment">//填充entry的内容</span></span><br><span class="line">           <span class="keyword">if</span> (b) e-&gt;refs = b-&gt;getWeakRefs();</span><br><span class="line">           result = b;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           result.force_set(b);</span><br><span class="line">           e-&gt;refs-&gt;decWeak(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    returnresult; <span class="comment">//返回BpBinder(handle)，注意，handle的值为0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到 实际返回的对象是一个<code>BpBinder</code>，<code>BpBinder</code>里持有一个<code>handle</code>成员变量。<br>实际上 <code>BpBinder</code> <code>BBinder</code> 都是继承自<code>IBinder</code>的。<br><img src="/media/15298408964173.jpg" alt=""></p>
<p>从名字也可以看出来，<code>BpBinder</code> ,BProxy（proxy:代理），肯定是与客户端打交道的。如果说<code>Proxy</code>代表客户端，那么<code>BBinder</code>则代表服务端。这里的<code>BpBinder</code>和<code>BBinder</code>是一一对应的，即某个<code>BpBinder</code>只能和对应的<code>BBinder</code>交互。我们当然不希望通过<code>BpBinderA</code>发送的请求，却由<code>BBinderB</code>来处理。<br>刚才我们在<code>defaultServiceManager()</code>函数中创建了这个<code>BpBinder</code>。<br>前面说了，<code>BpBinder</code>和<code>BBinder</code>是一一对应的，那么<code>BpBinder</code>如何标识它所对应的<code>BBinder</code>端呢？<br>答案是<code>Binder</code>系统通过<code>handler</code>来对应<code>BBinder</code>。以后我们会确认这个<code>Handle</code>值的作用。</p>
<blockquote>
<p>注：我们给BpBinder构造函数传的参数handle的值是0。这个0在整个Binder系统中有重要含义—因为0代表的就是ServiceManager所对应的BBinder。</p>
</blockquote>
<p>详细看一下<code>BpBinder</code>的实现</p>
<h3 id="1-BpBinder-cpp"><a href="#1-BpBinder-cpp" class="headerlink" title="1. BpBinder.cpp"></a>1. BpBinder.cpp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">BpBinder::BpBinder(<span class="keyword">int32_t</span> handle)</span><br><span class="line">    :mHandle(handle)<span class="comment">//handle是0</span></span><br><span class="line">    ,mAlive(<span class="number">1</span>)</span><br><span class="line">    ,mObitsSent(<span class="number">0</span>)</span><br><span class="line">    ,mObituaries(<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">   extendObjectLifetime(OBJECT_LIFETIME_WEAK);</span><br><span class="line">   <span class="comment">//另一个重要对象是IPCThreadState，我们稍后会详细讲解。</span></span><br><span class="line">   IPCThreadState::self()-&gt;incWeakHandle(handle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看上面的代码，会觉得<code>BpBinder</code>确实简单，不过再仔细查看，你或许会发现，<code>BpBinder</code>、<code>BBinder</code>这两个类没有任何地方操作<code>ProcessState</code>打开的那个<code>/dev/binder</code>设备，换言之，<strong>这两个Binder类没有和binder设备直接交互</strong>。那为什么说<code>BpBinder</code>会与通信相关呢? 我们接着看<code>interface_cast（）</code>函数</p>
<p>我们是从下面这个函数开始分析的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gDefaultServiceManager =interface_cast&lt;IServiceManager&gt;( ProcessState::self()-&gt;getContextObject(<span class="literal">NULL</span>));</span><br></pre></td></tr></table></figure>
<p>现在这个函数调用将变成如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gDefaultServiceManager =interface_cast&lt;IServiceManager&gt;(<span class="keyword">new</span> BpBinder(<span class="number">0</span>));</span><br></pre></td></tr></table></figure>
<p>这里出现了一个<code>interface_cast</code>。它是什么？其实是一个障眼法！下面就来具体分析它。</p>
<h3 id="2-障眼法——interface-cast"><a href="#2-障眼法——interface-cast" class="headerlink" title="2. 障眼法——interface_cast"></a>2. 障眼法——interface_cast</h3><p>看看<code>interface_cast</code>的具体实现，其代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">IInterface.h</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> INTERFACE&gt;</span><br><span class="line"><span class="keyword">inline</span> sp&lt;INTERFACE&gt; interface_cast(constsp&lt;IBinder&gt;&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">    returnINTERFACE::asInterface(obj);</span><br><span class="line">&#125;</span><br><span class="line">哦，仅仅是一个模板函数，所以interface_cast()等价于：</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> sp&lt;IServiceManager&gt;interface_cast(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> IServiceManager::asInterface(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>又转移到<strong>IServiceManager</strong>对象中去了，还原完模板函数，可以看到<code>interface_cast（）</code>实际调用的是<code>IServiceManager</code>中的<code>asInterface()</code> 方法，该方法传入了上文所说的<code>BpBinder</code>对象。看一下<code>IServiceManager（）</code>中做了什么操作</p>
<h3 id="3-IServiceManager"><a href="#3-IServiceManager" class="headerlink" title="3. IServiceManager"></a>3. IServiceManager</h3><p>刚才提到，<code>IBinder</code>家族的<code>BpBinder</code>和<code>BBinder</code>是与通信业务相关的，那么业务层的逻辑又是如何巧妙地架构在<code>Binder</code>机制上的呢？关于这些问题，可以用一个绝好的例子来解释，它就是<code>IServiceManager</code>。</p>
<blockquote>
<p>【笔记四：】 <code>IServiceManager</code>对象其实可以当做java中的接口函数来理解。它定义在<code>IServiceManager.h</code> 中，描述了<code>ServiceManager</code>可以提供的服务。</p>
</blockquote>
<h4 id="（1）定义业务逻辑"><a href="#（1）定义业务逻辑" class="headerlink" title="（1）定义业务逻辑"></a>（1）定义业务逻辑</h4><p>先回答第一个问题：如何表述应用的业务层逻辑。可以先分析一下<code>IServiceManager</code>是怎么做的。IServiceManager定义了<code>ServiceManager</code>所提供的服务，看它的定义可知，其中有很多有趣的内容。<code>IServiceManager</code>定义在<code>IServiceManager.h</code>中，代码如下所示：<br><strong>IServiceManager.h</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IServiceManager</span> :</span> <span class="keyword">public</span> IInterface</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">   <span class="comment">//关键无比的宏！</span></span><br><span class="line">   DECLARE_META_INTERFACE(ServiceManager);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//下面是ServiceManager所提供的业务函数</span></span><br><span class="line">    virtualsp&lt;IBinder&gt;    getService( constString16&amp; name) <span class="keyword">const</span> = <span class="number">0</span>;</span><br><span class="line">    virtualsp&lt;IBinder&gt;    checkService( constString16&amp; name) <span class="keyword">const</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtualstatus_t</span>        addService( <span class="keyword">const</span> String16&amp; name,</span><br><span class="line">                                               <span class="keyword">const</span> sp&lt;IBinder&gt;&amp;service) = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> Vector&lt;String16&gt;    listServices() = <span class="number">0</span>;</span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="（2）业务与通信的挂钩"><a href="#（2）业务与通信的挂钩" class="headerlink" title="（2）业务与通信的挂钩"></a>（2）业务与通信的挂钩</h4><p>Android巧妙地通过<code>DECLARE_META_INTERFACE</code>和<code>IMPLENT_META_INTERFACE</code>宏，将业务和通信牢牢地钩在了一起。<code>DECLARE_META_INTERFACE</code>和<code>IMPLEMENT_META_INTERFACE</code>这两个宏都定义在刚才的<code>IInterface.h</code>中。先看<code>DECLARE_META_INTERFACE</code>这个宏，如下所示：<br><strong>IInterface.h::DECLARE_META_INTERFACE</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DECLARE_META_INTERFACE(INTERFACE)                               \</span></span><br><span class="line">    staticconst android::String16 descriptor;                          \</span><br><span class="line">    staticandroid::sp&lt;I##INTERFACE&gt; asInterface(                       \</span><br><span class="line">           <span class="keyword">const</span> android::sp&lt;android::IBinder&gt;&amp; obj);                  \</span><br><span class="line">    virtualconst android::<span class="function">String16&amp; <span class="title">getInterfaceDescriptor</span><span class="params">()</span> <span class="keyword">const</span></span>;    \</span><br><span class="line">   I##INTERFACE();                                                    \</span><br><span class="line">    <span class="keyword">virtual</span>~I##INTERFACE();</span><br></pre></td></tr></table></figure>
<p>将IServiceManager的<code>DELCARE</code>宏进行相应的替换后得到的代码如下所示：<br><code>DECLARE_META_INTERFACE(IServiceManager)</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个描述字符串</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> android::String16 descriptor;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//定义一个asInterface函数</span></span><br><span class="line"><span class="keyword">static</span> android::sp&lt; IServiceManager &gt;</span><br><span class="line">asInterface(constandroid::sp&lt;android::IBinder&gt;&amp; obj)</span><br><span class="line"> </span><br><span class="line"><span class="comment">//定义一个getInterfaceDescriptor函数，估计就是返回descriptor字符串</span></span><br><span class="line"><span class="keyword">virtual</span> <span class="keyword">const</span> android::<span class="function">String16&amp;<span class="title">getInterfaceDescriptor</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//定义IServiceManager的构造函数和析构函数</span></span><br><span class="line">IServiceManager ();                                                   </span><br><span class="line"><span class="keyword">virtual</span> ~IServiceManager();</span><br></pre></td></tr></table></figure>
<p><code>DECLARE</code>宏声明了一些函数和一个变量，那么，<code>IMPLEMENT</code>宏的作用肯定就是定义它们了。<code>IMPLEMENT</code>的定义在<code>IInterface.h</code>中，<code>IServiceManager</code>是如何使用了这个宏呢？只有一行代码，在<strong>IServiceManager.cpp</strong>中，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">IMPLEMENT_META_INTERFACE(ServiceManager,<span class="string">"android.os.IServiceManager"</span>);</span><br><span class="line">很简单，可直接将IServiceManager中的IMPLEMENT宏的定义展开，如下所示：</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> android::String16</span><br><span class="line">IServiceManager::descriptor(“android.os.IServiceManager”);</span><br><span class="line"><span class="comment">//实现getInterfaceDescriptor函数</span></span><br><span class="line"><span class="keyword">const</span> android::String16&amp; IServiceManager::getInterfaceDescriptor()<span class="keyword">const</span></span><br><span class="line"> &#123; </span><br><span class="line">    <span class="comment">//返回字符串descriptor，值是“android.os.IServiceManager”</span></span><br><span class="line">      <span class="keyword">return</span> IServiceManager::descriptor;</span><br><span class="line">  &#125;    </span><br><span class="line"><span class="comment">//实现asInterface函数</span></span><br><span class="line"> android::sp&lt;IServiceManager&gt;</span><br><span class="line">             IServiceManager::asInterface(constandroid::sp&lt;android::IBinder&gt;&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">       android::sp&lt;IServiceManager&gt; intr;</span><br><span class="line">        <span class="keyword">if</span>(obj != <span class="literal">NULL</span>) &#123;                                              </span><br><span class="line">           intr = <span class="keyword">static_cast</span>&lt;IServiceManager *&gt;(                         </span><br><span class="line">               obj-&gt;queryLocalInterface(IServiceManager::descriptor).get());  </span><br><span class="line">           <span class="keyword">if</span> (intr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">             <span class="comment">//obj是我们刚才创建的那个BpBinder(0)</span></span><br><span class="line">               intr = <span class="keyword">new</span> BpServiceManager(obj);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">return</span> intr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现构造函数和析构函数</span></span><br><span class="line">IServiceManager::IServiceManager () &#123; &#125;</span><br><span class="line">IServiceManager::~ IServiceManager() &#123; &#125;</span><br></pre></td></tr></table></figure>
<p>我们曾提出过疑问：<code>interface_cast</code>是如何把<code>BpBinder</code>指针转换成一个<code>IServiceManager</code>指针的呢？答案就在asInterface函数的一行代码中，如下所示：</p>
<p><code>intr = new BpServiceManager(obj);</code><br>明白了！<code>interface_cast</code>不是指针的转换，而是利用<code>BpBinder</code>对象作为参数新建了一个<code>BpServiceManager</code>对象。我们已经知道<code>BpBinder</code>和<code>BBinder</code>与通信有关系，这里怎么突然冒出来一个<code>BpServiceManager</code>？它们之间又有什么关系呢？</p>
<h3 id="4-IServiceManager家族"><a href="#4-IServiceManager家族" class="headerlink" title="4 IServiceManager家族"></a>4 IServiceManager家族</h3><p>要搞清这个问题，必须先了解<code>IServiceManager</code>家族之间的关系，先来看图6-3，它展示了<code>IServiceManager</code>的家族图谱。<br><img src="/media/15298420766337.jpg" alt=""></p>
<p>图6-3 <code>IServiceManager</code>的家族图谱</p>
<p>根据图6-3和相关的代码可知，这里有以下几个重要的点值得注意：</p>
<p><code>IServiceManager</code>、<code>BpServiceManager</code>和<code>BnServiceManager</code>都与业务逻辑相关。<br><code>BnServiceManager</code>同时从<code>BBinder</code>派生，表示它可以直接参与<code>Binder</code>通信。<br><code>BpServiceManager</code>虽然从<code>BpInterface</code>中派生，但是这条分支似乎与<code>BpBinder</code>没有关系。<br><code>BnServiceManager</code>是一个虚类，它的业务函数最终需要子类来实现。<br>重要说明：以上这些关系很复杂，但<code>ServiceManager</code>并没有使用错综复杂的派生关系，它直接打开<code>Binder</code>设备并与之交互。后文，还会详细分析它的实现代码。</p>
<p>图6-3中的<code>BpServiceManager</code>，既然不像它的兄弟<code>BnServiceManager</code>那样直接与<code>Binder</code>有血缘关系，那么它又是如何与<code>Binder</code>交互的呢？简言之，<code>BpRefBase</code>中的<code>mRemote</code>的值就是<code>BpBinder</code>。如果你不相信，仔细看<code>BpServiceManager</code>左边的派生分支树上的一系列代码，它们都在<code>IServiceManager.cpp</code>中，如下所示：<br><strong>IServiceManager.cpp::BpServiceManager</strong>类</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过它的参数可得知，impl是IBinder类型，看来与Binder有间接关系,它实际上是BpBinder对象</span></span><br><span class="line">BpServiceManager(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; impl)</span><br><span class="line">   <span class="comment">//调用基类BpInterface的构造函数</span></span><br><span class="line">   : BpInterface&lt;IServiceManager&gt;(impl)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>BpInterface</strong>的实现代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">IInterface.h::BpInterface类</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> INTERFACE&gt;</span><br><span class="line">inlineBpInterface&lt;INTERFACE&gt;::BpInterface(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; remote)</span><br><span class="line">    :BpRefBase(remote)<span class="comment">//基类构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>BpRefBase()</code>的实现代码如下所示：<br><strong>Binder.cpp::BpRefBase</strong>类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">BpRefBase::BpRefBase(const sp&lt;IBinder&gt;&amp;o)</span><br><span class="line">  //mRemote最终等于那个new 出来的BpBinder(0)</span><br><span class="line">    :mRemote(o.get()), mRefs(NULL), mState(0)</span><br><span class="line">&#123;</span><br><span class="line">   extendObjectLifetime(OBJECT_LIFETIME_WEAK);</span><br><span class="line"> </span><br><span class="line">    if(mRemote) &#123;</span><br><span class="line">       mRemote-&gt;incStrong(this);          </span><br><span class="line">        mRefs= mRemote-&gt;createWeak(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原来，<code>BpServiceManager</code>的一个变量<code>mRemote</code>是指向了<code>BpBinder</code>。回想一下<code>defaultServiceManager</code>函数，可以得到以下两个关键对象：</p>
<p>有一个<code>BpBinder</code>对象，它的<code>handle</code>值是0。<br>有一个<code>BpServiceManager</code>对象，它的<code>mRemote</code>值是BpBinder。</p>
<blockquote>
<p>【笔记五：】在获取<code>ServiceManager</code>的时候，通过传入一个<code>BpBinder（0）</code>对象，调用到<code>IServiceManager</code>的<code>asInterface()</code>函数，这个函数创建了一个<code>BpServiceManger</code>对象，该对象也是定义在<code>IServiceManager.cpp</code> 中的，<code>BpServiceManager</code>对象通过构造函数持有了我们传过去的<code>BpBinder</code>，并实现了<code>IServiceManager</code>的业务函数（其实并没有真正实现，只不过<code>BpServiceManager</code>里有一个<code>IServiceManager</code>的同名方法，在同名方法里，会将客户端调用该函数的一些参数数据进行封装，打包成<code>parcel</code>对象，然后交给自己持有的<code>BpBinder</code>，<code>BpBinder</code>并不会直接与<code>binder</code>驱动进行交互，实际上所有的交互操作都是由<code>IPCTthreadState</code>完成的，后文会讲）</p>
</blockquote>
<h2 id="三、-注册MediaPlayerService"><a href="#三、-注册MediaPlayerService" class="headerlink" title="三、 注册MediaPlayerService"></a>三、 注册MediaPlayerService</h2><p>拿到了<code>BpServiceManager</code>，其实就可以通过这个代理，与server 也就是<code>ServiceManager</code>进行通信了。</p>
<p>现在要想<code>serviceManager</code> 注册<code>MediaPlayerService</code>服务。我们看一下 代码③ 具体做了什么</p>
<p><strong>MediaPlayerService.cpp</strong> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MediaPlayerService::instantiate() &#123;</span><br><span class="line">    defaultServiceManager()-&gt;addService(</span><br><span class="line">           String16(<span class="string">"media.player"</span>), <span class="keyword">new</span> MediaPlayerService());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据前面的分析，<code>defaultServiceManager()</code>实际返回的对象是<code>BpServiceManager</code>，它是<code>IServiceManager</code>的后代，代码如下所示：<br><strong>IServiceManager.cpp::BpServiceManager</strong>的<strong>addService()</strong>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> status_t <span class="title">addService</span><span class="params">(<span class="keyword">const</span> String16&amp;name, <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; service)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//Parcel:就把它当作是一个数据包。</span></span><br><span class="line">    Parceldata, reply;</span><br><span class="line">    data.writeInterfaceToken(IServiceManager::getInterfaceDescriptor());</span><br><span class="line">    data.writeString16(name);</span><br><span class="line">    data.writeStrongBinder(service);</span><br><span class="line">    <span class="comment">//remote返回的是mRemote，也就是BpBinder对象</span></span><br><span class="line">    status_terr = remote()-&gt;transact(ADD_SERVICE_TRANSACTION, data, &amp;reply);</span><br><span class="line">    returnerr == NO_ERROR ? reply.readInt32() : err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>别急着往下走，应先思考以下两个问题：</p>
<ul>
<li>调用<code>BpServiceManager</code>的<code>addService</code>是不是一个业务层的函数？</li>
<li><code>addService</code>函数中把请求数据打包成data后，传给了BpBinder的<code>transact</code>函数，这是不是把通信的工作交给了<code>BpBinder</code>？</li>
</ul>
<p>两个问题的答案都是肯定的。至此，业务层的工作原理应该是很清晰了，它的作用就是将请求信息打包后，再交给通信层去处理。<br>通信层的工作<br>下面分析<code>BpBinder</code>的<code>transact</code>函数。前面说过，在<code>BpBinder</code>中确实找不到任何与Binder设备交互的地方吗？那它是如何参与通信的呢？原来，秘密就在这个<code>transact</code>函数中，它的实现代码如下所示：<br><strong>BpBinder.cpp</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> BpBinder::transact(<span class="keyword">uint32_t</span> code, constParcel&amp; data, Parcel* reply,</span><br><span class="line">                                 uint32_tflags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(mAlive) &#123;</span><br><span class="line">     <span class="comment">//BpBinder果然是道具，它把transact工作交给了IPCThreadState</span></span><br><span class="line">       <span class="keyword">status_t</span> status = IPCThreadState::self()-&gt;transact(</span><br><span class="line">                           mHandle,code, data, reply, flags);<span class="comment">//mHandle也是参数</span></span><br><span class="line">        <span class="keyword">if</span>(status == DEAD_OBJECT) mAlive = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    returnDEAD_OBJECT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里又遇见了<code>IPCThreadState</code>，之前也见过一次。看来，它确实与<code>Binder</code>通信有关，所以必须对其进行深入分析！</p>
<h3 id="1-“劳者一份”的IPCThreadState"><a href="#1-“劳者一份”的IPCThreadState" class="headerlink" title="1 “劳者一份”的IPCThreadState"></a>1 “劳者一份”的IPCThreadState</h3><p>谁是“劳者”？线程，是进程中真正干活的伙计，所以它正是劳者。而“劳者一份”，就是每个伙计一份的意思。<code>IPCThreadState</code>的实现代码在<code>IPCThreadState.cpp</code>中，如下所示：<br><strong>IPCThreadState.cpp</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">IPCThreadState* IPCThreadState::self()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(gHaveTLS) &#123;<span class="comment">//第一次进来为false</span></span><br><span class="line">restart:</span><br><span class="line">        <span class="keyword">constpthread_key_t</span> k = gTLS;</span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">   TLS是Thread Local Storage（线程本地存储空间）的简称。</span></span><br><span class="line"><span class="comment">   这里只需知晓：这种空间每个线程都有，而且线程间不共享这些空间。</span></span><br><span class="line"><span class="comment">   通过pthread_getspecific/pthread_setspecific函数可以获取/设置这些空间中的内容。</span></span><br><span class="line"><span class="comment">   从线程本地存储空间中获得保存在其中的IPCThreadState对象。</span></span><br><span class="line"><span class="comment">   有调用pthread_getspecific的地方，肯定也有调用pthread_setspecific的地方</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">       IPCThreadState* st = (IPCThreadState*)pthread_getspecific(k);</span><br><span class="line">        <span class="keyword">if</span>(st) <span class="keyword">return</span> st;</span><br><span class="line"><span class="comment">// new一个对象，构造函数中会调用pthread_setspecific</span></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> IPCThreadState;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span>(gShutdown) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    pthread_mutex_lock(&amp;gTLSMutex);</span><br><span class="line">    <span class="keyword">if</span>(!gHaveTLS) &#123;</span><br><span class="line">        <span class="keyword">if</span>(pthread_key_create(&amp;gTLS, threadDestructor) != <span class="number">0</span>) &#123;</span><br><span class="line">           pthread_mutex_unlock(&amp;gTLSMutex);</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       gHaveTLS = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  pthread_mutex_unlock(&amp;gTLSMutex);</span><br><span class="line"><span class="comment">//其实goto没有我们说的那么不好，汇编代码也有很多跳转语句（没办法，太低级的语言了），关键是要用好</span></span><br><span class="line">  <span class="keyword">goto</span> restart;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，有必要转向分析它的构造函数IPCThreadState()，如下所示：<br><strong>IPCThreadState.cpp</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">IPCThreadState::IPCThreadState()</span><br><span class="line">    :mProcess(ProcessState::self()), mMyThreadId(androidGetTid())</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//在构造函数中，把自己设置到线程本地存储中去。</span></span><br><span class="line">   pthread_setspecific(gTLS, <span class="keyword">this</span>);</span><br><span class="line">    clearCaller();</span><br><span class="line">   <span class="comment">//mIn和mOut是两个Parcel。把它看成是发送和接收命令的缓冲区即可。</span></span><br><span class="line">mIn.setDataCapacity(<span class="number">256</span>);</span><br><span class="line">     mOut.setDataCapacity(<span class="number">256</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个线程都有一个<code>IPCThreadState</code>，每个<code>IPCThreadState</code>中都有一个<code>mIn</code>、一个<code>mOut</code>，其中mIn是用来接收来自<code>Binder</code>设备的数据的，而<code>mOut</code>则是用来存储发往<code>Binder</code>设备的数据的。</p>
<h3 id="2-勤劳的transact"><a href="#2-勤劳的transact" class="headerlink" title="2 勤劳的transact"></a>2 勤劳的transact</h3><p>传输工作是很辛苦的。我们刚才看到<code>BpBinder</code>的<code>transact</code>调用了<code>IPCThreadState</code>的<code>transact</code>函数，这个函数实际完成了与<code>Binder</code>通信的工作，如下面的代码所示：<br><strong>IPCThreadState.cpp</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意，handle的值为0，代表了通信的目的端</span></span><br><span class="line"><span class="keyword">status_t</span> IPCThreadState::transact(<span class="keyword">int32_t</span> handle,</span><br><span class="line">                                  uint32_tcode, <span class="keyword">const</span> Parcel&amp; data,</span><br><span class="line">                                  Parcel* reply, <span class="keyword">uint32_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    status_terr = data.errorCheck();</span><br><span class="line"> </span><br><span class="line">    flags |=TF_ACCEPT_FDS;</span><br><span class="line"> </span><br><span class="line">    ......</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">【笔记六：】</span></span><br><span class="line"><span class="comment"> 注意这里的第一个参数BC_TRANSACTION，它是应用程序向binder设备发送消息的消息码，</span></span><br><span class="line"><span class="comment"> 而binder设备向应用程序回复消息的消息码以BR_开头。消息码的定义在binder_module.h中，</span></span><br><span class="line"><span class="comment"> 请求消息码和回应消息码的对应关系可见上文驱动篇。这里BC_TRANSACTION对应一次binder事务，client </span></span><br><span class="line"><span class="comment"> 对server的请求	，这里client是服务端，server是serviceManager、</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">     err =writeTransactionData(BC_TRANSACTION, flags, handle, code, data, <span class="literal">NULL</span>);</span><br><span class="line">     ......</span><br><span class="line">     err = waitForResponse(reply);</span><br><span class="line">     ......</span><br><span class="line">   </span><br><span class="line">    returnerr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>多熟悉的流程：先发数据，然后等结果。再简单不过了！不过，我们有必要确认一下handle这个参数到底起了什么作用。先来看<strong>writeTransactionData</strong>函数，它的实现如下所示：<br><strong>IPCThreadState.cpp</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">status_tIPCThreadState::writeTransactionData(<span class="keyword">int32_t</span> cmd, <span class="keyword">uint32_t</span> binderFlags,</span><br><span class="line">    int32_thandle, <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, <span class="keyword">status_t</span>* statusBuffer)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//binder_transaction_data 是和binder设备通信的数据结构。   </span></span><br><span class="line">   binder_transaction_data tr;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">//果然，handle的值传递给了target，用来标识目的端，其中0是ServiceManager的标志。</span></span><br><span class="line">   tr.target.handle= handle;</span><br><span class="line">   <span class="comment">//code是消息码，用来switch/case的！</span></span><br><span class="line">    tr.code =code;</span><br><span class="line">    tr.flags= binderFlags;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">conststatus_t</span> err = data.errorCheck();</span><br><span class="line">    <span class="keyword">if</span> (err== NO_ERROR) &#123;</span><br><span class="line">       tr.data_size = data.ipcDataSize();</span><br><span class="line">       tr.data.ptr.buffer = data.ipcData();</span><br><span class="line">       tr.offsets_size = data.ipcObjectsCount()*<span class="keyword">sizeof</span>(<span class="keyword">size_t</span>);</span><br><span class="line">       tr.data.ptr.offsets = data.ipcObjects();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(statusBuffer) &#123;</span><br><span class="line">       tr.flags |= TF_STATUS_CODE;</span><br><span class="line">       *statusBuffer = err;</span><br><span class="line">       tr.data_size = <span class="keyword">sizeof</span>(<span class="keyword">status_t</span>);</span><br><span class="line">       tr.data.ptr.buffer = statusBuffer;</span><br><span class="line">       tr.offsets_size = <span class="number">0</span>;</span><br><span class="line">       tr.data.ptr.offsets = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> (mLastError = err);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//把命令写到mOut中， 而不是直接发出去</span></span><br><span class="line">      mOut.writeInt32(cmd);</span><br><span class="line">   mOut.write(&amp;tr, <span class="keyword">sizeof</span>(tr));</span><br><span class="line">    returnNO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，已经把<code>addService</code>的请求信息写到<code>mOut</code>中了。</p>
<blockquote>
<p>【笔记七：】<br>注意观察传递数据的变化 在<code>BpServiceManager</code>中还是<code>Parcel</code>，然后<code>BpServiceManager</code> 交给了<code>BpBinder</code>，<code>BpBinder</code>又把数据交给了<code>IPCThreadState</code>， <code>IPCThreadState</code>调用<code>writeTransactionData</code>方法，将数据进一步封装为 <code>binder_transaction_data</code>，并将<code>binder_transaction_data</code>和<code>BC_XXX</code>指令写到<code>IPCThreadState</code>中的<code>mOut</code>中。</p>
</blockquote>
<p>·</p>
<blockquote>
<p>【笔记八：】可以看到 真正与<code>binder驱动打</code>驱动打交道的是<code>IPCThreadState</code>。与<code>Binder</code>驱动打交道，意味着要往<code>binder</code>驱动写指令和数据，同时要从<code>binder</code>驱动读取返回的结果。<code>writeTranscationData()</code>方法实际上并没有做 往<code>binder</code>里写数据的操作，而是把数据写到自己的<code>mOut</code>成员变量里，那这个成员变量是怎么传给binder驱动的呢？ 其实是在<code>waitForResponse（）</code>函数里，<code>waitForResponse()</code>中的<code>talkWithDriver()</code>会读取<code>mOut</code>的数据并将数据传递给<code>binder</code>驱动，然后从<code>binder</code>驱动中读取返回数据传递给<code>mIn</code>，这样就完成了一次数据交互。</p>
</blockquote>
<p>接下来再看发送请求和接收回复部分的实现，代码在<code>waitForResponse</code>函数中，如下所示：<br><strong>IPCThreadState.cpp</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> IPCThreadState::waitForResponse(Parcel*reply, <span class="keyword">status_t</span> *acquireResult)</span><br><span class="line">&#123;</span><br><span class="line">    int32_tcmd;</span><br><span class="line">    int32_terr;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//talkWithDriver 在这里才真正开始与驱动打交道</span></span><br><span class="line">        <span class="keyword">if</span>((err=talkWithDriver()) &lt; NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line">        err =mIn.errorCheck();</span><br><span class="line">        <span class="keyword">if</span>(err &lt; NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(mIn.dataAvail() == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">       </span><br><span class="line">        cmd =mIn.readInt32();</span><br><span class="line">       <span class="keyword">switch</span>(cmd) &#123;</span><br><span class="line">        caseBR_TRANSACTION_COMPLETE:</span><br><span class="line">           <span class="keyword">if</span> (!reply &amp;&amp; !acquireResult) <span class="keyword">goto</span> finish;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">           err = executeCommand(cmd);<span class="comment">//看这个！</span></span><br><span class="line">           <span class="keyword">if</span> (err != NO_ERROR) <span class="keyword">goto</span> finish;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">finish:</span><br><span class="line">    <span class="keyword">if</span> (err!= NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">if</span>(acquireResult) *acquireResult = err;</span><br><span class="line">        <span class="keyword">if</span>(reply) reply-&gt;setError(err);</span><br><span class="line">       mLastError = err;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    returnerr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来看看<code>talkWithDriver()</code>函数</p>
<h3 id="3-talkWithDriver（）"><a href="#3-talkWithDriver（）" class="headerlink" title="3 talkWithDriver（）"></a>3 talkWithDriver（）</h3><p>talkwithDriver函数，如下所示：<br><strong>IPCThreadState.cpp</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> IPCThreadState::talkWithDriver(<span class="keyword">bool</span> doReceive)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// binder_write_read是用来与Binder设备交换数据的结构</span></span><br><span class="line">    binder_write_read bwr;</span><br><span class="line">    constbool needRead = mIn.dataPosition() &gt;= mIn.dataSize();</span><br><span class="line">    <span class="keyword">constsize_t</span> outAvail = (!doReceive || needRead) ? mOut.dataSize() : <span class="number">0</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//【笔记9】</span></span><br><span class="line">   bwr.write_size = outAvail;</span><br><span class="line">   bwr.write_buffer = (<span class="keyword">long</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>)mOut.data();</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span>(doReceive &amp;&amp; needRead) &#123;</span><br><span class="line">       <span class="comment">//接收数据缓冲区信息的填充。如果以后收到数据，就直接填在mIn中了。</span></span><br><span class="line">       bwr.read_size = mIn.dataCapacity();</span><br><span class="line">       bwr.read_buffer = (<span class="keyword">long</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>)mIn.data();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       bwr.read_size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span>((bwr.write_size == <span class="number">0</span>) &amp;&amp; (bwr.read_size == <span class="number">0</span>)) <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">   </span><br><span class="line">   bwr.write_consumed = <span class="number">0</span>;</span><br><span class="line">   bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">    status_terr;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="meta">#ifdefined(HAVE_ANDROID_OS)</span></span><br><span class="line">        <span class="comment">//看来不是read/write调用，而是ioctl方式。</span></span><br><span class="line">        <span class="keyword">if</span>(ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= <span class="number">0</span>)</span><br><span class="line">           err = NO_ERROR;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">           err = -errno;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        err =INVALID_OPERATION;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">       &#125;<span class="keyword">while</span> (err == -EINTR);</span><br><span class="line">   </span><br><span class="line">     <span class="keyword">if</span> (err&gt;= NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">if</span>(bwr.write_consumed &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (bwr.write_consumed &lt; (<span class="keyword">ssize_t</span>)mOut.dataSize())</span><br><span class="line">               mOut.remove(<span class="number">0</span>, bwr.write_consumed);</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               mOut.setDataSize(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(bwr.read_consumed &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           mIn.setDataSize(bwr.read_consumed);</span><br><span class="line">           mIn.setDataPosition(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    returnerr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/media/15298933056244.jpg" alt=""><br>图 <code>binder_write_read</code>结构体</p>
<blockquote>
<p>【笔记九：】<code>waitForResponse（）</code>是直接参与与<code>binder</code>驱动交互的地方了，首先 它初始化了<code>binder_read_write</code>结构体，将<code>mIn</code>和<code>mOut</code>中的数据读出来（如果有的话，没有就相当于初始化了），继而调用了<code>binder</code>驱动的ioctrl（）方法（对应驱动层的<code>binder_ioctrl()</code>），将这个封装好的<code>binder_read_write</code>结构发送给<code>binder</code>驱动，还记得上文<code>binder</code>驱动篇中的分析吗，binder驱动的<code>binder_ioctrl</code>()逻辑很简单，只是取出BC码和BR码，然后根据码来做对应的操作。<br><strong>这里综述一下framework到驱动层之间的通讯流程，具体如下</strong><br>1.<strong>ProcessState::self 打开驱动：</strong><code>binder</code>驱动会为每一个<code>flat_binder_object</code>对象在内核中创建一个唯一的<code>BinderNode</code>与之对应。 同时，每一个打开了<code>binder</code>驱动的进程，在内核中都有一个<code>binder_proc</code>结构体与之对应，该结构体被加载在<code>binder_procs</code>的全局链表上，是全局链表，所以这何一个进程（我们这里是<code>MediaServer</code>）都可以访问到任何进程的<code>binder_proc</code>对象了。同时，<code>binder_node</code> 被加载在<code>binder_proc</code>的<code>nodes</code>红黑树中。<br>.<br>.<br>2.<strong>mmap()让binder驱动去申请空间并做地址映射：</strong>还记得我们<code>MediaServer</code>初始化的时候调用了一个<code>ProcessState::self</code> 方法吗，它除了打开驱动，还调用了<code>mmap()</code>为该进程分配一个buffer，默认是4k ，也就是一个页面，这可以从分配函数看出来</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">binder_update_page_range(proc, <span class="number">1</span>, proc-&gt;buffer, proc-&gt;buffer + PAGE_SIZE, vma)；</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>PAGE_SIZE = 4K</code>，分配完成后 以<code>binder_buffer</code> 的形式 保存在<code>proc</code>的<code>buffers</code>红黑数里，同时进行了用户空间和内核空间的物理地址映射，也就是说现在<code>mediaserver</code>和内核空间映射了同一份物理地址，<code>server</code>端可以直接访问该物理地址而不需要将数据从内核空间往<code>server</code>进程所在的用户空间再拷贝一次了！<br>.<br>.</p>
<ol start="3">
<li><strong>通过ProcessState的getStrongProxyForHandle方法，创建了一个客户端“信使”BpBinder（0）</strong>，其中<code>handle = 0</code>，驱动其实正是通过handle值来查找客户端要通信的对端对应的<code>binderNode</code>，这个后面会说。该信使还持有<code>IPCThreadState</code>对象，它才是真正负责与驱动通讯的。<br>.<br>.<br>4.<strong>创建服务端</strong>（这里是<code>serviceManager</code>做特殊的服务端，它提供的服务是注册服务<code>add_service</code>方法）<strong>对应的BpServiceManager对象</strong>（<code>BpServiceManager</code>对象，它是<code>IServiceManager</code>的儿子，<code>IServiceManager</code>定义了业务函数和<code>interface_cast</code>转换函数，同时继承了<code>BpBinderInterface</code>接口,我们创建服务端的<code>BpServiceManager</code>，其实就是调用了<code>IServiceManager.cpp</code>中的<code>asInterface</code>函数，创建了一个<code>BpServiceManager</code>，同时它还持有我们传进去的信使“<code>BpBinder（0）</code>“的引用，对应<code>mRemote</code>）。现在我们有<code>BpServiceManager</code>了，它也有<code>IserviceMaganer</code>的业务函数，当我们调用对应的业务函数，这里是add_service（）要将我们的服务注册上去时，它会把命令交给<code>mRemote</code>，也就是我们的<code>BpBinder().transact()</code>方法，<code>transact（）</code>会调用<code>IPCThreadState</code>的<code>transact（）</code>方法。<br>.<br>.</li>
<li><strong>IPCThreadState.transact(int32_t handle,uint32_t,code, const Parcel&amp; data,Parcel* reply, uint32_t flags)与驱动交流，先写后读。</strong><br>.<br>.</li>
<li><strong>将请求内容写到写缓冲区mOut</strong>，通过<code>IPCThreadState::self.writeTransactionData</code> 吧数据封装成<code>binder_transaction_data</code><br>.<br>.</li>
<li><strong>把请求内容发送给驱动，并等待驱动返回结果，将结果写在mIn缓冲区</strong>，读写是通过<code>IPCThreadState</code>的<code>talkWithDriver()</code>方法，该方法进一步封装了要传递给<code>binder</code>驱动的数据，变为binder_read_write，同时把写的数据填入<code>write_buffer</code>里了。在<code>talkWithDriver</code>中，通过系统调用<code>ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr)</code>将数据发送给驱动。注意，现在<code>bwr</code>中的指令是<code>BC_TRANSACATION</code> ，并且<code>wirte_size&gt;0</code>,且<code>write_buffer</code>不为空。<br>.<br>.</li>
<li><strong>binder_proc对象，再看一下这张图复习一下</strong><br><img src="/media/15298989934622.jpg" alt=""><br><code>binder_proc</code>除了图中所画的几个成员之外，还有两个重要成员，都会在创建binder_proc对象的时候一起初始化。分别是<br><strong>struct list_head todo：</strong>当进程接收到一个进程间通信请求时，Binder驱动就将该请求封装成一个工作项，并且加入到进程的待处理工作向队列中，该队列使用成员变量<code>todo</code>来描述。<br><strong>wait_queue_head_t wait：</strong> 线程池中空闲Binder线程会睡眠在由该成员所描述的等待队列中， 当宿主进程的待处理工作项队列增加新工作项后，驱动会唤醒这些线程，以便处理新的工作项。<br>后面会讲到<code>binder</code>驱动会用他们来构建<code>binder_transaction</code> 结构体。</li>
</ol>
</blockquote>
<blockquote>
<p>以我们的例子为例，<code>MediaServer</code> 调用<code>IPCTtreadState</code>，并将mOut通过<code>waitForResponse()</code>里的<code>ioctrl(BINDER_READ_WRITE,&amp;data)</code>发送给驱动的时候，驱动早已经完成步骤1、2了。也就是<code>MediaServer</code> 已经有了一个对应的<code>binder_proc</code> 结构体，而且其携带的的<code>flat_binder_object</code>的<code>handle</code>指向0.注意，这里面的<code>flat_handle_object</code>中的<code>type</code>是<code>handle</code>，同时<code>handle = 0</code>；【注： 见上文 <a href="http://wenyiqingnian.xyz/2018/06/02/%E4%BB%8E%E9%A9%B1%E5%8A%A8%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3binder/">5.通讯过程中的binder实体的传递</a>】并且做了地址映射。<br>.<br>.<br>9.<strong>调用驱动的ioctrl()方法发送BINDER_WRITE_READ</strong>， 在<code>ioctrl</code>()函数的入口处，会执行 <code>thread = binder_get_thread(proc)</code>，该函数首先获取打开驱动的进程的<code>pid</code>号，根据pid号，检查是否可以在<code>threads</code>的红黑树中找到对应的<code>thread</code>对象，有就直接返回，没有就创建对应的<code>Thread</code>对象，加入<code>binder_proc</code>的<code>threads</code>的红黑树中。<br>.<br>.<br>10.现在binder驱动已经有了线程的<code>Thread</code>对象，并加入到<code>binder_proc</code>中的<code>threads</code>红黑树中。并且知道了请求码是<code>BINDER_WRITE_READ</code>，驱动篇讲过，<code>ioctrl</code>的功能就是根据不同请求码调用不同的处理方法。如果命令是<code>BINDER_WRITE_READ</code>，并且 <code>bwr.write_size &gt; 0</code>，则调用<code>binder_thread_write</code>。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">	<span class="keyword">case</span> BINDER_WRITE_READ: &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">binder_write_read</span> <span class="title">bwr</span>;</span></span><br><span class="line">        ...</span><br><span class="line">		<span class="keyword">if</span> (bwr.write_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			ret = binder_thread_write(proc, thread, (<span class="keyword">void</span> __user *)bwr.write_buffer, bwr.write_size, &amp;bwr.write_consumed);</span><br><span class="line">			trace_binder_write_done(ret);</span><br><span class="line">			<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">				bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr)))</span><br><span class="line">					ret = -EFAULT;</span><br><span class="line">				<span class="keyword">goto</span> err;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (bwr.read_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			ret = binder_thread_read(proc, thread, (<span class="keyword">void</span> __user *)bwr.read_buffer, bwr.read_size, &amp;bwr.read_consumed, filp-&gt;f_flags &amp; O_NONBLOCK);</span><br><span class="line">			trace_binder_read_done(ret);</span><br><span class="line">			<span class="keyword">if</span> (!list_empty(&amp;proc-&gt;todo))</span><br><span class="line">				wake_up_interruptible(&amp;proc-&gt;wait);</span><br><span class="line">			<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr)))</span><br><span class="line">					ret = -EFAULT;</span><br><span class="line">				<span class="keyword">goto</span> err;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当<code>write_buffer</code>存在数据，<code>binder</code>线程的写操作循环执行。这里<code>bwr.write_size&gt;0</code>,故会执行写循环，也就是binder_thread_write()方法。<br>.<br>.<br>11.<strong>进入binder_thread_write()来处理请求码</strong>。首先读取Binder命令，由于buffer里只是指向命令的指针，实际数据还保存在用户空间，因此调用get_user函数从用户空间读取数据（一次拷贝）。取得命令后，先更新命令的状态信息，然后根据不同命令 进行不同的处理。这里的例子中，<code>MediaServer</code>发送的命令是<code>BC_TRANSACTION</code>，对于请求码为<code>BC_TRANSACTION</code>或<code>BC_REPLY</code>时，会执行<code>binder_transaction()</code>方法，这是最为频繁的操作。 </p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binder_thread_write</span><span class="params">(struct binder_proc *proc, struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">void</span> __user *buffer, <span class="keyword">int</span> size, <span class="keyword">signed</span> <span class="keyword">long</span> *consumed)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">uint32_t</span> cmd;</span><br><span class="line">	<span class="keyword">void</span> __user *ptr = buffer + *consumed;</span><br><span class="line">	<span class="keyword">void</span> __user *end = buffer + size;</span><br><span class="line">	...</span><br><span class="line">		<span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">		<span class="keyword">case</span> BC_TRANSACTION:</span><br><span class="line">		<span class="keyword">case</span> BC_REPLY: &#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span> <span class="title">tr</span>;</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (copy_from_user(&amp;tr, ptr, <span class="keyword">sizeof</span>(tr)))</span><br><span class="line">				<span class="keyword">return</span> -EFAULT;</span><br><span class="line">			ptr += <span class="keyword">sizeof</span>(tr);</span><br><span class="line">			<span class="comment">// 【笔记十：】注意看最后一个参数，因为BC_TRANSACTION 还有BC_REPLY 都会</span></span><br><span class="line">			<span class="comment">//调用binder_transaction()，一个函数处理了两个逻辑，所有它用了一个boolean值 </span></span><br><span class="line">		   <span class="comment">//cmd == BC_REPLAY 来决定走哪个流程</span></span><br><span class="line">			binder_transaction(proc, thread, &amp;tr, cmd == BC_REPLY);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>.<br>.<br>12.<strong>binder_transaction内部流程</strong></p>
</blockquote>
<ul>
<li><p>首先梳理下当前传进来的<code>binder_transaction_data</code>到底包含了哪些数据：</p>
<p><img src="/media/15299308632940.png" alt=""></p>
</li>
</ul>
<ul>
<li>1 根据<code>binder_transaction_data</code> 中的<code>handle</code>,通过映射关系<img src="/media/15299136178694.jpg" alt=""><br>找到对应的<code>binder_node</code>，进而找到目标进程<code>binder_proc</code></li>
</ul>
<ul>
<li>2 根据本次<code>binder_transaction</code>是否是异步，如果不是异步，意味着当前的<code>binder</code>传输流程还没走完，还是同一个<code>transaction</code>流程，从<code>from_parent</code>查找，如果是异步，从<code>binder_proc</code> 回溯查找<code>target_thread</code>。 </li>
<li>3 如果找到<code>target_thread</code>，则它就是目标线程，否则<code>binder_proc</code>对应的进程是目标线程。</li>
<li>4 根据用户空间传入的数据和目标，发起事务的线程、进程信息，创建<code>binder_transaction</code>结构体，<code>binder_transaction</code> 其实与一次<code>binder_transaction（）</code>方法对应的，每执行一次，便会在驱动中为其创建一个对应的结构体。这里要解释一下什么是<code>binder_transaction</code>对象。可以这么理解，<code>binder_transaction_data</code>是<code>binder</code>传输对象的外部表示，应用于应用程序的，而<code>binder_transaction</code>是<code>binder</code>传输对象的内部表示，应用于内核binder驱动本身。<code>binder_transaction</code>对象都位于<code>binder_thread</code>的传输栈上，其本身是一个多级链表结构，描述了传输来源和传输目标，也记录了本次传输的信息，如<code>binder_work</code>、<code>binder_buffer</code>、<code>binder</code>命令等。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> debug_id;</span><br><span class="line">    <span class="comment">// 当驱动为目标进程或线程创建一个事务时，就会将该成员的type置为</span></span><br><span class="line">    <span class="comment">// BINDER_WORK_TRANSACTION，并将它添加到目标进程或线程的todo队列，等待处理</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_work</span> <span class="title">work</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">from</span>;</span>         <span class="comment">// 发起事务的线程</span></span><br><span class="line">    <span class="comment">// 事务所依赖的另外一个事务以及目标线程下一个要处理的事务</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">from_parent</span>;</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">to_proc</span>;</span>        <span class="comment">// 负责处理该事务的进程</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">to_thread</span>;</span>    <span class="comment">// 负责处理该事务的线程</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">to_parent</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> need_reply:<span class="number">1</span>;              <span class="comment">// 同步事务为1需要等待对方回复；异步为0</span></span><br><span class="line">    <span class="comment">/* unsigned is_dead:1; */</span>   <span class="comment">/* not used at the moment */</span></span><br><span class="line">    <span class="comment">// 指向驱动为该事务分配的内核缓冲区，保存了进程间通信数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_buffer</span> *<span class="title">buffer</span>;</span>   </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>    code;   <span class="comment">// 直接从进程间通信数据中拷贝过来</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>    flags;  <span class="comment">// 直接从进程间通信数据中拷贝过来</span></span><br><span class="line">    <span class="keyword">long</span>    priority;       <span class="comment">// 源线程优先级</span></span><br><span class="line">    <span class="comment">// 线程在处理事务时，驱动会修改它的优先级以满足源线程和目标Service组建的要求。在修改之</span></span><br><span class="line">    <span class="comment">// 前，会将它原来的线程优先级保存在该成员中，以便线程处理完该事务后可以恢复原来的优先级</span></span><br><span class="line">    <span class="keyword">long</span>    saved_priority; </span><br><span class="line">    <span class="keyword">uid_t</span>   sender_euid;    <span class="comment">// 源线程用户ID</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>4 根据传输的目标设置本次<code>binder</code>传输的目标等待队列(<code>wait_queue</code>)和本次<code>binder_work</code>需要挂载的列表(<code>list</code>)，也就是<code>target_wait</code>和<code>target_list</code>。其中<code>target_wait</code>中存放的就是本次要唤醒的目标进程/线程。 <code>target_list</code> 就是目标进程中的<code>todo</code></li>
<li>5 到目前，<code>target_node</code>，<code>target_thread</code>，<code>target_proc</code>，<code>target_wait</code>和<code>target_list</code>都已经找到了。下面就该为此次传输分配新的<code>binder_transaction</code>对象和<code>binder_work</code>对象了，并根据当前的信息填充内容</li>
<li>6 构造一个新的<code>binder_transaction</code> 对象，并为期分配内存，同时修改<code>flat_binder_object</code>,做好<code>handle</code>到<code>binder</code>地址之间的映射。如果发送端发的是<code>binder</code>，驱动会把<code>type</code> 修改为<code>HANDLE_TYPE</code>，同时找到<code>binder_node-&gt;binder_ref</code> 找到索引id，<code>binder_ref-&gt;desc</code>，将改id赋值给<code>handle</code>.如果是<code>handle</code>，吧流程返过来，<code>handle-&gt;binder_ref-&gt;binder_node</code>，将<code>binder_node</code> 赋值给<code>flat_binder_object</code>中的<code>binder</code>，修改<code>type</code>为<code>BINDER_TYPE</code>；</li>
<li>7 新的<code>binder_flat_object</code>修改好了，在此之前，还要根据是同步传输还是异步传输，设置<code>binder_transaction</code>中的<code>replay</code>值，并将<code>binder_transaction</code>插入到<code>target_list</code>也即<code>traget_tread</code>/<code>target_proc</code>的<code>todo</code>队列中。</li>
</ul>
<p>至此 发送命令算是做完了。可以看到，调用了<code>binder_transcation</code>之后，并没有把数据发送给<code>server</code>，驱动只不过是创建了一个<code>binder_transaction</code>结构，然后把它挂在<code>binder_proc</code>的<code>todo</code>队列中。<br><img src="/media/15299341943387.png" alt=""><br>图：驱动层调用层级</p>
<p><img src="/media/15299348916454.jpg" alt=""></p>
<blockquote>
<p><strong>总结： 客户端的每一次请求，驱动最终都会生成换一个binder_transaction结构体，并把这个结构体挂在目标进程target_proc 也就是Server端 ServerManager服务对应的那个binder_proc 中。</strong></p>
</blockquote>
<ul>
<li>8 唤醒等待线程的目标线程</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (target_wait)  </span><br><span class="line">    wake_up_interruptible(target_wait);</span><br></pre></td></tr></table></figure>
<ul>
<li>9 server端的目标线程开始进入<code>binder_loop</code>状态，从<code>ServiceManager</code>那端来看，它走的其实和client端发起请求的流程是类似的，只不过此时<code>mOut</code>为空，binder驱动执行<code>binder_thread_read</code>()方法。</li>
<li>10 server端通过<code>ioctrl</code>控制驱动执行<code>binder_thread_read</code>,首先读取<code>todo</code>列表的首节点。这是client端发送请求操作完成之后插进来的。</li>
<li>11 根据todo中的<code>binder_work</code> 找到对应的<code>binder_transaction</code>,有了<code>binder_transaction</code>,便从<code>binder_transaction</code> 和<code>binder_buffer</code>中提取出<code>client</code>端发送的数据，重新组装成<code>binder_transaction_data</code>。</li>
<li><p>12 将<code>binder_transaction_data</code>结构体通过<code>copy_to_user</code>拷贝到用户空间，由接收端<code>ServiceManager</code>收到</p>
</li>
<li><p>13 server端收到binder驱动转发的客户端数据 进行处理后，再发送回给binder驱动。一次循环往复。完成客户端往服务端发送数据的过程。</p>
<blockquote>
<p>总结：客户端的请求，都会被binder驱动创建一个对应的binder_transaction。并将这个transaction挂在目标进程binder_proc的todo链表里，binder驱动再唤醒目标进程，目标进程对驱动执行读取命令，驱动执行binder_thread_read，同时将客户端发送的数据，以查找todo链表 -&gt; 查找binder_transaction-&gt; binder_buffer 的方式，重新包装成binder_transaction_data，拷贝到server端对应的用户空间。同时将改todo列表删除。至此完成客户端-&gt;server端的传输。server的返回数据流程和这个基本一致，只不过server和client的角色需要对调一下。</p>
</blockquote>
</li>
</ul>
<p>OK，我们已发送了请求数据，假设马上就收到了回复，后续该怎么处理呢？来看executeCommand函数，如下所示：<br><strong>IPCThreadState.cpp</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> IPCThreadState::executeCommand(int32_tcmd)</span><br><span class="line">&#123;</span><br><span class="line">    BBinder*obj;</span><br><span class="line">   RefBase::weakref_type* refs;</span><br><span class="line">    status_tresult = NO_ERROR;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">switch</span>(cmd) &#123;</span><br><span class="line">    caseBR_ERROR:</span><br><span class="line">       result = mIn.readInt32();</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">        ......</span><br><span class="line">     caseBR_TRANSACTION:</span><br><span class="line">        &#123;</span><br><span class="line">           binder_transaction_data tr;</span><br><span class="line">           result = mIn.read(&amp;tr, <span class="keyword">sizeof</span>(tr));</span><br><span class="line">           <span class="keyword">if</span> (result != NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line">            Parcel buffer;</span><br><span class="line">           Parcel reply;</span><br><span class="line">           <span class="keyword">if</span> (tr.target.ptr) &#123;</span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">             看到了BBinder，想起图6-3了吗？BnServiceXXX从BBinder派生，</span></span><br><span class="line"><span class="comment">             这里的b实际上就是实现BnServiceXXX的那个对象，关于它的作用，后文会详述              </span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">                sp&lt;BBinder&gt; b((BBinder*)tr.cookie);</span><br><span class="line">               <span class="keyword">const</span> <span class="keyword">status_t</span> error = b-&gt;transact(tr.code, buffer, &amp;reply, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (error &lt; NO_ERROR)reply.setError(error);</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">           the_context_object是IPCThreadState.cpp中定义的一个全局变量，</span></span><br><span class="line"><span class="comment">           可通过setTheContextObject函数设置</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">               <span class="keyword">const</span> <span class="keyword">status_t</span> error =</span><br><span class="line">                             the_context_object-&gt;transact(tr.code,buffer, &amp;reply, <span class="number">0</span>);</span><br><span class="line">               <span class="keyword">if</span> (error &lt; NO_ERROR) reply.setError(error);</span><br><span class="line">         &#125;</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">case</span> BR_DEAD_BINDER:</span><br><span class="line">        &#123;</span><br><span class="line">         <span class="comment">/*</span></span><br><span class="line"><span class="comment">           收到binder驱动发来的service死掉的消息，看来只有Bp端能收到了，</span></span><br><span class="line"><span class="comment">           后面，我们将会对此进行分析。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">           BpBinder *proxy = (BpBinder*)mIn.readInt32();</span><br><span class="line">           proxy-&gt;sendObituary();</span><br><span class="line">           mOut.writeInt32(BC_DEAD_BINDER_DONE);</span><br><span class="line">           mOut.writeInt32((<span class="keyword">int32_t</span>)proxy);</span><br><span class="line">        &#125;<span class="keyword">break</span>;</span><br><span class="line">        ......</span><br><span class="line"><span class="keyword">case</span> BR_SPAWN_LOOPER:</span><br><span class="line">  <span class="comment">//特别注意，这里将收到来自驱动的指示以创建一个新线程，用于和Binder通信。</span></span><br><span class="line">       mProcess-&gt;spawnPooledThread(<span class="literal">false</span>);</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        result = UNKNOWN_ERROR;</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   ......</span><br><span class="line">    <span class="keyword">if</span>(result != NO_ERROR) &#123;</span><br><span class="line">       mLastError = result;</span><br><span class="line">    &#125;</span><br><span class="line">    returnresult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-StartThread-Pool和join-Thread-Pool"><a href="#4-StartThread-Pool和join-Thread-Pool" class="headerlink" title="4 StartThread Pool和join Thread Pool"></a>4 StartThread Pool和join Thread Pool</h2><h3 id="1-创造劳动力——startThreadPool"><a href="#1-创造劳动力——startThreadPool" class="headerlink" title="1.创造劳动力——startThreadPool()"></a>1.创造劳动力——startThreadPool()</h3><p><code>startThreadPool()</code>的实现，如下面的代码所示：<br><strong>ProcessState.cpp</strong><br>//太简单，没什么好说的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ProcessState::startThreadPool()</span><br><span class="line">&#123;</span><br><span class="line">AutoMutex _l(mLock);</span><br><span class="line"><span class="comment">//如果要是已经startThreadPool的话，这个函数就没有什么实质作用了</span></span><br><span class="line">    <span class="keyword">if</span>(!mThreadPoolStarted) &#123;</span><br><span class="line">       mThreadPoolStarted = <span class="literal">true</span>;</span><br><span class="line">       spawnPooledThread(<span class="literal">true</span>); <span class="comment">//注意，传进去的参数是true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">上面的spawnPooledThread()函数的实现，如下所示：</span><br><span class="line">ProcessState.cpp</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> ProcessState::spawnPooledThread(<span class="keyword">bool</span> isMain)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//注意，isMain参数是true。</span></span><br><span class="line">    <span class="keyword">if</span>(mThreadPoolStarted) &#123;</span><br><span class="line">       <span class="keyword">int32_t</span> s = android_atomic_add(<span class="number">1</span>, &amp;mThreadPoolSeq);</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">32</span>];</span><br><span class="line">       <span class="built_in">sprintf</span>(buf, <span class="string">"Binder Thread #%d"</span>, s);</span><br><span class="line">        sp&lt;Thread&gt; t = <span class="keyword">new</span> PoolThread(isMain);</span><br><span class="line">       t-&gt;run(buf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PoolThread是在IPCThreadState中定义的一个Thread子类，它的实现，如下所示：<br><strong>IPCThreadState.h::PoolThread</strong>类</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PoolThread</span> :</span> <span class="keyword">public</span> Thread</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   PoolThread(<span class="keyword">bool</span> isMain)</span><br><span class="line">        :mIsMain(isMain)&#123;&#125;</span><br><span class="line">   <span class="keyword">protected</span>:</span><br><span class="line">    <span class="function">virtualbool <span class="title">threadLoop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       <span class="comment">//线程函数如此简单，不过是在这个新线程中又创建了一个IPCThreadState。</span></span><br><span class="line">      <span class="comment">// 你还记得它是每个伙计都有一个的吗？</span></span><br><span class="line">        IPCThreadState::self()-&gt;joinThreadPool(mIsMain);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">const</span> boolmIsMain;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="2万众归一-joinThreadPool"><a href="#2万众归一-joinThreadPool" class="headerlink" title="2万众归一  joinThreadPool"></a>2万众归一  joinThreadPool</h3><p>还需要看看<code>IPCThreadState</code>的<code>joinThreadPool</code>的实现，因为新创建的线程也会调用这个函数，具体代码如下所示：<br><strong>IPCThreadState.cpp</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> IPCThreadState::joinThreadPool(<span class="keyword">bool</span> isMain)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//注意，如果isMain为true，我们需要循环处理。把请求信息写到mOut中，待会儿一起发出去</span></span><br><span class="line">   mOut.writeInt32(isMain ? BC_ENTER_LOOPER : BC_REGISTER_LOOPER);</span><br><span class="line">   </span><br><span class="line">  androidSetThreadSchedulingGroup(mMyThreadId, ANDROID_TGROUP_DEFAULT);</span><br><span class="line">       </span><br><span class="line">    status_tresult;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">       <span class="keyword">int32_t</span> cmd;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">if</span>(mIn.dataPosition() &gt;= mIn.dataSize()) &#123;</span><br><span class="line">           <span class="keyword">size_t</span> numPending = mPendingWeakDerefs.size();</span><br><span class="line">           <span class="keyword">if</span> (numPending &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; numPending; i++) &#123;</span><br><span class="line">                   RefBase::weakref_type* refs = mPendingWeakDerefs[i];</span><br><span class="line">                    refs-&gt;decWeak(mProcess.get());</span><br><span class="line">               &#125;</span><br><span class="line">               mPendingWeakDerefs.clear();</span><br><span class="line">            &#125;</span><br><span class="line">           <span class="comment">//处理已经死亡的BBinder对象</span></span><br><span class="line">           numPending = mPendingStrongDerefs.size();</span><br><span class="line">           <span class="keyword">if</span> (numPending &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; numPending; i++) &#123;</span><br><span class="line">                   BBinder* obj = mPendingStrongDerefs[i];</span><br><span class="line">                   obj-&gt;decStrong(mProcess.get());</span><br><span class="line">               &#125;</span><br><span class="line">               mPendingStrongDerefs.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 发送命令，读取请求</span></span><br><span class="line">       result = talkWithDriver();</span><br><span class="line">        <span class="keyword">if</span>(result &gt;= NO_ERROR) &#123;</span><br><span class="line">           <span class="keyword">size_t</span> IN = mIn.dataAvail();</span><br><span class="line">            <span class="keyword">if</span> (IN &lt; <span class="keyword">sizeof</span>(<span class="keyword">int32_t</span>)) <span class="keyword">continue</span>;</span><br><span class="line">           cmd = mIn.readInt32();</span><br><span class="line">            result= executeCommand(cmd); <span class="comment">//处理消息</span></span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">while</span>(result != -ECONNREFUSED &amp;&amp; result != -EBADF);</span><br><span class="line"> </span><br><span class="line">   mOut.writeInt32(BC_EXIT_LOOPER);</span><br><span class="line">   talkWithDriver(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原来，我们的两个伙计在<code>talkWithDriver</code>，它们希望能从<code>Binder</code>设备那里找到点可做的事情。</p>
<h3 id="3-有几个线程在服务"><a href="#3-有几个线程在服务" class="headerlink" title="3. 有几个线程在服务"></a>3. 有几个线程在服务</h3><p>到底有多少个线程在为Service服务呢？目前看来是两个：</p>
<p><code>startThreadPool</code>中新启动的线程通过<code>joinThreadPool</code>读取Binder设备，查看是否有请求。<br>主线程也调用<code>joinThreadPool</code>读取Binder设备，查看是否有请求。看来，binder设备是支持多线程操作的，其中一定是做了同步方面的工作。<br><code>mediaserver</code>这个进程一共注册了4个服务，繁忙的时候，两个线程会不会显得有点少呢？另外，如果实现的服务负担不是很重，完全可以不调用startThreadPool创建新的线程，使用主线程即可胜任。</p>
<h1 id="特殊的server端，ServiceManager"><a href="#特殊的server端，ServiceManager" class="headerlink" title="特殊的server端，ServiceManager"></a>特殊的server端，ServiceManager</h1><p>刚才分析的<code>MediaServer</code>，在跟<code>servicemanager</code>注册服务的时候，其实扮演的是client的角色。<br><code>serviceManager</code> 是系统所有服务的大管家，提供查询，注册服务等方法。</p>
<h2 id="1-serviceManager-原理"><a href="#1-serviceManager-原理" class="headerlink" title="1. serviceManager 原理"></a>1. serviceManager 原理</h2><p>前面说过，<code>defaultServiceManager</code>返回的是一个<code>BpServiceManager</code>，通过它可以把命令请求发送给handle值为0的目的端。按照图6-3所示的<code>IServiceManager</code>“家谱”，无论如何也应该有一个类从<code>BnServiceManager</code>派生出来并处理这些来自远方的请求吧？<br>很可惜，源码中竟然没有这样的一个类存在！但确实又有这么一个程序完成了<code>BnServiceManager</code>未尽的工作，这个程序就是<code>servicemanager</code>，它的代码在<strong>Service_manager.c</strong>中，如下所示：</p>
<p>注意：通过这件事情是否能感悟到什么？嗯，我们确实可以抛开前面所有的那些封装，直接与Binder设备打交道。</p>
<p>下面来看<code>ServiceManager</code>是怎么放弃华丽的封装去做Manager的。</p>
<h3 id="1-ServiceManager的入口函数"><a href="#1-ServiceManager的入口函数" class="headerlink" title="1 ServiceManager的入口函数"></a>1 ServiceManager的入口函数</h3><p>ServiceManager的入口函数如下所示。<br><strong>ServiceManager.c</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   structbinder_state *bs;</span><br><span class="line">   <span class="comment">//BINDER_SERVICE_MANAGER的值为NULL，是一个magic number。</span></span><br><span class="line">   <span class="keyword">void</span>*svcmgr = BINDER_SERVICE_MANAGER;</span><br><span class="line">   <span class="comment">//①应该是打开binder设备吧？</span></span><br><span class="line">   bs = binder_open(<span class="number">128</span>*<span class="number">1024</span>);</span><br><span class="line">   <span class="comment">//②成为manager，是不是把自己的handle置为0？</span></span><br><span class="line">   binder_become_context_manager(bs)</span><br><span class="line">   svcmgr_handle= svcmgr;</span><br><span class="line">   <span class="comment">//③处理客户端发过来的请求。</span></span><br><span class="line">   binder_loop(bs, svcmgr_handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，一共有三个重要关键点。必须对其逐一地进行分析。</p>
<p>注意：有一些函数是在<strong>Binder.c</strong>中实现的，此<strong>Binder.c</strong>不是前面碰到的那个<strong>Binder.cpp</strong>。</p>
<h3 id="2-打开Binder设备"><a href="#2-打开Binder设备" class="headerlink" title="2 打开Binder设备"></a>2 打开Binder设备</h3><p><code>binder_open</code>函数用于打开Binder设备，它的实现如下所示：<br><strong>Binder.c</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  这里的binder_open应该与我们之前在ProcessState中看到的一样：</span></span><br><span class="line"><span class="comment">  1）打开Binder设备</span></span><br><span class="line"><span class="comment">  2）内存映射</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">struct binder_state *<span class="title">binder_open</span><span class="params">(<span class="keyword">unsigned</span> mapsize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    structbinder_state *bs;</span><br><span class="line">    bs =<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*bs));</span><br><span class="line">    ....</span><br><span class="line">    bs-&gt;fd= open(<span class="string">"/dev/binder"</span>, O_RDWR);</span><br><span class="line">    ....</span><br><span class="line">   bs-&gt;mapsize = mapsize;</span><br><span class="line">   bs-&gt;mapped = mmap(<span class="literal">NULL</span>, mapsize, PROT_READ, MAP_PRIVATE, bs-&gt;fd,<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>果然如此，有了之前所学习掌握的知识，这里真的就不难理解了。</p>
<h3 id="3-成为老大"><a href="#3-成为老大" class="headerlink" title="3. 成为老大"></a>3. 成为老大</h3><p>怎么才成为系统中独一无二的manager了呢？manger的实现，如下面的代码所示：<br><strong>Binder.c</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binder_become_context_manager</span><span class="params">(structbinder_state *bs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">//实现太简单了！这个0是否就是设置自己的handle呢？</span></span><br><span class="line">    returnioctl(bs-&gt;fd, BINDER_SET_CONTEXT_MGR, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-死磕Binder"><a href="#4-死磕Binder" class="headerlink" title="4.死磕Binder"></a>4.死磕Binder</h3><p><code>binder_loop</code>是一个很尽责的函数。为什么这么说呢？因为它老是围绕着Binder设备转悠，实现代码如下所示：<br><strong>Binder.c</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  注意binder_handler参数，它是一个函数指针，binder_loop读取请求后将解析</span></span><br><span class="line"><span class="comment">  这些请求，最后调用binder_handler完成最终的处理。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binder_loop</span><span class="params">(struct binder_state *bs,binder_handler func)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    structbinder_write_read bwr;</span><br><span class="line">   readbuf[<span class="number">0</span>] = BC_ENTER_LOOPER;</span><br><span class="line">   binder_write(bs, readbuf, <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span>));</span><br><span class="line">    <span class="keyword">for</span> (;;)&#123;<span class="comment">//果然是循环</span></span><br><span class="line">       bwr.read_size = <span class="keyword">sizeof</span>(readbuf);</span><br><span class="line">       bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">       bwr.read_buffer = (<span class="keyword">unsigned</span>) readbuf;</span><br><span class="line"> </span><br><span class="line">        res =ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);</span><br><span class="line">        <span class="comment">//接收到请求，交给binder_parse，最终会调用func来处理这些请求。</span></span><br><span class="line">        res = binder_parse(bs, <span class="number">0</span>, readbuf,bwr.read_consumed, func);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-集中处理"><a href="#5-集中处理" class="headerlink" title="5 集中处理"></a>5 集中处理</h3><p>往<code>binder_loop</code>中传的那个函数指针是svcmgr_handler，它的代码如下所示：<br><strong>Service_manager.c</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">svcmgr_handler</span><span class="params">(struct binder_state *bs,structbinder_txn *txn,</span></span></span><br><span class="line"><span class="function"><span class="params">                      struct binder_io *msg,structbinder_io *reply)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    structsvcinfo *si;</span><br><span class="line">    <span class="keyword">uint16_t</span>*s;</span><br><span class="line">    unsignedlen;</span><br><span class="line">    <span class="keyword">void</span>*ptr;</span><br><span class="line">    <span class="comment">// svcmgr_handle就是前面说的那个magic number，值为NULL。</span></span><br><span class="line">   <span class="comment">//这里要比较target是不是自己。</span></span><br><span class="line">    <span class="keyword">if</span>(txn-&gt;target != svcmgr_handle)</span><br><span class="line">       <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    s =bio_get_string16(msg, &amp;len);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> ((len!= (<span class="keyword">sizeof</span>(svcmgr_id) / <span class="number">2</span>)) ||</span><br><span class="line">       <span class="built_in">memcmp</span>(svcmgr_id, s, <span class="keyword">sizeof</span>(svcmgr_id))) &#123;</span><br><span class="line">       <span class="keyword">return</span><span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">switch</span>(txn-&gt;code) &#123;</span><br><span class="line">    caseSVC_MGR_GET_SERVICE:<span class="comment">//得到某个service的信息，service用字符串表示。</span></span><br><span class="line">    caseSVC_MGR_CHECK_SERVICE:</span><br><span class="line">        s = bio_get_string16(msg, &amp;len);<span class="comment">//s是字符串表示的service名称。</span></span><br><span class="line">        ptr =do_find_service(bs, s, len);</span><br><span class="line">        <span class="keyword">if</span>(!ptr)</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">       bio_put_ref(reply, ptr);</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    caseSVC_MGR_ADD_SERVICE:<span class="comment">//对应addService请求</span></span><br><span class="line">        s =bio_get_string16(msg, &amp;len);</span><br><span class="line">        ptr =bio_get_ref(msg);</span><br><span class="line">        <span class="keyword">if</span>(do_add_service(bs, s, len, ptr, txn-&gt;sender_euid))</span><br><span class="line">           <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">//得到当前系统已经注册的所有service的名字。</span></span><br><span class="line">    caseSVC_MGR_LIST_SERVICES: &#123;</span><br><span class="line">       <span class="keyword">unsigned</span> n = bio_get_uint32(msg);</span><br><span class="line">        si =svclist;</span><br><span class="line">        <span class="keyword">while</span>((n-- &gt; <span class="number">0</span>) &amp;&amp; si)</span><br><span class="line">           si = si-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(si) &#123;</span><br><span class="line">           bio_put_string16(reply, si-&gt;name);</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">       <span class="keyword">return</span><span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    bio_put_uint32(reply,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-服务的注册"><a href="#2-服务的注册" class="headerlink" title="2 服务的注册"></a>2 服务的注册</h2><p>上面提到的<code>switch/case</code>语句，将实现<code>IServiceManager</code>中定义的各个业务函数，我们重点看<code>do_add_service</code>这个函数，它最终完成了对<code>addService</code>请求的处理实现，代码如下所示：<br><strong>Service_manager.c</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_add_service</span><span class="params">(struct binder_state *bs,<span class="keyword">uint16_t</span>*s, <span class="keyword">unsigned</span> len,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">void</span>*ptr, <span class="keyword">unsigned</span> uid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    structsvcinfo *si;</span><br><span class="line">    <span class="keyword">if</span> (!ptr|| (len == <span class="number">0</span>) || (len &gt; <span class="number">127</span>))</span><br><span class="line">       <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">     <span class="comment">//svc_can_register函数比较注册进程的uid和名字。</span></span><br><span class="line">    <span class="keyword">if</span>(!svc_can_register(uid, s)) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure>
<p>将上面的函数暂时放一下，先介绍<code>svc_can_register</code>函数。</p>
<h3 id="1不是什么都可以注册的"><a href="#1不是什么都可以注册的" class="headerlink" title="1不是什么都可以注册的"></a>1不是什么都可以注册的</h3><p><code>do_add_service</code>函数中的<code>svc_can_register</code>，是用来判断注册服务的进程是否有权限的，代码如下所示：<br><strong>Service_manager.c</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">svc_can_register</span><span class="params">(<span class="keyword">unsigned</span> uid, <span class="keyword">uint16_t</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    unsignedn;</span><br><span class="line">    <span class="comment">//如果用户组是root用户或者system用户，则权限够高，允许注册</span></span><br><span class="line">    <span class="keyword">if</span> ((uid== <span class="number">0</span>) || (uid == AID_SYSTEM))</span><br><span class="line">       <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (n =<span class="number">0</span>; n &lt; <span class="keyword">sizeof</span>(allowed) / <span class="keyword">sizeof</span>(allowed[<span class="number">0</span>]); n++)</span><br><span class="line">        <span class="keyword">if</span>((uid == allowed[n].uid) &amp;&amp; str16eq(name, allowed[n].name))</span><br><span class="line">           <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>allowed</code>结构数组，控制那些权限达不到root和system的进程，它的定义如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    unsigneduid;</span><br><span class="line">    constchar *name;</span><br><span class="line">&#125; allowed[] = &#123;</span><br><span class="line">#ifdef LVMX</span><br><span class="line">    &#123;AID_MEDIA, <span class="string">"com.lifevibes.mx.ipc"</span> &#125;,</span><br><span class="line">#endif</span><br><span class="line">    &#123;AID_MEDIA, <span class="string">"media.audio_flinger"</span> &#125;,</span><br><span class="line">    &#123;AID_MEDIA, <span class="string">"media.player"</span> &#125;,</span><br><span class="line">    &#123;AID_MEDIA, <span class="string">"media.camera"</span> &#125;,</span><br><span class="line">    &#123;AID_MEDIA, <span class="string">"media.audio_policy"</span> &#125;,</span><br><span class="line">    &#123;AID_RADIO, <span class="string">"radio.phone"</span> &#125;,</span><br><span class="line">    &#123;AID_RADIO, <span class="string">"radio.sms"</span> &#125;,</span><br><span class="line">    &#123;AID_RADIO, <span class="string">"radio.phonesubinfo"</span> &#125;,</span><br><span class="line">    &#123;AID_RADIO, <span class="string">"radio.simphonebook"</span> &#125;,</span><br><span class="line">    &#123;AID_RADIO, <span class="string">"phone"</span> &#125;,</span><br><span class="line">    &#123;AID_RADIO, <span class="string">"isms"</span> &#125;,</span><br><span class="line">    &#123;AID_RADIO, <span class="string">"iphonesubinfo"</span> &#125;,</span><br><span class="line">    &#123;AID_RADIO, <span class="string">"simphonebook"</span> &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>所以，如果Server进程权限不够root和system，那么请记住要在<code>allowed</code>中添加相应的项。</p>
<h3 id="2-添加服务项"><a href="#2-添加服务项" class="headerlink" title="2. 添加服务项"></a>2. 添加服务项</h3><p>再回到我们的<code>do_add_service</code>，如下所示：<br><strong>Service_manager.c</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_add_service</span><span class="params">(struct binder_state *bs,<span class="keyword">uint16_t</span>*s, <span class="keyword">unsigned</span> len,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">void</span> *ptr, <span class="keyword">unsigned</span> uid)</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">...... <span class="comment">//接前面的代码</span></span><br><span class="line">    si =find_svc(s, len);</span><br><span class="line">    <span class="keyword">if</span> (si) &#123;</span><br><span class="line">        <span class="keyword">if</span>(si-&gt;ptr) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       si-&gt;ptr = ptr;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        si =<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*si) + (len + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">uint16_t</span>));</span><br><span class="line">        <span class="keyword">if</span>(!si) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//ptr是关键数据，可惜为void*类型。只有分析驱动的实现才能知道它的真实含义了。</span></span><br><span class="line">       si-&gt;ptr = ptr;</span><br><span class="line">       si-&gt;len = len;</span><br><span class="line">       <span class="built_in">memcpy</span>(si-&gt;name, s, (len + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">uint16_t</span>));</span><br><span class="line">       si-&gt;name[len] = <span class="string">'\0'</span>;</span><br><span class="line">       si-&gt;death.func = svcinfo_death;<span class="comment">//service退出的通知函数</span></span><br><span class="line">       si-&gt;death.ptr = si;</span><br><span class="line">        <span class="comment">//这个svclist是一个list，保存了当前注册到ServiceManager中的信息。</span></span><br><span class="line">       si-&gt;next = svclist;</span><br><span class="line">       svclist = si;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">   binder_acquire(bs,ptr);</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">我们希望当服务进程退出后，ServiceManager能有机会做一些清理工作，例如释放前面malloc出来的si。</span></span><br><span class="line"><span class="comment">binder_link_to_death完成这项工作，每当有服务进程退出时，ServiceManager都会得到来自</span></span><br><span class="line"><span class="comment">Binder设备的通知。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">   binder_link_to_death(bs, ptr, &amp;si-&gt;death);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，服务注册分析完毕。可以知道，<code>ServiceManager</code>不过就是保存了一些服务的信息。那么，这样做又有什么意义呢？</p>
<ul>
<li><code>ServiceManger</code>能集中管理系统内的所有服务，它能施加权限控制，并不是任何进程都能注册服务。</li>
<li><code>ServiceManager</code>支持通过字符串名称来查找对应的Service。这个功能很像DNS。</li>
<li>由于各种原因，Server进程可能生死无常。如果让每个Client都去检测，压力实在太大。现在有了统一的管理机构，Client只需要查询<code>ServiceManager</code>，就能把握动向，得到最新信息。这可能正是<code>ServiceManager</code>存在的最大意义吧。</li>
</ul>
<h1 id="MediaPlayerService和它的Client"><a href="#MediaPlayerService和它的Client" class="headerlink" title="MediaPlayerService和它的Client"></a>MediaPlayerService和它的Client</h1><p>前面，一直在讨论<code>ServiceManager</code>和它的<code>Client</code>，现在我们以<code>MediaPlayerService</code>的<code>Client</code>换换口味吧。由于<code>ServiceManager</code>不是从<code>BnServiceManager</code>中派生的，所以之前没有讲述请求数据是如何从通讯层传递到业务层来处理的过程。本节，我们以<code>MediaPlayerService</code>和它的<code>Client</code>做为分析对象，试解决这些遗留问题。</p>
<h2 id="查询ServiceManager"><a href="#查询ServiceManager" class="headerlink" title="查询ServiceManager"></a>查询ServiceManager</h2><p>前文曾分析过<code>ServiceManager</code>的作用，一个Client想要得到某个Service的信息，就必须先和<code>ServiceManager</code>打交道，通过调用<code>getService</code>函数来获取对应Service的信息。请看来源于<strong>IMediaDeathNotifier.cpp</strong>中的例子<code>getMediaPlayerService()</code>，它的代码如下所示：<br><strong>IMediaDeathNotifier.cpp</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  这个函数通过与ServiceManager通信，获得一个能够与MediaPlayerService通信的BpBinder，</span></span><br><span class="line"><span class="comment">  然后再通过障眼法interface_cast，转换成一个BpMediaPlayerService。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">IMediaDeathNotifier::getMediaPlayerService()</span><br><span class="line">&#123;</span><br><span class="line">       sp&lt;IServiceManager&gt; sm = defaultServiceManager();</span><br><span class="line">       sp&lt;IBinder&gt; binder;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">       <span class="comment">//向ServiceManager查询对应服务的信息，返回BpBinder。</span></span><br><span class="line">               binder = sm-&gt;getService(String16(<span class="string">"media.player"</span>));</span><br><span class="line">                <span class="keyword">if</span>(binder != <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//如果ServiceManager上还没有注册对应的服务，则需要等待，直到对应服务注册</span></span><br><span class="line"><span class="comment">//到ServiceManager中为止。</span></span><br><span class="line">            usleep(<span class="number">500000</span>);</span><br><span class="line">        &#125;<span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     通过interface_cast，将这个binder转化成BpMediaPlayerService，</span></span><br><span class="line"><span class="comment">     binder中的handle标识的一定是目的端MediaPlayerService。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   sMediaPlayerService = interface_cast&lt;IMediaPlayerService&gt;(binder);</span><br><span class="line">    &#125;</span><br><span class="line">    returnsMediaPlayerService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了<code>BpMediaPlayerService</code>，就能够使用任何<code>IMediaPlayerService</code>提供的业务逻辑函数了。例如<code>createMediaRecorder</code>和<code>createMetadataRetriever</code>等。<br>显而易见的是，调用的这些函数都将把请求数据打包发送给Binder驱动，由<code>BpBinder</code>中的<code>handle</code>值找到对应端的处理者来处理。这中间经历过如下的过程：</p>
<ul>
<li>（1）通讯层接收到请求。 </li>
<li>（2）递交给业务层处理。</li>
</ul>
<p>##子承父业<br>根据前面的分析可知，<code>MediaPlayerService</code>驻留在<code>MediaServer</code>进程中，这个进程有两个线程在<code>talkWithDriver</code>。假设其中有一个线程收到了请求，它最终会通过<code>executeCommand</code>调用来处理这个请求，实现代码如下所示：<br><strong>IPCThreadState.cpp</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> IPCThreadState::executeCommand(int32_tcmd)</span><br><span class="line">&#123;</span><br><span class="line">    BBinder*obj;</span><br><span class="line">   RefBase::weakref_type* refs;</span><br><span class="line">    status_tresult = NO_ERROR;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">switch</span>(cmd) &#123;</span><br><span class="line">    <span class="keyword">case</span> BR_ERROR:</span><br><span class="line">       result = mIn.readInt32();</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">        ......</span><br><span class="line">     caseBR_TRANSACTION:</span><br><span class="line">        &#123;</span><br><span class="line">           binder_transaction_data tr;</span><br><span class="line">           result = mIn.read(&amp;tr, <span class="keyword">sizeof</span>(tr));</span><br><span class="line">           <span class="keyword">if</span> (result != NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line">           Parcel buffer;</span><br><span class="line">           Parcel reply;</span><br><span class="line">           <span class="keyword">if</span> (tr.target.ptr) &#123;</span><br><span class="line">              <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 看到BBinder，想起图6-3了吗？ BnServiceXXX从BBinder派生，</span></span><br><span class="line"><span class="comment">                 这里的b实际就是实现BnServiceXXX的那个对象，这样就直接定位到了业务层的对象。</span></span><br><span class="line"><span class="comment">               */</span></span><br><span class="line">               sp&lt;BBinder&gt; b((BBinder*)tr.cookie);</span><br><span class="line">               <span class="keyword">const</span> <span class="keyword">status_t</span> error = b-&gt;transact(tr.code, buffer, &amp;reply, <span class="number">0</span>);</span><br><span class="line">               <span class="keyword">if</span> (error &lt; NO_ERROR) reply.setError(error);</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             the_context_object是IPCThreadState.cpp中定义的一个全局变量。可通过</span></span><br><span class="line"><span class="comment">             setTheContextObject函数设置。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">               <span class="keyword">const</span> <span class="keyword">status_t</span> error =</span><br><span class="line">                             the_context_object-&gt;transact(tr.code,buffer, &amp;reply, <span class="number">0</span>);</span><br><span class="line">               <span class="keyword">if</span> (error &lt; NO_ERROR) reply.setError(error);</span><br><span class="line">         &#125;</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure>
<p><code>BBinder</code>和业务层有什么关系？还记得图6-3吗？我们以<code>MediaPlayerService</code>为例，来梳理一下其派生关系，如图6-5所示：</p>
<p><img src="/media/15299381744168.jpg" alt=""></p>
<p>图6-5 <code>MediaPlayerService</code>家谱</p>
<p><code>BnMediaPlayerService</code>实现了<code>onTransact</code>函数，它将根据消息码调用对应的业务逻辑函数，这些业务逻辑函数由<code>MediaPlayerService</code>来实现。这一路的历程，如下面的代码所示：<br><strong>Binder.cpp</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> BBinder::transact(</span><br><span class="line">    uint32_tcode, <span class="keyword">const</span> Parcel&amp; data, Parcel* reply, <span class="keyword">uint32_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">   data.setDataPosition(<span class="number">0</span>);</span><br><span class="line">    status_terr = NO_ERROR;</span><br><span class="line">    <span class="keyword">switch</span>(code) &#123;</span><br><span class="line">        casePING_TRANSACTION:</span><br><span class="line">           reply-&gt;writeInt32(pingBinder());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">       <span class="keyword">default</span>:</span><br><span class="line">         <span class="comment">//调用子类的onTransact，这是一个虚函数。</span></span><br><span class="line">           err = onTransact(code, data, reply, flags);</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (reply!= <span class="literal">NULL</span>) &#123;</span><br><span class="line">       reply-&gt;setDataPosition(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    returnerr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>IMediaPlayerService.cpp</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> BnMediaPlayerService::onTransact(uint32_tcode, <span class="keyword">const</span> Parcel&amp; data,</span><br><span class="line">                                                  Parcel* reply, <span class="keyword">uint32_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">switch</span>(code) &#123;</span><br><span class="line">        ......</span><br><span class="line">        caseCREATE_MEDIA_RECORDER: &#123;</span><br><span class="line">           CHECK_INTERFACE(IMediaPlayerService, data, reply);</span><br><span class="line">           <span class="comment">//从请求数据中解析对应的参数</span></span><br><span class="line">           <span class="keyword">pid_t</span> pid = data.readInt32();</span><br><span class="line">            <span class="comment">//子类要实现createMediaRecorder函数。</span></span><br><span class="line">           sp&lt;IMediaRecorder&gt; recorder = createMediaRecorder(pid);</span><br><span class="line">           reply-&gt;writeStrongBinder(recorder-&gt;asBinder());</span><br><span class="line">           <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">        &#125;<span class="keyword">break</span>;</span><br><span class="line">        caseCREATE_METADATA_RETRIEVER: &#123;</span><br><span class="line">           CHECK_INTERFACE(IMediaPlayerService, data, reply);</span><br><span class="line">           <span class="keyword">pid_t</span> pid = data.readInt32();</span><br><span class="line">   <span class="comment">//子类要实现createMetadataRetriever函数</span></span><br><span class="line">           sp&lt;IMediaMetadataRetriever&gt; retriever =createMetadataRetriever(pid);</span><br><span class="line">           reply-&gt;writeStrongBinder(retriever-&gt;asBinder());</span><br><span class="line">           <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">        &#125;<span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">           <span class="keyword">return</span> BBinder::onTransact(code, data, reply, flags);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://wenyiqingnian.xyz/2018/06/24/从一次native端的IPC流程理解binder/" data-id="cjqw00e13005bvtfyw4abgt5q" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    
        <a href="http://wenyiqingnian.xyz/2018/06/24/从一次native端的IPC流程理解binder/#comments" class="article-comment-link">Comments</a>
    

        </footer>
    </div>
    
</article>



    <article id="post-《现代艺术150年》未影印作品2" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2018/06/16/《现代艺术150年》未影印作品2/">《现代艺术150年》未影印作品2</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2018/06/16/《现代艺术150年》未影印作品2/">
            <time datetime="2018-06-16T06:00:50.000Z" itemprop="datePublished">2018-06-16</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/备忘录/">备忘录</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/备忘录/">备忘录</a>, <a class="tag-link" href="/tags/现代艺术150年/">现代艺术150年</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p>51.The Kiss (French: Le Baiser)  吻 1882（Auguste Rodin, 奥古斯特·罗丹）<br><a href="https://en.wikipedia.org/wiki/The_Kiss_(Rodin_sculpture)" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/The_Kiss_(Rodin_sculpture)</a><br><img src="/media/15292175984876.jpg" alt=""></p>
<p>52.The Kiss  吻 1907-1908（Constantin Brâncuși, 康斯坦丁·布朗库西）<br><a href="https://en.wikipedia.org/wiki/The_Kiss_(Br%C3%A2ncu%C8%99i_sculpture)" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/The_Kiss_(Br%C3%A2ncu%C8%99i_sculpture)</a></p>
<p><img src="/media/15292176140941.jpg" alt=""></p>
<p>53.Sleeping Muse, 沉睡的缪斯 1910 （Constantin Brâncuși, 康斯坦丁·布朗库西）<br><a href="http://www.artic.edu/aic/collections/artwork/9024" target="_blank" rel="noopener">http://www.artic.edu/aic/collections/artwork/9024</a></p>
<p><img src="/media/15292176224205.jpg" alt=""></p>
<p>54.Head 头 1911-1912（Amedeo Modigliani, 阿梅代奥·莫迪利亚尼）<br><a href="https://www.wikiart.org/en/amedeo-modigliani/head" target="_blank" rel="noopener">https://www.wikiart.org/en/amedeo-modigliani/head</a><br><img src="/media/15292176318034.jpg" alt=""></p>
<p>55.Walking Man I 行走的人1 1960（Alberto Giacometti， 阿尔伯托·贾科梅蒂）<br><a href="https://www.artsy.net/artwork/alberto-giacometti-walking-man-i" target="_blank" rel="noopener">https://www.artsy.net/artwork/alberto-giacometti-walking-man-i</a><br><img src="/media/15292176408821.jpg" alt=""></p>
<p>56.Spoon Woman勺形女人 1927 （Alberto Giacometti， 阿尔伯托·贾科梅蒂）<br><a href="http://www.artic.edu/aic/collections/artwork/37761" target="_blank" rel="noopener">http://www.artic.edu/aic/collections/artwork/37761</a><br><img src="/media/15292176525962.jpg" alt=""></p>
<p>57.Pierced Form 穿孔之形 1963-1964（Barbara Hepworth, 芭芭拉·赫普沃斯）<br><a href="http://www.tate.org.uk/art/artworks/hepworth-pierced-form-t00704" target="_blank" rel="noopener">http://www.tate.org.uk/art/artworks/hepworth-pierced-form-t00704</a><br><img src="/media/15292176617908.jpg" alt=""></p>
<p>58.Pelagos 海洋生物 1946 （Barbara Hepworth, 芭芭拉·赫普沃斯）<br><a href="http://www.tate.org.uk/art/artworks/hepworth-pelagos-t00699" target="_blank" rel="noopener">http://www.tate.org.uk/art/artworks/hepworth-pelagos-t00699</a><br><img src="/media/15292176742098.jpg" alt=""></p>
<p>59.Single Form 单一的形式 1961 （Barbara Hepworth, 芭芭拉·赫普沃斯）<br><a href="http://www.tate.org.uk/art/artworks/hepworth-single-form-september-t03143" target="_blank" rel="noopener">http://www.tate.org.uk/art/artworks/hepworth-single-form-september-t03143</a></p>
<p><img src="/media/15292176831725.jpg" alt=""></p>
<h2 id="SEVEN"><a href="#SEVEN" class="headerlink" title="SEVEN"></a>SEVEN</h2><p>60.Opening of the Fifth Seal 揭开第五印  1608（El Greco, 埃尔·格列柯）<br><a href="https://en.wikipedia.org/wiki/Opening_of_the_Fifth_Seal" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Opening_of_the_Fifth_Seal</a><br><img src="/media/15292176921293.jpg" alt=""></p>
<p>61.Houses at l’Estaque 埃斯塔克的房子 1908（Georges Braque, 乔治·布拉克）<br><a href="https://en.wikipedia.org/wiki/Houses_at_l%27Estaque" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Houses_at_l%27Estaque</a></p>
<p><img src="/media/15292177113811.jpg" alt=""></p>
<p>62.Violin and Palette 小提琴与调色板 1909（Georges Braque, 乔治·布拉克）<br><a href="https://www.wikiart.org/en/georges-braque/violin-and-palette-1909" target="_blank" rel="noopener">https://www.wikiart.org/en/georges-braque/violin-and-palette-1909</a><br><img src="/media/15292177210636.jpg" alt=""></p>
<p>63.Still Life with Flowers 静物花卉 1912（Juan Gris, 胡安·格里斯）<br><a href="https://www.wikiart.org/en/juan-gris/still-life-with-flowers-1912" target="_blank" rel="noopener">https://www.wikiart.org/en/juan-gris/still-life-with-flowers-1912</a></p>
<p><img src="/media/15292177353327.jpg" alt=""></p>
<p>64.Ma Jolie 我的美人 1912（Pablo Picasso, 巴勃罗·毕加索）<br><a href="https://www.moma.org/collection/works/79051" target="_blank" rel="noopener">https://www.moma.org/collection/works/79051</a><br><img src="/media/15292177517197.jpg" alt=""></p>
<p>65.Still-Life with Chair Caning有藤椅的静物 1912（Pablo Picasso, 巴勃罗·毕加索）<br><a href="http://www.pablo-ruiz-picasso.net/work-88.php" target="_blank" rel="noopener">http://www.pablo-ruiz-picasso.net/work-88.php</a><br><img src="/media/15292177652495.jpg" alt=""></p>
<p>66.Fruit Dish and Glass 水果盘与玻璃杯  1912 （Georges Braque, 乔治·布拉克）<br><a href="https://en.wikipedia.org/wiki/Fruit_Dish_and_Glass" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Fruit_Dish_and_Glass</a><br><img src="/media/15292177736853.jpg" alt=""></p>
<p>67.The Little Fourteen-Year-Old Dancer (French: La Petite Danseuse de Quatorze Ans)  小舞女 1880-1881 （Edgar Degas 埃德加·德加）<br><a href="https://en.wikipedia.org/wiki/Little_Dancer_of_Fourteen_Years" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Little_Dancer_of_Fourteen_Years</a><br><img src="/media/15292177894146.jpg" alt=""></p>
<p>68.Guitar 吉他 1912（Pablo Picasso, 巴勃罗·毕加索）<br><a href="https://www.wikiart.org/en/pablo-picasso/guitar-1912" target="_blank" rel="noopener">https://www.wikiart.org/en/pablo-picasso/guitar-1912</a><br><img src="/media/15292177950269.jpg" alt=""></p>
<h2 id="EIGHT"><a href="#EIGHT" class="headerlink" title="EIGHT"></a>EIGHT</h2><p>69.Dynamism of a Dog on a Leash (Italian: Dinamismo di un cane al guinzaglio)拴着皮带的狗的动态 1912（Giacomo Balla, 贾科莫·巴拉）<br><a href="https://en.wikipedia.org/wiki/Dynamism_of_a_Dog_on_a_Leash" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Dynamism_of_a_Dog_on_a_Leash</a></p>
<p><img src="/media/15292178075225.jpg" alt=""></p>
<p>70.Unique Forms of Continuity in Space 空间中连续的唯一形体 1913（UmbertoBoccioni, 翁贝托·薄丘尼） <a href="https://en.wikipedia.org/wiki/Unique_Forms_of_Continuity_in_Space" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Unique_Forms_of_Continuity_in_Space</a></p>
<p><img src="/media/15292178225341.jpg" alt=""></p>
<p>71.States of Mind I: The Farewells  心境I 告别 1911<br>     States of Mind II: Those Who Go 心境II 离开的人 1911<br>     States of Mind III: Those Who Stay 心境III 留下的人 1911<br>   （UmbertoBoccioni, 翁贝托·薄丘尼）<br><a href="https://www.wikiart.org/en/umberto-boccioni/states-of-mind-i-the-farewells-1911" target="_blank" rel="noopener">https://www.wikiart.org/en/umberto-boccioni/states-of-mind-i-the-farewells-1911</a><br><a href="https://www.wikiart.org/en/umberto-boccioni/states-of-mind-ii-those-who-go-1911" target="_blank" rel="noopener">https://www.wikiart.org/en/umberto-boccioni/states-of-mind-ii-those-who-go-1911</a><br><a href="https://www.wikiart.org/en/umberto-boccioni/states-of-mind-iii-those-who-stay-1911-1" target="_blank" rel="noopener">https://www.wikiart.org/en/umberto-boccioni/states-of-mind-iii-those-who-stay-1911-1</a><br><img src="/media/15292178379461.jpg" alt=""></p>
<p><img src="/media/15292178507767.jpg" alt=""></p>
<p><img src="/media/15292178598767.jpg" alt=""></p>
<p>72.L’Équipe de Cardiff 加迪夫队 1913（Robert Delaunay, 罗伯特·德劳内）<br><a href="https://fr.wikipedia.org/wiki/L%27%C3%89quipe_de_Cardiff" target="_blank" rel="noopener">https://fr.wikipedia.org/wiki/L%27%C3%89quipe_de_Cardiff</a><br><img src="/media/15292178739277.jpg" alt=""></p>
<p>73.Rock Drill 凿岩机 1913（Jacob Epstein, 雅各·爱泼斯坦）<br><a href="https://en.wikipedia.org/wiki/Rock_Drill_(Jacob_Epstein)" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Rock_Drill_(Jacob_Epstein)</a><br><img src="/media/15292178833052.jpg" alt=""></p>
<h2 id="NINE"><a href="#NINE" class="headerlink" title="NINE"></a>NINE</h2><p>74.The First Step 第一步 1910（František Kupka, 弗朗齐歇克·库普卡）<br><a href="https://www.moma.org/collection/works/79969" target="_blank" rel="noopener">https://www.moma.org/collection/works/79969</a><br><img src="/media/15292178942900.jpg" alt=""></p>
<p>75.Disque simultané（Simultaneous Disc）共时的圆盘 1912（Robert Delaunay, 罗伯特·德劳内）<br><a href="https://fr.wikipedia.org/wiki/Disque_simultan%C3%A9" target="_blank" rel="noopener">https://fr.wikipedia.org/wiki/Disque_simultan%C3%A9</a><br><img src="/media/15292179001516.jpg" alt=""></p>
<p>76.München - Planegg I 慕尼黑-普拉内格 1 1901（Wassily Kandinsky, 瓦西里·康定斯基）<br><a href="https://www.akg-images.de/archive/Munchen-%25E2%2580%2593-Planegg-I-2UMDHUORFRFR.html" target="_blank" rel="noopener">https://www.akg-images.de/archive/Munchen-%25E2%2580%2593-Planegg-I-2UMDHUORFRFR.html</a><br><img src="/media/15292179093621.jpg" alt=""></p>
<p>77.Murnau, Dorfstrasse (A Village Street) 穆尔瑙，乡村道路 1908 （Wassily Kandinsky, 瓦西里·康定斯基）<br><a href="https://commons.wikimedia.org/wiki/File:Vassily_Kandinsky,_1908,_Murnau,_Dorfstrasse.jpg" target="_blank" rel="noopener">https://commons.wikimedia.org/wiki/File:Vassily_Kandinsky,_1908,_Murnau,_Dorfstrasse.jpg</a><br><img src="/media/15292179178192.jpg" alt=""></p>
<p>78.Kochel - Straight Road 科黑尔，笔直的路 1909（Wassily Kandinsky, 瓦西里·康定斯基）<br><a href="http://www.the-athenaeum.org/art/detail.php?ID=116422" target="_blank" rel="noopener">http://www.the-athenaeum.org/art/detail.php?ID=116422</a></p>
<p><img src="/media/15292179294972.jpg" alt=""></p>
<p>79.Improvisation 4 即兴 4 1909（Wassily Kandinsky, 瓦西里·康定斯基）<br><a href="https://www.wikiart.org/en/wassily-kandinsky/improvisation-4-1909" target="_blank" rel="noopener">https://www.wikiart.org/en/wassily-kandinsky/improvisation-4-1909</a></p>
<p><img src="/media/15292179410842.jpg" alt=""></p>
<p>80.Impression III (Concert) 印象3（音乐会） 1911 （Wassily Kandinsky, 瓦西里·康定斯基）<br><a href="https://www.wikiart.org/en/wassily-kandinsky/impression-iii-concert-1911" target="_blank" rel="noopener">https://www.wikiart.org/en/wassily-kandinsky/impression-iii-concert-1911</a></p>
<p><img src="/media/15292179496940.jpg" alt=""></p>
<p>81.Picture with a Circle  带圆的画 1911 （Wassily Kandinsky, 瓦西里·康定斯基）<br><a href="http://www.wassilykandinsky.net/work-432.php" target="_blank" rel="noopener">http://www.wassilykandinsky.net/work-432.php</a><br><img src="/media/15292179605301.jpg" alt=""></p>
<p>82.Composition IV 作曲 4 1911（Wassily Kandinsky, 瓦西里·康定斯基）<br><a href="https://www.wikiart.org/en/wassily-kandinsky/composition-iv-1911" target="_blank" rel="noopener">https://www.wikiart.org/en/wassily-kandinsky/composition-iv-1911</a><br><img src="/media/15292179734750.jpg" alt=""></p>
<p>83.Composition VII 作曲 7 1913（Wassily Kandinsky, 瓦西里·康定斯基）<br><a href="http://www.wassilykandinsky.net/work-36.php" target="_blank" rel="noopener">http://www.wassilykandinsky.net/work-36.php</a><br><img src="/media/15292179891642.jpg" alt=""></p>
<p>84.Hammamet with mosque 哈马马特的清真寺 1914（Paul Klee, 保罗·克利）<br><a href="https://www.wikiart.org/en/paul-klee/hammamet-with-mosque-1914" target="_blank" rel="noopener">https://www.wikiart.org/en/paul-klee/hammamet-with-mosque-1914</a><br><img src="/media/15292179992868.jpg" alt=""></p>
<h2 id="TEN"><a href="#TEN" class="headerlink" title="TEN"></a>TEN</h2><p>85.Cow And Violin 奶牛和小提琴 1913（Kazimir Malevich, 卡济米尔·马列维奇）<br><a href="http://russianartgallery.org/famous/malevich_cow.htm" target="_blank" rel="noopener">http://russianartgallery.org/famous/malevich_cow.htm</a><br><img src="/media/15292180077535.jpg" alt=""></p>
<p>86.Black Square 黑色正方形 1915 （Kazimir Malevich, 卡济米尔·马列维奇）<br><a href="https://en.wikipedia.org/wiki/Black_Square_(painting)" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Black_Square_(painting)</a><br><img src="/media/15292180159011.jpg" alt=""></p>
<p>87.Suprematist Painting 至上主义 1915 （Kazimir Malevich, 卡济米尔·马列维奇）<br><a href="http://www.ibiblio.org/eldritch/el/mpix.html" target="_blank" rel="noopener">http://www.ibiblio.org/eldritch/el/mpix.html</a><br><img src="/media/15292180244412.jpg" alt=""></p>
<p>88.Corner Counter-Relief 1914 角落的反浮雕（Vladimir Tatlin, 弗拉基米尔·塔特林）<br><a href="http://rusmuseumvrm.ru/data/collections/sculpture/20/tatlin_ve_uglovoy_kontrrelef_1914/index.php?lang=en" target="_blank" rel="noopener">http://rusmuseumvrm.ru/data/collections/sculpture/20/tatlin_ve_uglovoy_kontrrelef_1914/index.php?lang=en</a></p>
<p><img src="/media/15292180343049.jpg" alt=""></p>
<p>89.Monument to the Third International 第三国际的纪念塔 1919-1920（Vladimir Tatlin, 弗拉基米尔·塔特林）<br> <a href="https://en.wikipedia.org/wiki/Tatlin%27s_Tower" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Tatlin%27s_Tower</a></p>
<p><img src="/media/15292180515507.jpg" alt=""></p>
<p>90.Pure Red Color, Pure Yellow Color, Pure Blue Color 纯红、纯黄和纯蓝 1921（Alexander Rodchenko, 亚历山大·罗琴科）</p>
<p><img src="/media/15292180607987.jpg" alt=""></p>
<p>91.Beat the Whites with the Red Wedge 以红锲攻打白军 1919（El Lissitzky, 埃尔·利西茨基）<br><a href="https://en.wikipedia.org/wiki/Beat_the_Whites_with_the_Red_Wedge" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Beat_the_Whites_with_the_Red_Wedge</a></p>
<p><img src="/media/15292180686570.jpg" alt=""></p>
<h2 id="ELEVEN"><a href="#ELEVEN" class="headerlink" title="ELEVEN"></a>ELEVEN</h2><p>92.Composition C (No.III) with Red, Yellow and Blue构成C（第 3号），红黄蓝 1935（Piet Mondrian, 皮埃特·蒙特里安）<br><a href="https://theartstack.com/artist/piet-mondrian/composition-c-no-iii-with-red-yellow-and-blue#" target="_blank" rel="noopener">https://theartstack.com/artist/piet-mondrian/composition-c-no-iii-with-red-yellow-and-blue#</a><br><img src="/media/15292180863314.jpg" alt=""></p>
<p>93.Evening; Red Tree 夜晚，红树 1908 （Piet Mondrian, 皮埃特·蒙特里安）<br><a href="https://en.wikipedia.org/wiki/Evening;_Red_Tree" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Evening;_Red_Tree</a></p>
<p><img src="/media/15292180959896.jpg" alt=""></p>
<p>94.Gray Tree 灰色的树 1912 （Piet Mondrian, 皮埃特·蒙特里安）<br><a href="https://en.wikipedia.org/wiki/Gray_Tree" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Gray_Tree</a><br><img src="/media/15292181033239.jpg" alt=""></p>
<p>95.Blossoming Apple Tree  开花的苹果树 1912 （Piet Mondrian, 皮埃特·蒙特里安）<br><a href="https://en.wikipedia.org/wiki/Evening;_Red_Tree#/media/File:Blossoming_apple_tree,_by_Piet_Mondriaan.jpg" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Evening;_Red_Tree#/media/File:Blossoming_apple_tree,_by_Piet_Mondriaan.jpg</a><br><img src="/media/15292181126923.jpg" alt=""></p>
<p>96.Tableau No. 2/Composition No. VII 画面 2/构成 7 1913 （Piet Mondrian, 皮埃特·蒙特里安）<br><a href="https://theartstack.com/artist/piet-mondrian/tableau-no-2-compositio" target="_blank" rel="noopener">https://theartstack.com/artist/piet-mondrian/tableau-no-2-compositio</a><br><img src="/media/15292181204601.jpg" alt=""></p>
<p>97.Composition No VI 构成 6 1914 （Piet Mondrian, 皮埃特·蒙特里安）<br><img src="/media/15292181399236.jpg" alt=""></p>
<p>98.Red and Blue Chair 红蓝椅 1923 （Gerrit Rietveld, 赫里特·里特费尔德）<br><a href="http://www.theartstory.org/movement-de-stijl-artworks.htm" target="_blank" rel="noopener">http://www.theartstory.org/movement-de-stijl-artworks.htm</a><br><img src="/media/15292181326462.jpg" alt=""></p>
<p>99.Rietveld Schröder House 施罗德住宅 1924 （Gerrit Rietveld, 赫里特·里特费尔德）<br><a href="https://en.wikipedia.org/wiki/Rietveld_Schr%C3%B6der_House" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Rietveld_Schr%C3%B6der_House</a></p>
<p><img src="/media/15292181532387.jpg" alt=""></p>
<p>100.Composition No.1 构成第一号 1920 （Piet Mondrian, 皮埃特·蒙特里安）<br><img src="/media/15292181590021.jpg" alt=""></p>
<h2 id="TWELVE"><a href="#TWELVE" class="headerlink" title="TWELVE"></a>TWELVE</h2><p>101.Wainwright Building 温赖特大厦 1891（ Dankmar Adler and Louis Sullivan, 阿德勒和路易斯·沙利文）<br><a href="https://en.wikipedia.org/wiki/Wainwright_Building" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Wainwright_Building</a></p>
<p><img src="/media/15292181722733.jpg" alt=""></p>
<p>102.AEG turbine factory 通用电气涡轮机工厂 1909 （Peter Behrens, 彼特·贝伦斯）<br><a href="https://en.wikipedia.org/wiki/AEG_turbine_factory" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/AEG_turbine_factory</a></p>
<p><img src="/media/15292181849573.jpg" alt=""></p>
<p>103.Fagus Factory (German:Fagus-Werk）法古斯工厂 1911-1913 （ Walter Gropius and Adolf Meyer, 沃尔特·格罗佩斯，阿道夫·梅耶）<br><a href="https://en.wikipedia.org/wiki/Fagus_Factory" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Fagus_Factory</a><br><img src="/media/15292181939189.jpg" alt=""></p>
<p>104.Self-Portrait as a Soldier 作为一个军人的自画像 1915（Ernst Ludwig Kirchner, 恩斯特·路德维希·凯尔希纳）<br><a href="https://www.wikiart.org/en/ernst-ludwig-kirchner/self-portrait-as-a-soldier-1915" target="_blank" rel="noopener">https://www.wikiart.org/en/ernst-ludwig-kirchner/self-portrait-as-a-soldier-1915</a><br><img src="/media/15292182030237.jpg" alt=""></p>
<p>105.Hot-Water Jug 1924（Marianne Brandt, 玛丽安·布兰德）<br><a href="https://www.moma.org/collection/works/2440" target="_blank" rel="noopener">https://www.moma.org/collection/works/2440</a></p>
<p><img src="/media/15292182113973.jpg" alt=""></p>
<p>106.Table Lamp 华根菲尔德台灯 1924（Wilhelm Wagenfeld &amp; Carl Jakob Jucker, 威尔赫姆·华根菲尔德，卡尔·朱克）<br><a href="https://www.moma.org/collection/works/4056?locale=en" target="_blank" rel="noopener">https://www.moma.org/collection/works/4056?locale=en</a><br><img src="/media/15292182221930.jpg" alt=""></p>
<p>107.EM 1 (Telephone Picture) 电话图 EM1 1923 （László Moholy-Nagy, 莫霍利·纳吉）<br><a href="https://www.moma.org/collection/works/147626" target="_blank" rel="noopener">https://www.moma.org/collection/works/147626</a><br><img src="/media/15292182328932.jpg" alt=""></p>
<p>108.NESTING TABLES 嵌套桌组 1927 （Josef Albers, 约瑟夫·亚伯斯）<br><a href="https://blog.timelesswroughtiron.com/2014/09/modern-history-bauhaus-nesting-tables/" target="_blank" rel="noopener">https://blog.timelesswroughtiron.com/2014/09/modern-history-bauhaus-nesting-tables/</a><br><img src="/media/15292182429532.jpg" alt=""></p>
<p>109.Wassily Chair 瓦西里椅 1925（Marcel Lajos Breuer, 马塞尔·布劳耶）<br><a href="https://en.wikipedia.org/wiki/Wassily_Chair" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Wassily_Chair</a></p>
<p><img src="/media/15292182521590.jpg" alt=""></p>
<p>110.Barcelona Pavilion 巴塞罗那世博会德国馆  1929 （Ludwig Mies van der Rohe, 路德维希·密斯·凡德罗）<br><a href="https://en.wikipedia.org/wiki/Barcelona_Pavilion" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Barcelona_Pavilion</a><br><img src="/media/15292182626406.jpg" alt=""></p>
<p>111.Barcelona Chair 巴塞罗那椅 1929 （Ludwig Mies van der Rohe, 路德维希·密斯·凡德罗）<br><a href="https://www.moma.org/collection/works/4369?locale=en" target="_blank" rel="noopener">https://www.moma.org/collection/works/4369?locale=en</a><br><img src="/media/15292182733434.jpg" alt=""></p>
<h2 id="THIRTEEN"><a href="#THIRTEEN" class="headerlink" title="THIRTEEN"></a>THIRTEEN</h2><p>112.La Nona Ora (The Ninth Hour) 第九时辰 1999（Maurizio Cattelan, 莫瑞吉奥·卡特兰）<br><a href="https://farticulate.wordpress.com/2010/10/21/la-nona-ora-the-ninth-hour-1999/" target="_blank" rel="noopener">https://farticulate.wordpress.com/2010/10/21/la-nona-ora-the-ninth-hour-1999/</a><br><img src="/media/15292182840020.jpg" alt=""></p>
<p>113.Collage with Squares Arranged according to the Laws of Chance 根据随机法则排布的正方形的拼贴画 1916-1917 （Jean （Hans）Arp, 让·阿尔普（汉斯·阿尔普））<br><a href="https://www.moma.org/collection/works/37013?locale=en" target="_blank" rel="noopener">https://www.moma.org/collection/works/37013?locale=en</a><br><img src="/media/15292182948826.jpg" alt=""></p>
<p>114.Revolving 旋转 1919 （Kurt Schwitters, 库尔特·施维特斯）<br><a href="https://www.moma.org/collection/works/79211?locale=en" target="_blank" rel="noopener">https://www.moma.org/collection/works/79211?locale=en</a><br><img src="/media/15292183044893.jpg" alt=""></p>
<p>115.Merzbau 梅尔兹堡 1933 （Kurt Schwitters, 库尔特·施维特斯）<br><a href="https://www.moma.org/explore/inside_out/2012/07/09/in-search-of-lost-art-kurt-schwitterss-merzbau/" target="_blank" rel="noopener">https://www.moma.org/explore/inside_out/2012/07/09/in-search-of-lost-art-kurt-schwitterss-merzbau/</a><br><img src="/media/15292183118486.jpg" alt=""></p>
<p>116.3 Standard Stoppages 三个标准的终止 1913-1914（Marcel Duchamp, 马塞尔·杜尚）<br><a href="https://www.moma.org/collection/works/78990?locale=en" target="_blank" rel="noopener">https://www.moma.org/collection/works/78990?locale=en</a></p>
<p><img src="/media/15292183180573.jpg" alt=""></p>
<p>117.L.H.O.O.Q. 1919 （Marcel Duchamp, 马塞尔·杜尚）<br><a href="https://en.wikipedia.org/wiki/L.H.O.O.Q" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/L.H.O.O.Q</a>.<br><img src="/media/15292183282990.jpg" alt=""></p>
<p>118.Beautiful Breath: Veil Water 美丽气息 1921 （Marcel Duchamp, 马塞尔·杜尚）<br><a href="http://www.toutfait.com/unmaking_the_museum/Belle%20Haleine.html" target="_blank" rel="noopener">http://www.toutfait.com/unmaking_the_museum/Belle%20Haleine.html</a></p>
<p><img src="/media/15292183377928.jpg" alt=""></p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://wenyiqingnian.xyz/2018/06/16/《现代艺术150年》未影印作品2/" data-id="cjqw00dzr001fvtfymw5kjuk0" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    
        <a href="http://wenyiqingnian.xyz/2018/06/16/《现代艺术150年》未影印作品2/#comments" class="article-comment-link">Comments</a>
    

        </footer>
    </div>
    
</article>



    <article id="post-深度学习1-反向传播" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2018/06/08/深度学习1-反向传播/">深度学习1-反向传播</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2018/06/08/深度学习1-反向传播/">
            <time datetime="2018-06-08T09:33:50.000Z" itemprop="datePublished">2018-06-08</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/机器学习/">机器学习</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/Tensorflow/">Tensorflow</a>, <a class="tag-link" href="/tags/机器学习/">机器学习</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <h1 id="机器学习算法中的数学思想"><a href="#机器学习算法中的数学思想" class="headerlink" title="机器学习算法中的数学思想"></a>机器学习算法中的数学思想</h1><h2 id="一、-机器学习的过程是在学习什么"><a href="#一、-机器学习的过程是在学习什么" class="headerlink" title="一、 机器学习的过程是在学习什么"></a>一、 机器学习的过程是在学习什么</h2><p>以<code>MNIST</code>手写数字识别为例 MNIST是一个手写数字数据库，它是以一个28*28像素的图片以及一个对应的数字标签作为键值对的数据库。<br><img src="/media/15285243813747.jpg" alt="-w218"></p>
<p>为了更好的将这个识别过程数学化，先将输入的图形像素化，每一个数字图形可以按照各像素的明度值 转化为一个784个参数的列向量。<br><code>[0.1,0.3,0.4 ...... 0.0,0.8]</code><br><img src="/media/15285243407818.jpg" alt="-w391"></p>
<p>其中每个向量值代表一个像素对应的明度值。<br>假设学习模型为一个有两个隐藏层的全连接层。<br><img src="/media/15285246497144.jpg" alt="-w367"></p>
<p>可以看到 每个神经元与神经元之间都由一根线连接着，这根线其实指代的是两个神经元之间的关系，用数学方式来说，可以称之为 <strong>权重值</strong>。</p>
<p>我们希望找到<strong>每根线所代表的权重</strong>，当输入一个手写数字图片的时候，通过第一层的权重值，点亮部分第一个隐藏层的神经元【注1】</p>
<blockquote>
<p>注释1： 可以假设 最后一层隐藏的神经元所代表的是类似人类识别数字那样，指代组成数字的一些笔画，比如说圆圈或者竖线，那么第一层隐藏的神经元可能指代的是 组成哪些笔画的更细微一些的笔画，比如一个左上角的圆弧，一个左下角的圆弧之类，但其实机器学习的过程并非我们想象的那样，每一层代表的可能是一些我们人类都看不懂的信息，我们称之为features，或者说是特征。为了更好理解机器学习的数学原理，我们暂且这么认为。</p>
</blockquote>
<p>那么 拿最后输出层的一个神经元 <code>a2</code>  来说，它就等于上一层神经元与权重值的求和$sum = \sum_j W_{i,j}x_j$<br>但只求和是不行的，因为对于输出端 <code>a2</code>来说，它的值必须在<code>[0,1]</code>范围内，这里就要用到<code>sigmoid()</code> 压缩函数。【注2】</p>
<blockquote>
<p>注2： sigmoid 函数 是一个压缩函数  $ S(x) = \frac{1}{1+e_{-x}}$，sigmoid函数连续，光滑，严格单调，以(0,0.5)中心对称，是一个非常良好的阈值函数。<br>当x趋近负无穷时，y趋近于0；趋近于正无穷时，y趋近于1；x=0时，y=0.5。当然，在x超出[-6,6]的范围后，函数值基本上没有变化，值非常接近，在应用中一般不考虑。 在机器学习中，常常使用sigmoid函数 将相似率控制在<code>0-1</code> 范围内。</p>
</blockquote>
<p>当然，神经元的触发难易程度也不应该是一样的，我们在求和函数$sum = \sum_j W_{i,j}x_j$中<br>增加一个偏置值$ b_i$，用来控制神经元激活的难易程度。<br>$sum = \sum_j W_{i,j}x_j+b_i$<br>那么 输出结果<code>ai</code> 就可以用公式表示为<br>$ a_i = sigmoid（\sum{w^{i-1}_j a_j^{l-1}+b_i}）$<br>所谓机器学习，就是找到上述有着无比复杂参数（偏置b和权重w）的函数<code>funa（）</code>，求出其正确的偏置和权重值,使得我们每次输入一个手写图片向量，该函数都能在最后点亮输出向量中的某个神经节点。<br>所以： 机器学习的核心，<strong>就是使用合适的方法 去找到学习的数学模型里，所有的 偏置和 权重</strong></p>
<h2 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h2><p>这是机器学习的核心，就是找到一个合适的方法，去调整偏置和权重，使输出层的结果尽可能的与我们期望的结果一致。<br>就以前面说到的识别mnist手写数字识别算法为例。<br>当输入一个手写数字 2 的时候<br><img src="/media/15285207921376.jpg" alt="-w78"></p>
<p>当模型还未完全训练完毕，输入的结果和输出的结果看起来应该是没有什么关联的。<br><img src="/media/15285208383753.jpg" alt="-w91"><br> 可以看到，尚未完成训练的模型，它的识别结果是很混乱的，同时点亮了好几个数字。</p>
<p> <strong>我们的期望：</strong> 是让数字2 对应的节点 值变得更大，让其他的节点 对应的结果值变得更小。同时 该变化应该和节点当前对应的值与期望值的差距成正比。</p>
<p> 比如说 节点2 当前激活的值为0.2  我们期望的值是1，那么节点2变大 对于我们预测模型来说就比让节点8变为0要来的更重要，因为节点8 当前的数值0.2 已经和我们期望的0 差距不大了，而2对应的0.2 与我们当前期望的1差距显然要更大。<br> 见下图：<br> <img src="/media/15285212725297.jpg" alt="-w280"></p>
<p>我们知道，数字2 对应的值0.2  是将输入的748列向量的值，与对应的偏置和权重相乘之后求和，再通过<code>sigmoid()</code>函数 将其结果约束在[0,1]之间的<br><img src="/media/15285213924586.jpg" alt=""></p>
<blockquote>
<p>注： w0 w1 w2…. 为上一层（该例子中为第二个隐藏层）对应的每个神经元的权重，b为偏置向量。<br>如果要让0.2（即节点2对应的输出）变大，有三个途径</p>
<ol>
<li>增大权重wi </li>
<li>增大偏置b</li>
<li>修改ai的值</li>
</ol>
</blockquote>
<p>我们目前只关注如何修改权重 使得输出节点2 对应的结果变大。<br> <img src="/media/15285217014448.jpg" alt="-w273"></p>
<p>可以看到上一个链接层对应的激活情况如图。<br>如果我们要更改权重值， 那么1，6，7，9对应的神经节点的参数更改会更有意义，因为预测结果是上层神经元与权重乘积求和的，因为1678 对应的节点更亮，那么增大他们之间的权重值会更有意义。同样，如果如果我们更改节点的值，那么1，6，7，9对应的节点更应该增大，但现在我们无法更改节点值，只能通过更改权重和偏置的值来修改最终的计算结果。</p>
<p>这只是当只有一个输入的时候，输出结果告诉我们它对上个节点权重值变化的诉求，以这个例子为例，就代表<br>当输入一个手写数字2 的时候，为了使输出结果更接近为2，结果神经元要求上一个隐藏层中 第 1，6，7，9对应的节点的权重应该更大，那么当吧全部训练数据输入进来的时候，所有的输出结果对上一个神经元 权重的诉求就都可以获取到了，那么将全部的诉求求和求均，就得到整个样本对该模型 第二个隐藏层 权重变化的诉求。</p>
<h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><p>当学习模型尚未训练好，它给出的结果可以说是相当随机的，那么有必要告诉模型，当前的输出结果与预期结果偏差有多大。 这里便引申出损失函数的概念。</p>
<blockquote>
<p>损失函数（loss function）是用来估量模型的预测值f(x)与真实值Y不一致的程度，它是一个非负实数值函数，通常使用L(Y,f(x))来表示，损失函数越小，模型稳健性越好。</p>
</blockquote>
<p>在机器学习里 我们的损失函数一般是 预测结果和期望结果的平方差之和。<br>我们训练模型，就是为了是损失函数最小。<br>机器学习的损失函数可以表示为【注3】<br><img src="/media/15285284715958.jpg" alt="-w233"></p>
<blockquote>
<p>参数解释：<br>$a^j$：机器学习预测出的结果值<br>$b^j$： 目标期望值<br>$C_0$： 表示输入一个样本的损失值</p>
</blockquote>
<p>其中 $a^j$ 又可以表示 上一层神经元与权重和偏置的加权和，我们记为z，对z进行sigmoid压缩得到的结果。</p>
<p>用公式可以表述如下：<br><img src="/media/15285287793871.jpg" alt="-w200"></p>
<p><img src="/media/15285287553501.jpg" alt="-w712"></p>
<p>那么 可以看到 最终的损失值$C_0$ 可以表示为<br><img src="/media/15285288771325.jpg" alt="-w222"> </p>
<h3 id="反向传播算法"><a href="#反向传播算法" class="headerlink" title="反向传播算法"></a>反向传播算法</h3><h4 id="正向传播过程"><a href="#正向传播过程" class="headerlink" title="正向传播过程"></a>正向传播过程</h4><p>当我们输入随机的一组权重和偏置，以及一张手写数字数组之后，将其按照求和公式求和，可得到一组预测值。<br>这叫正向传播</p>
<blockquote>
<p>正向传播： 根据输入的一组数据，计算出输出值</p>
</blockquote>
<h4 id="反向传播-1"><a href="#反向传播-1" class="headerlink" title="反向传播"></a>反向传播</h4><blockquote>
<p>概念： 当计算出预测值之后，因为它必定跟我们的期望结果有偏差，所以就需要将偏差值计算出来，将偏差反向传播，计算每个权重的偏导值，然后以一定的步长更新权重，减小误差，这叫反向传播。</p>
</blockquote>
<p>上面说过，我们判断上个神经元层与输出结果的神经元之间的权重变化，他们不仅与当前计算结果和预期结果的偏差相关（表现在数学上，就是输出向量与预期向量$y = [0,0,1,0,0,0,0,0,0]$ 之间的求和平均数），还与当前神经元的数值相关。</p>
<p>对于上文中 我们说过的损失函数C，机器学习的目的就是通过改变对应的偏置b和权重w 使该函数最小，那么我们只需要求出 损失函数对每一个偏置和每一个权重的偏导数即可，知道了偏导数，我们就知道权重应该以什么样的方式，以多大的数量，增加还是减少，来影响最终的预测结果从而是损失函数降低到最小。一般的处理是，算出权重的梯度值之后，如果梯度为正，就意味着<a href="https://zh.wikipedia.org/wiki/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%B3%95" target="_blank" rel="noopener">这里涉及到梯度下降算法的一些知识，可以详细的看一下梯度下降的维基百科，讲的很好</a></p>
<p>剩下的就是求偏导数的知识了，$C_0$ 对$ w_{l}^j$ 的敏感度，也就是偏导数，根据链式法则，可以求得为：<br><img src="/media/15285295752254.jpg" alt="-w341"></p>
<p>其中 每一项，抛去数学含义，它都是代表了一定意义的</p>
<ol>
<li>$C_0$ 对$a_j^{L}$ 的偏导数： 因为平方差函数（损失函数c0）的偏导数斜率一般为正，所以该函数意味着 目标函数与预测函数之间的差距越大，偏置w的改变对该偏差值的影响就越大，与上文所讲的吻合，就是预测值和期望值之间的差距，也会对权重的改变产生影响。偏差越大的，他们的权重改变对偏差值的影响会更大。（就是改变这些偏差大的神经元他们链接的权重会更有性价比一些）</li>
<li>a对z求导：就是你所选的非线性激活函数对z的偏导数</li>
<li>$z^{L}<em>j$对$w</em>{jk}^{L}$ 的偏导数： 偏导结果其实是$f(a^{L-1})$ ，意味着 L层的权重$w^{L}_{jk}$ 对偏差值的影响 受到它上一层的神经元的影响。也就是<strong>一同激活的神经元联系在一起</strong>这句话的由来</li>
</ol>
<p><strong>说到这里，我们有必要看一下 $C_0$ 对$a_j^{L-1}$（L1层的神经元）的敏偏导数。这是理解反向传播算法的核心</strong><br>虽然上文说过 我们无法改变$a_{L-1}$层神经元的值，只能改变他们的权重和偏置，但是看一下</p>
<p><img src="/media/15285328187937.jpg" alt="-w200"></p>
<p>$a^(L-1)$ 与$z^{L-1}$ 、$w^{L-1}$、$a^{L-2}$ 、$b^{L-1}$是直接相关联的，那么如果知道<br>$C_0$ 对$a_j^{L-1}$的偏导数，那么反过来用求导公式<br><img src="/media/15285338339984.jpg" alt="-w300"></p>
<p>（将公式中的L 替换为L-1，同时左边的移动到右边，也就知道了代价函数对之前偏置和权重的偏导数了。<br>对上一层神经元的的偏导数：<br><img src="/media/15285292224981.jpg" alt="-w419"></p>
<p>这里也可以看出，上一层神经元对代价函数的影响是同时通过下一层神经元的共同作用而影响的（因为偏导数是下一层神经元的偏导数乘积之和 ）<br> <img src="/media/15285304237096.jpg" alt="-w350"></p>
<p>将上式展开，可得偏差函数对L层每一个权重的偏导数为：</p>
<p><img src="/media/15285333463546.jpg" alt="-w400"></p>
<p>当求出$w_jk^{(L)}$的偏导数，下一步只需要采用合适的最优化方法，更新该偏导数的值，就可以使误差逐步减小。</p>
<p>关于反向传播算法的具体例子，可以参考<a href="https://www.cnblogs.com/charlotte77/p/5629865.html" target="_blank" rel="noopener">这篇博客</a>，以具体的例子展示了反向传播的过程中 权重值是如何变化的。</p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://wenyiqingnian.xyz/2018/06/08/深度学习1-反向传播/" data-id="cjqw00dzy0020vtfy1dyafr9t" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    
        <a href="http://wenyiqingnian.xyz/2018/06/08/深度学习1-反向传播/#comments" class="article-comment-link">Comments</a>
    

        </footer>
    </div>
    
</article>



    <article id="post-《现代艺术150年》未影印作品1" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2018/06/02/《现代艺术150年》未影印作品1/">《现代艺术150年》未影印作品1</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2018/06/02/《现代艺术150年》未影印作品1/">
            <time datetime="2018-06-02T14:00:50.000Z" itemprop="datePublished">2018-06-02</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/备忘录/">备忘录</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/备忘录/">备忘录</a>, <a class="tag-link" href="/tags/现代艺术150年/">现代艺术150年</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p>以书中提到的艺术品先后为时序，罗列出书中未影印出的作品。</p>
<h2 id="ZERO"><a href="#ZERO" class="headerlink" title="ZERO"></a>ZERO</h2><p>1.Equivalent VIII  等价物 8 1966 （ Carl Andre 卡尔·安德烈）<br> <a href="http://www.tate.org.uk/art/artworks/andre-equivalent-viii-t01534" target="_blank" rel="noopener">http://www.tate.org.uk/art/artworks/andre-equivalent-viii-t01534</a><br><img src="/media/15280367296629.jpg" alt=""></p>
<p>2.Puppy 小狗 1992 （Jeff Koons，杰夫·昆斯）<br> <a href="https://www.guggenheim.org/artwork/48" target="_blank" rel="noopener">https://www.guggenheim.org/artwork/48</a></p>
<p><img src="/media/15280367669284.jpg" alt=""></p>
<h2 id="ONE"><a href="#ONE" class="headerlink" title="ONE"></a>ONE</h2><p>3.Fountain 泉  1917 （Marcel Duchamp, 马塞尔·杜尚）<br><a href="https://en.wikipedia.org/wiki/Fountain_(Duchamp)" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Fountain_(Duchamp)</a></p>
<p><img src="/media/15280368038504.jpg" alt=""></p>
<h2 id="TWO"><a href="#TWO" class="headerlink" title="TWO"></a>TWO</h2><p>4.睡莲  Reflections of Clouds on the Water-Lily Pond，1920 （Claude Monet  克劳德·莫奈）<br><a href="https://en.wikipedia.org/wiki/Water_Lilies_(Monet_series)" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Water_Lilies_(Monet_series)</a><br><img src="/media/15280368205608.jpg" alt=""></p>
<p>5.The Dance Class (La Classe de Danse) 舞蹈课 1874（Edgar Degas 埃德加·德加）<br><a href="https://en.wikipedia.org/wiki/The_Ballet_Class_(Degas,_Mus%C3%A9e_d%27Orsay)" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/The_Ballet_Class_(Degas,_Mus%C3%A9e_d%27Orsay)</a></p>
<p><img src="/media/15280368314302.jpg" alt=""></p>
<p>6.Hoar Frost, the Old Road to Ennery 白霜，通往埃纳里的老路  1873（Camille Pissarro , 米耶·毕沙罗）<br><a href="https://artbookannex.com/tag/ennery/" target="_blank" rel="noopener">https://artbookannex.com/tag/ennery/</a><br><img src="/media/15280368390516.jpg" alt=""></p>
<p>7.The Raft of the Medusa 美杜莎之筏 1818-1819（Théodore Géricault, 泰奥多尔·席里柯）<br><a href="https://en.wikipedia.org/wiki/The_Raft_of_the_Medusa" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/The_Raft_of_the_Medusa</a><br><img src="/media/15292171752937.jpg" alt=""></p>
<p>8.Liberty Leading the People 自由引导人民 1830 （Eugène Delacroix, 欧仁·德拉克罗瓦）<br><a href="https://en.wikipedia.org/wiki/Liberty_Leading_the_People" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Liberty_Leading_the_People</a></p>
<p><img src="/media/15280368550582.jpg" alt=""></p>
<p>9.L’Origine du monde (“The Origin of the World”) 世界的起源 1866 （Gustave Courbet, 古斯塔夫·库尔贝 ）<br><a href="https://en.wikipedia.org/wiki/L%27Origine_du_monde" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/L%27Origine_du_monde</a></p>
<p><img src="/media/15280368669003.jpg" alt=""></p>
<p>10.The Absinthe Drinker (French: Le Buveur d’absinthe)  喝苦艾酒的人 1859 （Édouard Manet, 爱德华·马奈）<a href="https://en.wikipedia.org/wiki/The_Absinthe_Drinker_(Manet_painting)" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/The_Absinthe_Drinker_(Manet_painting)</a><br><img src="/media/15280368750452.jpg" alt=""></p>
<p>11.Le Déjeuner sur l’herbe (English: The Luncheon on the Grass)  草地上的午餐 1863 （Édouard Manet, 爱德华·马奈）<br><a href="https://en.wikipedia.org/wiki/Le_D%C3%A9jeuner_sur_l%E2%80%99herbe" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Le_D%C3%A9jeuner_sur_l%E2%80%99herbe</a><br><img src="/media/15280368815725.jpg" alt=""></p>
<p>12.Olympia 奥林匹亚 1863 （Édouard Manet, 爱德华·马奈）<br><a href="https://en.wikipedia.org/wiki/Olympia_(Manet)" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Olympia_(Manet)</a></p>
<p><img src="/media/15280368890602.jpg" alt=""></p>
<h2 id="THREE"><a href="#THREE" class="headerlink" title="THREE"></a>THREE</h2><p>13.Impression, Sunrise (French: Impression, soleil levant) 1872（Claude Monet  克劳德·莫奈）<br> <a href="https://en.wikipedia.org/wiki/Impression,_Sunrise" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Impression,_Sunrise</a><br><img src="/media/15280368943475.jpg" alt=""></p>
<p>14.A Modern Olympia 现代奥林匹亚 1870（Paul Cézanne, 保罗·塞尚）<br><a href="http://www.paulcezanne.org/a-modern-olympia.jsp#prettyPhoto" target="_blank" rel="noopener">http://www.paulcezanne.org/a-modern-olympia.jsp#prettyPhoto</a></p>
<p><img src="/media/15280368994531.jpg" alt=""></p>
<p>15.Bain à la Grenouillère 青蛙塘 1869 （Claude Monet  克劳德·莫奈）<br><a href="https://en.wikipedia.org/wiki/Bain_%C3%A0_la_Grenouill%C3%A8re" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Bain_%C3%A0_la_Grenouill%C3%A8re</a></p>
<p><img src="/media/15280369066710.jpg" alt=""></p>
<p>16.La Grenouillère 青蛙塘 1869 （Pierre-Auguste Renoir, 皮埃尔-奥古斯特·雷诺阿）<br><a href="https://en.wikipedia.org/wiki/Pierre-Auguste_Renoir" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Pierre-Auguste_Renoir</a><br><img src="/media/15280369102094.jpg" alt=""></p>
<p>17.Rain, Steam and Speed – The Great Western Railway  雨、蒸汽和速度 1844 （ J. M. W. Turner, J.M.W 特纳）<br><a href="https://en.wikipedia.org/wiki/Rain,_Steam_and_Speed_%E2%80%93_The_Great_Western_Railway" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Rain,_Steam_and_Speed_%E2%80%93_The_Great_Western_Railway</a></p>
<p><img src="/media/15292172977610.jpg" alt=""></p>
<p>18.The Thames below Westminster 威斯敏斯特下的泰晤士河 1871 （Claude Monet  克劳德·莫奈）<br><a href="https://artuk.org/discover/artworks/the-thames-below-westminster-115865" target="_blank" rel="noopener">https://artuk.org/discover/artworks/the-thames-below-westminster-115865</a></p>
<p><img src="/media/15280369265797.jpg" alt=""></p>
<p>19.神奈川沖浪裏  The Great Wave off Kanagawa 神奈川巨浪  1829-1833 （葛飾北斎，Katsushika Hokusai, 葛饰北斋）<br><a href="https://en.wikipedia.org/wiki/The_Great_Wave_off_Kanagawa" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/The_Great_Wave_off_Kanagawa</a><br><img src="/media/15280369875264.jpg" alt=""></p>
<p>20.大津駅 Station of Otsu 大津站 1840（安藤 広重, Ando Hiroshige, 安藤广重（后改名 歌川 広重,  Utagawa Hiroshige,  歌川广重））<br><a href="https://www.metmuseum.org/toah/works-of-art/JP804/" target="_blank" rel="noopener">https://www.metmuseum.org/toah/works-of-art/JP804/</a><br><img src="/media/15280369927683.jpg" alt=""></p>
<p>21.A Carriage at The Races 赛马场上的马车 1870 （Edgar Degas 埃德加·德加）<br><a href="https://www.wikiart.org/en/edgar-degas/a-carriage-at-the-races-1872" target="_blank" rel="noopener">https://www.wikiart.org/en/edgar-degas/a-carriage-at-the-races-1872</a><br><img src="/media/15280369989475.jpg" alt=""></p>
<h2 id="FOUR"><a href="#FOUR" class="headerlink" title="FOUR"></a>FOUR</h2><p>22.The Potato Eaters 吃土豆的人 1885（Vincent Willem van Gogh, 文森特·梵高）<br><a href="https://en.wikipedia.org/wiki/The_Potato_Eaters" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/The_Potato_Eaters</a><br><img src="/media/15280370515155.jpg" alt=""></p>
<p>23.The Yellow House 黄房子 1888 （Vincent Willem van Gogh, 文森特·梵高）<br><a href="https://en.wikipedia.org/wiki/The_Yellow_House" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/The_Yellow_House</a><br><img src="/media/15280373427589.jpg" alt=""></p>
<p>24.Still Life With a Plate of Onions 静物：一盘洋葱  1889 （Vincent Willem van Gogh, 文森特·梵高）<br><a href="https://commons.wikimedia.org/wiki/File:Still_life_with_a_plate_of_onions.jpg" target="_blank" rel="noopener">https://commons.wikimedia.org/wiki/File:Still_life_with_a_plate_of_onions.jpg</a><br><img src="/media/15280373580005.jpg" alt=""></p>
<p>25.The Sower 播种者 1888（Vincent Willem van Gogh, 文森特·梵高）<br><a href="https://en.wikipedia.org/wiki/Vincent_van_Gogh#/media/File:The_Sower.jpg" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Vincent_van_Gogh#/media/File:The_Sower.jpg</a><br><img src="/media/15280373715966.jpg" alt=""></p>
<p>26.The Night Café 夜间咖啡馆 1888（Vincent Willem van Gogh, 文森特·梵高）<br><a href="https://en.wikipedia.org/wiki/The_Night_Caf%C3%A9" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/The_Night_Caf%C3%A9</a></p>
<p><img src="/media/15280373791394.jpg" alt=""></p>
<p>27.Sunflowers 向日葵 1888（Vincent Willem van Gogh, 文森特·梵高）<br><a href="https://en.wikipedia.org/wiki/Sunflowers_(Van_Gogh_series)" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Sunflowers_(Van_Gogh_series)</a></p>
<p><img src="/media/15280373867451.jpg" alt=""></p>
<p>28.Starry Night Over the Rhône 满天星斗下的罗纳河 1888 （Vincent Willem van Gogh, 文森特·梵高）<br><a href="https://en.wikipedia.org/wiki/Starry_Night_Over_the_Rh%C3%B4ne" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Starry_Night_Over_the_Rh%C3%B4ne</a><br><img src="/media/15280373993252.jpg" alt=""></p>
<p>29.Bedroom in Arles 寝室 1888（Vincent Willem van Gogh, 文森特·梵高）<br><a href="https://en.wikipedia.org/wiki/Bedroom_in_Arles" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Bedroom_in_Arles</a><br><img src="/media/15280374505879.jpg" alt=""></p>
<p>30.The Scream 呐喊 1893 （Edvard Munch, 爱德华·蒙克）<br><a href="https://en.wikipedia.org/wiki/The_Scream" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/The_Scream</a></p>
<p><img src="/media/15280374589455.jpg" alt=""></p>
<p>31.Study after Velázquez’s Portrait of Pope Innocent X 临摹委拉斯开兹的《教皇英诺森十世肖像》1953（Francis Bacon, 弗朗西斯·培根）<br><a href="https://en.wikipedia.org/wiki/Study_after_Vel%C3%A1zquez%27s_Portrait_of_Pope_Innocent_X" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Study_after_Vel%C3%A1zquez%27s_Portrait_of_Pope_Innocent_X</a></p>
<p><img src="/media/15280374976202.jpg" alt=""></p>
<p>32.Homage to Van Gogh 向梵高致敬 1960 （Francis Bacon, 弗朗西斯·培根）<br><a href="https://www.artimage.org.uk/3087/francis-bacon/homage-to-van-gogh--1960" target="_blank" rel="noopener">https://www.artimage.org.uk/3087/francis-bacon/homage-to-van-gogh--1960</a><br><img src="/media/15280375078516.jpg" alt=""></p>
<p>33.Painter on the Road to Tarascon, August 1888 (destroyed by fire in the Second World War) 去往塔拉斯孔路上的画家 1888  （Vincent Willem van Gogh, 文森特·梵高）<br><a href="https://en.wikipedia.org/wiki/Vincent_van_Gogh#/media/File:Vincent_Van_Gogh_0013.jpg" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Vincent_van_Gogh#/media/File:Vincent_Van_Gogh_0013.jpg</a></p>
<p><img src="/media/15280375183706.jpg" alt=""></p>
<p>34.Vision after the Sermon (Jacob Wrestling with the Angel) 布道后的幻象（雅各与天使搏斗） 1888（Paul Gauguin,  保罗·高更）<br><a href="https://en.wikipedia.org/wiki/Vision_After_the_Sermon" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Vision_After_the_Sermon</a><br><img src="/media/15280375447688.jpg" alt=""></p>
<p>35.No te aha oe riri (Why Are You Angry?), 你为何生气 1896（Paul Gauguin,  保罗·高更）<br><a href="http://www.artic.edu/aic/collections/artwork/16496" target="_blank" rel="noopener">http://www.artic.edu/aic/collections/artwork/16496</a></p>
<p><img src="/media/15280375640354.jpg" alt=""></p>
<p>36.Bathers at Asnières (French: Une Baignade, Asnières)  阿尼埃尔的浴场 1884（Georges Seurat, 乔治·修拉）<br><a href="https://en.wikipedia.org/wiki/Bathers_at_Asni%C3%A8res" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Bathers_at_Asni%C3%A8res</a><br><img src="/media/15280375818140.jpg" alt=""></p>
<p>37.A Sunday Afternoon on the Island of La Grande Jatte 大碗岛的星期天下午 1884-1886（Georges Seurat, 乔治·修拉）<br><a href="https://en.wikipedia.org/wiki/A_Sunday_Afternoon_on_the_Island_of_La_Grande_Jatte" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/A_Sunday_Afternoon_on_the_Island_of_La_Grande_Jatte</a></p>
<p><img src="/media/15280375999874.jpg" alt=""></p>
<h2 id="FIVE"><a href="#FIVE" class="headerlink" title="FIVE"></a>FIVE</h2><p>38.Still Life with Apples and Peaches 有苹果和桃子的静物 1905（Paul Cézanne, 保罗·塞尚）<br><a href="https://www.nga.gov/Collection/art-object-page.45986.html" target="_blank" rel="noopener">https://www.nga.gov/Collection/art-object-page.45986.html</a><br><img src="/media/15280376214294.jpg" alt=""></p>
<p>39.Mont Sainte-Victoire with Large Pine 圣维克多山 1887  （Paul Cézanne, 保罗·塞尚）<br><a href="https://en.wikipedia.org/wiki/Mont_Sainte-Victoire_with_Large_Pine" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Mont_Sainte-Victoire_with_Large_Pine</a></p>
<p><img src="/media/15280376340285.jpg" alt=""></p>
<h2 id="SIX"><a href="#SIX" class="headerlink" title="SIX"></a>SIX</h2><p>40.The Kiss 吻 1907-1908  （Gustav Klimt,  古斯塔夫·克里姆特）<br><a href="https://en.wikipedia.org/wiki/The_Kiss_(Klimt)" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/The_Kiss_(Klimt)</a><br><img src="/media/15280376621257.jpg" alt=""></p>
<p>41.Boats in the Harbour at Collioure 科利乌尔港的船 1905 （André Derain, 安德烈·德兰）<br><img src="/media/15280376701808.jpg" alt=""></p>
<p>42.Restaurant de la Machine at Bougival 布吉瓦尔的餐馆 1905（Maurice de Vlaminck, 莫里斯·德·弗拉芒克）<br><img src="/media/15280376817721.jpg" alt=""></p>
<p>43.Woman with a Hat 戴帽子的妇人 1905 （Henri Matisse, 亨利·马蒂斯）<br><a href="https://en.wikipedia.org/wiki/Woman_with_a_Hat" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Woman_with_a_Hat</a><br><img src="/media/15280377195099.jpg" alt=""></p>
<p>44.Le bonheur de vivre (The Joy of Life) 生之欢乐 1905-1906 （Henri Matisse, 亨利·马蒂斯）<br><a href="https://en.wikipedia.org/wiki/Le_bonheur_de_vivre" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Le_bonheur_de_vivre</a><br><img src="/media/15280377678492.jpg" alt=""></p>
<p>45.Reciproco Amore 互爱 1589-1595（Agostino Carracci, 阿戈斯蒂诺·卡拉奇）</p>
<p><img src="/media/15280378038769.jpg" alt=""></p>
<p>46.Portrait of Gertrude Stein 格特鲁德·斯泰因肖像 1905-1906 （Pablo Picasso, 巴勃罗·毕加索）<br><a href="https://en.wikipedia.org/wiki/Portrait_of_Gertrude_Stein" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Portrait_of_Gertrude_Stein</a><br><img src="/media/15280378295150.jpg" alt=""></p>
<p>47.Les Demoiselles d’Avignon (The Young Ladies of Avignon, and originally titled The Brothel of Avignon)  亚维农少女 1907 （Pablo Picasso, 巴勃罗·毕加索）<br><a href="https://en.wikipedia.org/wiki/Les_Demoiselles_d%27Avignon" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Les_Demoiselles_d%27Avignon</a></p>
<p><img src="/media/15280378595060.jpg" alt=""></p>
<p>48.A Carnival Evening 狂欢节之夜 1886（Henri Rousseau, 亨利·卢梭）</p>
<p><img src="/media/15280378738525.jpg" alt=""></p>
<p>49.The Hungry Lion Throws Itself on the Antelope (Le lion ayant faim se jette sur l’antilope)  饿狮猛扑羚羊 1905（Henri Rousseau, 亨利·卢梭）<br><a href="https://en.wikipedia.org/wiki/The_Hungry_Lion_Throws_Itself_on_the_Antelope" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/The_Hungry_Lion_Throws_Itself_on_the_Antelope</a><br><img src="/media/15280379054759.jpg" alt=""></p>
<ol start="50">
<li>Portrait of a Woman 一个女人的肖像 1895 （Henri Rousseau, 亨利·卢梭）<br><a href="https://commons.wikimedia.org/wiki/File:Henri_Rousseau__Portrait_of_a_Woman_(1895).jpg" target="_blank" rel="noopener">https://commons.wikimedia.org/wiki/File:Henri_Rousseau__Portrait_of_a_Woman_(1895).jpg</a><br><img src="/media/15280379340355.jpg" alt=""></li>
</ol>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://wenyiqingnian.xyz/2018/06/02/《现代艺术150年》未影印作品1/" data-id="cjqw00dzq001avtfycb5rrzbn" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    
        <a href="http://wenyiqingnian.xyz/2018/06/02/《现代艺术150年》未影印作品1/#comments" class="article-comment-link">Comments</a>
    

        </footer>
    </div>
    
</article>



    <article id="post-从驱动角度理解binder" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2018/06/02/从驱动角度理解binder/">从驱动角度理解binder</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2018/06/02/从驱动角度理解binder/">
            <time datetime="2018-06-02T11:00:50.000Z" itemprop="datePublished">2018-06-02</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/Android/">Android</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/Binder/">Binder</a>, <a class="tag-link" href="/tags/android/">android</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p>一次binder通讯建立的大致流程我们已经了解了，首先是要注册一个serviceManager，server端创建实名binder，向smg注册自己可以提供的服务，以及该实名binder的标签，smg会在svcinfo 链表中缓存该server提供的binder信息，当client需要使用该服务时，只需要向smg中查询服务，获取server端binder的引用就可以了，这其中所有的通讯细节，全部需要binder驱动来实现。<br><img src="/media/15280074117127.jpg" alt=""></p>
<p>本文主要总结一下对binder驱动的理解，了解驱动设计的细节，以及binder通讯过程中驱动主要做了哪些事情。</p>
<h1 id="Binder驱动的定义"><a href="#Binder驱动的定义" class="headerlink" title="Binder驱动的定义"></a>Binder驱动的定义</h1><p>Binder驱动其实是一种特殊的字符型驱动，实现方式类似硬件驱动，工作在内核态。<br>如果了解过linux驱动相关知识，应该知道<code>file_operations</code> 结构体的重要性，linux 使用该结构体访问驱动程序的函数，这个结构体的每一个成员的名字都对应一个内核调用。<br>当用户进程利用设备文件（binder对应的设备文件为/dev/test）对文件进行类似<code>read()/write()</code> 操作的时候，系统调用通过设备文件的主设备号找到对应的设备驱动程序，每一个驱动程序在内核中是由一个<code>cdev</code>结构体描述，<code>cdev</code>结构体中又包括一个成员<code>fops</code>结构体，fops便是<code>file_operations</code>类型的，然后读取<code>file_operations</code> 结构体相应的函数指针，接着把控制权交给该函数的linux 设备驱动程序工作。</p>
<p>下面以binder驱动在内核中的注册流程来分析binder驱动为用户空间定义了哪些可用来调用的函数。</p>
<h2 id="注册Binder"><a href="#注册Binder" class="headerlink" title="注册Binder"></a>注册Binder</h2><p> 在binder驱动源码中（<a href="https://elixir.bootlin.com/linux/v3.11.4/source/drivers/staging/android/binder.c" target="_blank" rel="noopener">kernel/drivers/staging/android/binder.c</a>），通过调用 <code>ret = misc_register(&amp;binder_msicdev)</code>函数完成向内核注册<code>binder</code>驱动，主设备号为10，次设备号动态分配， 其中传入的参数便是一个<code>miscdev</code>的结构体，<br> 它的定义如下</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">miscdevice</span> <span class="title">binder_miscdev</span> = &#123;</span></span><br><span class="line">	.minor = MISC_DYNAMIC_MINOR,</span><br><span class="line">	.name = <span class="string">"binder"</span>,</span><br><span class="line">	.fops = &amp;binder_fops</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到<code>cdev</code>文件中标注了<code>binder</code>设备的设备名”binder”，以及<code>fops</code>结构体，<code>fops</code>结构体如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">binder_fops</span> = &#123;</span></span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .poll = binder_poll,</span><br><span class="line">    .unlocked_ioctl = binder_ioctl,</span><br><span class="line">    .mmap = binder_mmap,</span><br><span class="line">    .open = binder_open,</span><br><span class="line">    .flush = binder_flush,</span><br><span class="line">    .release = binder_release,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到binder驱动为应用层提供了<code>open()</code>,<code>mmap()</code>,<code>poll()</code>,<code>ioctl()</code>等标准的文件操作【注1】，<code>open()</code>负责打开驱动，<code>mmap()</code>负责对<code>binder</code>做内核空间向用户空间的地址映射，<code>ioctl()</code>负责binder协议的通信。</p>
<p>我们知道，用户态的引用程序调用<code>kernel</code>驱动程序是会陷入内核态的，进行系统调用，比如我使用 <code>fd = open(&quot;dev/binder&quot;,O_RDWR)</code>，开打开<code>binder</code>驱动时，它会先通过通过系统调用<code>_open()</code>【注1】，通过主次设备号来找到对应的binder驱动程序，即在 <code>cdev</code> 链表中找到binder驱动对应的<br><code>binder_miscdev</code>，找到 <code>binder_fops</code>结构体，找到<code>open()</code>方法对应的 <code>binder_open()</code>函数，实际执行到的便是<code>binder_open（）</code>函数。那么其他的 比如 mmap(),ioctl()方法，他们的执行流程也是类似的。 参考下图<br><img src="/media/15280103450907.jpg" alt=""></p>
<blockquote>
<p>注释1： open()为用户空间的方法，_open()为系统调用中对应的处理方法。</p>
</blockquote>
<p>打开一次binder通讯，大致分为以下流程：</p>
<ul>
<li>1 调用<code>open()</code>方法打开<code>binder</code>驱动 </li>
<li>2 调用 <code>mmap()</code>方法申请一块内存用来接受通信中的数据，并进行内存映射（binder机制为什么只进行一次拷贝，这里有文章），</li>
<li>3 调用 <code>ioctl()</code>方法 开启binder通讯。<br>这里每一步中具体都做了些什么，下文会有详细描述，但为了更好理解，需要先要搞清楚binder驱动中的几个关键的数据结构和binder的通讯协议。</li>
</ul>
<h2 id="Binder驱动中的结构体"><a href="#Binder驱动中的结构体" class="headerlink" title="Binder驱动中的结构体"></a>Binder驱动中的结构体</h2><p>驱动中的结构体分为两部分，一部分与用户空间共用，这些结构体在Binder通信协议中会用到，被定义在binder.h 头文件中。<br>具体内容见下表：</p>
<table>
<thead>
<tr>
<th>结构体名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>flat_binder_object</td>
<td>binder通讯过程中在client-binderDriver-server之间传递的实际内容，所谓跨进程传递的binder对象，其实传递的就是这个</td>
</tr>
<tr>
<td>binder_wirte_read</td>
<td>存储对binder驱动进行读写操作的数据，当为写的时候，结构体中的write_size非空，当为读的时候，read_size不为空</td>
</tr>
<tr>
<td>binder_version</td>
<td>存储binder的版本号</td>
</tr>
<tr>
<td>transaction_flags</td>
<td>描述一次binder事务的flag，比如是同步还是异步请求</td>
</tr>
<tr>
<td>binder_transcation_data</td>
<td>存储一次事务的数据</td>
</tr>
<tr>
<td>binder_handle_cookie</td>
<td>包含一个句柄和一个cookie</td>
</tr>
<tr>
<td>binder_ptr_cookie</td>
<td>包含一个指针和一个cookie </td>
</tr>
<tr>
<td>binder_pri_dest</td>
<td>暂未用到 </td>
</tr>
<tr>
<td>binder_pri_ptr_cookie</td>
<td>暂未用到</td>
</tr>
</tbody>
</table>
<p>另一部分定义在binder驱动中，是驱动特有的结构体</p>
<table>
<thead>
<tr>
<th>结构体名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>binder_node</td>
<td>描述binder的实体节点，对应一个server，当server通过binder驱动向smg注册时，binder驱动便会在内核中为其创建一个binder实体节点，该实体节点即为binder_node，同时驱动会为server与该节点创建引用关系</td>
</tr>
<tr>
<td>binder_ref</td>
<td>描述对binder实体节点的引用</td>
</tr>
<tr>
<td>binder_buffer</td>
<td>描述binder通讯过程中存储数据的buffer</td>
</tr>
<tr>
<td>binder_proc</td>
<td>描述使用binder的进程</td>
</tr>
<tr>
<td>binder_thread</td>
<td>描述使用binder的线程</td>
</tr>
<tr>
<td>binder_work</td>
<td>描述通信过程中的一项任务</td>
</tr>
<tr>
<td>binder_transcation</td>
<td>描述一次事务的相关信息</td>
</tr>
<tr>
<td>binder_deferred_state</td>
<td>藐视延迟任务</td>
</tr>
<tr>
<td>binder_ref_death</td>
<td>描述binder实体的死亡信息</td>
</tr>
<tr>
<td>binder_transcation_log</td>
<td>debugfs 日志</td>
</tr>
<tr>
<td>binder_transcation_log_entry</td>
<td>debugfs 日志条目</td>
</tr>
</tbody>
</table>
<h2 id="binder协议"><a href="#binder协议" class="headerlink" title="binder协议"></a>binder协议</h2><p>Binder协议 可以分为 <strong>控制协议</strong>和<strong>驱动协议</strong>两部分。</p>
<h3 id="1-控制协议"><a href="#1-控制协议" class="headerlink" title="1.控制协议"></a>1.控制协议</h3><p><strong>控制协议</strong>是进程(client 或server端)通过系统调用（syscall）直接操作binder设备文件，使用<code>ioctl(&#39;dev/binder&#39;)</code>控制binder驱动的协议，该协议包含以下几种命令</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>含义</th>
<th>参数</th>
</tr>
</thead>
<tbody>
<tr>
<td>BINDER_WRITE_READ</td>
<td>该命令想binder写入或者读出数据，参数分为两段，写和度部分，如果write_size不为零，就先将write_buffer中的数据写入binder； 如果read_size不为零，就先从binder中取出数据，写入read_buffer中。 write_consumed和read_consumed 表示操作完成时驱动实际写入和读出的数据个数。</td>
<td>struct binder_wirte_read{ Singned long write_size;Signed long write_consumed;unsigend long write_buffer;signed long read_size;signed long read_consumed;Unsigned long read_buffer}</td>
</tr>
<tr>
<td>BINDER_SET_MAX_THREADS</td>
<td>告知binder驱动接收方(server端)，线程池中最大的线程数。（详见下文 驱动线程管理）</td>
<td>int max_threads</td>
</tr>
<tr>
<td>BINDER_SET_CONEXT_MGR</td>
<td>将当前进程注册为smg，系统同时只可以出现一个smg，只要当前smg没有调用close关闭binder驱动，就不可能有别的进程可以成为smg</td>
<td></td>
</tr>
<tr>
<td>BINDER_THREAD_EXIT</td>
<td>通知binder驱动当前线程退出了，binder会为所有参与binder通信的线程（包括server端线程池中的线程以及client端发出请求的线程）建立相应的数据结构，这些线程在退出时必须显示通知binder释放相应的数据。详见下文 binder驱动的线程控制</td>
</tr>
</tbody>
</table>
<h3 id="2-驱动协议"><a href="#2-驱动协议" class="headerlink" title="2. 驱动协议"></a>2. 驱动协议</h3><p>驱动协议根据具体使用过程，又分为<strong>发送</strong>和<strong>返回</strong>协议。<br><strong>发送协议</strong> 定义在<code>binder.c</code> 中的<br> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> binder_driver_command_protocol</span><br></pre></td></tr></table></figure></p>
<p>，<strong>返回协议 </strong> 定义在<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> binder_driver_return_protocol</span><br></pre></td></tr></table></figure></p>
<p> 根据协议不同，存放的位置也不相同。<br>驱动协议都是封装在控制协议   <code>BINDER_WRITE_READ</code> 命令参数 <code>binder_wirte_read</code> 结构体中，根据发送和返回类型，分别存放在 <code>write_buffer</code>和 <code>read_buffer</code>域所指向的内存空间中。<br><code>binder_write_read</code>结构体的数据结构见下图：<br><img src="/media/15280146752888.jpg" alt=""></p>
<p>它们的数据格式都是命令 + 数据 的格式，多条命令可以连续存放。数据紧接着放在命令的后面，根据命令不同，执行的操作也不同。</p>
<h4 id="发送协议："><a href="#发送协议：" class="headerlink" title="发送协议："></a>发送协议：</h4><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
<th>参数</th>
</tr>
</thead>
<tbody>
<tr>
<td>BC_TRANSCATION</td>
<td>binder事务，client对server的请求</td>
<td>binder_transction_data</td>
</tr>
<tr>
<td>BC_REPLAY</td>
<td>事务的回答，server对client的回复</td>
<td>Binder_transctin_data</td>
</tr>
<tr>
<td>BC_FREE_BUFFER</td>
<td>通知驱动释放buffer</td>
<td>Binder_uinptr_t</td>
</tr>
<tr>
<td>BC_ACQUIRE</td>
<td>强引用计数+1</td>
<td>_u32</td>
</tr>
<tr>
<td>BC_RELEASE</td>
<td>强引用计数-1</td>
<td>_u32</td>
</tr>
<tr>
<td>BC_INCREFS</td>
<td>弱引用计数+1</td>
<td>_u32</td>
</tr>
<tr>
<td>BC_DECREFS</td>
<td>弱引用计数-1</td>
<td>_u32</td>
</tr>
<tr>
<td>BC_ACQUIRE_DODE</td>
<td>acquire指令的回复</td>
<td>Binder_ptr_cookie</td>
</tr>
<tr>
<td>BC_INCREFS_DONE</td>
<td>increfs指令的回复</td>
<td>Binder_prt_cookie</td>
</tr>
<tr>
<td>BC_ENTER_LOOPER</td>
<td>通知驱动主线程ready</td>
<td>Void</td>
</tr>
<tr>
<td>BC_REGISTER_LOOPER</td>
<td>通知驱动子线程ready</td>
<td>Void</td>
</tr>
<tr>
<td>BC_EXIT_LOOPER</td>
<td>通知驱动线程已退出</td>
<td>Void</td>
</tr>
<tr>
<td>BC_REQUEST_DEATH_NOTIFICATION</td>
<td>请求接受死亡通知</td>
<td>Binder_handle_cookie</td>
</tr>
<tr>
<td>BC_CLEAR_DEATH_NOTIFICATION</td>
<td>去除接受死亡通知</td>
<td>Binder_handle_cookie</td>
</tr>
<tr>
<td>BC_DEAD_BINDER_DONE</td>
<td>已经处理完死亡通知</td>
<td>Binder_uinptr_t</td>
</tr>
<tr>
<td>BC_ATTEMPT_ACQUIRE</td>
<td>暂未实现</td>
<td>-</td>
</tr>
<tr>
<td>BC_ACQUIRE_RESULT</td>
<td>暂为实现</td>
<td>-</td>
</tr>
</tbody>
</table>
<h4 id="返回协议："><a href="#返回协议：" class="headerlink" title="返回协议："></a>返回协议：</h4><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
<th>参数</th>
</tr>
</thead>
<tbody>
<tr>
<td>BR_OK</td>
<td>操作完成</td>
<td>void</td>
</tr>
<tr>
<td>BR_NOOP</td>
<td>操作完成</td>
<td>void</td>
</tr>
<tr>
<td>BR_ERROR</td>
<td>发生错误</td>
<td>_s32</td>
</tr>
<tr>
<td>BR_TRANSCATION</td>
<td>进程收到一次binder请求 （server端）</td>
<td>binder_transcation_data</td>
</tr>
<tr>
<td>BR_REPLAY</td>
<td>进程收到binder请求的回复（client）</td>
<td>binder_transtaction_data</td>
</tr>
<tr>
<td>BR_TRANSCATION_COMPLETED</td>
<td>驱动对于接收请求的确认回复</td>
<td>void</td>
</tr>
<tr>
<td>BR_FAILED_REPLAY</td>
<td>告知发送方 通信目标不存在</td>
<td>void</td>
</tr>
<tr>
<td>BR_SPAWN_LOOPER</td>
<td>通server端创建一个新的进程</td>
<td>void</td>
</tr>
<tr>
<td>BR_ACQUIRE</td>
<td>强用用计数+1</td>
<td>Binder_prt_cookie</td>
</tr>
<tr>
<td>BR_RELEASE</td>
<td>强引用计数-1</td>
<td>Binder_prt_cookie</td>
</tr>
<tr>
<td>BR_INCREFS</td>
<td>弱引用计数+1</td>
<td>Binder_prt_cookie</td>
</tr>
<tr>
<td>BR_DECREFS</td>
<td>弱引用计数-1</td>
<td>Binder_prt_cookie</td>
</tr>
<tr>
<td>BR_DEAD_BINDER</td>
<td>发送死亡通知</td>
<td>binder_uintptr_t</td>
</tr>
<tr>
<td>BR_CLEAR_DEATH_NOTIFICATION_DONE</td>
<td>清除死亡通知完成</td>
<td>binder_uintptr_t</td>
</tr>
<tr>
<td>BR_DEAD_REPLAY</td>
<td>改制发送方对方已死亡</td>
<td>void</td>
</tr>
<tr>
<td>BR_ATTEMPT_ACQUIRE</td>
<td>暂未实现</td>
<td>-</td>
</tr>
<tr>
<td>BR_ACQUIRE_RESULT</td>
<td>暂为实现</td>
<td>-</td>
</tr>
<tr>
<td>BR_FINISHED</td>
<td>暂未实现</td>
<td>-</td>
</tr>
</tbody>
</table>
<h4 id="binder-请求的过程"><a href="#binder-请求的过程" class="headerlink" title="binder 请求的过程"></a>binder 请求的过程</h4><p>见下图：</p>
<p><img src="/media/15280173877321.jpg" alt=""></p>
<p>通过上面的Binder协议的说明中我们看到，Binder协议的通信过程中，不仅仅是发送请求和接受数据这些命令。同时包括了对于引用计数的管理和对于死亡通知的管理（告知一方，通讯的另外一方已经死亡）等功能。</p>
<p>这些功能的通信过程和上面这幅图是类似的：一方发送<code>BC_XXX</code>，然后由驱动控制通信过程，接着发送对应的<code>BR_XXX</code>命令给通信的另外一方。因为这种相似性，对于这些内容就不再赘述了。</p>
<h3 id="由驱动角度理解-Binder通讯建立的过程"><a href="#由驱动角度理解-Binder通讯建立的过程" class="headerlink" title="由驱动角度理解 Binder通讯建立的过程"></a>由驱动角度理解 Binder通讯建立的过程</h3><h4 id="1-打开驱动（open-“dev-binder”-）"><a href="#1-打开驱动（open-“dev-binder”-）" class="headerlink" title="1 打开驱动（open(“dev/binder”)）"></a>1 打开驱动（open(“dev/binder”)）</h4><p>任何进程在使用Binder之前，都需要先通过<code>open(&quot;/dev/binder&quot;)</code>打开Binder设备。上文已经提到，用户空间的<code>open</code>系统调用对应了驱动中的<code>binder_open</code>函数。在这个函数，Binder驱动会为调用的进程做一些初始化工作。<code>binder_open</code>函数代码如下所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_open</span><span class="params">(struct inode *nodp, struct file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span>;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 创建进程对应的binder_proc对象 </span></span><br><span class="line">	proc = kzalloc(<span class="keyword">sizeof</span>(*proc), GFP_KERNEL); </span><br><span class="line">	<span class="keyword">if</span> (proc == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	get_task_struct(current);</span><br><span class="line">	proc-&gt;tsk = current;</span><br><span class="line">	<span class="comment">// 初始化binder_proc</span></span><br><span class="line">	INIT_LIST_HEAD(&amp;proc-&gt;todo);</span><br><span class="line">	init_waitqueue_head(&amp;proc-&gt;wait);</span><br><span class="line">	proc-&gt;default_priority = task_nice(current);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 锁保护</span></span><br><span class="line">	binder_lock(__func__);</span><br><span class="line"></span><br><span class="line">	binder_stats_created(BINDER_STAT_PROC);</span><br><span class="line">	<span class="comment">// 添加到全局列表binder_procs中</span></span><br><span class="line">	hlist_add_head(&amp;proc-&gt;proc_node, &amp;binder_procs);</span><br><span class="line">	proc-&gt;pid = current-&gt;group_leader-&gt;pid;</span><br><span class="line">	INIT_LIST_HEAD(&amp;proc-&gt;delivered_death);</span><br><span class="line">	filp-&gt;private_data = proc;</span><br><span class="line"></span><br><span class="line">	binder_unlock(__func__);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在打开binder驱动时，<code>binder_procs</code>会将所有打开binder驱动的进程加入到该列表中，上文中提到binder中的几个主要结构体，其实都是通过<code>binder_procs</code>结构体链接在一起的。</p>
<p><img src="/media/15280179417192.jpg" alt=""></p>
<h4 id="2-创建内存空间并实现用户空间-内核空间的映射（mmap）"><a href="#2-创建内存空间并实现用户空间-内核空间的映射（mmap）" class="headerlink" title="2. 创建内存空间并实现用户空间 内核空间的映射（mmap）"></a>2. 创建内存空间并实现用户空间 内核空间的映射（mmap）</h4><p>打开binder驱动之后，进程会通过<code>mmap()</code>方法进行内存空间的映射。 </p>
<p>上文描述过，<code>mmap()</code>对应的<code>binder_mmap()</code>函数，它会先申请一份物理内存，默认<code>PAGE_SIZE</code> 是4k，然后会<strong>同时在 用户空间和 内核空间</strong>映射该物理内存。当client 发送数据给server的时候，只需要将client端的数据，拷贝到server端所指向的 内核中的地址即可，因为server的用户空间和binder对应的内核空间映射的是同一份物理内存，当server取数据的时候，就无需再从内科中拷贝了，server可以直接使用。</p>
<p><img src="/media/15280184528253.jpg" alt=""></p>
<p>这幅图的说明如下：</p>
<p>Server在启动之后，对<code>/dev/binder</code>设备调用<code>mmap</code><br>内核中的<code>binder_mmap</code>函数进行对应的处理：申请一块物理内存，然后在用户空间和内核空间同时进行映射</p>
<p>Client通过<code>BINDER_WRITE_READ</code>命令发送请求，这个请求将先到驱动中，同时需要将数据从<code>Client</code>进程的用户空间拷贝到内核空间<br>驱动通过<code>BR_TRANSACTION</code>通知Server有人发出请求，Server进行处理。由于这块内存也在用户空间进行了映射，因此Server进程的代码可以直接访问</p>
<h4 id="3-内存管理（非重点）"><a href="#3-内存管理（非重点）" class="headerlink" title="3. 内存管理（非重点）"></a>3. 内存管理（非重点）</h4><p>上文中，我们看到<code>binder_mmap</code>的时候，会申请一个<code>PAGE_SIZE</code>通常是4K的内存。而实际使用过程中，一个<code>PAGE_SIZE</code>的大小通常是不够的。</p>
<p>在驱动中，会根据实际的使用情况进行内存的分配。有内存的分配，当然也需要内存的释放。这里我们就来看看Binder驱动中是如何进行内存的管理的。</p>
<p>首先，我们还是从一次IPC请求说起。</p>
<p>当一个Client想要对Server发出请求时，它首先将请求发送到Binder设备上，由Binder驱动根据请求的信息找到对应的目标节点，然后将请求数据传递过去。</p>
<p>进程通过ioctl系统调用来发出请求：<code>ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr)</code></p>
<p>PS：这行代码来自于Framework层的<code>IPCThreadState</code>类。在后文中，我们将看到，<code>IPCThreadState</code>类专门负责与驱动进行通信。</p>
<p>这里的<code>mProcess-&gt;mDriverFD</code>对应了打开Binder设备时的<code>fd</code>。<code>BINDER_WRITE_READ</code>对应了具体要做的操作码，这个操作码将由Binder驱动解析。<code>bwr</code>存储了请求数据，其类型是<code>binder_write_read</code>。</p>
<p><code>binder_write_read</code>其实是一个相对外层的数据结构，其内部会包含一个<code>binder_transaction_data</code>结构的数据。<code>binder_transaction_data</code>包含了发出请求者的标识，请求的目标对象以及请求所需要的参数。它们的关系如下图所示：</p>
<p><img src="/media/15280191293122.jpg" alt=""></p>
<p><code>binder_ioctl</code>函数对应了<code>ioctl</code>系统调用的处理。这个函数的逻辑比较简单，就是根据<code>ioctl</code>的命令来确定进一步处理的逻辑，具体如下:</p>
<p>如果命令是<code>BINDER_WRITE_READ</code>，并且<br>如果 <code>bwr.write_size &gt; 0</code>，则调用<code>binder_thread_write</code><br>该方法用于处理Binder协议中的请求码。当<code>binder_buffer</code>存在数据，binder线程的写操作循环执行。对于请求码为<code>BC_TRANSACTION</code>或<code>BC_REPLY</code>时，会执行<code>binder_transaction</code>()方法，这是最为频繁的操作。 对于其他命令则不同。</p>
<p>如果 <code>bwr.read_size &gt; 0</code>，则调用<code>binder_thread_read</code>，该方法用以处理响应过程，根据不同的<code>binder_work-&gt;type</code>以及不同状态，生成相应的响应码。</p>
<p>如果命令是<code>BINDER_SET_MAX_THREADS</code>，则设置进程的<code>max_threads</code>，即进程支持的最大线程数<br>如果命令是<code>BINDER_SET_CONTEXT_MGR</code>，则设置当前进程为<code>ServiceManager</code>，见下文<br>如果命令是<code>BINDER_THREAD_EXIT</code>，则调用<code>binder_free_thread</code>，释放<code>binder_thread</code><br>如果命令是<code>BINDER_VERSION</code>，则返回当前的Binder版本号<br>这其中，最关键的就是<code>binder_thread_write</code>方法。当Client请求Server的时候，便会发送一个<code>BINDER_WRITE_READ</code>命令，同时框架会将将实际的数据包装好。此时，<code>binder_transaction_data</code>中的code将是<code>BC_TRANSACTION</code>，由此便会调用到<code>binder_transaction</code>方法，这个方法是对一次Binder事务的处理，这其中会调用<code>binder_alloc_buf</code>函数为此次事务申请一个缓存。<br>调用关系见下图<br><img src="/media/15280210111665.jpg" alt=""></p>
<p><code>binder_update_page_range</code>这个函数在上文中，我们已经看到过了。其作用就是：进行内存分配并且完成内存的映射。而<code>binder_alloc_buf</code>函数，正如其名称那样的：完成缓存的分配。</p>
<p>在驱动中，通过<code>binder_buffer</code>结构体描述缓存。一次Binder事务就会对应一个<code>binder_buffer</code>，<br>进程在mmap时，会设定支持的总缓存大小的上限。而进程每当收到<code>BC_TRANSACTION</code>，就会判断已使用缓存加本次申请的和有没有超过上限。如果没有，就考虑进行内存的分配。</p>
<p>进程的空闲缓存记录在<code>binder_proc</code>的<code>free_buffers</code>中，这是一个以红黑树形式存储的结构。每次尝试分配缓存的时候，会从这里面按大小顺序进行查找，找到最接近需要的一块缓存。找到之后，还要对binder_proc的字段进行更新。</p>
<p><code>BC_FREE_BUFFER</code>命令是通知驱动进行内存的释放，<code>binder_free_buf</code>函数是真正实现的逻辑，这个函数与<code>binder_alloc_buf</code>是刚好对应的。在这个函数中，所做的事情包括：</p>
<ul>
<li>重新计算进程的空闲缓存大小</li>
<li>通过<code>binder_update_page_range</code>释放内存</li>
<li>更新<code>binder_proc</code>的<code>buffers</code>，<code>free_buffers</code>，<code>allocated_buffers</code>字段</li>
</ul>
<h4 id="4-通讯过程"><a href="#4-通讯过程" class="headerlink" title="4 通讯过程"></a>4 通讯过程</h4><p><code>BINDER_COMMAND_PROTOCOL</code>：binder请求码，以”BC_“开头，简称BC码，用于从IPC层传递到Binder Driver层；<br><code>BINDER_RETURN_PROTOCOL</code> ：binder响应码，以”BR_“开头，简称BR码，用于从Binder Driver层传递到IPC层；</p>
<p>一次完整的binder通讯流程：<br><img src="/media/15280207692595.jpg" alt=""><strong>Binder IPC通信至少是两个进程的交互</strong>：</p>
<ul>
<li>client进程执行<code>binder_thread_write</code>，<code>thread_write</code>根据<code>BC_XXX</code>命令，生成相应的<code>binder_work</code>；</li>
<li>server进程执行<code>binder_thread_read</code>，<code>thread_read</code>根据<code>binder_work.type</code>类型，生成<code>BR_XXX</code>，发送到用户空间处理。<br><img src="/media/15280214808773.jpg" alt=""></li>
</ul>
<p><code>binder_work.type</code> ：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BINDER_WORK_TRANSACTION <span class="comment">//最常见类型</span></span><br><span class="line">BINDER_WORK_TRANSACTION_COMPLETE</span><br><span class="line">BINDER_WORK_NODE</span><br><span class="line">BINDER_WORK_DEAD_BINDER</span><br><span class="line">BINDER_WORK_DEAD_BINDER_AND_CLEAR</span><br><span class="line">BINDER_WORK_CLEAR_DEATH_NOTIFICATION</span><br></pre></td></tr></table></figure></p>
<p>可以知道，上述通信流程涉及到三种状态码的转换：<br><code>BR_CODE</code> <code>BC_CODE</code>  <code>BW_CODE</code>,<br>他们之间的转换图如下：</p>
<p><img src="/media/15280221155795.jpg" alt=""></p>
<p><img src="/media/15280221222039.jpg" alt=""></p>
<p>图解：(以<code>BC_TRANSACTION</code>为例)</p>
<p>发起端进程：<code>binder_transaction</code>()过程将<code>BC_TRANSACTION</code>转换为<code>BW_TRANSACTION</code>；<br>接收端进程：<code>binder_thread_read</code>()过程，将<code>BW_TRANSACTION</code>转换为<code>BR_TRANSACTION</code>;<br>接收端进程：<code>IPC.execute()</code>过程，处理<code>BR_TRANSACTION</code>命令</p>
<p>以gityuan的一张图来总结binder通信的全过程</p>
<p><img src="/media/15280227943358.jpg" alt=""></p>
<h4 id="5-通讯过程中-binder实体的传递"><a href="#5-通讯过程中-binder实体的传递" class="headerlink" title="5 通讯过程中 binder实体的传递"></a>5 通讯过程中 binder实体的传递</h4><p>Binder机制淡化了进程的边界，使得跨越进程也能够调用到指定服务的方法，其原因是因为Binder机制在底层处理了在进程间的“对象”传递。</p>
<p>在Binder驱动中，并不是真的将对象在进程间来回序列化，而是通过特定的标识来进行对象的传递。Binder驱动中，通过<code>flat_binder_object</code>来描述需要跨越进程传递的对象。其定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">flat_binder_object</span> &#123;</span></span><br><span class="line">	__u32		type;</span><br><span class="line">	__u32		flags;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="keyword">binder_uintptr_t</span>	binder; <span class="comment">/* local object */</span></span><br><span class="line">		__u32			handle;	<span class="comment">/* remote object */</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">binder_uintptr_t</span>	cookie;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这其中，type有如下5种类型。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">	BINDER_TYPE_BINDER	= B_PACK_CHARS(<span class="string">'s'</span>, <span class="string">'b'</span>, <span class="string">'*'</span>, B_TYPE_LARGE),</span><br><span class="line">	BINDER_TYPE_WEAK_BINDER	= B_PACK_CHARS(<span class="string">'w'</span>, <span class="string">'b'</span>, <span class="string">'*'</span>, B_TYPE_LARGE),</span><br><span class="line">	BINDER_TYPE_HANDLE	= B_PACK_CHARS(<span class="string">'s'</span>, <span class="string">'h'</span>, <span class="string">'*'</span>, B_TYPE_LARGE),</span><br><span class="line">	BINDER_TYPE_WEAK_HANDLE	= B_PACK_CHARS(<span class="string">'w'</span>, <span class="string">'h'</span>, <span class="string">'*'</span>, B_TYPE_LARGE),</span><br><span class="line">	BINDER_TYPE_FD		= B_PACK_CHARS(<span class="string">'f'</span>, <span class="string">'d'</span>, <span class="string">'*'</span>, B_TYPE_LARGE),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>当对象传递到Binder驱动中的时候，由驱动来进行翻译和解释，然后传递到接收的进程。</p>
<p>例如当Server把Binder实体传递给Client时，在发送数据流中，<code>flat_binder_object</code>中的type是<code>BINDER_TYPE_BINDER</code>，同时binder字段指向Server进程用户空间地址。但这个地址对于Client进程是没有意义的（Linux中，每个进程的地址空间是互相隔离的），驱动必须对数据流中的<code>flat_binder_object</code>做相应的翻译：将type该成<code>BINDER_TYPE_HANDLE</code>；为这个Binder在接收进程中创建位于内核中的引用并将引用号填入handle中。对于发生数据流中引用类型的Binder也要做同样转换。经过处理后接收进程从数据流中取得的Binder引用才是有效的，才可以将其填入数据包<code>binder_transaction_data</code>的<code>target.handle</code>域，向Binder实体发送请求。<br><img src="/media/15299006076637.jpg" alt=""><br>图 binder对象索引和映射关系<br><code>flat_binder_object</code>就是进程间传递的<code>Binder</code>对象，每一个<code>flat_binder_object</code>对象内核都有一个唯一的<code>binder_node</code>对象，这个对象挂接在<code>binder_proc</code>的一颗二叉树上。对于一个<code>binder_node</code>对象，内核也会有一个唯一的<code>binder_ref</code>对象，可以这么理解，<code>binder_ref</code>的<code>desc</code>唯一的映射到<code>binder_node</code>的<code>ptr</code>和<code>cookie</code>上，同时也唯一的映射到了<code>flat_binder_object</code>的<code>handler</code>上。而<code>binder_ref</code>又按照<code>node</code>和<code>desc</code>两种方式映射到<code>binder_proc</code>对象上，也就是可以通过<code>binder_node</code>对象或者<code>desc</code>两种方式在<code>binder_proc</code>上查找到<code>binder_ref</code>或<code>binder_node</code>。所以，对于<code>flat_binder_object</code>对象来说，它的<code>binder+cookie</code>和<code>handler</code>指向了同一个<code>binder_node</code>对象上，即同一个<code>binder</code>对象。</p>
<p>由于每个请求和请求的返回都会经历内核的翻译，因此这个过程从进程的角度来看是完全透明的。进程完全不用感知这个过程，就好像对象真的在进程间来回传递一样。</p>
<h4 id="6-驱动层的线程管理"><a href="#6-驱动层的线程管理" class="headerlink" title="6 驱动层的线程管理"></a>6 驱动层的线程管理</h4><p>上文多次提到，Binder本身是C/S架构。由Server提供服务，被Client使用。既然是C/S架构，就可能存在多个Client会同时访问Server的情况。 在这种情况下，如果Server只有一个线程处理响应，就会导致客户端的请求可能需要排队而导致响应过慢的现象发生。解决这个问题的方法就是引入多线程。</p>
<p>Binder机制的设计从最底层–驱动层，就考虑到了对于多线程的支持。具体内容如下：</p>
<ul>
<li>使用Binder的进程在启动之后，通过<code>BINDER_SET_MAX_THREADS</code>告知驱动其支持的最大线程数量</li>
<li>驱动会对线程进行管理。在<code>binder_proc</code>结构中，这些字段记录了进程中线程的信息：<code>max_threads，requested_threads，requested_threads_started，ready_threads</code></li>
<li><code>binder_thread</code>结构对应了Binder进程中的线程</li>
<li>驱动通过<code>BR_SPAWN_LOOPER</code>命令告知进程需要创建一个新的线程</li>
<li>进程通过<code>BC_ENTER_LOOPER</code>命令告知驱动其主线程已经ready</li>
<li>进程通过<code>BC_REGISTER_LOOPER</code>命令告知驱动其子线程（非主线程）已经ready</li>
<li>进程通过<code>BC_EXIT_LOOPER</code>命令告知驱动其线程将要退出</li>
<li>在线程退出之后，通过<code>BINDER_THREAD_EXIT</code>告知Binder驱动。驱动将对应的<code>binder_thread</code>对象销毁</li>
</ul>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://wenyiqingnian.xyz/2018/06/02/从驱动角度理解binder/" data-id="cjqw00dzs001hvtfyg0g89377" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    
        <a href="http://wenyiqingnian.xyz/2018/06/02/从驱动角度理解binder/#comments" class="article-comment-link">Comments</a>
    

        </footer>
    </div>
    
</article>



    <nav id="page-nav">
        <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
</section>
            
                
<aside id="sidebar">
   
        
    <div class="widget-wrap">
        <h3 class="widget-title">recent</h3>
        <div class="widget">
            <ul id="recent-post" class="">
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2018/11/19/深度学习课程笔记 第二周 优化算法/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/机器学习/">机器学习</a></p>
                            <p class="item-title"><a href="/2018/11/19/深度学习课程笔记 第二周 优化算法/" class="title">深度学习课程笔记 第二周 优化算法</a></p>
                            <p class="item-date"><time datetime="2018-11-19T11:52:50.000Z" itemprop="datePublished">2018-11-19</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2018/11/15/深度学习课程笔记 第一周 深度学习的实践层面/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/机器学习/">机器学习</a></p>
                            <p class="item-title"><a href="/2018/11/15/深度学习课程笔记 第一周 深度学习的实践层面/" class="title">深度学习课程笔记 第一周 深度学习的实践层面</a></p>
                            <p class="item-date"><time datetime="2018-11-15T03:52:50.000Z" itemprop="datePublished">2018-11-15</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2018/11/11/机器学习算法的演进/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/机器学习/">机器学习</a></p>
                            <p class="item-title"><a href="/2018/11/11/机器学习算法的演进/" class="title">机器学习算法的演进</a></p>
                            <p class="item-date"><time datetime="2018-11-11T11:33:50.000Z" itemprop="datePublished">2018-11-11</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2018/08/21/八月份学习计划/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/学习计划/">学习计划</a></p>
                            <p class="item-title"><a href="/2018/08/21/八月份学习计划/" class="title">下个阶段的学习计划整理</a></p>
                            <p class="item-date"><time datetime="2018-08-21T09:12:50.000Z" itemprop="datePublished">2018-08-21</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2018/08/16/一些知识点总结/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/Android/">Android</a></p>
                            <p class="item-title"><a href="/2018/08/16/一些知识点总结/" class="title">一些知识点总结</a></p>
                            <p class="item-date"><time datetime="2018-08-16T11:00:50.000Z" itemprop="datePublished">2018-08-16</time></p>
                        </div>
                    </li>
                
            </ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">categories</h3>
        <div class="widget">
            <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/AOSP/">AOSP</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/CoolUI/">CoolUI</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MQTT/">MQTT</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/bug记录/">bug记录</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java基础/">java基础</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/webrtc/">webrtc</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/备忘录/">备忘录</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/学习计划/">学习计划</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/容器技术/">容器技术</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/机器学习/">机器学习</a><span class="category-list-count">4</span></li></ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">archives</h3>
        <div class="widget">
            <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a><span class="archive-list-count">1</span></li></ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">tags</h3>
        <div class="widget">
            <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AnimatedVectorDrawable/">AnimatedVectorDrawable</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Binder/">Binder</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SEAndroid/">SEAndroid</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tensorflow/">Tensorflow</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android/">android</a><span class="tag-list-count">9</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/aosp/">aosp</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/bugs/">bugs</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/">docker</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/">linux</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux命令/">linux命令</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mk/">mk</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mqtt/">mqtt</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/">python</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/qt/">qt</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/rxjava2/">rxjava2</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webrtc/">webrtc</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/句柄animation/">句柄animation</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/句柄泄露/">句柄泄露</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/垃圾回收/">垃圾回收</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/备忘录/">备忘录</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/多线程/">多线程</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/学习计划/">学习计划</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/容器/">容器</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/开源框架/">开源框架</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/抓包/">抓包</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/机器学习/">机器学习</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/现代艺术150年/">现代艺术150年</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/编译/">编译</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/音视频/">音视频</a><span class="tag-list-count">1</span></li></ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">tag cloud</h3>
        <div class="widget tagcloud">
            <a href="/tags/AnimatedVectorDrawable/" style="font-size: 10px;">AnimatedVectorDrawable</a> <a href="/tags/Binder/" style="font-size: 17.5px;">Binder</a> <a href="/tags/SEAndroid/" style="font-size: 10px;">SEAndroid</a> <a href="/tags/Tensorflow/" style="font-size: 17.5px;">Tensorflow</a> <a href="/tags/android/" style="font-size: 20px;">android</a> <a href="/tags/aosp/" style="font-size: 10px;">aosp</a> <a href="/tags/bugs/" style="font-size: 10px;">bugs</a> <a href="/tags/docker/" style="font-size: 10px;">docker</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/java/" style="font-size: 17.5px;">java</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/linux命令/" style="font-size: 10px;">linux命令</a> <a href="/tags/mk/" style="font-size: 10px;">mk</a> <a href="/tags/mqtt/" style="font-size: 10px;">mqtt</a> <a href="/tags/python/" style="font-size: 10px;">python</a> <a href="/tags/qt/" style="font-size: 10px;">qt</a> <a href="/tags/rxjava2/" style="font-size: 10px;">rxjava2</a> <a href="/tags/webrtc/" style="font-size: 10px;">webrtc</a> <a href="/tags/句柄animation/" style="font-size: 10px;">句柄animation</a> <a href="/tags/句柄泄露/" style="font-size: 10px;">句柄泄露</a> <a href="/tags/垃圾回收/" style="font-size: 12.5px;">垃圾回收</a> <a href="/tags/备忘录/" style="font-size: 12.5px;">备忘录</a> <a href="/tags/多线程/" style="font-size: 10px;">多线程</a> <a href="/tags/学习计划/" style="font-size: 10px;">学习计划</a> <a href="/tags/容器/" style="font-size: 10px;">容器</a> <a href="/tags/开源框架/" style="font-size: 10px;">开源框架</a> <a href="/tags/抓包/" style="font-size: 10px;">抓包</a> <a href="/tags/机器学习/" style="font-size: 17.5px;">机器学习</a> <a href="/tags/现代艺术150年/" style="font-size: 12.5px;">现代艺术150年</a> <a href="/tags/编译/" style="font-size: 15px;">编译</a> <a href="/tags/设计模式/" style="font-size: 10px;">设计模式</a> <a href="/tags/音视频/" style="font-size: 10px;">音视频</a>
        </div>
    </div>

    
        
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">links</h3>
        <div class="widget">
            <ul>
                
                    <li>
                        <a href="https://github.com/QuincyJiang">github</a>
                    </li>
                
            </ul>
        </div>
    </div>


    
    <div id="toTop" class="fa fa-angle-up"></div>
</aside>

            
        </div>
        <footer id="footer">
<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <div class="outer">
        <div id="footer-info" class="inner">
            &copy; 2019 QuincyJiang<br>
            Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>. Theme by <a href="http://github.com/ppoffice">PPOffice</a>
            <br/>本站总访问量<span id="busuanzi_value_site_pv"></span>次，你是来本站的第<span id="busuanzi_value_site_uv"></span>位小伙伴，本文总阅读量<span id="busuanzi_value_page_pv"></span>次
        </div>
    </div>
</footer>
        
    
    
    <!-- 来必力City版安装代码 -->
    <script type="text/javascript">
     (function(d, s) {
         var j, e = d.getElementsByTagName(s)[0];

         if (typeof LivereTower === 'function') { return; }

         j = d.createElement(s);
         j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
         j.async = true;

         e.parentNode.insertBefore(j, e);
     })(document, 'script');
    </script>
  <noscript> 为正常使用来必力评论功能请激活JavaScript</noscript>
  <!-- City版安装代码已完成 -->





    
        <script src="/libs/lightgallery/js/lightgallery.min.js"></script>
        <script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script>
        <script src="/libs/lightgallery/js/lg-pager.min.js"></script>
        <script src="/libs/lightgallery/js/lg-autoplay.min.js"></script>
        <script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script>
        <script src="/libs/lightgallery/js/lg-zoom.min.js"></script>
        <script src="/libs/lightgallery/js/lg-hash.min.js"></script>
        <script src="/libs/lightgallery/js/lg-share.min.js"></script>
        <script src="/libs/lightgallery/js/lg-video.min.js"></script>
    
    
        <script src="/libs/justified-gallery/jquery.justifiedGallery.min.js"></script>
    
    



<!-- Custom Scripts -->
<script src="/js/main.js"></script>

    </div><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>
</html>