<!DOCTYPE html>
<html lang=en>
<head>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
    
    <title>瘟疫青年</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta property="og:type" content="website">
<meta property="og:title" content="瘟疫青年">
<meta property="og:url" content="http://wenyiqingnian.xyz/index.html">
<meta property="og:site_name" content="瘟疫青年">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="瘟疫青年">
    

    

    
        <link rel="icon" href="/css/images/avatar.png" />
    

    <link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="/libs/open-sans/styles.css">
    <link rel="stylesheet" href="/libs/source-code-pro/styles.css">

    <link rel="stylesheet" href="/css/style.css">

    <script src="/libs/jquery/2.1.3/jquery.min.js"></script>
    
    
        <link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css">
    
    
        <link rel="stylesheet" href="/libs/justified-gallery/justifiedGallery.min.css"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
    
    
    
    


</head>

<body>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="container">
        <header id="header">
    <div id="header-main" class="header-inner">
        <div class="outer">
            <a href="/" id="logo">
                <i class="logo"></i>
                <span class="site-title">瘟疫青年</span>
            </a>
            <nav id="main-nav">
                
                    <a class="main-nav-link" href="/.">Home</a>
                
                    <a class="main-nav-link" href="/archives">Archives</a>
                
                    <a class="main-nav-link" href="/categories">Categories</a>
                
                    <a class="main-nav-link" href="/tags">Tags</a>
                
                    <a class="main-nav-link" href="/about">About</a>
                
            </nav>
            
                
                <nav id="sub-nav">
                    <div class="profile" id="profile-nav">
                        <a id="profile-anchor" href="javascript:;">
                            <img class="avatar" src="/css/images/avatar.png" />
                            <i class="fa fa-caret-down"></i>
                        </a>
                    </div>
                </nav>
            
            <div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="Search" />
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="Type something..." />
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: 'Posts',
            PAGES: 'Pages',
            CATEGORIES: 'Categories',
            TAGS: 'Tags',
            UNTITLED: '(Untitled)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div>
        </div>
    </div>
    <div id="main-nav-mobile" class="header-sub header-inner">
        <table class="menu outer">
            <tr>
                
                    <td><a class="main-nav-link" href="/.">Home</a></td>
                
                    <td><a class="main-nav-link" href="/archives">Archives</a></td>
                
                    <td><a class="main-nav-link" href="/categories">Categories</a></td>
                
                    <td><a class="main-nav-link" href="/tags">Tags</a></td>
                
                    <td><a class="main-nav-link" href="/about">About</a></td>
                
                <td>
                    
    <div class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="Search" />
    </div>

                </td>
            </tr>
        </table>
    </div>
</header>

        <div class="outer">
            
                

<aside id="profile" class="profile-fixed">
    <div class="inner profile-inner">
        <div class="base-info profile-block">
            <img id="avatar" src="/css/images/avatar.png" />
            <h2 id="name">QuincyJiang</h2>
            <h3 id="title">Coder &amp; FilmPlayer</h3>
            <span id="location"><i class="fa fa-map-marker"></i>Guangzhou, China</span>
            <a id="follow" target="_blank" href="https://github.com/QuincyJiang">FOLLOW</a>
        </div>
        <div class="article-info profile-block">
            <div class="article-info-block">
                26
                <span>posts</span>
            </div>
            <div class="article-info-block">
                30
                <span>tags</span>
            </div>
        </div>
        
        <div class="profile-block social-links">
            <table>
                <tr>
                    
                    
                    <td>
                        <a href="https://github.com/QuincyJiang" target="_blank" title="github" class=tooltip>
                            <i class="fa fa-github"></i>
                        </a>
                    </td>
                    
                    <td>
                        <a href="https://weibo.com/2425393311/" target="_blank" title="weibo" class=tooltip>
                            <i class="fa fa-weibo"></i>
                        </a>
                    </td>
                    
                    <td>
                        <a href="http://aquencyua11.lofter.com/" target="_blank" title="photo" class=tooltip>
                            <i class="fa fa-photo"></i>
                        </a>
                    </td>
                    
                </tr>
            </table>
        </div>
        
    </div>
</aside>

            
            <section id="main">
    <article id="post-《现代艺术150年》未影印作品2" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2018/06/16/《现代艺术150年》未影印作品2/">《现代艺术150年》未影印作品2</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2018/06/16/《现代艺术150年》未影印作品2/">
            <time datetime="2018-06-16T06:00:50.000Z" itemprop="datePublished">2018-06-16</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/备忘录/">备忘录</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/备忘录/">备忘录</a>, <a class="tag-link" href="/tags/现代艺术150年/">现代艺术150年</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p>51.The Kiss (French: Le Baiser)  吻 1882（Auguste Rodin, 奥古斯特·罗丹）<br><a href="https://en.wikipedia.org/wiki/The_Kiss_(Rodin_sculpture)" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/The_Kiss_(Rodin_sculpture)</a><br><img src="/media/15292175984876.jpg" alt=""></p>
<p>52.The Kiss  吻 1907-1908（Constantin Brâncuși, 康斯坦丁·布朗库西）<br><a href="https://en.wikipedia.org/wiki/The_Kiss_(Br%C3%A2ncu%C8%99i_sculpture)" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/The_Kiss_(Br%C3%A2ncu%C8%99i_sculpture)</a></p>
<p><img src="/media/15292176140941.jpg" alt=""></p>
<p>53.Sleeping Muse, 沉睡的缪斯 1910 （Constantin Brâncuși, 康斯坦丁·布朗库西）<br><a href="http://www.artic.edu/aic/collections/artwork/9024" target="_blank" rel="noopener">http://www.artic.edu/aic/collections/artwork/9024</a></p>
<p><img src="/media/15292176224205.jpg" alt=""></p>
<p>54.Head 头 1911-1912（Amedeo Modigliani, 阿梅代奥·莫迪利亚尼）<br><a href="https://www.wikiart.org/en/amedeo-modigliani/head" target="_blank" rel="noopener">https://www.wikiart.org/en/amedeo-modigliani/head</a><br><img src="/media/15292176318034.jpg" alt=""></p>
<p>55.Walking Man I 行走的人1 1960（Alberto Giacometti， 阿尔伯托·贾科梅蒂）<br><a href="https://www.artsy.net/artwork/alberto-giacometti-walking-man-i" target="_blank" rel="noopener">https://www.artsy.net/artwork/alberto-giacometti-walking-man-i</a><br><img src="/media/15292176408821.jpg" alt=""></p>
<p>56.Spoon Woman勺形女人 1927 （Alberto Giacometti， 阿尔伯托·贾科梅蒂）<br><a href="http://www.artic.edu/aic/collections/artwork/37761" target="_blank" rel="noopener">http://www.artic.edu/aic/collections/artwork/37761</a><br><img src="/media/15292176525962.jpg" alt=""></p>
<p>57.Pierced Form 穿孔之形 1963-1964（Barbara Hepworth, 芭芭拉·赫普沃斯）<br><a href="http://www.tate.org.uk/art/artworks/hepworth-pierced-form-t00704" target="_blank" rel="noopener">http://www.tate.org.uk/art/artworks/hepworth-pierced-form-t00704</a><br><img src="/media/15292176617908.jpg" alt=""></p>
<p>58.Pelagos 海洋生物 1946 （Barbara Hepworth, 芭芭拉·赫普沃斯）<br><a href="http://www.tate.org.uk/art/artworks/hepworth-pelagos-t00699" target="_blank" rel="noopener">http://www.tate.org.uk/art/artworks/hepworth-pelagos-t00699</a><br><img src="/media/15292176742098.jpg" alt=""></p>
<p>59.Single Form 单一的形式 1961 （Barbara Hepworth, 芭芭拉·赫普沃斯）<br><a href="http://www.tate.org.uk/art/artworks/hepworth-single-form-september-t03143" target="_blank" rel="noopener">http://www.tate.org.uk/art/artworks/hepworth-single-form-september-t03143</a></p>
<p><img src="/media/15292176831725.jpg" alt=""></p>
<h2 id="SEVEN"><a href="#SEVEN" class="headerlink" title="SEVEN"></a>SEVEN</h2><p>60.Opening of the Fifth Seal 揭开第五印  1608（El Greco, 埃尔·格列柯）<br><a href="https://en.wikipedia.org/wiki/Opening_of_the_Fifth_Seal" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Opening_of_the_Fifth_Seal</a><br><img src="/media/15292176921293.jpg" alt=""></p>
<p>61.Houses at l’Estaque 埃斯塔克的房子 1908（Georges Braque, 乔治·布拉克）<br><a href="https://en.wikipedia.org/wiki/Houses_at_l%27Estaque" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Houses_at_l%27Estaque</a></p>
<p><img src="/media/15292177113811.jpg" alt=""></p>
<p>62.Violin and Palette 小提琴与调色板 1909（Georges Braque, 乔治·布拉克）<br><a href="https://www.wikiart.org/en/georges-braque/violin-and-palette-1909" target="_blank" rel="noopener">https://www.wikiart.org/en/georges-braque/violin-and-palette-1909</a><br><img src="/media/15292177210636.jpg" alt=""></p>
<p>63.Still Life with Flowers 静物花卉 1912（Juan Gris, 胡安·格里斯）<br><a href="https://www.wikiart.org/en/juan-gris/still-life-with-flowers-1912" target="_blank" rel="noopener">https://www.wikiart.org/en/juan-gris/still-life-with-flowers-1912</a></p>
<p><img src="/media/15292177353327.jpg" alt=""></p>
<p>64.Ma Jolie 我的美人 1912（Pablo Picasso, 巴勃罗·毕加索）<br><a href="https://www.moma.org/collection/works/79051" target="_blank" rel="noopener">https://www.moma.org/collection/works/79051</a><br><img src="/media/15292177517197.jpg" alt=""></p>
<p>65.Still-Life with Chair Caning有藤椅的静物 1912（Pablo Picasso, 巴勃罗·毕加索）<br><a href="http://www.pablo-ruiz-picasso.net/work-88.php" target="_blank" rel="noopener">http://www.pablo-ruiz-picasso.net/work-88.php</a><br><img src="/media/15292177652495.jpg" alt=""></p>
<p>66.Fruit Dish and Glass 水果盘与玻璃杯  1912 （Georges Braque, 乔治·布拉克）<br><a href="https://en.wikipedia.org/wiki/Fruit_Dish_and_Glass" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Fruit_Dish_and_Glass</a><br><img src="/media/15292177736853.jpg" alt=""></p>
<p>67.The Little Fourteen-Year-Old Dancer (French: La Petite Danseuse de Quatorze Ans)  小舞女 1880-1881 （Edgar Degas 埃德加·德加）<br><a href="https://en.wikipedia.org/wiki/Little_Dancer_of_Fourteen_Years" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Little_Dancer_of_Fourteen_Years</a><br><img src="/media/15292177894146.jpg" alt=""></p>
<p>68.Guitar 吉他 1912（Pablo Picasso, 巴勃罗·毕加索）<br><a href="https://www.wikiart.org/en/pablo-picasso/guitar-1912" target="_blank" rel="noopener">https://www.wikiart.org/en/pablo-picasso/guitar-1912</a><br><img src="/media/15292177950269.jpg" alt=""></p>
<h2 id="EIGHT"><a href="#EIGHT" class="headerlink" title="EIGHT"></a>EIGHT</h2><p>69.Dynamism of a Dog on a Leash (Italian: Dinamismo di un cane al guinzaglio)拴着皮带的狗的动态 1912（Giacomo Balla, 贾科莫·巴拉）<br><a href="https://en.wikipedia.org/wiki/Dynamism_of_a_Dog_on_a_Leash" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Dynamism_of_a_Dog_on_a_Leash</a></p>
<p><img src="/media/15292178075225.jpg" alt=""></p>
<p>70.Unique Forms of Continuity in Space 空间中连续的唯一形体 1913（UmbertoBoccioni, 翁贝托·薄丘尼） <a href="https://en.wikipedia.org/wiki/Unique_Forms_of_Continuity_in_Space" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Unique_Forms_of_Continuity_in_Space</a></p>
<p><img src="/media/15292178225341.jpg" alt=""></p>
<p>71.States of Mind I: The Farewells  心境I 告别 1911<br>     States of Mind II: Those Who Go 心境II 离开的人 1911<br>     States of Mind III: Those Who Stay 心境III 留下的人 1911<br>   （UmbertoBoccioni, 翁贝托·薄丘尼）<br><a href="https://www.wikiart.org/en/umberto-boccioni/states-of-mind-i-the-farewells-1911" target="_blank" rel="noopener">https://www.wikiart.org/en/umberto-boccioni/states-of-mind-i-the-farewells-1911</a><br><a href="https://www.wikiart.org/en/umberto-boccioni/states-of-mind-ii-those-who-go-1911" target="_blank" rel="noopener">https://www.wikiart.org/en/umberto-boccioni/states-of-mind-ii-those-who-go-1911</a><br><a href="https://www.wikiart.org/en/umberto-boccioni/states-of-mind-iii-those-who-stay-1911-1" target="_blank" rel="noopener">https://www.wikiart.org/en/umberto-boccioni/states-of-mind-iii-those-who-stay-1911-1</a><br><img src="/media/15292178379461.jpg" alt=""></p>
<p><img src="/media/15292178507767.jpg" alt=""></p>
<p><img src="/media/15292178598767.jpg" alt=""></p>
<p>72.L’Équipe de Cardiff 加迪夫队 1913（Robert Delaunay, 罗伯特·德劳内）<br><a href="https://fr.wikipedia.org/wiki/L%27%C3%89quipe_de_Cardiff" target="_blank" rel="noopener">https://fr.wikipedia.org/wiki/L%27%C3%89quipe_de_Cardiff</a><br><img src="/media/15292178739277.jpg" alt=""></p>
<p>73.Rock Drill 凿岩机 1913（Jacob Epstein, 雅各·爱泼斯坦）<br><a href="https://en.wikipedia.org/wiki/Rock_Drill_(Jacob_Epstein)" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Rock_Drill_(Jacob_Epstein)</a><br><img src="/media/15292178833052.jpg" alt=""></p>
<h2 id="NINE"><a href="#NINE" class="headerlink" title="NINE"></a>NINE</h2><p>74.The First Step 第一步 1910（František Kupka, 弗朗齐歇克·库普卡）<br><a href="https://www.moma.org/collection/works/79969" target="_blank" rel="noopener">https://www.moma.org/collection/works/79969</a><br><img src="/media/15292178942900.jpg" alt=""></p>
<p>75.Disque simultané（Simultaneous Disc）共时的圆盘 1912（Robert Delaunay, 罗伯特·德劳内）<br><a href="https://fr.wikipedia.org/wiki/Disque_simultan%C3%A9" target="_blank" rel="noopener">https://fr.wikipedia.org/wiki/Disque_simultan%C3%A9</a><br><img src="/media/15292179001516.jpg" alt=""></p>
<p>76.München - Planegg I 慕尼黑-普拉内格 1 1901（Wassily Kandinsky, 瓦西里·康定斯基）<br><a href="https://www.akg-images.de/archive/Munchen-%25E2%2580%2593-Planegg-I-2UMDHUORFRFR.html" target="_blank" rel="noopener">https://www.akg-images.de/archive/Munchen-%25E2%2580%2593-Planegg-I-2UMDHUORFRFR.html</a><br><img src="/media/15292179093621.jpg" alt=""></p>
<p>77.Murnau, Dorfstrasse (A Village Street) 穆尔瑙，乡村道路 1908 （Wassily Kandinsky, 瓦西里·康定斯基）<br><a href="https://commons.wikimedia.org/wiki/File:Vassily_Kandinsky,_1908,_Murnau,_Dorfstrasse.jpg" target="_blank" rel="noopener">https://commons.wikimedia.org/wiki/File:Vassily_Kandinsky,_1908,_Murnau,_Dorfstrasse.jpg</a><br><img src="/media/15292179178192.jpg" alt=""></p>
<p>78.Kochel - Straight Road 科黑尔，笔直的路 1909（Wassily Kandinsky, 瓦西里·康定斯基）<br><a href="http://www.the-athenaeum.org/art/detail.php?ID=116422" target="_blank" rel="noopener">http://www.the-athenaeum.org/art/detail.php?ID=116422</a></p>
<p><img src="/media/15292179294972.jpg" alt=""></p>
<p>79.Improvisation 4 即兴 4 1909（Wassily Kandinsky, 瓦西里·康定斯基）<br><a href="https://www.wikiart.org/en/wassily-kandinsky/improvisation-4-1909" target="_blank" rel="noopener">https://www.wikiart.org/en/wassily-kandinsky/improvisation-4-1909</a></p>
<p><img src="/media/15292179410842.jpg" alt=""></p>
<p>80.Impression III (Concert) 印象3（音乐会） 1911 （Wassily Kandinsky, 瓦西里·康定斯基）<br><a href="https://www.wikiart.org/en/wassily-kandinsky/impression-iii-concert-1911" target="_blank" rel="noopener">https://www.wikiart.org/en/wassily-kandinsky/impression-iii-concert-1911</a></p>
<p><img src="/media/15292179496940.jpg" alt=""></p>
<p>81.Picture with a Circle  带圆的画 1911 （Wassily Kandinsky, 瓦西里·康定斯基）<br><a href="http://www.wassilykandinsky.net/work-432.php" target="_blank" rel="noopener">http://www.wassilykandinsky.net/work-432.php</a><br><img src="/media/15292179605301.jpg" alt=""></p>
<p>82.Composition IV 作曲 4 1911（Wassily Kandinsky, 瓦西里·康定斯基）<br><a href="https://www.wikiart.org/en/wassily-kandinsky/composition-iv-1911" target="_blank" rel="noopener">https://www.wikiart.org/en/wassily-kandinsky/composition-iv-1911</a><br><img src="/media/15292179734750.jpg" alt=""></p>
<p>83.Composition VII 作曲 7 1913（Wassily Kandinsky, 瓦西里·康定斯基）<br><a href="http://www.wassilykandinsky.net/work-36.php" target="_blank" rel="noopener">http://www.wassilykandinsky.net/work-36.php</a><br><img src="/media/15292179891642.jpg" alt=""></p>
<p>84.Hammamet with mosque 哈马马特的清真寺 1914（Paul Klee, 保罗·克利）<br><a href="https://www.wikiart.org/en/paul-klee/hammamet-with-mosque-1914" target="_blank" rel="noopener">https://www.wikiart.org/en/paul-klee/hammamet-with-mosque-1914</a><br><img src="/media/15292179992868.jpg" alt=""></p>
<h2 id="TEN"><a href="#TEN" class="headerlink" title="TEN"></a>TEN</h2><p>85.Cow And Violin 奶牛和小提琴 1913（Kazimir Malevich, 卡济米尔·马列维奇）<br><a href="http://russianartgallery.org/famous/malevich_cow.htm" target="_blank" rel="noopener">http://russianartgallery.org/famous/malevich_cow.htm</a><br><img src="/media/15292180077535.jpg" alt=""></p>
<p>86.Black Square 黑色正方形 1915 （Kazimir Malevich, 卡济米尔·马列维奇）<br><a href="https://en.wikipedia.org/wiki/Black_Square_(painting)" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Black_Square_(painting)</a><br><img src="/media/15292180159011.jpg" alt=""></p>
<p>87.Suprematist Painting 至上主义 1915 （Kazimir Malevich, 卡济米尔·马列维奇）<br><a href="http://www.ibiblio.org/eldritch/el/mpix.html" target="_blank" rel="noopener">http://www.ibiblio.org/eldritch/el/mpix.html</a><br><img src="/media/15292180244412.jpg" alt=""></p>
<p>88.Corner Counter-Relief 1914 角落的反浮雕（Vladimir Tatlin, 弗拉基米尔·塔特林）<br><a href="http://rusmuseumvrm.ru/data/collections/sculpture/20/tatlin_ve_uglovoy_kontrrelef_1914/index.php?lang=en" target="_blank" rel="noopener">http://rusmuseumvrm.ru/data/collections/sculpture/20/tatlin_ve_uglovoy_kontrrelef_1914/index.php?lang=en</a></p>
<p><img src="/media/15292180343049.jpg" alt=""></p>
<p>89.Monument to the Third International 第三国际的纪念塔 1919-1920（Vladimir Tatlin, 弗拉基米尔·塔特林）<br> <a href="https://en.wikipedia.org/wiki/Tatlin%27s_Tower" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Tatlin%27s_Tower</a></p>
<p><img src="/media/15292180515507.jpg" alt=""></p>
<p>90.Pure Red Color, Pure Yellow Color, Pure Blue Color 纯红、纯黄和纯蓝 1921（Alexander Rodchenko, 亚历山大·罗琴科）</p>
<p><img src="/media/15292180607987.jpg" alt=""></p>
<p>91.Beat the Whites with the Red Wedge 以红锲攻打白军 1919（El Lissitzky, 埃尔·利西茨基）<br><a href="https://en.wikipedia.org/wiki/Beat_the_Whites_with_the_Red_Wedge" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Beat_the_Whites_with_the_Red_Wedge</a></p>
<p><img src="/media/15292180686570.jpg" alt=""></p>
<h2 id="ELEVEN"><a href="#ELEVEN" class="headerlink" title="ELEVEN"></a>ELEVEN</h2><p>92.Composition C (No.III) with Red, Yellow and Blue构成C（第 3号），红黄蓝 1935（Piet Mondrian, 皮埃特·蒙特里安）<br><a href="https://theartstack.com/artist/piet-mondrian/composition-c-no-iii-with-red-yellow-and-blue#" target="_blank" rel="noopener">https://theartstack.com/artist/piet-mondrian/composition-c-no-iii-with-red-yellow-and-blue#</a><br><img src="/media/15292180863314.jpg" alt=""></p>
<p>93.Evening; Red Tree 夜晚，红树 1908 （Piet Mondrian, 皮埃特·蒙特里安）<br><a href="https://en.wikipedia.org/wiki/Evening;_Red_Tree" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Evening;_Red_Tree</a></p>
<p><img src="/media/15292180959896.jpg" alt=""></p>
<p>94.Gray Tree 灰色的树 1912 （Piet Mondrian, 皮埃特·蒙特里安）<br><a href="https://en.wikipedia.org/wiki/Gray_Tree" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Gray_Tree</a><br><img src="/media/15292181033239.jpg" alt=""></p>
<p>95.Blossoming Apple Tree  开花的苹果树 1912 （Piet Mondrian, 皮埃特·蒙特里安）<br><a href="https://en.wikipedia.org/wiki/Evening;_Red_Tree#/media/File:Blossoming_apple_tree,_by_Piet_Mondriaan.jpg" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Evening;_Red_Tree#/media/File:Blossoming_apple_tree,_by_Piet_Mondriaan.jpg</a><br><img src="/media/15292181126923.jpg" alt=""></p>
<p>96.Tableau No. 2/Composition No. VII 画面 2/构成 7 1913 （Piet Mondrian, 皮埃特·蒙特里安）<br><a href="https://theartstack.com/artist/piet-mondrian/tableau-no-2-compositio" target="_blank" rel="noopener">https://theartstack.com/artist/piet-mondrian/tableau-no-2-compositio</a><br><img src="/media/15292181204601.jpg" alt=""></p>
<p>97.Composition No VI 构成 6 1914 （Piet Mondrian, 皮埃特·蒙特里安）<br><img src="/media/15292181399236.jpg" alt=""></p>
<p>98.Red and Blue Chair 红蓝椅 1923 （Gerrit Rietveld, 赫里特·里特费尔德）<br><a href="http://www.theartstory.org/movement-de-stijl-artworks.htm" target="_blank" rel="noopener">http://www.theartstory.org/movement-de-stijl-artworks.htm</a><br><img src="/media/15292181326462.jpg" alt=""></p>
<p>99.Rietveld Schröder House 施罗德住宅 1924 （Gerrit Rietveld, 赫里特·里特费尔德）<br><a href="https://en.wikipedia.org/wiki/Rietveld_Schr%C3%B6der_House" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Rietveld_Schr%C3%B6der_House</a></p>
<p><img src="/media/15292181532387.jpg" alt=""></p>
<p>100.Composition No.1 构成第一号 1920 （Piet Mondrian, 皮埃特·蒙特里安）<br><img src="/media/15292181590021.jpg" alt=""></p>
<h2 id="TWELVE"><a href="#TWELVE" class="headerlink" title="TWELVE"></a>TWELVE</h2><p>101.Wainwright Building 温赖特大厦 1891（ Dankmar Adler and Louis Sullivan, 阿德勒和路易斯·沙利文）<br><a href="https://en.wikipedia.org/wiki/Wainwright_Building" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Wainwright_Building</a></p>
<p><img src="/media/15292181722733.jpg" alt=""></p>
<p>102.AEG turbine factory 通用电气涡轮机工厂 1909 （Peter Behrens, 彼特·贝伦斯）<br><a href="https://en.wikipedia.org/wiki/AEG_turbine_factory" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/AEG_turbine_factory</a></p>
<p><img src="/media/15292181849573.jpg" alt=""></p>
<p>103.Fagus Factory (German:Fagus-Werk）法古斯工厂 1911-1913 （ Walter Gropius and Adolf Meyer, 沃尔特·格罗佩斯，阿道夫·梅耶）<br><a href="https://en.wikipedia.org/wiki/Fagus_Factory" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Fagus_Factory</a><br><img src="/media/15292181939189.jpg" alt=""></p>
<p>104.Self-Portrait as a Soldier 作为一个军人的自画像 1915（Ernst Ludwig Kirchner, 恩斯特·路德维希·凯尔希纳）<br><a href="https://www.wikiart.org/en/ernst-ludwig-kirchner/self-portrait-as-a-soldier-1915" target="_blank" rel="noopener">https://www.wikiart.org/en/ernst-ludwig-kirchner/self-portrait-as-a-soldier-1915</a><br><img src="/media/15292182030237.jpg" alt=""></p>
<p>105.Hot-Water Jug 1924（Marianne Brandt, 玛丽安·布兰德）<br><a href="https://www.moma.org/collection/works/2440" target="_blank" rel="noopener">https://www.moma.org/collection/works/2440</a></p>
<p><img src="/media/15292182113973.jpg" alt=""></p>
<p>106.Table Lamp 华根菲尔德台灯 1924（Wilhelm Wagenfeld &amp; Carl Jakob Jucker, 威尔赫姆·华根菲尔德，卡尔·朱克）<br><a href="https://www.moma.org/collection/works/4056?locale=en" target="_blank" rel="noopener">https://www.moma.org/collection/works/4056?locale=en</a><br><img src="/media/15292182221930.jpg" alt=""></p>
<p>107.EM 1 (Telephone Picture) 电话图 EM1 1923 （László Moholy-Nagy, 莫霍利·纳吉）<br><a href="https://www.moma.org/collection/works/147626" target="_blank" rel="noopener">https://www.moma.org/collection/works/147626</a><br><img src="/media/15292182328932.jpg" alt=""></p>
<p>108.NESTING TABLES 嵌套桌组 1927 （Josef Albers, 约瑟夫·亚伯斯）<br><a href="https://blog.timelesswroughtiron.com/2014/09/modern-history-bauhaus-nesting-tables/" target="_blank" rel="noopener">https://blog.timelesswroughtiron.com/2014/09/modern-history-bauhaus-nesting-tables/</a><br><img src="/media/15292182429532.jpg" alt=""></p>
<p>109.Wassily Chair 瓦西里椅 1925（Marcel Lajos Breuer, 马塞尔·布劳耶）<br><a href="https://en.wikipedia.org/wiki/Wassily_Chair" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Wassily_Chair</a></p>
<p><img src="/media/15292182521590.jpg" alt=""></p>
<p>110.Barcelona Pavilion 巴塞罗那世博会德国馆  1929 （Ludwig Mies van der Rohe, 路德维希·密斯·凡德罗）<br><a href="https://en.wikipedia.org/wiki/Barcelona_Pavilion" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Barcelona_Pavilion</a><br><img src="/media/15292182626406.jpg" alt=""></p>
<p>111.Barcelona Chair 巴塞罗那椅 1929 （Ludwig Mies van der Rohe, 路德维希·密斯·凡德罗）<br><a href="https://www.moma.org/collection/works/4369?locale=en" target="_blank" rel="noopener">https://www.moma.org/collection/works/4369?locale=en</a><br><img src="/media/15292182733434.jpg" alt=""></p>
<h2 id="THIRTEEN"><a href="#THIRTEEN" class="headerlink" title="THIRTEEN"></a>THIRTEEN</h2><p>112.La Nona Ora (The Ninth Hour) 第九时辰 1999（Maurizio Cattelan, 莫瑞吉奥·卡特兰）<br><a href="https://farticulate.wordpress.com/2010/10/21/la-nona-ora-the-ninth-hour-1999/" target="_blank" rel="noopener">https://farticulate.wordpress.com/2010/10/21/la-nona-ora-the-ninth-hour-1999/</a><br><img src="/media/15292182840020.jpg" alt=""></p>
<p>113.Collage with Squares Arranged according to the Laws of Chance 根据随机法则排布的正方形的拼贴画 1916-1917 （Jean （Hans）Arp, 让·阿尔普（汉斯·阿尔普））<br><a href="https://www.moma.org/collection/works/37013?locale=en" target="_blank" rel="noopener">https://www.moma.org/collection/works/37013?locale=en</a><br><img src="/media/15292182948826.jpg" alt=""></p>
<p>114.Revolving 旋转 1919 （Kurt Schwitters, 库尔特·施维特斯）<br><a href="https://www.moma.org/collection/works/79211?locale=en" target="_blank" rel="noopener">https://www.moma.org/collection/works/79211?locale=en</a><br><img src="/media/15292183044893.jpg" alt=""></p>
<p>115.Merzbau 梅尔兹堡 1933 （Kurt Schwitters, 库尔特·施维特斯）<br><a href="https://www.moma.org/explore/inside_out/2012/07/09/in-search-of-lost-art-kurt-schwitterss-merzbau/" target="_blank" rel="noopener">https://www.moma.org/explore/inside_out/2012/07/09/in-search-of-lost-art-kurt-schwitterss-merzbau/</a><br><img src="/media/15292183118486.jpg" alt=""></p>
<p>116.3 Standard Stoppages 三个标准的终止 1913-1914（Marcel Duchamp, 马塞尔·杜尚）<br><a href="https://www.moma.org/collection/works/78990?locale=en" target="_blank" rel="noopener">https://www.moma.org/collection/works/78990?locale=en</a></p>
<p><img src="/media/15292183180573.jpg" alt=""></p>
<p>117.L.H.O.O.Q. 1919 （Marcel Duchamp, 马塞尔·杜尚）<br><a href="https://en.wikipedia.org/wiki/L.H.O.O.Q" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/L.H.O.O.Q</a>.<br><img src="/media/15292183282990.jpg" alt=""></p>
<p>118.Beautiful Breath: Veil Water 美丽气息 1921 （Marcel Duchamp, 马塞尔·杜尚）<br><a href="http://www.toutfait.com/unmaking_the_museum/Belle%20Haleine.html" target="_blank" rel="noopener">http://www.toutfait.com/unmaking_the_museum/Belle%20Haleine.html</a></p>
<p><img src="/media/15292183377928.jpg" alt=""></p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://wenyiqingnian.xyz/2018/06/16/《现代艺术150年》未影印作品2/" data-id="cjiih6wym0018hx0csw9usn4e" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    
        <a href="http://wenyiqingnian.xyz/2018/06/16/《现代艺术150年》未影印作品2/#comments" class="article-comment-link">Comments</a>
    

        </footer>
    </div>
    
</article>



    <article id="post-深度学习1-反向传播" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2018/06/08/深度学习1-反向传播/">深度学习1-反向传播</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2018/06/08/深度学习1-反向传播/">
            <time datetime="2018-06-08T09:33:50.000Z" itemprop="datePublished">2018-06-08</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/机器学习/">机器学习</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/Tensorflow/">Tensorflow</a>, <a class="tag-link" href="/tags/机器学习/">机器学习</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <h1 id="机器学习算法中的数学思想"><a href="#机器学习算法中的数学思想" class="headerlink" title="机器学习算法中的数学思想"></a>机器学习算法中的数学思想</h1><h2 id="一、-机器学习的过程是在学习什么"><a href="#一、-机器学习的过程是在学习什么" class="headerlink" title="一、 机器学习的过程是在学习什么"></a>一、 机器学习的过程是在学习什么</h2><p>以<code>MNIST</code>手写数字识别为例 MNIST是一个手写数字数据库，它是以一个28*28像素的图片以及一个对应的数字标签作为键值对的数据库。<br><img src="/media/15285243813747.jpg" alt="-w218"></p>
<p>为了更好的将这个识别过程数学化，先将输入的图形像素化，每一个数字图形可以按照各像素的明度值 转化为一个784个参数的列向量。<br><code>[0.1,0.3,0.4 ...... 0.0,0.8]</code><br><img src="/media/15285243407818.jpg" alt="-w391"></p>
<p>其中每个向量值代表一个像素对应的明度值。<br>假设学习模型为一个有两个隐藏层的全连接层。<br><img src="/media/15285246497144.jpg" alt="-w367"></p>
<p>可以看到 每个神经元与神经元之间都由一根线连接着，这根线其实指代的是两个神经元之间的关系，用数学方式来说，可以称之为 <strong>权重值</strong>。</p>
<p>我们希望找到<strong>每根线所代表的权重</strong>，当输入一个手写数字图片的时候，通过第一层的权重值，点亮部分第一个隐藏层的神经元【注1】</p>
<blockquote>
<p>注释1： 可以假设 最后一层隐藏的神经元所代表的是类似人类识别数字那样，指代组成数字的一些笔画，比如说圆圈或者竖线，那么第一层隐藏的神经元可能指代的是 组成哪些笔画的更细微一些的笔画，比如一个左上角的圆弧，一个左下角的圆弧之类，但其实机器学习的过程并非我们想象的那样，每一层代表的可能是一些我们人类都看不懂的信息，我们称之为features，或者说是特征。为了更好理解机器学习的数学原理，我们暂且这么认为。</p>
</blockquote>
<p>那么 拿最后输出层的一个神经元 <code>a2</code>  来说，它就等于上一层神经元与权重值的求和$sum = \sum_j W_{i,j}x_j$<br>但只求和是不行的，因为对于输出端 <code>a2</code>来说，它的值必须在<code>[0,1]</code>范围内，这里就要用到<code>sigmoid()</code> 压缩函数。【注2】</p>
<blockquote>
<p>注2： sigmoid 函数 是一个压缩函数  $ S(x) = \frac{1}{1+e_{-x}}$，sigmoid函数连续，光滑，严格单调，以(0,0.5)中心对称，是一个非常良好的阈值函数。<br>当x趋近负无穷时，y趋近于0；趋近于正无穷时，y趋近于1；x=0时，y=0.5。当然，在x超出[-6,6]的范围后，函数值基本上没有变化，值非常接近，在应用中一般不考虑。 在机器学习中，常常使用sigmoid函数 将相似率控制在<code>0-1</code> 范围内。</p>
</blockquote>
<p>当然，神经元的触发难易程度也不应该是一样的，我们在求和函数$sum = \sum_j W_{i,j}x_j$中<br>增加一个偏置值$ b_i$，用来控制神经元激活的难易程度。<br>$sum = \sum_j W_{i,j}x_j+b_i$<br>那么 输出结果<code>ai</code> 就可以用公式表示为<br>$ a_i = sigmoid（\sum{w^{i-1}_j a_j^{l-1}+b_i}）$<br>所谓机器学习，就是找到上述有着无比复杂参数（偏置b和权重w）的函数<code>funa（）</code>，求出其正确的偏置和权重值,使得我们每次输入一个手写图片向量，该函数都能在最后点亮输出向量中的某个神经节点。<br>所以： 机器学习的核心，<strong>就是使用合适的方法 去找到学习的数学模型里，所有的 偏置和 权重</strong></p>
<h2 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h2><p>这是机器学习的核心，就是找到一个合适的方法，去调整偏置和权重，使输出层的结果尽可能的与我们期望的结果一致。<br>就以前面说到的识别mnist手写数字识别算法为例。<br>当输入一个手写数字 2 的时候<br><img src="/media/15285207921376.jpg" alt="-w78"></p>
<p>当模型还未完全训练完毕，输入的结果和输出的结果看起来应该是没有什么关联的。<br><img src="/media/15285208383753.jpg" alt="-w91"><br> 可以看到，尚未完成训练的模型，它的识别结果是很混乱的，同时点亮了好几个数字。</p>
<p> <strong>我们的期望：</strong> 是让数字2 对应的节点 值变得更大，让其他的节点 对应的结果值变得更小。同时 该变化应该和节点当前对应的值与期望值的差距成正比。</p>
<p> 比如说 节点2 当前激活的值为0.2  我们期望的值是1，那么节点2变大 对于我们预测模型来说就比让节点8变为0要来的更重要，因为节点8 当前的数值0.2 已经和我们期望的0 差距不大了，而2对应的0.2 与我们当前期望的1差距显然要更大。<br> 见下图：<br> <img src="/media/15285212725297.jpg" alt="-w280"></p>
<p>我们知道，数字2 对应的值0.2  是将输入的748列向量的值，与对应的偏置和权重相乘之后求和，再通过<code>sigmoid()</code>函数 将其结果约束在[0,1]之间的<br><img src="/media/15285213924586.jpg" alt=""></p>
<blockquote>
<p>注： w0 w1 w2…. 为上一层（该例子中为第二个隐藏层）对应的每个神经元的权重，b为偏置向量。<br>如果要让0.2（即节点2对应的输出）变大，有三个途径</p>
<ol>
<li>增大权重wi </li>
<li>增大偏置b</li>
<li>修改ai的值</li>
</ol>
</blockquote>
<p>我们目前只关注如何修改权重 使得输出节点2 对应的结果变大。<br> <img src="/media/15285217014448.jpg" alt="-w273"></p>
<p>可以看到上一个链接层对应的激活情况如图。<br>如果我们要更改权重值， 那么1，6，7，9对应的神经节点的参数更改会更有意义，因为预测结果是上层神经元与权重乘积求和的，因为1678 对应的节点更亮，那么增大他们之间的权重值会更有意义。同样，如果如果我们更改节点的值，那么1，6，7，9对应的节点更应该增大，但现在我们无法更改节点值，只能通过更改权重和偏置的值来修改最终的计算结果。</p>
<p>这只是当只有一个输入的时候，输出结果告诉我们它对上个节点权重值变化的诉求，以这个例子为例，就代表<br>当输入一个手写数字2 的时候，为了使输出结果更接近为2，结果神经元要求上一个隐藏层中 第 1，6，7，9对应的节点的权重应该更大，那么当吧全部训练数据输入进来的时候，所有的输出结果对上一个神经元 权重的诉求就都可以获取到了，那么将全部的诉求求和求均，就得到整个样本对该模型 第二个隐藏层 权重变化的诉求。</p>
<h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><p>当学习模型尚未训练好，它给出的结果可以说是相当随机的，那么有必要告诉模型，当前的输出结果与预期结果偏差有多大。 这里便引申出损失函数的概念。</p>
<blockquote>
<p>损失函数（loss function）是用来估量模型的预测值f(x)与真实值Y不一致的程度，它是一个非负实数值函数，通常使用L(Y,f(x))来表示，损失函数越小，模型稳健性越好。</p>
</blockquote>
<p>在机器学习里 我们的损失函数一般是 预测结果和期望结果的平方差之和。<br>我们训练模型，就是为了是损失函数最小。<br>机器学习的损失函数可以表示为【注3】<br><img src="/media/15285284715958.jpg" alt="-w233"></p>
<blockquote>
<p>参数解释：<br>$a^j$：机器学习预测出的结果值<br>$b^j$： 目标期望值<br>$C_0$： 表示输入一个样本的损失值</p>
</blockquote>
<p>其中 $a^j$ 又可以表示 上一层神经元与权重和偏置的加权和，我们记为z，对z进行sigmoid压缩得到的结果。</p>
<p>用公式可以表述如下：<br><img src="/media/15285287793871.jpg" alt="-w200"></p>
<p><img src="/media/15285287553501.jpg" alt="-w712"></p>
<p>那么 可以看到 最终的损失值$C_0$ 可以表示为<br><img src="/media/15285288771325.jpg" alt="-w222"> </p>
<h3 id="反向传播算法"><a href="#反向传播算法" class="headerlink" title="反向传播算法"></a>反向传播算法</h3><h4 id="正向传播过程"><a href="#正向传播过程" class="headerlink" title="正向传播过程"></a>正向传播过程</h4><p>当我们输入随机的一组权重和偏置，以及一张手写数字数组之后，将其按照求和公式求和，可得到一组预测值。<br>这叫正向传播</p>
<blockquote>
<p>正向传播： 根据输入的一组数据，计算出输出值</p>
</blockquote>
<h4 id="反向传播-1"><a href="#反向传播-1" class="headerlink" title="反向传播"></a>反向传播</h4><blockquote>
<p>概念： 当计算出预测值之后，因为它必定跟我们的期望结果有偏差，所以就需要将偏差值计算出来，将偏差反向传播，计算每个权重的偏导值，然后以一定的步长更新权重，减小误差，这叫反向传播。</p>
</blockquote>
<p>上面说过，我们判断上个神经元层与输出结果的神经元之间的权重变化，他们不仅与当前计算结果和预期结果的偏差相关（表现在数学上，就是输出向量与预期向量$y = [0,0,1,0,0,0,0,0,0]$ 之间的求和平均数），还与当前神经元的数值相关。</p>
<p>对于上文中 我们说过的损失函数C，机器学习的目的就是通过改变对应的偏置b和权重w 使该函数最小，那么我们只需要求出 损失函数对每一个偏置和每一个权重的偏导数即可，知道了偏导数，我们就知道权重应该以什么样的方式，以多大的数量，增加还是减少，来影响最终的预测结果从而是损失函数降低到最小。一般的处理是，算出权重的梯度值之后，如果梯度为正，就意味着<a href="https://zh.wikipedia.org/wiki/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%B3%95" target="_blank" rel="noopener">这里涉及到梯度下降算法的一些知识，可以详细的看一下梯度下降的维基百科，讲的很好</a></p>
<p>剩下的就是求偏导数的知识了，$C_0$ 对$ w_{l}^j$ 的敏感度，也就是偏导数，根据链式法则，可以求得为：<br><img src="/media/15285295752254.jpg" alt="-w341"></p>
<p>其中 每一项，抛去数学含义，它都是代表了一定意义的</p>
<ol>
<li>$C_0$ 对$a_j^{L}$ 的偏导数： 因为平方差函数（损失函数c0）的偏导数斜率一般为正，所以该函数意味着 目标函数与预测函数之间的差距越大，偏置w的改变对该偏差值的影响就越大，与上文所讲的吻合，就是预测值和期望值之间的差距，也会对权重的改变产生影响。偏差越大的，他们的权重改变对偏差值的影响会更大。（就是改变这些偏差大的神经元他们链接的权重会更有性价比一些）</li>
<li>a对z求导：就是你所选的非线性激活函数对z的偏导数</li>
<li>$z^{L}<em>j$对$w</em>{jk}^{L}$ 的偏导数： 偏导结果其实是$f(a^{L-1})$ ，意味着 L层的权重$w^{L}_{jk}$ 对偏差值的影响 受到它上一层的神经元的影响。也就是<strong>一同激活的神经元联系在一起</strong>这句话的由来</li>
</ol>
<p><strong>说到这里，我们有必要看一下 $C_0$ 对$a_j^{L-1}$（L1层的神经元）的敏偏导数。这是理解反向传播算法的核心</strong><br>虽然上文说过 我们无法改变$a_{L-1}$层神经元的值，只能改变他们的权重和偏置，但是看一下</p>
<p><img src="/media/15285328187937.jpg" alt="-w200"></p>
<p>$a^(L-1)$ 与$z^{L-1}$ 、$w^{L-1}$、$a^{L-2}$ 、$b^{L-1}$是直接相关联的，那么如果知道<br>$C_0$ 对$a_j^{L-1}$的偏导数，那么反过来用求导公式<br><img src="/media/15285338339984.jpg" alt="-w300"></p>
<p>（将公式中的L 替换为L-1，同时左边的移动到右边，也就知道了代价函数对之前偏置和权重的偏导数了。<br>对上一层神经元的的偏导数：<br><img src="/media/15285292224981.jpg" alt="-w419"></p>
<p>这里也可以看出，上一层神经元对代价函数的影响是同时通过下一层神经元的共同作用而影响的（因为偏导数是下一层神经元的偏导数乘积之和 ）<br> <img src="/media/15285304237096.jpg" alt="-w350"></p>
<p>将上式展开，可得偏差函数对L层每一个权重的偏导数为：</p>
<p><img src="/media/15285333463546.jpg" alt="-w400"></p>
<p>当求出$w_jk^{(L)}$的偏导数，下一步只需要采用合适的最优化方法，更新该偏导数的值，就可以使误差逐步减小。</p>
<p>关于反向传播算法的具体例子，可以参考<a href="https://www.cnblogs.com/charlotte77/p/5629865.html" target="_blank" rel="noopener">这篇博客</a>，以具体的例子展示了反向传播的过程中 权重值是如何变化的。</p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://wenyiqingnian.xyz/2018/06/08/深度学习1-反向传播/" data-id="cjiih6wyu001phx0ckimroyrr" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    
        <a href="http://wenyiqingnian.xyz/2018/06/08/深度学习1-反向传播/#comments" class="article-comment-link">Comments</a>
    

        </footer>
    </div>
    
</article>



    <article id="post-《现代艺术150年》未影印作品1" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2018/06/02/《现代艺术150年》未影印作品1/">《现代艺术150年》未影印作品1</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2018/06/02/《现代艺术150年》未影印作品1/">
            <time datetime="2018-06-02T14:00:50.000Z" itemprop="datePublished">2018-06-02</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/备忘录/">备忘录</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/备忘录/">备忘录</a>, <a class="tag-link" href="/tags/现代艺术150年/">现代艺术150年</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p>以书中提到的艺术品先后为时序，罗列出书中未影印出的作品。</p>
<h2 id="ZERO"><a href="#ZERO" class="headerlink" title="ZERO"></a>ZERO</h2><p>1.Equivalent VIII  等价物 8 1966 （ Carl Andre 卡尔·安德烈）<br> <a href="http://www.tate.org.uk/art/artworks/andre-equivalent-viii-t01534" target="_blank" rel="noopener">http://www.tate.org.uk/art/artworks/andre-equivalent-viii-t01534</a><br><img src="/media/15280367296629.jpg" alt=""></p>
<p>2.Puppy 小狗 1992 （Jeff Koons，杰夫·昆斯）<br> <a href="https://www.guggenheim.org/artwork/48" target="_blank" rel="noopener">https://www.guggenheim.org/artwork/48</a></p>
<p><img src="/media/15280367669284.jpg" alt=""></p>
<h2 id="ONE"><a href="#ONE" class="headerlink" title="ONE"></a>ONE</h2><p>3.Fountain 泉  1917 （Marcel Duchamp, 马塞尔·杜尚）<br><a href="https://en.wikipedia.org/wiki/Fountain_(Duchamp)" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Fountain_(Duchamp)</a></p>
<p><img src="/media/15280368038504.jpg" alt=""></p>
<h2 id="TWO"><a href="#TWO" class="headerlink" title="TWO"></a>TWO</h2><p>4.睡莲  Reflections of Clouds on the Water-Lily Pond，1920 （Claude Monet  克劳德·莫奈）<br><a href="https://en.wikipedia.org/wiki/Water_Lilies_(Monet_series)" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Water_Lilies_(Monet_series)</a><br><img src="/media/15280368205608.jpg" alt=""></p>
<p>5.The Dance Class (La Classe de Danse) 舞蹈课 1874（Edgar Degas 埃德加·德加）<br><a href="https://en.wikipedia.org/wiki/The_Ballet_Class_(Degas,_Mus%C3%A9e_d%27Orsay)" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/The_Ballet_Class_(Degas,_Mus%C3%A9e_d%27Orsay)</a></p>
<p><img src="/media/15280368314302.jpg" alt=""></p>
<p>6.Hoar Frost, the Old Road to Ennery 白霜，通往埃纳里的老路  1873（Camille Pissarro , 米耶·毕沙罗）<br><a href="https://artbookannex.com/tag/ennery/" target="_blank" rel="noopener">https://artbookannex.com/tag/ennery/</a><br><img src="/media/15280368390516.jpg" alt=""></p>
<p>7.The Raft of the Medusa 美杜莎之筏 1818-1819（Théodore Géricault, 泰奥多尔·席里柯）<br><a href="https://en.wikipedia.org/wiki/The_Raft_of_the_Medusa" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/The_Raft_of_the_Medusa</a><br><img src="/media/15292171752937.jpg" alt=""></p>
<p>8.Liberty Leading the People 自由引导人民 1830 （Eugène Delacroix, 欧仁·德拉克罗瓦）<br><a href="https://en.wikipedia.org/wiki/Liberty_Leading_the_People" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Liberty_Leading_the_People</a></p>
<p><img src="/media/15280368550582.jpg" alt=""></p>
<p>9.L’Origine du monde (“The Origin of the World”) 世界的起源 1866 （Gustave Courbet, 古斯塔夫·库尔贝 ）<br><a href="https://en.wikipedia.org/wiki/L%27Origine_du_monde" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/L%27Origine_du_monde</a></p>
<p><img src="/media/15280368669003.jpg" alt=""></p>
<p>10.The Absinthe Drinker (French: Le Buveur d’absinthe)  喝苦艾酒的人 1859 （Édouard Manet, 爱德华·马奈）<a href="https://en.wikipedia.org/wiki/The_Absinthe_Drinker_(Manet_painting)" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/The_Absinthe_Drinker_(Manet_painting)</a><br><img src="/media/15280368750452.jpg" alt=""></p>
<p>11.Le Déjeuner sur l’herbe (English: The Luncheon on the Grass)  草地上的午餐 1863 （Édouard Manet, 爱德华·马奈）<br><a href="https://en.wikipedia.org/wiki/Le_D%C3%A9jeuner_sur_l%E2%80%99herbe" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Le_D%C3%A9jeuner_sur_l%E2%80%99herbe</a><br><img src="/media/15280368815725.jpg" alt=""></p>
<p>12.Olympia 奥林匹亚 1863 （Édouard Manet, 爱德华·马奈）<br><a href="https://en.wikipedia.org/wiki/Olympia_(Manet)" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Olympia_(Manet)</a></p>
<p><img src="/media/15280368890602.jpg" alt=""></p>
<h2 id="THREE"><a href="#THREE" class="headerlink" title="THREE"></a>THREE</h2><p>13.Impression, Sunrise (French: Impression, soleil levant) 1872（Claude Monet  克劳德·莫奈）<br> <a href="https://en.wikipedia.org/wiki/Impression,_Sunrise" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Impression,_Sunrise</a><br><img src="/media/15280368943475.jpg" alt=""></p>
<p>14.A Modern Olympia 现代奥林匹亚 1870（Paul Cézanne, 保罗·塞尚）<br><a href="http://www.paulcezanne.org/a-modern-olympia.jsp#prettyPhoto" target="_blank" rel="noopener">http://www.paulcezanne.org/a-modern-olympia.jsp#prettyPhoto</a></p>
<p><img src="/media/15280368994531.jpg" alt=""></p>
<p>15.Bain à la Grenouillère 青蛙塘 1869 （Claude Monet  克劳德·莫奈）<br><a href="https://en.wikipedia.org/wiki/Bain_%C3%A0_la_Grenouill%C3%A8re" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Bain_%C3%A0_la_Grenouill%C3%A8re</a></p>
<p><img src="/media/15280369066710.jpg" alt=""></p>
<p>16.La Grenouillère 青蛙塘 1869 （Pierre-Auguste Renoir, 皮埃尔-奥古斯特·雷诺阿）<br><a href="https://en.wikipedia.org/wiki/Pierre-Auguste_Renoir" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Pierre-Auguste_Renoir</a><br><img src="/media/15280369102094.jpg" alt=""></p>
<p>17.Rain, Steam and Speed – The Great Western Railway  雨、蒸汽和速度 1844 （ J. M. W. Turner, J.M.W 特纳）<br><a href="https://en.wikipedia.org/wiki/Rain,_Steam_and_Speed_%E2%80%93_The_Great_Western_Railway" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Rain,_Steam_and_Speed_%E2%80%93_The_Great_Western_Railway</a></p>
<p><img src="/media/15292172977610.jpg" alt=""></p>
<p>18.The Thames below Westminster 威斯敏斯特下的泰晤士河 1871 （Claude Monet  克劳德·莫奈）<br><a href="https://artuk.org/discover/artworks/the-thames-below-westminster-115865" target="_blank" rel="noopener">https://artuk.org/discover/artworks/the-thames-below-westminster-115865</a></p>
<p><img src="/media/15280369265797.jpg" alt=""></p>
<p>19.神奈川沖浪裏  The Great Wave off Kanagawa 神奈川巨浪  1829-1833 （葛飾北斎，Katsushika Hokusai, 葛饰北斋）<br><a href="https://en.wikipedia.org/wiki/The_Great_Wave_off_Kanagawa" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/The_Great_Wave_off_Kanagawa</a><br><img src="/media/15280369875264.jpg" alt=""></p>
<p>20.大津駅 Station of Otsu 大津站 1840（安藤 広重, Ando Hiroshige, 安藤广重（后改名 歌川 広重,  Utagawa Hiroshige,  歌川广重））<br><a href="https://www.metmuseum.org/toah/works-of-art/JP804/" target="_blank" rel="noopener">https://www.metmuseum.org/toah/works-of-art/JP804/</a><br><img src="/media/15280369927683.jpg" alt=""></p>
<p>21.A Carriage at The Races 赛马场上的马车 1870 （Edgar Degas 埃德加·德加）<br><a href="https://www.wikiart.org/en/edgar-degas/a-carriage-at-the-races-1872" target="_blank" rel="noopener">https://www.wikiart.org/en/edgar-degas/a-carriage-at-the-races-1872</a><br><img src="/media/15280369989475.jpg" alt=""></p>
<h2 id="FOUR"><a href="#FOUR" class="headerlink" title="FOUR"></a>FOUR</h2><p>22.The Potato Eaters 吃土豆的人 1885（Vincent Willem van Gogh, 文森特·梵高）<br><a href="https://en.wikipedia.org/wiki/The_Potato_Eaters" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/The_Potato_Eaters</a><br><img src="/media/15280370515155.jpg" alt=""></p>
<p>23.The Yellow House 黄房子 1888 （Vincent Willem van Gogh, 文森特·梵高）<br><a href="https://en.wikipedia.org/wiki/The_Yellow_House" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/The_Yellow_House</a><br><img src="/media/15280373427589.jpg" alt=""></p>
<p>24.Still Life With a Plate of Onions 静物：一盘洋葱  1889 （Vincent Willem van Gogh, 文森特·梵高）<br><a href="https://commons.wikimedia.org/wiki/File:Still_life_with_a_plate_of_onions.jpg" target="_blank" rel="noopener">https://commons.wikimedia.org/wiki/File:Still_life_with_a_plate_of_onions.jpg</a><br><img src="/media/15280373580005.jpg" alt=""></p>
<p>25.The Sower 播种者 1888（Vincent Willem van Gogh, 文森特·梵高）<br><a href="https://en.wikipedia.org/wiki/Vincent_van_Gogh#/media/File:The_Sower.jpg" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Vincent_van_Gogh#/media/File:The_Sower.jpg</a><br><img src="/media/15280373715966.jpg" alt=""></p>
<p>26.The Night Café 夜间咖啡馆 1888（Vincent Willem van Gogh, 文森特·梵高）<br><a href="https://en.wikipedia.org/wiki/The_Night_Caf%C3%A9" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/The_Night_Caf%C3%A9</a></p>
<p><img src="/media/15280373791394.jpg" alt=""></p>
<p>27.Sunflowers 向日葵 1888（Vincent Willem van Gogh, 文森特·梵高）<br><a href="https://en.wikipedia.org/wiki/Sunflowers_(Van_Gogh_series)" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Sunflowers_(Van_Gogh_series)</a></p>
<p><img src="/media/15280373867451.jpg" alt=""></p>
<p>28.Starry Night Over the Rhône 满天星斗下的罗纳河 1888 （Vincent Willem van Gogh, 文森特·梵高）<br><a href="https://en.wikipedia.org/wiki/Starry_Night_Over_the_Rh%C3%B4ne" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Starry_Night_Over_the_Rh%C3%B4ne</a><br><img src="/media/15280373993252.jpg" alt=""></p>
<p>29.Bedroom in Arles 寝室 1888（Vincent Willem van Gogh, 文森特·梵高）<br><a href="https://en.wikipedia.org/wiki/Bedroom_in_Arles" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Bedroom_in_Arles</a><br><img src="/media/15280374505879.jpg" alt=""></p>
<p>30.The Scream 呐喊 1893 （Edvard Munch, 爱德华·蒙克）<br><a href="https://en.wikipedia.org/wiki/The_Scream" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/The_Scream</a></p>
<p><img src="/media/15280374589455.jpg" alt=""></p>
<p>31.Study after Velázquez’s Portrait of Pope Innocent X 临摹委拉斯开兹的《教皇英诺森十世肖像》1953（Francis Bacon, 弗朗西斯·培根）<br><a href="https://en.wikipedia.org/wiki/Study_after_Vel%C3%A1zquez%27s_Portrait_of_Pope_Innocent_X" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Study_after_Vel%C3%A1zquez%27s_Portrait_of_Pope_Innocent_X</a></p>
<p><img src="/media/15280374976202.jpg" alt=""></p>
<p>32.Homage to Van Gogh 向梵高致敬 1960 （Francis Bacon, 弗朗西斯·培根）<br><a href="https://www.artimage.org.uk/3087/francis-bacon/homage-to-van-gogh--1960" target="_blank" rel="noopener">https://www.artimage.org.uk/3087/francis-bacon/homage-to-van-gogh--1960</a><br><img src="/media/15280375078516.jpg" alt=""></p>
<p>33.Painter on the Road to Tarascon, August 1888 (destroyed by fire in the Second World War) 去往塔拉斯孔路上的画家 1888  （Vincent Willem van Gogh, 文森特·梵高）<br><a href="https://en.wikipedia.org/wiki/Vincent_van_Gogh#/media/File:Vincent_Van_Gogh_0013.jpg" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Vincent_van_Gogh#/media/File:Vincent_Van_Gogh_0013.jpg</a></p>
<p><img src="/media/15280375183706.jpg" alt=""></p>
<p>34.Vision after the Sermon (Jacob Wrestling with the Angel) 布道后的幻象（雅各与天使搏斗） 1888（Paul Gauguin,  保罗·高更）<br><a href="https://en.wikipedia.org/wiki/Vision_After_the_Sermon" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Vision_After_the_Sermon</a><br><img src="/media/15280375447688.jpg" alt=""></p>
<p>35.No te aha oe riri (Why Are You Angry?), 你为何生气 1896（Paul Gauguin,  保罗·高更）<br><a href="http://www.artic.edu/aic/collections/artwork/16496" target="_blank" rel="noopener">http://www.artic.edu/aic/collections/artwork/16496</a></p>
<p><img src="/media/15280375640354.jpg" alt=""></p>
<p>36.Bathers at Asnières (French: Une Baignade, Asnières)  阿尼埃尔的浴场 1884（Georges Seurat, 乔治·修拉）<br><a href="https://en.wikipedia.org/wiki/Bathers_at_Asni%C3%A8res" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Bathers_at_Asni%C3%A8res</a><br><img src="/media/15280375818140.jpg" alt=""></p>
<p>37.A Sunday Afternoon on the Island of La Grande Jatte 大碗岛的星期天下午 1884-1886（Georges Seurat, 乔治·修拉）<br><a href="https://en.wikipedia.org/wiki/A_Sunday_Afternoon_on_the_Island_of_La_Grande_Jatte" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/A_Sunday_Afternoon_on_the_Island_of_La_Grande_Jatte</a></p>
<p><img src="/media/15280375999874.jpg" alt=""></p>
<h2 id="FIVE"><a href="#FIVE" class="headerlink" title="FIVE"></a>FIVE</h2><p>38.Still Life with Apples and Peaches 有苹果和桃子的静物 1905（Paul Cézanne, 保罗·塞尚）<br><a href="https://www.nga.gov/Collection/art-object-page.45986.html" target="_blank" rel="noopener">https://www.nga.gov/Collection/art-object-page.45986.html</a><br><img src="/media/15280376214294.jpg" alt=""></p>
<p>39.Mont Sainte-Victoire with Large Pine 圣维克多山 1887  （Paul Cézanne, 保罗·塞尚）<br><a href="https://en.wikipedia.org/wiki/Mont_Sainte-Victoire_with_Large_Pine" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Mont_Sainte-Victoire_with_Large_Pine</a></p>
<p><img src="/media/15280376340285.jpg" alt=""></p>
<h2 id="SIX"><a href="#SIX" class="headerlink" title="SIX"></a>SIX</h2><p>40.The Kiss 吻 1907-1908  （Gustav Klimt,  古斯塔夫·克里姆特）<br><a href="https://en.wikipedia.org/wiki/The_Kiss_(Klimt)" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/The_Kiss_(Klimt)</a><br><img src="/media/15280376621257.jpg" alt=""></p>
<p>41.Boats in the Harbour at Collioure 科利乌尔港的船 1905 （André Derain, 安德烈·德兰）<br><img src="/media/15280376701808.jpg" alt=""></p>
<p>42.Restaurant de la Machine at Bougival 布吉瓦尔的餐馆 1905（Maurice de Vlaminck, 莫里斯·德·弗拉芒克）<br><img src="/media/15280376817721.jpg" alt=""></p>
<p>43.Woman with a Hat 戴帽子的妇人 1905 （Henri Matisse, 亨利·马蒂斯）<br><a href="https://en.wikipedia.org/wiki/Woman_with_a_Hat" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Woman_with_a_Hat</a><br><img src="/media/15280377195099.jpg" alt=""></p>
<p>44.Le bonheur de vivre (The Joy of Life) 生之欢乐 1905-1906 （Henri Matisse, 亨利·马蒂斯）<br><a href="https://en.wikipedia.org/wiki/Le_bonheur_de_vivre" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Le_bonheur_de_vivre</a><br><img src="/media/15280377678492.jpg" alt=""></p>
<p>45.Reciproco Amore 互爱 1589-1595（Agostino Carracci, 阿戈斯蒂诺·卡拉奇）</p>
<p><img src="/media/15280378038769.jpg" alt=""></p>
<p>46.Portrait of Gertrude Stein 格特鲁德·斯泰因肖像 1905-1906 （Pablo Picasso, 巴勃罗·毕加索）<br><a href="https://en.wikipedia.org/wiki/Portrait_of_Gertrude_Stein" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Portrait_of_Gertrude_Stein</a><br><img src="/media/15280378295150.jpg" alt=""></p>
<p>47.Les Demoiselles d’Avignon (The Young Ladies of Avignon, and originally titled The Brothel of Avignon)  亚维农少女 1907 （Pablo Picasso, 巴勃罗·毕加索）<br><a href="https://en.wikipedia.org/wiki/Les_Demoiselles_d%27Avignon" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Les_Demoiselles_d%27Avignon</a></p>
<p><img src="/media/15280378595060.jpg" alt=""></p>
<p>48.A Carnival Evening 狂欢节之夜 1886（Henri Rousseau, 亨利·卢梭）</p>
<p><img src="/media/15280378738525.jpg" alt=""></p>
<p>49.The Hungry Lion Throws Itself on the Antelope (Le lion ayant faim se jette sur l’antilope)  饿狮猛扑羚羊 1905（Henri Rousseau, 亨利·卢梭）<br><a href="https://en.wikipedia.org/wiki/The_Hungry_Lion_Throws_Itself_on_the_Antelope" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/The_Hungry_Lion_Throws_Itself_on_the_Antelope</a><br><img src="/media/15280379054759.jpg" alt=""></p>
<ol start="50">
<li>Portrait of a Woman 一个女人的肖像 1895 （Henri Rousseau, 亨利·卢梭）<br><a href="https://commons.wikimedia.org/wiki/File:Henri_Rousseau__Portrait_of_a_Woman_(1895).jpg" target="_blank" rel="noopener">https://commons.wikimedia.org/wiki/File:Henri_Rousseau__Portrait_of_a_Woman_(1895).jpg</a><br><img src="/media/15280379340355.jpg" alt=""></li>
</ol>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://wenyiqingnian.xyz/2018/06/02/《现代艺术150年》未影印作品1/" data-id="cjiih6wyn001ahx0chjh8q2ug" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    
        <a href="http://wenyiqingnian.xyz/2018/06/02/《现代艺术150年》未影印作品1/#comments" class="article-comment-link">Comments</a>
    

        </footer>
    </div>
    
</article>



    <article id="post-从驱动角度理解binder" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2018/06/02/从驱动角度理解binder/">从驱动角度理解binder</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2018/06/02/从驱动角度理解binder/">
            <time datetime="2018-06-02T11:00:50.000Z" itemprop="datePublished">2018-06-02</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/Android/">Android</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/Binder/">Binder</a>, <a class="tag-link" href="/tags/android/">android</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p>一次binder通讯建立的大致流程我们已经了解了，首先是要注册一个serviceManager，server端创建实名binder，向smg注册自己可以提供的服务，以及该实名binder的标签，smg会在svcinfo 链表中缓存该server提供的binder信息，当client需要使用该服务时，只需要向smg中查询服务，获取server端binder的引用就可以了，这其中所有的通讯细节，全部需要binder驱动来实现。<br><img src="/media/15280074117127.jpg" alt=""></p>
<p>本文主要总结一下对binder驱动的理解，了解驱动设计的细节，以及binder通讯过程中驱动主要做了哪些事情。</p>
<h1 id="Binder驱动的定义"><a href="#Binder驱动的定义" class="headerlink" title="Binder驱动的定义"></a>Binder驱动的定义</h1><p>Binder驱动其实是一种特殊的字符型驱动，实现方式类似硬件驱动，工作在内核态。<br>如果了解过linux驱动相关知识，应该知道<code>file_operations</code> 结构体的重要性，linux 使用该结构体访问驱动程序的函数，这个结构体的每一个成员的名字都对应一个内核调用。<br>当用户进程利用设备文件（binder对应的设备文件为/dev/test）对文件进行类似<code>read()/write()</code> 操作的时候，系统调用通过设备文件的主设备号找到对应的设备驱动程序，每一个驱动程序在内核中是由一个<code>cdev</code>结构体描述，<code>cdev</code>结构体中又包括一个成员<code>fops</code>结构体，fops便是<code>file_operations</code>类型的，然后读取<code>file_operations</code> 结构体相应的函数指针，接着把控制权交给该函数的linux 设备驱动程序工作。</p>
<p>下面以binder驱动在内核中的注册流程来分析binder驱动为用户空间定义了哪些可用来调用的函数。</p>
<h2 id="注册Binder"><a href="#注册Binder" class="headerlink" title="注册Binder"></a>注册Binder</h2><p> 在binder驱动源码中（<a href="https://elixir.bootlin.com/linux/v3.11.4/source/drivers/staging/android/binder.c" target="_blank" rel="noopener">kernel/drivers/staging/android/binder.c</a>），通过调用 <code>ret = misc_register(&amp;binder_msicdev)</code>函数完成向内核注册<code>binder</code>驱动，主设备号为10，次设备号动态分配， 其中传入的参数便是一个<code>miscdev</code>的结构体，<br> 它的定义如下</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">miscdevice</span> <span class="title">binder_miscdev</span> = &#123;</span></span><br><span class="line">	.minor = MISC_DYNAMIC_MINOR,</span><br><span class="line">	.name = <span class="string">"binder"</span>,</span><br><span class="line">	.fops = &amp;binder_fops</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到<code>cdev</code>文件中标注了<code>binder</code>设备的设备名”binder”，以及<code>fops</code>结构体，<code>fops</code>结构体如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">binder_fops</span> = &#123;</span></span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .poll = binder_poll,</span><br><span class="line">    .unlocked_ioctl = binder_ioctl,</span><br><span class="line">    .mmap = binder_mmap,</span><br><span class="line">    .open = binder_open,</span><br><span class="line">    .flush = binder_flush,</span><br><span class="line">    .release = binder_release,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到binder驱动为应用层提供了<code>open()</code>,<code>mmap()</code>,<code>poll()</code>,<code>ioctl()</code>等标准的文件操作【注1】，<code>open()</code>负责打开驱动，<code>mmap()</code>负责对<code>binder</code>做内核空间向用户空间的地址映射，<code>ioctl()</code>负责binder协议的通信。</p>
<p>我们知道，用户态的引用程序调用<code>kernel</code>驱动程序是会陷入内核态的，进行系统调用，比如我使用 <code>fd = open(&quot;dev/binder&quot;,O_RDWR)</code>，开打开<code>binder</code>驱动时，它会先通过通过系统调用<code>_open()</code>【注1】，通过主次设备号来找到对应的binder驱动程序，即在 <code>cdev</code> 链表中找到binder驱动对应的<br><code>binder_miscdev</code>，找到 <code>binder_fops</code>结构体，找到<code>open()</code>方法对应的 <code>binder_open()</code>函数，实际执行到的便是<code>binder_open（）</code>函数。那么其他的 比如 mmap(),ioctl()方法，他们的执行流程也是类似的。 参考下图<br><img src="/media/15280103450907.jpg" alt=""></p>
<blockquote>
<p>注释1： open()为用户空间的方法，_open()为系统调用中对应的处理方法。</p>
</blockquote>
<p>打开一次binder通讯，大致分为以下流程：</p>
<ul>
<li>1 调用<code>open()</code>方法打开<code>binder</code>驱动 </li>
<li>2 调用 <code>mmap()</code>方法申请一块内存用来接受通信中的数据，并进行内存映射（binder机制为什么只进行一次拷贝，这里有文章），</li>
<li>3 调用 <code>ioctl()</code>方法 开启binder通讯。<br>这里每一步中具体都做了些什么，下文会有详细描述，但为了更好理解，需要先要搞清楚binder驱动中的几个关键的数据结构和binder的通讯协议。</li>
</ul>
<h2 id="Binder驱动中的结构体"><a href="#Binder驱动中的结构体" class="headerlink" title="Binder驱动中的结构体"></a>Binder驱动中的结构体</h2><p>驱动中的结构体分为两部分，一部分与用户空间共用，这些结构体在Binder通信协议中会用到，被定义在binder.h 头文件中。<br>具体内容见下表：</p>
<table>
<thead>
<tr>
<th>结构体名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>flat_binder_object</td>
<td>binder通讯过程中在client-binderDriver-server之间传递的实际内容，所谓跨进程传递的binder对象，其实传递的就是这个</td>
</tr>
<tr>
<td>binder_wirte_read</td>
<td>存储对binder驱动进行读写操作的数据，当为写的时候，结构体中的write_size非空，当为读的时候，read_size不为空</td>
</tr>
<tr>
<td>binder_version</td>
<td>存储binder的版本号</td>
</tr>
<tr>
<td>transaction_flags</td>
<td>描述一次binder事务的flag，比如是同步还是异步请求</td>
</tr>
<tr>
<td>binder_transcation_data</td>
<td>存储一次事务的数据</td>
</tr>
<tr>
<td>binder_handle_cookie</td>
<td>包含一个句柄和一个cookie</td>
</tr>
<tr>
<td>binder_ptr_cookie</td>
<td>包含一个指针和一个cookie </td>
</tr>
<tr>
<td>binder_pri_dest</td>
<td>暂未用到 </td>
</tr>
<tr>
<td>binder_pri_ptr_cookie</td>
<td>暂未用到</td>
</tr>
</tbody>
</table>
<p>另一部分定义在binder驱动中，是驱动特有的结构体</p>
<table>
<thead>
<tr>
<th>结构体名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>binder_node</td>
<td>描述binder的实体节点，对应一个server，当server通过binder驱动向smg注册时，binder驱动便会在内核中为其创建一个binder实体节点，该实体节点即为binder_node，同时驱动会为server与该节点创建引用关系</td>
</tr>
<tr>
<td>binder_ref</td>
<td>描述对binder实体节点的引用</td>
</tr>
<tr>
<td>binder_buffer</td>
<td>描述binder通讯过程中存储数据的buffer</td>
</tr>
<tr>
<td>binder_proc</td>
<td>描述使用binder的进程</td>
</tr>
<tr>
<td>binder_thread</td>
<td>描述使用binder的线程</td>
</tr>
<tr>
<td>binder_work</td>
<td>描述通信过程中的一项任务</td>
</tr>
<tr>
<td>binder_transcation</td>
<td>描述一次事务的相关信息</td>
</tr>
<tr>
<td>binder_deferred_state</td>
<td>藐视延迟任务</td>
</tr>
<tr>
<td>binder_ref_death</td>
<td>描述binder实体的死亡信息</td>
</tr>
<tr>
<td>binder_transcation_log</td>
<td>debugfs 日志</td>
</tr>
<tr>
<td>binder_transcation_log_entry</td>
<td>debugfs 日志条目</td>
</tr>
</tbody>
</table>
<h2 id="binder协议"><a href="#binder协议" class="headerlink" title="binder协议"></a>binder协议</h2><p>Binder协议 可以分为 <strong>控制协议</strong>和<strong>驱动协议</strong>两部分。</p>
<h3 id="1-控制协议"><a href="#1-控制协议" class="headerlink" title="1.控制协议"></a>1.控制协议</h3><p><strong>控制协议</strong>是进程(client 或server端)通过系统调用（syscall）直接操作binder设备文件，使用<code>ioctl(&#39;dev/binder&#39;)</code>控制binder驱动的协议，该协议包含以下几种命令</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>含义</th>
<th>参数</th>
</tr>
</thead>
<tbody>
<tr>
<td>BINDER_WRITE_READ</td>
<td>该命令想binder写入或者读出数据，参数分为两段，写和度部分，如果write_size不为零，就先将write_buffer中的数据写入binder； 如果read_size不为零，就先从binder中取出数据，写入read_buffer中。 write_consumed和read_consumed 表示操作完成时驱动实际写入和读出的数据个数。</td>
<td>struct binder_wirte_read{ Singned long write_size;Signed long write_consumed;unsigend long write_buffer;signed long read_size;signed long read_consumed;Unsigned long read_buffer}</td>
</tr>
<tr>
<td>BINDER_SET_MAX_THREADS</td>
<td>告知binder驱动接收方(server端)，线程池中最大的线程数。（详见下文 驱动线程管理）</td>
<td>int max_threads</td>
</tr>
<tr>
<td>BINDER_SET_CONEXT_MGR</td>
<td>将当前进程注册为smg，系统同时只可以出现一个smg，只要当前smg没有调用close关闭binder驱动，就不可能有别的进程可以成为smg</td>
<td></td>
</tr>
<tr>
<td>BINDER_THREAD_EXIT</td>
<td>通知binder驱动当前线程退出了，binder会为所有参与binder通信的线程（包括server端线程池中的线程以及client端发出请求的线程）建立相应的数据结构，这些线程在退出时必须显示通知binder释放相应的数据。详见下文 binder驱动的线程控制</td>
</tr>
</tbody>
</table>
<h3 id="2-驱动协议"><a href="#2-驱动协议" class="headerlink" title="2. 驱动协议"></a>2. 驱动协议</h3><p>驱动协议根据具体使用过程，又分为<strong>发送</strong>和<strong>返回</strong>协议。<br><strong>发送协议</strong> 定义在<code>binder.c</code> 中的<br> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> binder_driver_command_protocol</span><br></pre></td></tr></table></figure></p>
<p>，<strong>返回协议 </strong> 定义在<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> binder_driver_return_protocol</span><br></pre></td></tr></table></figure></p>
<p> 根据协议不同，存放的位置也不相同。<br>驱动协议都是封装在控制协议   <code>BINDER_WRITE_READ</code> 命令参数 <code>binder_wirte_read</code> 结构体中，根据发送和返回类型，分别存放在 <code>write_buffer</code>和 <code>read_buffer</code>域所指向的内存空间中。<br><code>binder_write_read</code>结构体的数据结构见下图：<br><img src="/media/15280146752888.jpg" alt=""></p>
<p>它们的数据格式都是命令 + 数据 的格式，多条命令可以连续存放。数据紧接着放在命令的后面，根据命令不同，执行的操作也不同。</p>
<h4 id="发送协议："><a href="#发送协议：" class="headerlink" title="发送协议："></a>发送协议：</h4><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
<th>参数</th>
</tr>
</thead>
<tbody>
<tr>
<td>BC_TRANSCATION</td>
<td>binder事务，client对server的请求</td>
<td>binder_transction_data</td>
</tr>
<tr>
<td>BC_REPLAY</td>
<td>事务的回答，server对client的回复</td>
<td>Binder_transctin_data</td>
</tr>
<tr>
<td>BC_FREE_BUFFER</td>
<td>通知驱动释放buffer</td>
<td>Binder_uinptr_t</td>
</tr>
<tr>
<td>BC_ACQUIRE</td>
<td>强引用计数+1</td>
<td>_u32</td>
</tr>
<tr>
<td>BC_RELEASE</td>
<td>强引用计数-1</td>
<td>_u32</td>
</tr>
<tr>
<td>BC_INCREFS</td>
<td>弱引用计数+1</td>
<td>_u32</td>
</tr>
<tr>
<td>BC_DECREFS</td>
<td>弱引用计数-1</td>
<td>_u32</td>
</tr>
<tr>
<td>BC_ACQUIRE_DODE</td>
<td>acquire指令的回复</td>
<td>Binder_ptr_cookie</td>
</tr>
<tr>
<td>BC_INCREFS_DONE</td>
<td>increfs指令的回复</td>
<td>Binder_prt_cookie</td>
</tr>
<tr>
<td>BC_ENTER_LOOPER</td>
<td>通知驱动主线程ready</td>
<td>Void</td>
</tr>
<tr>
<td>BC_REGISTER_LOOPER</td>
<td>通知驱动子线程ready</td>
<td>Void</td>
</tr>
<tr>
<td>BC_EXIT_LOOPER</td>
<td>通知驱动线程已退出</td>
<td>Void</td>
</tr>
<tr>
<td>BC_REQUEST_DEATH_NOTIFICATION</td>
<td>请求接受死亡通知</td>
<td>Binder_handle_cookie</td>
</tr>
<tr>
<td>BC_CLEAR_DEATH_NOTIFICATION</td>
<td>去除接受死亡通知</td>
<td>Binder_handle_cookie</td>
</tr>
<tr>
<td>BC_DEAD_BINDER_DONE</td>
<td>已经处理完死亡通知</td>
<td>Binder_uinptr_t</td>
</tr>
<tr>
<td>BC_ATTEMPT_ACQUIRE</td>
<td>暂未实现</td>
<td>-</td>
</tr>
<tr>
<td>BC_ACQUIRE_RESULT</td>
<td>暂为实现</td>
<td>-</td>
</tr>
</tbody>
</table>
<h4 id="返回协议："><a href="#返回协议：" class="headerlink" title="返回协议："></a>返回协议：</h4><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
<th>参数</th>
</tr>
</thead>
<tbody>
<tr>
<td>BR_OK</td>
<td>操作完成</td>
<td>void</td>
</tr>
<tr>
<td>BR_NOOP</td>
<td>操作完成</td>
<td>void</td>
</tr>
<tr>
<td>BR_ERROR</td>
<td>发生错误</td>
<td>_s32</td>
</tr>
<tr>
<td>BR_TRANSCATION</td>
<td>进程收到一次binder请求 （server端）</td>
<td>binder_transcation_data</td>
</tr>
<tr>
<td>BR_REPLAY</td>
<td>进程收到binder请求的回复（client）</td>
<td>binder_transtaction_data</td>
</tr>
<tr>
<td>BR_TRANSCATION_COMPLETED</td>
<td>驱动对于接收请求的确认回复</td>
<td>void</td>
</tr>
<tr>
<td>BR_FAILED_REPLAY</td>
<td>告知发送方 通信目标不存在</td>
<td>void</td>
</tr>
<tr>
<td>BR_SPAWN_LOOPER</td>
<td>通server端创建一个新的进程</td>
<td>void</td>
</tr>
<tr>
<td>BR_ACQUIRE</td>
<td>强用用计数+1</td>
<td>Binder_prt_cookie</td>
</tr>
<tr>
<td>BR_RELEASE</td>
<td>强引用计数-1</td>
<td>Binder_prt_cookie</td>
</tr>
<tr>
<td>BR_INCREFS</td>
<td>弱引用计数+1</td>
<td>Binder_prt_cookie</td>
</tr>
<tr>
<td>BR_DECREFS</td>
<td>弱引用计数-1</td>
<td>Binder_prt_cookie</td>
</tr>
<tr>
<td>BR_DEAD_BINDER</td>
<td>发送死亡通知</td>
<td>binder_uintptr_t</td>
</tr>
<tr>
<td>BR_CLEAR_DEATH_NOTIFICATION_DONE</td>
<td>清除死亡通知完成</td>
<td>binder_uintptr_t</td>
</tr>
<tr>
<td>BR_DEAD_REPLAY</td>
<td>改制发送方对方已死亡</td>
<td>void</td>
</tr>
<tr>
<td>BR_ATTEMPT_ACQUIRE</td>
<td>暂未实现</td>
<td>-</td>
</tr>
<tr>
<td>BR_ACQUIRE_RESULT</td>
<td>暂为实现</td>
<td>-</td>
</tr>
<tr>
<td>BR_FINISHED</td>
<td>暂未实现</td>
<td>-</td>
</tr>
</tbody>
</table>
<h4 id="binder-请求的过程"><a href="#binder-请求的过程" class="headerlink" title="binder 请求的过程"></a>binder 请求的过程</h4><p>见下图：</p>
<p><img src="/media/15280173877321.jpg" alt=""></p>
<p>通过上面的Binder协议的说明中我们看到，Binder协议的通信过程中，不仅仅是发送请求和接受数据这些命令。同时包括了对于引用计数的管理和对于死亡通知的管理（告知一方，通讯的另外一方已经死亡）等功能。</p>
<p>这些功能的通信过程和上面这幅图是类似的：一方发送<code>BC_XXX</code>，然后由驱动控制通信过程，接着发送对应的<code>BR_XXX</code>命令给通信的另外一方。因为这种相似性，对于这些内容就不再赘述了。</p>
<h3 id="由驱动角度理解-Binder通讯建立的过程"><a href="#由驱动角度理解-Binder通讯建立的过程" class="headerlink" title="由驱动角度理解 Binder通讯建立的过程"></a>由驱动角度理解 Binder通讯建立的过程</h3><h4 id="1-打开驱动（open-“dev-binder”-）"><a href="#1-打开驱动（open-“dev-binder”-）" class="headerlink" title="1 打开驱动（open(“dev/binder”)）"></a>1 打开驱动（open(“dev/binder”)）</h4><p>任何进程在使用Binder之前，都需要先通过<code>open(&quot;/dev/binder&quot;)</code>打开Binder设备。上文已经提到，用户空间的<code>open</code>系统调用对应了驱动中的<code>binder_open</code>函数。在这个函数，Binder驱动会为调用的进程做一些初始化工作。<code>binder_open</code>函数代码如下所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_open</span><span class="params">(struct inode *nodp, struct file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span>;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 创建进程对应的binder_proc对象 </span></span><br><span class="line">	proc = kzalloc(<span class="keyword">sizeof</span>(*proc), GFP_KERNEL); </span><br><span class="line">	<span class="keyword">if</span> (proc == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	get_task_struct(current);</span><br><span class="line">	proc-&gt;tsk = current;</span><br><span class="line">	<span class="comment">// 初始化binder_proc</span></span><br><span class="line">	INIT_LIST_HEAD(&amp;proc-&gt;todo);</span><br><span class="line">	init_waitqueue_head(&amp;proc-&gt;wait);</span><br><span class="line">	proc-&gt;default_priority = task_nice(current);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 锁保护</span></span><br><span class="line">	binder_lock(__func__);</span><br><span class="line"></span><br><span class="line">	binder_stats_created(BINDER_STAT_PROC);</span><br><span class="line">	<span class="comment">// 添加到全局列表binder_procs中</span></span><br><span class="line">	hlist_add_head(&amp;proc-&gt;proc_node, &amp;binder_procs);</span><br><span class="line">	proc-&gt;pid = current-&gt;group_leader-&gt;pid;</span><br><span class="line">	INIT_LIST_HEAD(&amp;proc-&gt;delivered_death);</span><br><span class="line">	filp-&gt;private_data = proc;</span><br><span class="line"></span><br><span class="line">	binder_unlock(__func__);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在打开binder驱动时，<code>binder_procs</code>会将所有打开binder驱动的进程加入到该列表中，上文中提到binder中的几个主要结构体，其实都是通过<code>binder_procs</code>结构体链接在一起的。</p>
<p><img src="/media/15280179417192.jpg" alt=""></p>
<h4 id="2-创建内存空间并实现用户空间-内核空间的映射（mmap）"><a href="#2-创建内存空间并实现用户空间-内核空间的映射（mmap）" class="headerlink" title="2. 创建内存空间并实现用户空间 内核空间的映射（mmap）"></a>2. 创建内存空间并实现用户空间 内核空间的映射（mmap）</h4><p>打开binder驱动之后，进程会通过<code>mmap()</code>方法进行内存空间的映射。 </p>
<p>上文描述过，<code>mmap()</code>对应的<code>binder_mmap()</code>函数，它会先申请一份物理内存，默认<code>PAGE_SIZE</code> 是4k，然后会<strong>同时在 用户空间和 内核空间</strong>映射该物理内存。当client 发送数据给server的时候，只需要将client端的数据，拷贝到server端所指向的 内核中的地址即可，因为server的用户空间和binder对应的内核空间映射的是同一份物理内存，当server取数据的时候，就无需再从内科中拷贝了，server可以直接使用。</p>
<p><img src="/media/15280184528253.jpg" alt=""></p>
<p>这幅图的说明如下：</p>
<p>Server在启动之后，对<code>/dev/binder</code>设备调用<code>mmap</code><br>内核中的<code>binder_mmap</code>函数进行对应的处理：申请一块物理内存，然后在用户空间和内核空间同时进行映射</p>
<p>Client通过<code>BINDER_WRITE_READ</code>命令发送请求，这个请求将先到驱动中，同时需要将数据从<code>Client</code>进程的用户空间拷贝到内核空间<br>驱动通过<code>BR_TRANSACTION</code>通知Server有人发出请求，Server进行处理。由于这块内存也在用户空间进行了映射，因此Server进程的代码可以直接访问</p>
<h4 id="3-内存管理（非重点）"><a href="#3-内存管理（非重点）" class="headerlink" title="3. 内存管理（非重点）"></a>3. 内存管理（非重点）</h4><p>上文中，我们看到<code>binder_mmap</code>的时候，会申请一个<code>PAGE_SIZE</code>通常是4K的内存。而实际使用过程中，一个<code>PAGE_SIZE</code>的大小通常是不够的。</p>
<p>在驱动中，会根据实际的使用情况进行内存的分配。有内存的分配，当然也需要内存的释放。这里我们就来看看Binder驱动中是如何进行内存的管理的。</p>
<p>首先，我们还是从一次IPC请求说起。</p>
<p>当一个Client想要对Server发出请求时，它首先将请求发送到Binder设备上，由Binder驱动根据请求的信息找到对应的目标节点，然后将请求数据传递过去。</p>
<p>进程通过ioctl系统调用来发出请求：<code>ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr)</code></p>
<p>PS：这行代码来自于Framework层的<code>IPCThreadState</code>类。在后文中，我们将看到，<code>IPCThreadState</code>类专门负责与驱动进行通信。</p>
<p>这里的<code>mProcess-&gt;mDriverFD</code>对应了打开Binder设备时的<code>fd</code>。<code>BINDER_WRITE_READ</code>对应了具体要做的操作码，这个操作码将由Binder驱动解析。<code>bwr</code>存储了请求数据，其类型是<code>binder_write_read</code>。</p>
<p><code>binder_write_read</code>其实是一个相对外层的数据结构，其内部会包含一个<code>binder_transaction_data</code>结构的数据。<code>binder_transaction_data</code>包含了发出请求者的标识，请求的目标对象以及请求所需要的参数。它们的关系如下图所示：</p>
<p><img src="/media/15280191293122.jpg" alt=""></p>
<p><code>binder_ioctl</code>函数对应了<code>ioctl</code>系统调用的处理。这个函数的逻辑比较简单，就是根据<code>ioctl</code>的命令来确定进一步处理的逻辑，具体如下:</p>
<p>如果命令是<code>BINDER_WRITE_READ</code>，并且<br>如果 <code>bwr.write_size &gt; 0</code>，则调用<code>binder_thread_write</code><br>该方法用于处理Binder协议中的请求码。当<code>binder_buffer</code>存在数据，binder线程的写操作循环执行。对于请求码为<code>BC_TRANSACTION</code>或<code>BC_REPLY</code>时，会执行<code>binder_transaction</code>()方法，这是最为频繁的操作。 对于其他命令则不同。</p>
<p>如果 <code>bwr.read_size &gt; 0</code>，则调用<code>binder_thread_read</code>，该方法用以处理响应过程，根据不同的<code>binder_work-&gt;type</code>以及不同状态，生成相应的响应码。</p>
<p>如果命令是<code>BINDER_SET_MAX_THREADS</code>，则设置进程的<code>max_threads</code>，即进程支持的最大线程数<br>如果命令是<code>BINDER_SET_CONTEXT_MGR</code>，则设置当前进程为<code>ServiceManager</code>，见下文<br>如果命令是<code>BINDER_THREAD_EXIT</code>，则调用<code>binder_free_thread</code>，释放<code>binder_thread</code><br>如果命令是<code>BINDER_VERSION</code>，则返回当前的Binder版本号<br>这其中，最关键的就是<code>binder_thread_write</code>方法。当Client请求Server的时候，便会发送一个<code>BINDER_WRITE_READ</code>命令，同时框架会将将实际的数据包装好。此时，<code>binder_transaction_data</code>中的code将是<code>BC_TRANSACTION</code>，由此便会调用到<code>binder_transaction</code>方法，这个方法是对一次Binder事务的处理，这其中会调用<code>binder_alloc_buf</code>函数为此次事务申请一个缓存。<br>调用关系见下图<br><img src="/media/15280210111665.jpg" alt=""></p>
<p><code>binder_update_page_range</code>这个函数在上文中，我们已经看到过了。其作用就是：进行内存分配并且完成内存的映射。而<code>binder_alloc_buf</code>函数，正如其名称那样的：完成缓存的分配。</p>
<p>在驱动中，通过<code>binder_buffer</code>结构体描述缓存。一次Binder事务就会对应一个<code>binder_buffer</code>，<br>进程在mmap时，会设定支持的总缓存大小的上限。而进程每当收到<code>BC_TRANSACTION</code>，就会判断已使用缓存加本次申请的和有没有超过上限。如果没有，就考虑进行内存的分配。</p>
<p>进程的空闲缓存记录在<code>binder_proc</code>的<code>free_buffers</code>中，这是一个以红黑树形式存储的结构。每次尝试分配缓存的时候，会从这里面按大小顺序进行查找，找到最接近需要的一块缓存。找到之后，还要对binder_proc的字段进行更新。</p>
<p><code>BC_FREE_BUFFER</code>命令是通知驱动进行内存的释放，<code>binder_free_buf</code>函数是真正实现的逻辑，这个函数与<code>binder_alloc_buf</code>是刚好对应的。在这个函数中，所做的事情包括：</p>
<ul>
<li>重新计算进程的空闲缓存大小</li>
<li>通过<code>binder_update_page_range</code>释放内存</li>
<li>更新<code>binder_proc</code>的<code>buffers</code>，<code>free_buffers</code>，<code>allocated_buffers</code>字段</li>
</ul>
<h4 id="4-通讯过程"><a href="#4-通讯过程" class="headerlink" title="4 通讯过程"></a>4 通讯过程</h4><p><code>BINDER_COMMAND_PROTOCOL</code>：binder请求码，以”BC_“开头，简称BC码，用于从IPC层传递到Binder Driver层；<br><code>BINDER_RETURN_PROTOCOL</code> ：binder响应码，以”BR_“开头，简称BR码，用于从Binder Driver层传递到IPC层；</p>
<p>一次完整的binder通讯流程：<br><img src="/media/15280207692595.jpg" alt=""><strong>Binder IPC通信至少是两个进程的交互</strong>：</p>
<ul>
<li>client进程执行<code>binder_thread_write</code>，<code>thread_write</code>根据<code>BC_XXX</code>命令，生成相应的<code>binder_work</code>；</li>
<li>server进程执行<code>binder_thread_read</code>，<code>thread_read</code>根据<code>binder_work.type</code>类型，生成<code>BR_XXX</code>，发送到用户空间处理。<br><img src="/media/15280214808773.jpg" alt=""></li>
</ul>
<p><code>binder_work.type</code> ：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BINDER_WORK_TRANSACTION <span class="comment">//最常见类型</span></span><br><span class="line">BINDER_WORK_TRANSACTION_COMPLETE</span><br><span class="line">BINDER_WORK_NODE</span><br><span class="line">BINDER_WORK_DEAD_BINDER</span><br><span class="line">BINDER_WORK_DEAD_BINDER_AND_CLEAR</span><br><span class="line">BINDER_WORK_CLEAR_DEATH_NOTIFICATION</span><br></pre></td></tr></table></figure></p>
<p>可以知道，上述通信流程涉及到三种状态码的转换：<br><code>BR_CODE</code> <code>BC_CODE</code>  <code>BW_CODE</code>,<br>他们之间的转换图如下：</p>
<p><img src="/media/15280221155795.jpg" alt=""></p>
<p><img src="/media/15280221222039.jpg" alt=""></p>
<p>图解：(以<code>BC_TRANSACTION</code>为例)</p>
<p>发起端进程：<code>binder_transaction</code>()过程将<code>BC_TRANSACTION</code>转换为<code>BW_TRANSACTION</code>；<br>接收端进程：<code>binder_thread_read</code>()过程，将<code>BW_TRANSACTION</code>转换为<code>BR_TRANSACTION</code>;<br>接收端进程：<code>IPC.execute()</code>过程，处理<code>BR_TRANSACTION</code>命令</p>
<p>以gityuan的一张图来总结binder通信的全过程</p>
<p><img src="/media/15280227943358.jpg" alt=""></p>
<h4 id="5-通讯过程中-binder实体的传递"><a href="#5-通讯过程中-binder实体的传递" class="headerlink" title="5 通讯过程中 binder实体的传递"></a>5 通讯过程中 binder实体的传递</h4><p>Binder机制淡化了进程的边界，使得跨越进程也能够调用到指定服务的方法，其原因是因为Binder机制在底层处理了在进程间的“对象”传递。</p>
<p>在Binder驱动中，并不是真的将对象在进程间来回序列化，而是通过特定的标识来进行对象的传递。Binder驱动中，通过<code>flat_binder_object</code>来描述需要跨越进程传递的对象。其定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">flat_binder_object</span> &#123;</span></span><br><span class="line">	__u32		type;</span><br><span class="line">	__u32		flags;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="keyword">binder_uintptr_t</span>	binder; <span class="comment">/* local object */</span></span><br><span class="line">		__u32			handle;	<span class="comment">/* remote object */</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">binder_uintptr_t</span>	cookie;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这其中，type有如下5种类型。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">	BINDER_TYPE_BINDER	= B_PACK_CHARS(<span class="string">'s'</span>, <span class="string">'b'</span>, <span class="string">'*'</span>, B_TYPE_LARGE),</span><br><span class="line">	BINDER_TYPE_WEAK_BINDER	= B_PACK_CHARS(<span class="string">'w'</span>, <span class="string">'b'</span>, <span class="string">'*'</span>, B_TYPE_LARGE),</span><br><span class="line">	BINDER_TYPE_HANDLE	= B_PACK_CHARS(<span class="string">'s'</span>, <span class="string">'h'</span>, <span class="string">'*'</span>, B_TYPE_LARGE),</span><br><span class="line">	BINDER_TYPE_WEAK_HANDLE	= B_PACK_CHARS(<span class="string">'w'</span>, <span class="string">'h'</span>, <span class="string">'*'</span>, B_TYPE_LARGE),</span><br><span class="line">	BINDER_TYPE_FD		= B_PACK_CHARS(<span class="string">'f'</span>, <span class="string">'d'</span>, <span class="string">'*'</span>, B_TYPE_LARGE),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>当对象传递到Binder驱动中的时候，由驱动来进行翻译和解释，然后传递到接收的进程。</p>
<p>例如当Server把Binder实体传递给Client时，在发送数据流中，<code>flat_binder_object</code>中的type是<code>BINDER_TYPE_BINDER</code>，同时binder字段指向Server进程用户空间地址。但这个地址对于Client进程是没有意义的（Linux中，每个进程的地址空间是互相隔离的），驱动必须对数据流中的<code>flat_binder_object</code>做相应的翻译：将type该成<code>BINDER_TYPE_HANDLE</code>；为这个Binder在接收进程中创建位于内核中的引用并将引用号填入handle中。对于发生数据流中引用类型的Binder也要做同样转换。经过处理后接收进程从数据流中取得的Binder引用才是有效的，才可以将其填入数据包<code>binder_transaction_data</code>的<code>target.handle</code>域，向Binder实体发送请求。</p>
<p>由于每个请求和请求的返回都会经历内核的翻译，因此这个过程从进程的角度来看是完全透明的。进程完全不用感知这个过程，就好像对象真的在进程间来回传递一样。</p>
<h4 id="6-驱动层的线程管理"><a href="#6-驱动层的线程管理" class="headerlink" title="6 驱动层的线程管理"></a>6 驱动层的线程管理</h4><p>上文多次提到，Binder本身是C/S架构。由Server提供服务，被Client使用。既然是C/S架构，就可能存在多个Client会同时访问Server的情况。 在这种情况下，如果Server只有一个线程处理响应，就会导致客户端的请求可能需要排队而导致响应过慢的现象发生。解决这个问题的方法就是引入多线程。</p>
<p>Binder机制的设计从最底层–驱动层，就考虑到了对于多线程的支持。具体内容如下：</p>
<ul>
<li>使用Binder的进程在启动之后，通过<code>BINDER_SET_MAX_THREADS</code>告知驱动其支持的最大线程数量</li>
<li>驱动会对线程进行管理。在<code>binder_proc</code>结构中，这些字段记录了进程中线程的信息：<code>max_threads，requested_threads，requested_threads_started，ready_threads</code></li>
<li><code>binder_thread</code>结构对应了Binder进程中的线程</li>
<li>驱动通过<code>BR_SPAWN_LOOPER</code>命令告知进程需要创建一个新的线程</li>
<li>进程通过<code>BC_ENTER_LOOPER</code>命令告知驱动其主线程已经ready</li>
<li>进程通过<code>BC_REGISTER_LOOPER</code>命令告知驱动其子线程（非主线程）已经ready</li>
<li>进程通过<code>BC_EXIT_LOOPER</code>命令告知驱动其线程将要退出</li>
<li>在线程退出之后，通过<code>BINDER_THREAD_EXIT</code>告知Binder驱动。驱动将对应的<code>binder_thread</code>对象销毁</li>
</ul>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://wenyiqingnian.xyz/2018/06/02/从驱动角度理解binder/" data-id="cjiih6wyq001fhx0ca8yhcd3u" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    
        <a href="http://wenyiqingnian.xyz/2018/06/02/从驱动角度理解binder/#comments" class="article-comment-link">Comments</a>
    

        </footer>
    </div>
    
</article>



    <article id="post-理解Liunx的FD与Inode" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2018/06/02/理解Liunx的FD与Inode/">理解Linux的FD与Inode</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2018/06/02/理解Liunx的FD与Inode/">
            <time datetime="2018-06-02T08:30:15.000Z" itemprop="datePublished">2018-06-02</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/Linux/">Linux</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/linux/">linux</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <h1 id="FD-文件描述符"><a href="#FD-文件描述符" class="headerlink" title="FD 文件描述符"></a>FD 文件描述符</h1><h2 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h2><p>　　Linux 系统中，把一切都看做是文件，当进程打开现有文件或创建新文件时，内核向进程返回一个文件描述符，文件描述符就是内核为了高效管理已被打开的文件所创建的索引，用来指向被打开的文件，所有执行I/O操作的系统调用都会通过文件描述符。</p>
<h2 id="二、文件描述符、文件、进程间的关系"><a href="#二、文件描述符、文件、进程间的关系" class="headerlink" title="二、文件描述符、文件、进程间的关系"></a>二、文件描述符、文件、进程间的关系</h2><h3 id="1-描述："><a href="#1-描述：" class="headerlink" title="1.描述："></a>1.描述：</h3><p>我们可以通过linux的几个基本的I/O操作函数来理解什么是文件操作符。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fd = open(pathname, flags, mode)</span><br><span class="line"><span class="comment">// 返回了该文件的fd</span></span><br><span class="line">rlen = read(fd, buf, count)</span><br><span class="line"><span class="comment">// IO操作均需要传入该文件的fd值</span></span><br><span class="line">wlen = write(fd, buf, count)</span><br><span class="line">status = close(fd)</span><br></pre></td></tr></table></figure>
<p>每当进程用<code>open（）</code>函数打开一个文件，内核便会返回该文件的文件操作符（一个非负的整形值），此后所有对该文件的操作，都会以返回的fd文件操作符为参数。【注1】</p>
<blockquote>
<p>注1： <strong>文件描述符</strong>可以理解为进程文件描述表这个表的<strong>索引</strong>，或者把文件描述表看做一个数组的话，文件描述符可以看做是数组的下标。当需要进行I/O操作的时候，会传入fd作为参数，先从进程文件描述符表查找该fd对应的那个条目，取出对应的那个已经打开的文件的<strong>句柄</strong>，根据文件句柄指向，去系统fd表中查找到该文件指向的<strong>inode</strong>，从而定位到该文件的真正位置，从而进行I/O操作。</p>
</blockquote>
<ul>
<li><p>每个文件描述符会与一个打开的文件相对应</p>
</li>
<li><p>不同的文件描述符也可能指向同一个文件</p>
</li>
<li><p>相同的文件可以被不同的进程打开，也可以在同一个进程被多次打开</p>
</li>
</ul>
<h3 id="2-系统为维护文件描述符，建立了三个表"><a href="#2-系统为维护文件描述符，建立了三个表" class="headerlink" title="2.系统为维护文件描述符，建立了三个表"></a>2.系统为维护文件描述符，建立了三个表</h3><ul>
<li><p>进程级的文件描述符表</p>
</li>
<li><p>系统级的文件描述符表</p>
</li>
<li><p>文件系统的i-node表 (inode 见下文)</p>
</li>
</ul>
<h4 id="进程级别的文件描述表："><a href="#进程级别的文件描述表：" class="headerlink" title="进程级别的文件描述表："></a>进程级别的文件描述表：</h4><p>linux内核会为每一个进程创建一个<code>task_truct</code>结构体来维护进程信息，称之为 进程描述符，该结构体中 指针 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">files</span></span></span><br></pre></td></tr></table></figure></p>
<p>指向一个名称为<code>file_struct</code>的结构体，该结构体即 进程级别的文件描述表。</p>
<p>它的每一个条目记录的是单个文件描述符的相关信息</p>
<ol>
<li>fd控制标志，前内核仅定义了一个，即close-on-exec</li>
<li>文件描述符所打开的文件句柄的引用【注2】</li>
</ol>
<blockquote>
<p>[注释2]：文件句柄这里可以理解为文件名，或者文件的全路径名，因为linux文件系统文件名和文件是独立的，以此与inode区分</p>
</blockquote>
<h4 id="系统级别的文件描述符表"><a href="#系统级别的文件描述符表" class="headerlink" title="系统级别的文件描述符表"></a>系统级别的文件描述符表</h4><p>内核对系统中所有打开的文件维护了一个描述符表，也被称之为 【打开文件表】，表格中的每一项被称之为 【打开文件句柄】，一个【打开文件句柄】 描述了一个打开文件的全部信息。<br>主要包括：</p>
<ol>
<li>当前文件偏移量（调用read()和write()时更新，或使用lseek()直接修改）</li>
<li>打开文件时所使用的状态标识（即，open()的flags参数）</li>
<li>文件访问模式（如调用open()时所设置的只读模式、只写模式或读写模式）</li>
<li>与信号驱动相关的设置</li>
<li>对该文件i-node对象的引用</li>
<li>文件类型（例如：常规文件、套接字或FIFO）和访问权限</li>
<li>一个指针，指向该文件所持有的锁列表</li>
<li>文件的各种属性，包括文件大小以及与不同类型操作相关的时间戳 </li>
</ol>
<h4 id="Inode表"><a href="#Inode表" class="headerlink" title="Inode表"></a>Inode表</h4><p> 每个文件系统会为存储于其上的所有文件(包括目录)维护一个i-node表，单个i-node包含以下信息：</p>
<ol>
<li>文件类型(file type)，可以是常规文件、目录、套接字或FIFO</li>
<li>访问权限</li>
<li>文件锁列表(file locks)</li>
<li>文件大小<br>等等<br>i-node存储在磁盘设备上，内核在内存中维护了一个副本，这里的i-node表为后者。副本除了原有信息，还包括：引用计数(从打开文件描述体)、所在设备号以及一些临时属性，例如文件锁。</li>
</ol>
<p><img src="/media/15279154636960.jpg" alt=""></p>
<blockquote>
<p>注：进程A的fd表中，左边fd0，fd1，fd2… 就是各个文件描述符，它是fd表的索引，fd不是表里那个fd flags！这里不要搞混淆了，fd flags 目前只有一个取值。</p>
</blockquote>
<p>在进程A中，文件描述符1和30都指向了同一个打开的文件句柄（标号23）。这可能是通过调用dup()、dup2()、fcntl()或者对同一个文件多次调用了open()函数而形成的。<br><strong>dup（）</strong>，也称之为<strong>文件描述符复制函数</strong>，在某些场景下非常有用，比如：标准输入/输出重定向。在shell下，完成这个操作非常简单，大部分人都会，但是极少人思考过背后的原理。</p>
<p>大概描述一下需要的几个步骤，以标准输出(文件描述符为1)重定向为例：</p>
<ol>
<li>打开目标文件，返回文件描述符n；</li>
<li>关闭文件描述符1；</li>
<li>调用dup将文件描述符n复制到1；</li>
<li>关闭文件描述符n；</li>
</ol>
<p>进程A的文件描述符2和进程B的文件描述符2都指向了同一个打开的文件句柄（标号73）。这种情形可能是在调用fork()后出现的（即，进程A、B是父子进程关系）【注3】，或者当某进程通过UNIX域套接字将一个打开的文件描述符传递给另一个进程时，也会发生。再者是不同的进程独自去调用open函数打开了同一个文件，此时进程内部的描述符正好分配到与其他进程打开该文件的描述符一样。</p>
<blockquote>
<p>注3： 子进程会继承父进程的文件描述符表，也就是子进程继承父进程打开的文件 这句话的由来。</p>
</blockquote>
<p>此外，进程A的描述符0和进程B的描述符3分别指向不同的打开文件句柄，但这些句柄均指向i-node表的相同条目（1976），换言之，指向同一个文件。发生这种情况是因为每个进程各自对同一个文件发起了open()调用。同一个进程两次打开同一个文件，也会发生类似情况。</p>
<h2 id="三、文件描述符限制"><a href="#三、文件描述符限制" class="headerlink" title="三、文件描述符限制"></a>三、文件描述符限制</h2><p>　　有资源的地方就有战争，“文件描述符”也是一种资源，系统中的每个进程都需要有“文件描述符”才能进行改变世界的宏图霸业。世界需要秩序，于是就有了“文件描述符限制”的规定。</p>
<p>如下表：<br><img src="/media/15279200633321.jpg" alt=""></p>
<p>永久修改用户级限制时有三种设置类型：</p>
<ul>
<li><p>soft 指的是当前系统生效的设置值</p>
</li>
<li><p>hard 指的是系统中所能设定的最大值</p>
</li>
<li><p>“-” 指的是同时设置了 soft 和 hard 的值</p>
</li>
</ul>
<h1 id="Inode-文件节点"><a href="#Inode-文件节点" class="headerlink" title="Inode 文件节点"></a>Inode 文件节点</h1><h2 id="一、inode是什么？"><a href="#一、inode是什么？" class="headerlink" title="一、inode是什么？"></a>一、inode是什么？</h2><p>理解inode，要从文件储存说起。</p>
<p>文件储存在硬盘上，硬盘的最小存储单位叫做”扇区”（Sector）。每个扇区储存512字节（相当于0.5KB）。</p>
<p>操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个”块”（block）。这种由多个扇区组成的”块”，是文件存取的最小单位。”块”的大小，最常见的是4KB，即连续八个 sector组成一个 block。</p>
<p>文件数据都储存在”块”中，那么很显然，我们还必须找到一个地方储存文件的元信息，比如文件的创建者、文件的创建日期、文件的大小等等。这种储存文件元信息的区域就叫做inode，中文译名为”索引节点”。</p>
<p>每一个文件都有对应的inode，里面包含了与该文件有关的一些信息。</p>
<h2 id="二、inode的内容"><a href="#二、inode的内容" class="headerlink" title="二、inode的内容"></a>二、inode的内容</h2><p>inode包含文件的元信息，具体来说有以下内容：</p>
<ul>
<li>文件的字节数</li>
<li>文件拥有者的User ID</li>
<li>文件的Group ID</li>
<li>文件的读、写、执行权限</li>
<li>文件的时间戳，共有三个：ctime指inode上一次变动的时间，mtime指文件内容上一次变动的时间，atime指文件上一次打开的时间。</li>
<li>链接数，即有多少文件名指向这个inode</li>
<li>文件数据block的位置</li>
</ul>
<p>可以用<code>stat</code>命令，查看某个文件的inode信息：<br>　<code>stat 233.txt</code><br>　<img src="/media/15279145480304.jpg" alt=""></p>
<p>总之，除了文件名以外的所有文件信息，都存在inode之中。至于为什么没有文件名，下文会有详细解释。</p>
<h2 id="三、inode的大小"><a href="#三、inode的大小" class="headerlink" title="三、inode的大小"></a>三、inode的大小</h2><p>inode也会消耗硬盘空间，所以硬盘格式化的时候，操作系统自动将硬盘分成两个区域。一个是数据区，存放文件数据；另一个是inode区（inode table），存放inode所包含的信息。</p>
<p>每个inode节点的大小，一般是128字节或256字节。inode节点的总数，在格式化时就给定，一般是每1KB或每2KB就设置一个inode。假定在一块1GB的硬盘中，每个inode节点的大小为128字节，每1KB就设置一个inode，那么inode table的大小就会达到128MB，占整块硬盘的12.8%。</p>
<p>查看每个硬盘分区的inode总数和已经使用的数量，可以使用df命令。</p>
<p>　　<code>df -i</code><br><img src="/media/15279146030394.jpg" alt=""></p>
<p>查看每个inode节点的大小，可以用如下命令：</p>
<p>　<code>sudo dumpe2fs -h /dev/hda | grep &quot;Inode size&quot;</code></p>
<p>由于每个文件都必须有一个inode，因此有可能发生inode已经用光，但是硬盘还未存满的情况。这时，就无法在硬盘上创建新文件。</p>
<h2 id="四、inode号码"><a href="#四、inode号码" class="headerlink" title="四、inode号码"></a>四、inode号码</h2><p>每个inode都有一个号码，操作系统用inode号码来识别不同的文件。</p>
<p>这里值得重复一遍，Unix/Linux系统内部不使用文件名，而使用inode号码来识别文件。对于系统来说，文件名只是inode号码便于识别的别称或者绰号。</p>
<p>表面上，用户通过文件名，打开文件。实际上，系统内部这个过程分成三步：首先，系统找到这个文件名对应的inode号码；其次，通过inode号码，获取inode信息；最后，根据inode信息，找到文件数据所在的block，读出数据。</p>
<p>使用ls -i命令，可以看到文件名对应的inode号码：</p>
<p><code>ls -i 233.txt</code></p>
<p><img src="/media/15279146959888.jpg" alt=""></p>
<p>五、目录文件</p>
<p>Unix/Linux系统中，目录（directory）也是一种文件。打开目录，实际上就是打开目录文件。</p>
<p>目录文件的结构非常简单，就是一系列目录项（dirent）的列表。每个目录项，由两部分组成：所包含文件的文件名，以及该文件名对应的inode号码。</p>
<p>ls命令只列出目录文件中的所有文件名：</p>
<p>　<code>ls /etc</code></p>
<p>ls -i命令列出整个目录文件，即文件名和inode号码：</p>
<p>　　<code>ls -i /etc</code></p>
<p>如果要查看文件的详细信息，就必须根据inode号码，访问inode节点，读取信息。ls -l命令列出文件的详细信息。</p>
<p>　　<code>ls -l /etc</code></p>
<p>理解了上面这些知识，就能理解目录的权限。目录文件的读权限（r）和写权限（w），都是针对目录文件本身。由于目录文件内只有文件名和inode号码，所以如果只有读权限，只能获取文件名，无法获取其他信息，因为其他信息都储存在inode节点中，而读取inode节点内的信息需要目录文件的执行权限（x）。</p>
<h2 id="六、硬链接"><a href="#六、硬链接" class="headerlink" title="六、硬链接"></a>六、硬链接</h2><p>一般情况下，文件名和inode号码是”一一对应”关系，每个inode号码对应一个文件名。但是，Unix/Linux系统允许，多个文件名指向同一个inode号码。</p>
<p>这意味着，可以用不同的文件名访问同样的内容；对文件内容进行修改，会影响到所有文件名；但是，删除一个文件名，不影响另一个文件名的访问。这种情况就被称为”硬链接”（hard link）。</p>
<p>ln命令可以创建硬链接：</p>
<p>　　<code>ln 源文件 目标文件</code></p>
<p>运行上面这条命令以后，源文件与目标文件的inode号码相同，都指向同一个inode。inode信息中有一项叫做”链接数”，记录指向该inode的文件名总数，这时就会增加1。</p>
<p>反过来，删除一个文件名，就会使得inode节点中的”链接数”减1。当这个值减到0，表明没有文件名指向这个inode，系统就会回收这个inode号码，以及其所对应block区域。</p>
<p>这里顺便说一下目录文件的”链接数”。创建目录时，默认会生成两个目录项：”.”和”..”。前者的inode号码就是当前目录的inode号码，等同于当前目录的”硬链接”；后者的inode号码就是当前目录的父目录的inode号码，等同于父目录的”硬链接”。所以，任何一个目录的”硬链接”总数，总是等于2加上它的子目录总数（含隐藏目录）。</p>
<h2 id="七、软链接"><a href="#七、软链接" class="headerlink" title="七、软链接"></a>七、软链接</h2><p>除了硬链接以外，还有一种特殊情况。</p>
<p>文件A和文件B的inode号码虽然不一样，但是文件A的内容是文件B的路径。读取文件A时，系统会自动将访问者导向文件B。因此，无论打开哪一个文件，最终读取的都是文件B。这时，文件A就称为文件B的”软链接”（soft link）或者”符号链接（symbolic link）。</p>
<p>这意味着，文件A依赖于文件B而存在，如果删除了文件B，打开文件A就会报错：”No such file or directory”。这是软链接与硬链接最大的不同：文件A指向文件B的文件名，而不是文件B的inode号码，文件B的inode”链接数”不会因此发生变化。</p>
<p><strong>ln -s命令可以创建软链接</strong>。</p>
<p>　　<code>ln -s 源文文件或目录 目标文件或目录</code></p>
<h2 id="八、inode的特殊作用"><a href="#八、inode的特殊作用" class="headerlink" title="八、inode的特殊作用"></a>八、inode的特殊作用</h2><p>由于inode号码与文件名分离，这种机制导致了一些Unix/Linux系统特有的现象。</p>
<ul>
<li><p>有时，文件名包含特殊字符，无法正常删除。这时，直接删除inode节点，就能起到删除文件的作用。</p>
</li>
<li><p>移动文件或重命名文件，只是改变文件名，不影响inode号码。</p>
</li>
<li><p>打开一个文件以后，系统就以inode号码来识别这个文件，不再考虑文件名。因此，通常来说，系统无法从inode号码得知文件名。</p>
</li>
</ul>
<p>第3点使得软件更新变得简单，可以在不关闭软件的情况下进行更新，不需要重启。因为系统通过inode号码，识别运行中的文件，不通过文件名。更新的时候，新版文件以同样的文件名，生成一个新的inode，不会影响到运行中的文件。等到下一次运行这个软件的时候，文件名就自动指向新版文件，旧版文件的inode则被回收。</p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://wenyiqingnian.xyz/2018/06/02/理解Liunx的FD与Inode/" data-id="cjiih6wyy001xhx0c20l1fggt" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    
        <a href="http://wenyiqingnian.xyz/2018/06/02/理解Liunx的FD与Inode/#comments" class="article-comment-link">Comments</a>
    

        </footer>
    </div>
    
</article>



    <article id="post-Docker入门" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2018/05/30/Docker入门/">Docker入门</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2018/05/30/Docker入门/">
            <time datetime="2018-05-30T07:56:50.000Z" itemprop="datePublished">2018-05-30</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/容器技术/">容器技术</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/docker/">docker</a>, <a class="tag-link" href="/tags/容器/">容器</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p>Docker是目前最火的Linux容器解决方案，真正做到一劳永逸的解决环境配置和依赖问题，而且可以方便的修改、分享，版本管理，本篇文章摘选自 <strong>阮一峰的博客</strong>：<a href="http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html" target="_blank" rel="noopener">Docker 入门教程
</a></p>
<h1 id="一、环境配置的难题"><a href="#一、环境配置的难题" class="headerlink" title="一、环境配置的难题"></a>一、环境配置的难题</h1><p>软件开发最大的麻烦事之一，就是环境配置。用户计算机的环境都不相同，你怎么知道自家的软件，能在那些机器跑起来？</p>
<p>用户必须保证两件事：操作系统的设置，各种库和组件的安装。只有它们都正确，软件才能运行。举例来说，安装一个 Python 应用，计算机必须有 Python 引擎，还必须有各种依赖，可能还要配置环境变量。</p>
<p>如果某些老旧的模块与当前环境不兼容，那就麻烦了。开发者常常会说：”它在我的机器可以跑了”（It works on my machine），言下之意就是，其他机器很可能跑不了。</p>
<p>环境配置如此麻烦，换一台机器，就要重来一次，旷日费时。很多人想到，能不能从根本上解决问题，软件可以带环境安装？也就是说，安装的时候，把原始环境一模一样地复制过来。</p>
<h1 id="二、虚拟机"><a href="#二、虚拟机" class="headerlink" title="二、虚拟机"></a>二、虚拟机</h1><p>虚拟机（virtual machine）就是带环境安装的一种解决方案。它可以在一种操作系统里面运行另一种操作系统，比如在 Windows 系统里面运行 Linux 系统。应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。</p>
<p>虽然用户可以通过虚拟机还原软件的原始环境。但是，这个方案有几个缺点。</p>
<ul>
<li>（1）资源占用多</li>
</ul>
<p>虚拟机会独占一部分内存和硬盘空间。它运行的时候，其他程序就不能使用这些资源了。哪怕虚拟机里面的应用程序，真正使用的内存只有 1MB，虚拟机依然需要几百 MB 的内存才能运行。</p>
<ul>
<li>（2）冗余步骤多</li>
</ul>
<p>虚拟机是完整的操作系统，一些系统级别的操作步骤，往往无法跳过，比如用户登录。</p>
<ul>
<li>（3）启动慢</li>
</ul>
<p>启动操作系统需要多久，启动虚拟机就需要多久。可能要等几分钟，应用程序才能真正运行。</p>
<h1 id="三、Linux-容器"><a href="#三、Linux-容器" class="headerlink" title="三、Linux 容器"></a>三、Linux 容器</h1><p>由于虚拟机存在这些缺点，Linux 发展出了另一种虚拟化技术：Linux 容器（Linux Containers，缩写为 LXC）。</p>
<p>Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离。或者说，在正常进程的外面套了一个保护层。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。</p>
<p>由于容器是进程级别的，相比虚拟机有很多优势。</p>
<ul>
<li>（1）启动快</li>
</ul>
<p>容器里面的应用，直接就是底层系统的一个进程，而不是虚拟机内部的进程。所以，启动容器相当于启动本机的一个进程，而不是启动一个操作系统，速度就快很多。</p>
<ul>
<li>（2）资源占用少</li>
</ul>
<p>容器只占用需要的资源，不占用那些没有用到的资源；虚拟机由于是完整的操作系统，不可避免要占用所有资源。另外，多个容器可以共享资源，虚拟机都是独享资源。</p>
<ul>
<li>（3）体积小</li>
</ul>
<p>容器只要包含用到的组件即可，而虚拟机是整个操作系统的打包，所以容器文件比虚拟机文件要小很多。</p>
<p>总之，容器有点像轻量级的虚拟机，能够提供虚拟化的环境，但是成本开销小得多。</p>
<h1 id="四、Docker-是什么？"><a href="#四、Docker-是什么？" class="headerlink" title="四、Docker 是什么？"></a>四、Docker 是什么？</h1><p>Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。它是目前最流行的 Linux 容器解决方案。</p>
<p>Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。</p>
<p>总体来说，Docker 的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。</p>
<h1 id="五、Docker-的用途"><a href="#五、Docker-的用途" class="headerlink" title="五、Docker 的用途"></a>五、Docker 的用途</h1><p>Docker 的主要用途，目前有三大类。</p>
<ul>
<li><p>（1）提供一次性的环境。比如，本地测试他人的软件、持续集成的时候提供单元测试和构建的环境。</p>
</li>
<li><p>（2）提供弹性的云服务。因为 Docker 容器可以随开随关，很适合动态扩容和缩容。</p>
</li>
<li><p>（3）组建微服务架构。通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构。</p>
</li>
</ul>
<h1 id="六、Docker-的安装"><a href="#六、Docker-的安装" class="headerlink" title="六、Docker 的安装"></a>六、Docker 的安装</h1><p>Docker 是一个开源的商业产品，有两个版本：社区版（Community Edition，缩写为 CE）和企业版（Enterprise Edition，缩写为 EE）。企业版包含了一些收费服务，个人开发者一般用不到。下面的介绍都针对社区版。</p>
<p>Docker CE 的安装请参考官方文档。</p>
<p><a href="https://docs.docker.com/docker-for-mac/install/" target="_blank" rel="noopener">Mac</a><br><a href="https://docs.docker.com/docker-for-windows/install/" target="_blank" rel="noopener">Windows</a><br><a href="https://docs.docker.com/install/linux/docker-ce/ubuntu/" target="_blank" rel="noopener">Ubuntu</a><br><a href="https://docs.docker.com/install/linux/docker-ce/binaries/" target="_blank" rel="noopener">其他 Linux 发行版</a><br>安装完成后，运行下面的命令，验证是否安装成功。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> docker version</span><br><span class="line"><span class="meta">#</span> 或者</span><br><span class="line"><span class="meta">$</span> docker info</span><br></pre></td></tr></table></figure>
<p>Docker 需要用户具有 sudo 权限，为了避免每次命令都输入sudo，可以把用户加入 Docker 用户组（<a href="https://docs.docker.com/install/linux/linux-postinstall/#manage-docker-as-a-non-root-user" target="_blank" rel="noopener">官方文档</a>）。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo usermod -aG docker $USER</span><br></pre></td></tr></table></figure>
<p>Docker 是服务器—-客户端架构。命令行运行docker命令的时候，需要本机有 Docker 服务。如果这项服务没有启动，可以用下面的命令启动（<a href="https://docs.docker.com/config/daemon/systemd/" target="_blank" rel="noopener">官方文档</a>）。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> service 命令的用法</span><br><span class="line"><span class="meta">$</span> sudo service docker start</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> systemctl 命令的用法</span><br><span class="line"><span class="meta">$</span> sudo systemctl start docker</span><br></pre></td></tr></table></figure>
<h1 id="六、image-文件"><a href="#六、image-文件" class="headerlink" title="六、image 文件"></a>六、image 文件</h1><p>Docker 把应用程序及其依赖，打包在 image 文件里面。只有通过这个文件，才能生成 Docker 容器。image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。</p>
<p>image 是二进制文件。实际开发中，一个 image 文件往往通过继承另一个 image 文件，加上一些个性化设置而生成。举例来说，你可以在 Ubuntu 的 image 基础上，往里面加入 Apache 服务器，形成你的 image。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 列出本机的所有 image 文件。</span><br><span class="line"><span class="meta">$</span> docker image ls</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 删除 image 文件</span><br><span class="line"><span class="meta">$</span> docker image rm [imageName]</span><br></pre></td></tr></table></figure>
<p>image 文件是通用的，一台机器的 image 文件拷贝到另一台机器，照样可以使用。一般来说，为了节省时间，我们应该尽量使用别人制作好的 image 文件，而不是自己制作。即使要定制，也应该基于别人的 image 文件进行加工，而不是从零开始制作。</p>
<p>为了方便共享，image 文件制作完成后，可以上传到网上的仓库。Docker 的官方仓库 Docker Hub 是最重要、最常用的 image 仓库。此外，出售自己制作的 image 文件也是可以的。</p>
<h1 id="七、实例：hello-world"><a href="#七、实例：hello-world" class="headerlink" title="七、实例：hello world"></a>七、实例：hello world</h1><p>下面，我们通过最简单的 image 文件”hello world”，感受一下 Docker。</p>
<p>需要说明的是，国内连接 Docker 的官方仓库很慢，还会断线，需要将默认仓库改成国内的镜像网站，具体的修改方法在下一篇文章的第一节。有需要的朋友，可以先看一下。</p>
<p>首先，运行下面的命令，将 image 文件从仓库抓取到本地。</p>
<p><code>$ docker image pull library/hello-world</code><br>上面代码中，docker image pull是抓取 image 文件的命令。<code>library/hello-world</code>是 image 文件在仓库里面的位置，其中library是 image 文件所在的组，<code>hello-world</code>是 image 文件的名字。</p>
<p>由于 Docker 官方提供的 image 文件，都放在library组里面，所以它的是默认组，可以省略。因此，上面的命令可以写成下面这样。</p>
<p><code>$ docker image pull hello-world</code><br>抓取成功以后，就可以在本机看到这个 image 文件了。</p>
<p><code>$ docker image ls</code><br>现在，运行这个 image 文件。</p>
<p><code>$ docker container run hello-world</code><br>docker container run命令会从 image 文件，生成一个正在运行的容器实例。</p>
<p>注意，docker container run命令具有自动抓取 image 文件的功能。如果发现本地没有指定的 image 文件，就会从仓库自动抓取。因此，前面的docker image pull命令并不是必需的步骤。</p>
<p>如果运行成功，你会在屏幕上读到下面的输出。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> docker container run hello-world</span><br><span class="line"></span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line"></span><br><span class="line">... ...</span><br></pre></td></tr></table></figure>
<p>输出这段提示以后，hello world就会停止运行，容器自动终止。</p>
<p>有些容器不会自动终止，因为提供的是服务。比如，安装运行 Ubuntu 的 image，就可以在命令行体验 Ubuntu 系统。</p>
<p><code>$ docker container run -it ubuntu bash</code>对于那些不会自动终止的容器，必须使用docker container kill 命令手动终止。</p>
<p><code>$ docker container kill [containID]</code></p>
<h1 id="八、容器文件"><a href="#八、容器文件" class="headerlink" title="八、容器文件"></a>八、容器文件</h1><p>image 文件生成的容器实例，本身也是一个文件，称为容器文件。也就是说，一旦容器生成，就会同时存在两个文件： image 文件和容器文件。而且关闭容器并不会删除容器文件，只是容器停止运行而已。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 列出本机正在运行的容器</span><br><span class="line"><span class="meta">$</span> docker container ls</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 列出本机所有容器，包括终止运行的容器</span><br><span class="line"><span class="meta">$</span> docker container ls --all</span><br></pre></td></tr></table></figure>
<p>上面命令的输出结果之中，包括容器的 ID。很多地方都需要提供这个 ID，比如上一节终止容器运行的<code>docker container kill</code>命令。</p>
<p>终止运行的容器文件，依然会占据硬盘空间，可以使用<code>docker container rm</code>命令删除。</p>
<p><code>$ docker container rm [containerID]</code><br>运行上面的命令之后，再使用<code>docker container ls --all</code>命令，就会发现被删除的容器文件已经消失了。</p>
<h1 id="九、Dockerfile-文件"><a href="#九、Dockerfile-文件" class="headerlink" title="九、Dockerfile 文件"></a>九、Dockerfile 文件</h1><p>学会使用 image 文件以后，接下来的问题就是，如何可以生成 image 文件？如果你要推广自己的软件，势必要自己制作 image 文件。</p>
<p>这就需要用到 Dockerfile 文件。它是一个文本文件，用来配置 image。Docker 根据 该文件生成二进制的 image 文件。</p>
<p>下面通过一个实例，演示如何编写 Dockerfile 文件。</p>
<h1 id="十、实例：制作自己的-Docker-容器"><a href="#十、实例：制作自己的-Docker-容器" class="headerlink" title="十、实例：制作自己的 Docker 容器"></a>十、实例：制作自己的 Docker 容器</h1><p>下面我以 koa-demos 项目为例，介绍怎么写 Dockerfile 文件，实现让用户在 Docker 容器里面运行 Koa 框架。</p>
<p>作为准备工作，请先下载源码。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git clone https://github.com/ruanyf/koa-demos.git</span><br><span class="line"><span class="meta">$</span> cd koa-demos</span><br></pre></td></tr></table></figure>
<h3 id="10-1-编写-Dockerfile-文件"><a href="#10-1-编写-Dockerfile-文件" class="headerlink" title="10.1 编写 Dockerfile 文件"></a>10.1 编写 Dockerfile 文件</h3><p>首先，在项目的根目录下，新建一个文本文件<code>.dockerignore</code>，写入下面的内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.git</span><br><span class="line">node_modules</span><br><span class="line">npm-debug.log</span><br></pre></td></tr></table></figure>
<p>上面代码表示，这三个路径要排除，不要打包进入 image 文件。如果你没有路径要排除，这个文件可以不新建。</p>
<p>然后，在项目的根目录下，新建一个文本文件 <code>Dockerfile</code>，写入下面的内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM node:8.4</span><br><span class="line">COPY . /app</span><br><span class="line">WORKDIR /app</span><br><span class="line">RUN npm install --registry=https://registry.npm.taobao.org</span><br><span class="line">EXPOSE 3000</span><br></pre></td></tr></table></figure>
<p>上面代码一共五行，含义如下。</p>
<h4 id="FROM-node-8-4"><a href="#FROM-node-8-4" class="headerlink" title="FROM node:8.4:"></a>FROM node:8.4:</h4><p>该 image 文件继承官方的 node image，冒号表示标签，这里标签是8.4，即8.4版本的 node。</p>
<h4 id="COPY-app："><a href="#COPY-app：" class="headerlink" title="COPY . /app："></a>COPY . /app：</h4><p>将当前目录下的所有文件（除了.dockerignore排除的路径），都拷贝进入 image 文件的/app目录。</p>
<h4 id="WORKDIR-app："><a href="#WORKDIR-app：" class="headerlink" title="WORKDIR /app："></a>WORKDIR /app：</h4><p>指定接下来的工作路径为/app。</p>
<h4 id="RUN-npm-install："><a href="#RUN-npm-install：" class="headerlink" title="RUN npm install："></a>RUN npm install：</h4><p>在/app目录下，运行npm install命令安装依赖。注意，安装后所有的依赖，都将打包进入 image 文件。<br>EXPOSE 3000：将容器 3000 端口暴露出来， 允许外部连接这个端口。</p>
<h3 id="10-2-创建-image-文件"><a href="#10-2-创建-image-文件" class="headerlink" title="10.2 创建 image 文件"></a>10.2 创建 image 文件</h3><p>有了 Dockerfile 文件以后，就可以使用docker <code>image build</code>命令创建 image 文件了。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> docker image build -t koa-demo </span><br><span class="line"><span class="meta">#</span> 或者</span><br><span class="line"><span class="meta">$</span> docker image build -t koa-demo:0.0.1 .</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>-t</code>参数用来指定 image 文件的名字，后面还可以用冒号指定标签。如果不指定，默认的标签就是<code>latest</code>。最后的那个点表示 <code>Dockerfile</code> 文件所在的路径，上例是当前路径，所以是一个点。</p>
<p>如果运行成功，就可以看到新生成的 image 文件koa-demo了。</p>
<p><code>$ docker image ls</code></p>
<h3 id="10-3-生成容器"><a href="#10-3-生成容器" class="headerlink" title="10.3 生成容器"></a>10.3 生成容器</h3><p><code>docker container run</code>命令会从 image 文件生成容器。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> docker container run -p 8000:3000 -it koa-demo /bin/bash</span><br><span class="line"><span class="meta">#</span> 或者</span><br><span class="line"><span class="meta">$</span> docker container run -p 8000:3000 -it koa-demo:0.0.1 /bin/bash</span><br></pre></td></tr></table></figure>
<p>上面命令的各个参数含义如下：</p>
<h4 id="p参数："><a href="#p参数：" class="headerlink" title="-p参数："></a>-p参数：</h4><p>容器的 3000 端口映射到本机的 8000 端口。</p>
<h4 id="it参数："><a href="#it参数：" class="headerlink" title="-it参数："></a>-it参数：</h4><p>容器的 Shell 映射到当前的 Shell，然后你在本机窗口输入的命令，就会传入容器。</p>
<h4 id="koa-demo-0-0-1："><a href="#koa-demo-0-0-1：" class="headerlink" title="koa-demo:0.0.1："></a>koa-demo:0.0.1：</h4><p>image 文件的名字（如果有标签，还需要提供标签，默认是 latest 标签）。</p>
<h4 id="bin-bash："><a href="#bin-bash：" class="headerlink" title="/bin/bash："></a>/bin/bash：</h4><p>容器启动以后，内部第一个执行的命令。这里是启动 Bash，保证用户可以使用 Shell。<br>如果一切正常，运行上面的命令以后，就会返回一个命令行提示符。</p>
<p><code>root@66d80f4aaf1e:/app#</code><br>这表示你已经在容器里面了，返回的提示符就是容器内部的 Shell 提示符。执行下面的命令。</p>
<p><code>root@66d80f4aaf1e:/app# node demos/01.js</code><br>这时，Koa 框架已经运行起来了。打开本机的浏览器，访问 <a href="http://127.0.0.1:8000，网页显示&quot;Not" target="_blank" rel="noopener">http://127.0.0.1:8000，网页显示&quot;Not</a> Found”，这是因为这个 demo 没有写路由。</p>
<p>这个例子中，Node 进程运行在 Docker 容器的虚拟环境里面，进程接触到的文件系统和网络接口都是虚拟的，与本机的文件系统和网络接口是隔离的，因此需要定义容器与物理机的端口映射（map）。</p>
<p>现在，在容器的命令行，按下 <code>Ctrl + c</code> 停止 Node 进程，然后按下 <code>Ctrl + d</code> （或者输入 exit）退出容器。此外，也可以用<code>docker container kill</code>终止容器运行。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 在本机的另一个终端窗口，查出容器的 ID</span><br><span class="line"><span class="meta">$</span> docker container ls</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 停止指定的容器运行</span><br><span class="line"><span class="meta">$</span> docker container kill [containerID]</span><br><span class="line">容器停止运行之后，并不会消失，用下面的命令删除容器文件。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 查出容器的 ID</span><br><span class="line"><span class="meta">$</span> docker container ls --all</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 删除指定的容器文件</span><br><span class="line"><span class="meta">$</span> docker container rm [containerID]</span><br></pre></td></tr></table></figure>
<p>也可以使用<code>docker container run</code>命令的<code>--rm</code>参数，在容器终止运行后自动删除容器文件。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> docker container run --rm -p 8000:3000 -it koa-demo /bin/bash</span><br></pre></td></tr></table></figure>
<h3 id="10-4-CMD-命令"><a href="#10-4-CMD-命令" class="headerlink" title="10.4 CMD 命令"></a>10.4 CMD 命令</h3><p>上一节的例子里面，容器启动以后，需要手动输入命令node demos/01.js。我们可以把这个命令写在 Dockerfile 里面，这样容器启动以后，这个命令就已经执行了，不用再手动输入了。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FROM node:8.4</span><br><span class="line">COPY . /app</span><br><span class="line">WORKDIR /app</span><br><span class="line">RUN npm install --registry=https://registry.npm.taobao.org</span><br><span class="line">EXPOSE 3000</span><br><span class="line">CMD node demos/01.js</span><br></pre></td></tr></table></figure>
<p>上面的 Dockerfile 里面，多了最后一行CMD node demos/01.js，它表示容器启动后自动执行node demos/01.js。</p>
<p>你可能会问，RUN命令与CMD命令的区别在哪里？简单说，RUN命令在 image 文件的构建阶段执行，执行结果都会打包进入 image 文件；CMD命令则是在容器启动后执行。另外，一个 Dockerfile 可以包含多个RUN命令，但是只能有一个CMD命令。</p>
<p>注意，指定了CMD命令以后，<code>docker container run</code>命令就不能附加命令了（比如前面的/bin/bash），否则它会覆盖CMD命令。现在，启动容器可以使用下面的命令。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> docker container run --rm -p 8000:3000 -it koa-demo:0.0.1</span><br></pre></td></tr></table></figure>
<h3 id="10-5-发布-image-文件"><a href="#10-5-发布-image-文件" class="headerlink" title="10.5 发布 image 文件"></a>10.5 发布 image 文件</h3><p>容器运行成功后，就确认了 image 文件的有效性。这时，我们就可以考虑把 image 文件分享到网上，让其他人使用。</p>
<p>首先，去 <a href="hub.docker.com">cloud.docker.com</a> 或 <a href="">cloud.docker.com</a> 注册一个账户。然后，用下面的命令登录。</p>
<p><code>$ docker login</code><br>接着，为本地的 image 标注用户名和版本。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> docker image tag [imageName] [username]/[repository]:[tag]</span><br><span class="line"><span class="meta">#</span> 实例</span><br><span class="line"><span class="meta">$</span> docker image tag koa-demos:0.0.1 ruanyf/koa-demos:0.0.1</span><br></pre></td></tr></table></figure>
<p>也可以不标注用户名，重新构建一下 image 文件。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> docker image build -t [username]/[repository]:[tag] .</span><br></pre></td></tr></table></figure>
<p>最后，发布 image 文件。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> docker image push [username]/[repository]:[tag]</span><br></pre></td></tr></table></figure>
<p>发布成功以后，登录 hub.docker.com，就可以看到已经发布的 image 文件。</p>
<h3 id="十一、其他有用的命令"><a href="#十一、其他有用的命令" class="headerlink" title="十一、其他有用的命令"></a>十一、其他有用的命令</h3><p>docker 的主要用法就是上面这些，此外还有几个命令，也非常有用。</p>
<ul>
<li>（1）docker container start</li>
</ul>
<p>前面的docker container run命令是新建容器，每运行一次，就会新建一个容器。同样的命令运行两次，就会生成两个一模一样的容器文件。如果希望重复使用容器，就要使用docker container start命令，它用来启动已经生成、已经停止运行的容器文件。</p>
<p><code>$ docker container start [containerID]</code></p>
<ul>
<li>（2）docker container stop</li>
</ul>
<p>前面的<code>docker container kill</code>命令终止容器运行，相当于向容器里面的主进程发出 SIGKILL 信号。而<code>docker container stop</code>命令也是用来终止容器运行，相当于向容器里面的主进程发出 SIGTERM 信号，然后过一段时间再发出 SIGKILL 信号。</p>
<p><code>$ bash container stop [containerID]</code><br>这两个信号的差别是，应用程序收到 SIGTERM 信号以后，可以自行进行收尾清理工作，但也可以不理会这个信号。如果收到 SIGKILL 信号，就会强行立即终止，那些正在进行中的操作会全部丢失。</p>
<ul>
<li>（3）docker container logs</li>
</ul>
<p><code>docker container logs</code>命令用来查看 docker 容器的输出，即容器里面 Shell 的标准输出。如果<code>docker run</code>命令运行容器的时候，没有使用-it参数，就要用这个命令查看输出。</p>
<p><code>$ docker container logs [containerID]</code></p>
<ul>
<li>（4）docker container exec</li>
</ul>
<p><code>docker container exec</code>命令用于进入一个正在运行的 docker 容器。如果docker run命令运行容器的时候，没有使用-it参数，就要用这个命令进入容器。一旦进入了容器，就可以在容器的 Shell 执行命令了。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> docker container exec -it [containerID] /bin/bash</span><br></pre></td></tr></table></figure>
<ul>
<li>（5）docker container cp</li>
</ul>
<p>docker container cp命令用于从正在运行的 Docker 容器里面，将文件拷贝到本机。下面是拷贝到当前目录的写法。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> docker container cp [containID]:[/path/to/file] .</span><br></pre></td></tr></table></figure>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://wenyiqingnian.xyz/2018/05/30/Docker入门/" data-id="cjiih6wy10006hx0cvetp6xuh" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    
        <a href="http://wenyiqingnian.xyz/2018/05/30/Docker入门/#comments" class="article-comment-link">Comments</a>
    

        </footer>
    </div>
    
</article>



    <article id="post-Binder的设计架构" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2018/05/29/Binder的设计架构/">Binder的设计架构</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2018/05/29/Binder的设计架构/">
            <time datetime="2018-05-29T11:20:50.000Z" itemprop="datePublished">2018-05-29</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/Android/">Android</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/Binder/">Binder</a>, <a class="tag-link" href="/tags/android/">android</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <h2 id="一、为什么选择Binder"><a href="#一、为什么选择Binder" class="headerlink" title="一、为什么选择Binder"></a>一、为什么选择Binder</h2><p>android 是基于Linux开发的移动端操作系统，而传统的Linux已有的IPC机制，包括管道，消息队列、共享内存、信号量、socket为什么不适合安卓，而非要采用Binder？</p>
<h3 id="1-拷贝次数"><a href="#1-拷贝次数" class="headerlink" title="1.拷贝次数"></a>1.拷贝次数</h3><h4 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h4><p>Linux中除了Binder之外唯一一个C/S架构的IPC，为了兼容本地操作系统中的进程间通讯和互联网中的远程主机之间的通讯，Socket采用的是更加通用型的架构，一般的socket通讯流程如下</p>
<ol>
<li>客户端通过 <code>int socket(int domain, int type, int protocol);</code> 函数创建了一个socket，返回了该套接字的文件描述符</li>
<li>通过bind函数 绑定了该socket的端口号，监听该端口</li>
<li>循环检查该端口是否有消息，如果有消息则fork出子进程去处理</li>
<li>使用read（）读取客户端发送的消息数据，通过write（）处理消息并发送给客户端</li>
<li>客户端也要创建socket</li>
<li>客户端连接到制定IP和端口的服务端socket</li>
<li>使用write向服务端写数据，用read 从服务端度数据<br>可以看到，一次标准的socket通讯步骤繁琐，计算机内的进程间通讯，如果采用socket，不可避免的会先write()将文件写到内核缓冲区，再read() 将文件读取到用户缓冲区，涉及两次拷贝。如果是网络传输，一次通讯过程可能会涉及三到四次拷贝，多次切换上下文。<h4 id="匿名管道"><a href="#匿名管道" class="headerlink" title="匿名管道"></a>匿名管道</h4></li>
<li>半双工，数据流动方向是单向的，读写端都是固定的</li>
<li>只能用于父子进程间的通讯</li>
<li>属于一种特殊的文件，只存在内存中</li>
<li>数据传递方式仍然采用read 和 write ，先从发送方缓冲区拷贝到内核，再从内核缓冲区拷贝到接收方<br><img src="/media/15276457266040.jpg" alt="父子进程通过管道实现数据交互"></li>
</ol>
<ul>
<li>拷贝次数 两次</li>
</ul>
<h4 id="命名管道"><a href="#命名管道" class="headerlink" title="命名管道"></a>命名管道</h4><p>可以在无关进程之间交流数据，它有些类似用文件的方式在进城之间传递数据，但该文件又同时具有管道的特点，它允许所有知道其FIFO接口的进程参与读写，遵循先入先出的原则。</p>
<ul>
<li>拷贝次数 2次拷贝</li>
</ul>
<h4 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h4><ol>
<li>面向记录，消息队列中的消息具有特定格式和优先级</li>
<li>独立于进程，就算进程被杀死，队列中的消息也不会被清除</li>
<li>可以实现消息的独立查询</li>
<li>消息队列同样需要两次拷贝，进程A 拷贝消息到消息队列，消息队列从队列中取消息 将其拷贝到进程B<h4 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h4>指的是两个或以上进程共享的一块内存区域</li>
<li>速度最快 因为是直接读取，不涉及拷贝</li>
<li>多个进程需要同时读取，所以需要同步机制，一般配合信号量使用</li>
</ol>
<h4 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h4><p>Binder是Android系统中广泛采用的C/S架构IPC通讯方式，它只需要一次内存拷贝。<br>Binder的一次通讯过程：<br>通过 <code>BinderProxy</code> 将我们的请求参数发送给 <code>ServiceManager</code>，通过共享内存的方式使用内核方法 <code>copy_from_user()</code> 将我们的参数先拷贝到内核空间，这时我们的客户端进入等待状态，然后 Binder 驱动向服务端的 todo 队列里面插入一条事务，执行完之后把执行结果通过 <code>copy_to_user()</code>将内核的结果拷贝到用户空间（这里只是执行了拷贝命令，并没有拷贝数据，binder只进行一次拷贝），唤醒等待的客户端并把结果响应回来，这样就完成了一次通讯。</p>
<p>关于消息传递效率 参考下表</p>
<table>
<thead>
<tr>
<th>IPC</th>
<th>特征</th>
<th>拷贝次数</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td>共享内存</td>
<td>速度快，但是控制复杂，要解决同步问题</td>
<td>0</td>
<td>极少用</td>
</tr>
<tr>
<td>Binder</td>
<td>简单 通用 安全</td>
<td>1</td>
<td>Android常用、性能高</td>
</tr>
<tr>
<td>Socket</td>
<td>A缓冲区-&gt;内核缓冲区-&gt;B缓冲区</td>
<td>2</td>
<td>Socket作为通用接口，开销大，传输性能低，一般用作跨网络或者进程间的低速IPC</td>
</tr>
</tbody>
</table>
<h3 id="2-安全性"><a href="#2-安全性" class="headerlink" title="2.安全性"></a>2.安全性</h3><p>Android作为一个开放式，拥有众多开发者的的平台，应用程序的来源广泛，确保智能终端的安全是非常重要的。终端用户不希望从网上下载的程序在不知情的情况下偷窥隐私数据，连接无线网络，长期操作底层设备导致电池很快耗尽等等。传统IPC没有任何安全措施，完全依赖上层协议来确保。</p>
<ul>
<li>传统IPC的接收方无法获得对方进程可靠的UID/PID（用户ID/进程ID），从而无法鉴别对方身份。Android为每个安装好的应用程序分配了自己的UID，故进程的UID是鉴别进程身份的重要标志。</li>
<li>使用传统IPC只能由用户在数据包里填入UID/PID，但这样不可靠，容易被恶意程序利用。可靠的身份标记只有由IPC机制本身在内核中添加。其次传统IPC访问接入点是开放的，无法建立私有通道。比如命名管道的名称，system V的键值，socket的ip地址或文件名都是开放的，只要知道这些接入点的程序都可以和对端建立连接，不管怎样都无法阻止恶意程序通过猜测接收方地址获得连接。</li>
</ul>
<p>基于以上原因，Android需要建立一套新的IPC机制来满足系统对通信方式，传输性能和安全性的要求，这就是Binder。Binder基于Client-Server通信模式，传输过程只需一次拷贝，为发送发添加UID/PID身份，既支持实名Binder也支持匿名Binder，安全性高。</p>
<h1 id="二、-Binder-的面向对象思想"><a href="#二、-Binder-的面向对象思想" class="headerlink" title="二、  Binder 的面向对象思想"></a>二、  Binder 的面向对象思想</h1><p>Binder可以看做是server端提供某个功能的访问接入点，client通过访问该接入点获得server的服务，但和其他ipc不同的是，binder采用一种面向对象的思想来设计该入口。</p>
<p>Binder的实体是位于server中的对象，它实现了一系列方法用以访问server的服务，有点类似于类中的成员函数，而client中拿到的其实是该binder对象的引用</p>
<blockquote>
<p>client —&gt; binder引用—-&gt;Binder—-&gt;server</p>
</blockquote>
<p>面向对象思想的引入将进程间通信转化为通过对某个Binder对象的引用调用该对象的方法，而其独特之处在于Binder对象是一个可以跨进程引用的对象，它的实体位于一个进程中，而它的引用却遍布于系统的各个进程之中。这个引用和java里引用一样既可以是强类型，也可以是弱类型，而且可以从一个进程传给其它进程，让大家都能访问同一Server，就象将一个对象或引用赋值给另一个引用一样。Binder模糊了进程边界，淡化了进程间通信过程，整个系统仿佛运行于同一个面向对象的程序之中。形形色色的Binder对象以及星罗棋布的引用仿佛粘接各个应用程序的胶水，这也是Binder在英文里的原意。</p>
<p>当然面向对象只是针对应用程序而言，对于Binder驱动和内核其它模块一样使用C语言实现，没有类和对象的概念。Binder驱动为面向对象的进程间通信提供底层支持。</p>
<h1 id="三、Binder的通讯模型"><a href="#三、Binder的通讯模型" class="headerlink" title="三、Binder的通讯模型"></a>三、Binder的通讯模型</h1><p>一个完整的Binder驱动包含四个角色</p>
<blockquote>
<p>Server、Client、ServiceManager、Binder驱动。</p>
</blockquote>
<p>server client smg 运行在用户空间，Binder驱动运行在内和空间。</p>
<h2 id="1-Binder驱动"><a href="#1-Binder驱动" class="headerlink" title="1.Binder驱动"></a>1.Binder驱动</h2><p>实现方式类似硬件驱动，工作在内核态<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">binder_fops</span> = &#123;</span></span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .poll = binder_poll,</span><br><span class="line">    .unlocked_ioctl = binder_ioctl,</span><br><span class="line">    .mmap = binder_mmap,</span><br><span class="line">    .open = binder_open,</span><br><span class="line">    .flush = binder_flush,</span><br><span class="line">    .release = binder_release,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这是binder驱动的<code>file_operation</code>结构体，可以看到binder驱动为应用层提供了open(),mmap(),poll(),ioctl()等标准的文件操作【注1】，open()负责打开驱动，mmap()负责对binder做内核空间向用户空间的地址映射，ioctl()负责binder协议的通信。<br>Binder驱动负责在内核中创建对应的Binder实体节点，为client或者server进程创建对该实体节点的引用，负责进程之间Binder通信的建立，Binder在进程之间传递，Binder引用计数管理，数据包在进程之间的传递等一系列操作的底层支持，驱动和应用程序之间定义了一套标准的接口协议，主要功能由ioctl()【注2】来实现，不提供read（），write接口。（因为ioctl是更为高灵活的操作文件的接口，自动遵循先写后读的顺序，可以满足同步请求）</p>
<blockquote>
<p>注释1：设备驱动程序是操作系统内核和机器硬件之间的接口。设备驱动程序为应用程序屏蔽了硬件的细节，这样在应用程序看来，硬件设备只是一个设备文件，应用程序可以象操作普通文件一样对硬件设备进行操作。设备驱动程序是内核的一部分，它完成以下的功能:<br>1、对设备初始化和释放；<br>2、把数据从内核传送到硬件和从硬件读取数据；<br>3、读取应用程序传送给设备文件的数据和回送应用程序请求的数据；<br>4、检测和处理设备出现的错误。</p>
</blockquote>
<blockquote>
<p>注释2： ioctl()函数是驱动中对设备的I/O通道进行管理的函数，ioctl函数里面都实现了多个的对硬件的操作步骤，将他们综合起来完成一个任务，而不是单一的某个write/read操作，通过应用层传入的命令来调用相应的操作。</p>
</blockquote>
<h2 id="ServiceManager"><a href="#ServiceManager" class="headerlink" title="ServiceManager"></a>ServiceManager</h2><p>ServiceManger有点类似于路由器，使得client端可以通过字符串形式的binder名来获取server端binder的引用，它提供注册和查询服务。server端像smg注册服务，client从smg获取服务。</p>
<p>server创建了一个binder实体，为其取一个容易记住的名字，然后将这个binder实体 连同名字通过binder驱动发送给smg，通知smg注册一个服务，以及该服务的名字，binder驱动会为这个穿过进程边际的binder创建一个位于内核的实体节点，以及smg对该实体节点的引用，然后将名字以及新建的引用打包发送给serviceManager，smg会在它的svcinfo表中添加该信息。该svcinfo便是服务查询表。</p>
<p><img src="/media/15280001106523.jpg" alt=""></p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://wenyiqingnian.xyz/2018/05/29/Binder的设计架构/" data-id="cjiih6wy20008hx0coriqnztz" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    
        <a href="http://wenyiqingnian.xyz/2018/05/29/Binder的设计架构/#comments" class="article-comment-link">Comments</a>
    

        </footer>
    </div>
    
</article>



    <article id="post-JAVA的垃圾回收策略（二）" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2018/05/23/JAVA的垃圾回收策略（二）/">JAVA的垃圾回收策略（二）</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2018/05/23/JAVA的垃圾回收策略（二）/">
            <time datetime="2018-05-23T08:56:50.000Z" itemprop="datePublished">2018-05-23</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/java基础/">java基础</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/java/">java</a>, <a class="tag-link" href="/tags/垃圾回收/">垃圾回收</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p>上文说到了一个java对象的生命周期以及生存位置<br>本文主要讲 jvm虚拟机如何判定一个对象是否是垃圾，以及以何种算法回收垃圾。</p>
<h2 id="GC的工作流程"><a href="#GC的工作流程" class="headerlink" title="GC的工作流程"></a>GC的工作流程</h2><h3 id="1-判定那些对象已成为垃圾"><a href="#1-判定那些对象已成为垃圾" class="headerlink" title="1. 判定那些对象已成为垃圾"></a>1. 判定那些对象已成为垃圾</h3><p>jvm一般有两种方法判断对象是否成为垃圾</p>
<h4 id="1-引用标记算法"><a href="#1-引用标记算法" class="headerlink" title="1. 引用标记算法"></a>1. 引用标记算法</h4><h5 id="1-流程"><a href="#1-流程" class="headerlink" title="1.流程"></a>1.流程</h5><ol>
<li>给每一个对象都增加一个引用计数器</li>
<li>每次对象新增一个引用的时候，该计数器+1</li>
<li>当该引用对象失效（比如超出了作用域）==【注1】==，该引用计数器-1</li>
<li>当该对象的引用计数器为1时，表明该对象不可用，可作为垃圾回收了。<blockquote>
<p>注1：<br>作用域的概念，上文其实已经说过了，见<br><a href="http://wenyiqingnian.xyz/2018/05/17/JAVA%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5/">JAVA垃圾回收机制</a>。当在方法内创建了一个引用变量并指向它引用的对象的时候，引用的对象会在方法执行完后仍然存活在堆内存上，只是引用变量会随方法一起出栈销毁而已，见下面的例子。</p>
</blockquote>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">...</span><br><span class="line">Persion p = <span class="keyword">new</span> Person();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*方法之外，引用变量P就消失了，因为引用变量是存放在</span></span><br><span class="line"><span class="comment">*方法栈中的，所以方法执行完毕，p便随着方法栈一起出</span></span><br><span class="line"><span class="comment">*栈，但是因为这中间调用了new 关键字,其创建的person对象会一直存放在堆内存中等待**被GC，此时person对象，就是超出了作用域的对象。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">CLASS_A--&gt;CLASS_B</span><br><span class="line">CLASS_B--&gt;CLASS_A</span><br></pre></td></tr></table></figure>
<h5 id="2-引用标记算法的优缺点"><a href="#2-引用标记算法的优缺点" class="headerlink" title="2. 引用标记算法的优缺点"></a>2. 引用标记算法的优缺点</h5><ul>
<li>优点：算法简单，执行速度快，不需要长时间中断应用程序的执行</li>
<li>缺陷：无法解决循环引用问题（A引用B，B引用A，此时引用计数器永远无法置0）。<h4 id="2-GC-ROOT-可达性算法"><a href="#2-GC-ROOT-可达性算法" class="headerlink" title="2. GC_ROOT 可达性算法"></a>2. GC_ROOT 可达性算法</h4><h5 id="1-原理"><a href="#1-原理" class="headerlink" title="1. 原理"></a>1. 原理</h5></li>
</ul>
<ol>
<li>以GC root作为根节点 ==（gcroot具体包含那些对象下面会详细解释）==,向下搜寻所有对象</li>
<li>如果可以走到该对象，就建立一个该对象和GCTROOT之间的引用链。</li>
<li>从根节点开始，生成对象引用树，不可达的对象，会被判断为垃圾由GC判断是否回收</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">GCROOT--&gt;CLASS_A</span><br><span class="line">GCROOT--&gt;CLASS_B</span><br><span class="line">GCROOT--&gt;CLASS_C</span><br><span class="line">GCROOT--&gt;CLASS_E</span><br><span class="line">CLASS_A--&gt;CLASS_D</span><br><span class="line">CLASS_A--&gt;CLASS_F</span><br><span class="line">CLASS_B--&gt;CLASS_F</span><br><span class="line">CLASS_B--&gt;CLASS_G</span><br><span class="line">CLASS_H--&gt;CLASS_J</span><br><span class="line">CLASS_J--&gt;CLASS_H</span><br><span class="line">CLASS_E--&gt;CLASS_K</span><br></pre></td></tr></table></figure>
<p>上图的对象h和对象j 就是不可达的引用，但是彼此持有对方的引用，如果用引用计数算法，该对象是无法被回收的，gcroot算法，他们是不可达的，会随时被gc回收。</p>
<h4 id="3-关于回收的一些其他问题"><a href="#3-关于回收的一些其他问题" class="headerlink" title="3.关于回收的一些其他问题"></a>3.关于回收的一些其他问题</h4><p>当对象被标记为不可达的时候，gc并不会立刻启动回收程序，而是再使用两次标记算法来区分何时回收。<br>在GC启动回收程序的时候，为了保证引用状态不变，系统会暂停所有应用进程（stopt the world ），这个时间很短，反应在UI上就是UI卡顿了一下，所以安卓应用要十分注意合理控制好内存回收，不要频繁处罚GC，不然体验会十分糟糕。</p>
<blockquote>
<p>二次标记算法:<br>1.如果对象与GC Root没有连接的引用链，就会被第一次标记，随后判定该对象是否有必要执行finalize()方法</p>
</blockquote>
<blockquote>
<p>2.如果有必要执行finalize()方法，则这个对象就会被放到F-Queue的队列中，稍后由虚<br>拟机建立低优先级的Finalizer线程去执行，但并不承诺等待它运行结束（对象类中能够<br>重写finalize()方法进行自救，但系统最多只能执行一次）</p>
</blockquote>
<blockquote>
<p>3.如果没必要执行finalize()方法，则第二次标记</p>
</blockquote>
<h4 id="2-通过特定算法回收垃圾"><a href="#2-通过特定算法回收垃圾" class="headerlink" title="2. 通过特定算法回收垃圾"></a>2. 通过特定算法回收垃圾</h4><p>主要包括以下四种算法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、标记清除算法</span><br><span class="line">2、算法算法</span><br><span class="line">3、标记整理算法</span><br><span class="line">4、分代回收算法</span><br></pre></td></tr></table></figure>
<h5 id="1-标记清除算法"><a href="#1-标记清除算法" class="headerlink" title="1. 标记清除算法"></a>1. 标记清除算法</h5><p>两步走</p>
<ul>
<li>标记 标记出无用的对象</li>
<li>清除 清除掉对象的空间</li>
</ul>
<p>可以看到 优缺点很明显</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">缺点：容易造成内存碎片，当下次申请大内存的时候，可能找不到连续的内存给其使用，会频繁出发gc，</span><br><span class="line"></span><br><span class="line">优点：是算法比较简单。</span><br></pre></td></tr></table></figure>
<p><img src="/media/1.png" alt="1"></p>
<p>因为标记无用对象耗时，可以看出 标记清除算法比较适合于 垃圾少，存活对象多的情况，可以减少标记次数。在分代回收算法中，它一般应用在老年代（对象存活率高，需要回收的少）</p>
<h5 id="2-复制算法（也被成为拷贝回收算法）"><a href="#2-复制算法（也被成为拷贝回收算法）" class="headerlink" title="2. 复制算法（也被成为拷贝回收算法）"></a>2. 复制算法（也被成为拷贝回收算法）</h5><p>此方法将内存按容量分为两块，例如A、B两块，每次只使用其中的一块，当要进行回收操作时，将A中还存活的对象复制到B块中（假设上次使用A），然后对A中所有对象清空就又构成一个完整的内存块。这种方法就避免了标记清除的内存碎片问题。<br><img src="/media/2.png" alt="2"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">优点：不会产生内存碎片</span><br><span class="line"></span><br><span class="line">缺点： 会浪费内存，因为不管A块中有多少存活对象，都只能使用内存的一半，AB块中始终有一块为空，属于用空间换时间。 分代回收法中新生代的部分，使用的是该算法。</span><br></pre></td></tr></table></figure>
<p>适合存活对象少 回收对象多的情况，因为存活对象多复制的过程就长一些，算法效率会受影响。</p>
<h5 id="3-标记整理算法"><a href="#3-标记整理算法" class="headerlink" title="3. 标记整理算法"></a>3. 标记整理算法</h5><p>解决了上述两种算法的缺点，但也带来了新的缺点，就是算法效率不够高。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 标记存活对象</span><br><span class="line">2. 移动对象到左上角</span><br><span class="line">3. 将其他空间全部回收</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">优点： 不会产生内存碎片 不会造成空间使用浪费</span><br><span class="line"></span><br><span class="line">缺点：标记的过程导致其效率不如复制算法，移动的过程，导致其效率不如标记算法。</span><br></pre></td></tr></table></figure>
<p><img src="/media/3.png" alt="3"></p>
<p>适合存活对象多</p>
<h5 id="4-分代回收算法"><a href="#4-分代回收算法" class="headerlink" title="4. 分代回收算法"></a>4. 分代回收算法</h5><p>该算法其实是上述三种算法的组合，因为上述三种算法都有其适用的适用情景，不可能适用所有情况，分代回收算法就是根据jvm里不同对象的存活特性来组合使用上述三种算法。</p>
<p>jvm按照对象生命周期将内存划分为两个区域。</p>
<ul>
<li><strong>新生代</strong> </li>
</ul>
<p>新生代会产生大量的临时对象。这些对象 朝生夕死。存活时间短，经常需要回收，所以采用拷贝回收算法。在新生代的gc，称之为<strong>minor gc</strong>。</p>
<ul>
<li><strong>老年代</strong> </li>
</ul>
<p>一般是生命周期长的对象，回收频率很低，只有当老年代内存占满了之后，才会触发一次full gc，或称之为（major gc）。</p>
<p>内存的具体划分</p>
<p><img src="/media/4.jpg" alt="4"></p>
<p>可以看到 </p>
<p>新生代又被分为Eden 区 和 s1，s2区。s1 s2是为了拷贝算法划分的乒乓区域。他们大小是相同的。</p>
<h5 id="2-分代回收算法的具体回收过程"><a href="#2-分代回收算法的具体回收过程" class="headerlink" title="2. 分代回收算法的具体回收过程"></a>2. 分代回收算法的具体回收过程</h5><ol>
<li>新生对象全部在Eden区域活动，当Eden区域满了之后，会触发一次minor gc  将Eden区域中还能用的的对象拷贝到From区域。<br><img src="/media/5.png" alt="5"></li>
</ol>
<p>此时 Eden区域的空间被清空，存活对象在From区。</p>
<ol start="2">
<li>当From区域满了之后，会再次触发monor gc，将Eden和From区域中还可用的对象拷贝到To区域中。<br><img src="/media/6.png" alt="6"></li>
</ol>
<p>此时 Eden 和From区的空间被清空。</p>
<ol start="3">
<li>当To的空间满了之后，会再次触发minor gc，此时会将Eden 和To 空间中还存活的对象拷贝到From区。Eden 和To space被清空。<br><img src="/media/7.png" alt="7"></li>
<li>在多次minor gc之后，有些对象会一直在from和to 区域之间来回拷贝，此时会被算法标注为老年代对象，gc会将该对象从新生代直接拷贝到老年代。<br>JVM虚拟机默认的反复拷贝次数为==15次==。如果对象在From 到 to区域中反复拷贝了15次，就会被划分为老年代。<br><img src="/media/8.png" alt="8"></li>
<li>对象进入老年代之后，当老年代内存区域也满了，便会触发一次Full gc， 此时使用的算法是标记算法和标记整理算法。</li>
<li>为什么老年代的gc 不使用拷贝算法，因为老年代中的对象大多是存活率高的对象，使用拷贝算法要创建一个很大的新内存空间来做拷贝，这样很浪费资源。为什么不只使用标记算法，因为这样会导致内存碎片。使用标记清除算法，会将存活对象做地址移动，都集中在一块连续地址空间中，防止产生内存碎片。</li>
<li>所monor gc的时候，是用空间换时间，因为该gc发生频繁，效率是首要考虑的问题。 而full gc的时候，腾出空间更重要，所以选择用时间（使用标注整理算法）换空间。</li>
</ol>
<h5 id="3-新生代老年代的内存划分比"><a href="#3-新生代老年代的内存划分比" class="headerlink" title="3. 新生代老年代的内存划分比"></a>3. 新生代老年代的内存划分比</h5><p>新生代：老年代 2：1</p>
<p>新生代中</p>
<p>Eden : s1 : s2  = 8 : 1 : 1</p>
<h3 id="3-GC-ROOT"><a href="#3-GC-ROOT" class="headerlink" title="3. GC_ROOT"></a>3. GC_ROOT</h3><p>要记住一个概念，选gcroot，就是要以这些当前活跃的gcroot对象为根去遍历所有引用关系，能遍历到的就是存活的，遍历不到的认为死去，所以选gcroot，本质是找到==所有存活的对象==，把其他空间认定为无用去清除掉。<br>所以gcroot必须具备两个性质</p>
<ol>
<li>必须存活</li>
<li>必须有其他引用（因为要以它自己去遍历引用关系）</li>
</ol>
<p>jvm 运行时内存</p>
<p><img src="/media/9.png" alt="9"></p>
<p>所以“GC roots”，或者说tracing GC的“根集合”，就是一组必须==活跃==的==引用==。<br>具体包括以下几种：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. Class 由System Class Loader/Boot Class Loader加载的类，类似于java.util.*包下的类，因为它</span><br><span class="line">一定是贯穿于整个生命周期的，可以以此为根遍历出去找到其他引用的类。被引用到的就一定是存活的。</span><br><span class="line"><span class="number">2</span>. Thread 对象，已激活但是未结束的线程对象；</span><br><span class="line"><span class="number">3</span>. Stack Local 栈中的对象。每个线程都会分配一个栈，栈中的局部变量或者参数的引用都是GC root，因为仍在栈中，表明方法还没执行完，对象仍存活，（执行后的方法会出栈，就不满足存活条件了），同时是引用对象。</span><br><span class="line"><span class="number">4</span>.JNI Local JNI中的局部变量和参数引用的对象；可能在JNI中定义的，也可能在虚拟机中定义</span><br><span class="line"><span class="number">5</span>. JNI Global JNI中的全局变量引用的对象；同上</span><br><span class="line"><span class="number">6</span>. Monitor Used 用于保证同步的对象，例如wait()，notify()中使用的对象、锁等。</span><br><span class="line"><span class="number">7</span>. Held by JVM JVM持有的对象。JVM为了特殊用途保留的对象，它与JVM的具体实现有关。比如有System Class Loader, 一些Exceptions对象，和一些其它的ClassLoader。对于这些类，JVM也没有过多的信息。</span><br><span class="line"><span class="number">8</span>. 静态数据结构指向对象堆的引用。</span><br></pre></td></tr></table></figure>
<p>关于1 2 我举几个具体例子来说明一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.由系统类加载器加载的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceManager</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Person p = <span class="keyword">new</span> Person();</span><br><span class="line">&#125;</span><br><span class="line">这里不确切，但是大致可以表明意思，安卓</span><br><span class="line">ServiceManager贯穿整个应用生命周期，它里面持有Persion对象的引用，这个ServiceManager对象就是gcroot 它持有的person对象永远不会被释放。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>. <span class="comment">//Thred Local</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">      Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                B b = <span class="keyword">new</span> B();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        t.start();</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">t 属于gcroot 如果不停止thread t永远不会被回收，它持有的b 也不会被回收。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>.</span><br></pre></td></tr></table></figure>
<blockquote>
<p>==注意，是一组必须活跃的引用，不是对象==<br>Tracing GC的根本思路就是：给定一个集合的引用作为根出发，通过引用关系遍历对象图，能被遍历到的（可到达的）对象就被判定为存活，其余对象（也就是没有被遍历到的）就自然被判定为死亡。注意再注意：tracing GC的本质是==通过找出所有活对象来把其余空间认定为“无用”==，而不是==找出所有死掉的对象并回收它们占用的空间==。这里非常容易搞混淆！！GC roots这组引用是tracing GC的起点。</p>
</blockquote>
<h3 id="4-安卓的Dalvik虚拟机与jvm不同的地方"><a href="#4-安卓的Dalvik虚拟机与jvm不同的地方" class="headerlink" title="4 . 安卓的Dalvik虚拟机与jvm不同的地方"></a>4 . 安卓的Dalvik虚拟机与jvm不同的地方</h3><h4 id="1-堆的结构不同"><a href="#1-堆的结构不同" class="headerlink" title="1. 堆的结构不同"></a>1. 堆的结构不同</h4><p>  Dalvik虚拟机用来分配对象的堆划分为两部分，一部分叫做<strong>Active Heap</strong>，另一部分叫做<strong>Zygote Heap</strong>。为什么要划分为两个堆，是为了减少内存拷贝的过程。(5.0之后改为ART虚拟机，ART运行时堆划分为四个空间，分别是Image Space、Zygote Space、Allocation Space和Large Object Space)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">ActiveHeap</span><br><span class="line">ZygoteHeap</span><br></pre></td></tr></table></figure>
<p>  我们知道 安卓系统的父进程是Zygote进程，它在开机的过程中就为Android系统准备好了一个Dalvik虚拟机实例。</p>
<p>  安卓的每一个应用程序都是一个独立的进程，都有自己独立的内存空间和虚拟机实例，如果在应用启动的时候都重新为其创建虚拟机实例，是十分消耗资源的，为了加快这个速度，dalvik虚拟机采用写时拷贝的方式，将Zygote进程在开机时就创建好的Dalvik虚拟机实例，复制到应用程序的进程中去，从而加快了Android应用程序进程的启动过程。</p>
<p>  因为zygote进程作为核心进程，应用的虚拟机实例都是复制于它，在创建虚拟机实例的时候，要预先加载安卓系统的核心方法还有一些核心类，是重量级的进程。主要做了以下四件事情：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 创建了一个Dalvik虚拟机实例；</span><br><span class="line">2. 加载了Java核心类及其JNI方法；</span><br><span class="line">3. 为主线程的设置了一个JNI环境；</span><br><span class="line">4. 注册了Android核心类的JNI方法。</span><br></pre></td></tr></table></figure></p>
<p>这些核心类可以与应用程序共享，所以说<br> zygote牺牲自己的启动时间，来提高应用的加载速度。</p>
<p>  但拷贝仍然是很费时的操作，为了避免拷贝，dalvik将自己的堆分为两部分，事实上，Dalvik虚拟机的堆最初是只有一个的。也就是Zygote进程在启动过程中创建Dalvik虚拟机的时候，只有一个堆。但是当Zygote进程在fork第一个应用程序进程之前，会将已经使用了的那部分堆内存划分为一部分，还没有使用的堆内存划分为另外一部分。前者就称为Zygote堆，后者就称为Active堆。以后无论是Zygote进程，还是应用程序进程，当它们需要分配对象的时候，都在Active堆上进行。</p>
<blockquote>
<p>zygote堆  zygote进程启动创建虚拟机的时候已经用了的那部分内存，主要存的是Zygote进程在启动过程中预加载的类、资源和对象</p>
</blockquote>
<blockquote>
<p>active堆  zygote启动创建虚拟机时尚未使用的堆内存。应用程序还有zygote进程创建对象都在该堆进行</p>
</blockquote>
<p>  这样就可以使得Zygote堆尽可能少地被执行写操作，因而就可以减少执行写时拷贝的操作，在zygote堆中存放的预加载的类、资源和对象可以在Zygote进程和应用程序进程中做到长期共享。这样既能减少拷贝操作，还能减少对内存的需求。</p>
<h4 id="2-标记机制不同"><a href="#2-标记机制不同" class="headerlink" title="2.标记机制不同"></a>2.标记机制不同</h4><p>  虽然dalvik虚拟机也是用的标记-清除算法，但为了减少Stop_the_world 造成的停顿，采用的并行垃圾回收算法（Concurrent GC）<br>  标记被分为两部分</p>
<ol>
<li>第一步 只标记gcroot 引用的对象 </li>
<li>第二步 标记被gcroot 引用对象所引用的其他对象<br>例如，一个栈变量引了一个对象，而这个对象又通过成员变量引用了另外一个对象，那该被引用的对象也会同时标记为正在使用。这个标记被根集对象引用的对象的过程就是第二个子阶段。</li>
</ol>
<p><strong>注意</strong></p>
<blockquote>
<p>在Concurrent GC，第一个子阶段是不允许垃圾收集线程之外的线程运行的，但是第二个子阶段是允许的。不过，在第二个子阶段执行的过程中，如果一个线程修改了一个对象，那么该对象必须要记录起来，因为它很有可能引用了新的对象，或者引用了之前未引用过的对象。如果不这样做的话，那么就会导致被引用对象还在使用然而却被回收。这种情况出现在只进行部分垃圾收集的情况，这时候Card Table的作用就是用来记录非垃圾收集堆对象对垃圾收集堆对象的引用。</p>
</blockquote>
<h3 id="4-由垃圾回收机制引申的内存泄漏问题"><a href="#4-由垃圾回收机制引申的内存泄漏问题" class="headerlink" title="4. 由垃圾回收机制引申的内存泄漏问题"></a>4. 由垃圾回收机制引申的内存泄漏问题</h3><p>所谓内存泄漏，其实就是该回收的对象无法回收，造成无法回收的原因就是它还被gcroot直接或者间接引用。</p>
<p>可以看几个内存泄漏的例子</p>
<ol>
<li>静态类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Context instance;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(Context context)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.instance = context;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>静态成员变量 instance 持有一个context的引用，instance是gcroot，不会被回收，它持有的context对象也不会被回收，导致内存泄漏。</p>
<ol start="2">
<li>匿名内部类</li>
</ol>
<p>创建HashMap的时候，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;HashMap&lt;String,Object&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>属于匿名创建，list中会持有外部类的引用，list又是一个gcroot，导致类A 无法被回收，另一个常见的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> MyHandler handler = <span class="keyword">new</span> MyHandler();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>静态成员变量handler指向Myhandler()，是GCROOT成员，但MyHandler是内部类，持有外部类MainActivity的引用，会导致MainActivity 无法被回收。</p>
<ol start="3">
<li>线程未结束<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span>  <span class="title">MainActivity</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">      Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Activity a = MainActivity.<span class="keyword">this</span>;</span><br><span class="line">                ...</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        t.start();</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>如果t不执行完，Activity1就无法被回收。</p>
<ol start="4">
<li>JNI LOCAL GLOBAL reference<br>这类对象一般发生在参与Jni交互的类中。</li>
</ol>
<p>比如说很多close()相关的类，InputStream,OutputStream,Cursor,SqliteDatabase等。这些对象不止被Java代码中的引用持有，也会被虚拟机中的底层代码持有。在将持有它们的引用设置为null之前，要先将他们close()掉。<br>还有一个特殊的类是Bitmap。在Android系统3.0之前，它的内存一部分在虚拟机中，一部分在虚拟机外。因此它的一部分内存不参与垃圾回收，需要我们主动调用recycler()才能回收。</p>
<p>动态链接库中的内存是用C/C++语言申请的，这些内存不受虚拟机的管辖。所以，so库中的数组，类等都有可能发生内存泄漏，使用的时候务必小心。</p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://wenyiqingnian.xyz/2018/05/23/JAVA的垃圾回收策略（二）/" data-id="cjiih6wy7000dhx0cgi78s798" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    
        <a href="http://wenyiqingnian.xyz/2018/05/23/JAVA的垃圾回收策略（二）/#comments" class="article-comment-link">Comments</a>
    

        </footer>
    </div>
    
</article>



    <article id="post-JAVA的垃圾回收策略" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2018/05/17/JAVA的垃圾回收策略/">JAVA的垃圾回收策略</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2018/05/17/JAVA的垃圾回收策略/">
            <time datetime="2018-05-16T16:56:50.000Z" itemprop="datePublished">2018-05-17</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/java基础/">java基础</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/java/">java</a>, <a class="tag-link" href="/tags/垃圾回收/">垃圾回收</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>创建了一个对象，就意味着或早或晚，该对象都是需要 被释放掉的，只不过这个时间有长有短，对象从被new出来到被垃圾回收器回收，就是一个生命周期的完整过程，java的垃圾回收机制可以做到自动决定哪些对象是无用的从而被回收掉，无需使用者担心，但是不健壮的java代码会影响到回收算法对无效对象的识别，从而影响对象的生命周期，导致无法回收。为了弄清楚java的垃圾回收机制，有必要先搞懂下面这些概念。</p>
<h2 id="java程序的生存空间：-堆与栈"><a href="#java程序的生存空间：-堆与栈" class="headerlink" title="java程序的生存空间： 堆与栈"></a>java程序的生存空间： 堆与栈</h2><ul>
<li>堆：实例变量（成员变量）与对象的生存空间</li>
<li>栈：方法调用与局部变量的生存空间<blockquote>
<p>注1：实例变量生命在对象内部，而不是方法内，塔代表每一个独立对象的“字段”，是存储在对象中的。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>注2：局部变量生命在方法中，他们是暂时的，生命周期只限于方法被放入栈上的时间，也就是方法执行到结束的过程。</p>
</blockquote>
<blockquote>
<p>注3：方法的调用过程，是伴随方法栈入栈出栈的过程的，方法被调用，一个对应的方法堆栈块也就被放置到栈顶，这个堆栈块里除了存放局部变量和方法参数之外，还会存放方法的执行状态，包括方法执行的行数，当方法执行完毕之后，该方法堆栈块便会出栈。</p>
</blockquote>
<p>如果是这样</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    foo1();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo2</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    foo2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法foo1 调用了foo2 执行到调用时，会将foo2放在foo1()的栈顶上，foo1被压下去。</p>
<blockquote>
<p>注4：非primitive（注5）的变量都只是对对象的引用而已，所以所有的局部变量，变量本身都是存放在方法栈空间的，当所指向的对象被实例化了，对象存放在堆空间。</p>
</blockquote>
<blockquote>
<p>注5：java的变量类型分为 primitive数据类型和 引用类型，primitive 主数据类型用来保存基本类型的值，包括整数、布尔和浮点数等，而对象引用保存的是对象的引用。</p>
</blockquote>
<blockquote>
<p>注6： 不管是实例变量还是局部变量，对象本身都是存放在堆上的</p>
</blockquote>
<h2 id="对象的创建-三部曲：声明、创建、赋值"><a href="#对象的创建-三部曲：声明、创建、赋值" class="headerlink" title="对象的创建 三部曲：声明、创建、赋值"></a>对象的创建 三部曲：声明、创建、赋值</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Duck duck   <span class="comment">// 1.创建出新的引用变量duck给Duck类型</span></span><br><span class="line">=           <span class="comment">//3. 赋值该对象给引用变量</span></span><br><span class="line"><span class="keyword">new</span> Duck(); <span class="comment">//2. 创建该对象实例</span></span><br></pre></td></tr></table></figure>
<p>调用new 方法，便创建了一个duck实例，这其中的过程其实是调用了类的构造方法。</p>
<p><strong>注意</strong> 对象构造方法会先与对象实例被赋值给引用对象之前就执行。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">People</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">'people'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        People p = <span class="keyword">new</span> People();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>会打印出people的log</p>
<h2 id="对象的声明周期"><a href="#对象的声明周期" class="headerlink" title="对象的声明周期"></a>对象的声明周期</h2><p>对象的生命周期是看对象的引用。如果还有引用，对象继续存活在堆上，如果没有引用了，对象就会被垃圾回收器回收。<br>所以==对象的声明周期 要看引用变量的声明周期==，而引用变量的声明周期，又要看它是局部变量还是成员变量。</p>
<ul>
<li>局部变量： 与方法声明周期同步，只活在该方法内，方法执行完毕，对象立即被释放，对其他程序和方法不可见。</li>
<li>成员变量： 与对象声明周期同步。如果对象活着，该成员变量也活着。<h4 id="关于局部变量，这里需要讲两个概念"><a href="#关于局部变量，这里需要讲两个概念" class="headerlink" title="关于局部变量，这里需要讲两个概念"></a>关于局部变量，这里需要讲两个概念</h4><h3 id="Life"><a href="#Life" class="headerlink" title="Life"></a>Life</h3>对象的堆栈块还在栈内，方法还没执行完，就还活着。活到方法执行完结束。</li>
</ul>
<h3 id="Scope"><a href="#Scope" class="headerlink" title="Scope"></a>Scope</h3><p>局部变量的范围，只存在声明它的方法内，如果该方法调用了其他方法，则该变量仍然存活，只不过在执行调用方法的时候，该变量不在它的范围而已。</p>
<blockquote>
<p>只要方法还没执行完，对象就不会死，但只有方法在栈顶，对象才是可用的。</p>
</blockquote>
<h2 id="变量的生命周期如何影响对象的生命周期？"><a href="#变量的生命周期如何影响对象的生命周期？" class="headerlink" title="变量的生命周期如何影响对象的生命周期？"></a>变量的生命周期如何影响对象的生命周期？</h2><p>只要有活的引用，对象会一直活着，如果对某个对象的引用不在它的范围内，但该引用变量还是活的，则该对象也会活着，呆在堆内存中。如果对该对象的唯一引用没有了，对象便会回收</p>
<p>三种方法释放对象引用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法执行完，引用便释放了</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">go</span><span class="params">()</span></span>&#123;</span><br><span class="line">    People p = <span class="keyword">new</span> People();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 引用被赋值到别处</span></span><br><span class="line">People p = <span class="keyword">new</span> People();</span><br><span class="line">p = <span class="keyword">new</span> People(); <span class="comment">//第一个对象会在此时被释放</span></span><br><span class="line"><span class="comment">// 直接置空</span></span><br><span class="line">People p = <span class="keyword">new</span> People();</span><br><span class="line">p =<span class="keyword">null</span>;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>—待续 5.17 00:51</p>
</blockquote>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://wenyiqingnian.xyz/2018/05/17/JAVA的垃圾回收策略/" data-id="cjiih6wy40009hx0cax664019" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    
        <a href="http://wenyiqingnian.xyz/2018/05/17/JAVA的垃圾回收策略/#comments" class="article-comment-link">Comments</a>
    

        </footer>
    </div>
    
</article>



    <article id="post-hexo+icarus" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2018/05/14/hexo+icarus/">hexo+icarus</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2018/05/14/hexo+icarus/">
            <time datetime="2018-05-13T16:15:50.000Z" itemprop="datePublished">2018-05-14</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/备忘录/">备忘录</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/hexo/">hexo</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <h1 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h1><h3 id="1-安装node"><a href="#1-安装node" class="headerlink" title="1. 安装node"></a>1. 安装node</h3><h3 id="2-生成ssh公钥秘钥对-并且添加到github上"><a href="#2-生成ssh公钥秘钥对-并且添加到github上" class="headerlink" title="2. 生成ssh公钥秘钥对 并且添加到github上"></a>2. 生成ssh公钥秘钥对 并且添加到github上</h3><h3 id="3-安装hexo"><a href="#3-安装hexo" class="headerlink" title="3. 安装hexo"></a>3. 安装hexo</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo</span><br></pre></td></tr></table></figure>
<h3 id="4-初始化hexo"><a href="#4-初始化hexo" class="headerlink" title="4. 初始化hexo"></a>4. 初始化hexo</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init hexo</span><br></pre></td></tr></table></figure>
<h3 id="5-安装部署依赖文件"><a href="#5-安装部署依赖文件" class="headerlink" title="5. 安装部署依赖文件"></a>5. 安装部署依赖文件</h3><p>进入hexo目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure></p>
<h3 id="6-安装hexo-server"><a href="#6-安装hexo-server" class="headerlink" title="6. 安装hexo-server"></a>6. 安装hexo-server</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-server</span><br></pre></td></tr></table></figure>
<p>hexo-server 会创建本地服务器，你可以使用hexo s<br>来在本地预览你的博客效果。</p>
<h3 id="6-生成hexo的目录结构"><a href="#6-生成hexo的目录结构" class="headerlink" title="6. 生成hexo的目录结构"></a>6. 生成hexo的目录结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure>
<h3 id="7-配置-config-yml文件"><a href="#7-配置-config-yml文件" class="headerlink" title="7. 配置_config.yml文件"></a>7. 配置_config.yml文件</h3><p>需要修改博客根目录的config文件，添加上你的github.io仓库地址，注意，你的ssh公钥此时应该已经添加到github上了 我的配置如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: https://github.com/QuincyJiang/QuincyJiang.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<h3 id="8-目录结构以及写作流程"><a href="#8-目录结构以及写作流程" class="headerlink" title="8.目录结构以及写作流程"></a>8.目录结构以及写作流程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/scaffolds</span><br><span class="line">source</span><br><span class="line">/themes</span><br><span class="line">.gitignore</span><br><span class="line">_config.yml</span><br><span class="line">package.json</span><br><span class="line">package-lock.json</span><br></pre></td></tr></table></figure>
<ul>
<li>public文件夹是每次hexo g 自动生成的网页静态代码 </li>
<li>source中存放日志的原始md文件，每次写了新的文章，就需要将文章放置在该目录下，然后<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>来生成静态网页代码，生成的代码会创建<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/public</span><br></pre></td></tr></table></figure></p>
<p>文件夹，<br> 如果启用了 about tags categories等界面 也需要在source目录中创建对应的文件夹（about，tags，categories文件夹，内部放index.md文件，文件头以</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">title: &quot;About&quot;</span><br><span class="line">layout: &quot;about&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>这种格式编写。</p>
<ul>
<li><p>当文章写完并且已使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>
<p>生成public文件夹后，使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br><span class="line">INFO  Start processing</span><br><span class="line">INFO  Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure>
<p>在浏览器输入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localhost:4000</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>来本地预览博客效果。</p>
<ul>
<li>确认无误，使用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<p>部署博客到github.io仓库。</p>
<h1 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h1><h3 id="下载主题"><a href="#下载主题" class="headerlink" title="下载主题"></a>下载主题</h3><p>克隆你喜欢的主题到/themes文件夹内。我使用的是<strong>icarus</strong>主题</p>
<h3 id="自定义主题配置"><a href="#自定义主题配置" class="headerlink" title="自定义主题配置"></a>自定义主题配置</h3><ol>
<li>修改根目录config文件，指定主题为icarus</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: icarus</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>进入themes/icarus/目录下,修改config文件</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"># Menus</span><br><span class="line">menu: # 配置主页上方的分类项 如果需要开启 要在博客根目录的source 文件夹下创建对应的同名文件并防止index.md 上面已经说过了</span><br><span class="line">  Home: . </span><br><span class="line">  Archives: archives</span><br><span class="line">  Categories: categories</span><br><span class="line">  Tags: tags</span><br><span class="line">  About: about</span><br><span class="line"></span><br><span class="line"># Customize</span><br><span class="line">customize:</span><br><span class="line">    logo: # 左上方小logo 将png文件放在主题目录下的css/image目录下</span><br><span class="line">        enabled: true</span><br><span class="line">        width: 40</span><br><span class="line">        height: 40</span><br><span class="line">        url: images/logo.png</span><br><span class="line">    profile:</span><br><span class="line">        enabled: true # Whether to show profile bar</span><br><span class="line">        fixed: true</span><br><span class="line">        avatar: css/images/avatar.png</span><br><span class="line">        gravatar: # Gravatar email address, if you enable Gravatar, your avatar config will be overriden</span><br><span class="line">        author: QuincyJiang</span><br><span class="line">        author_title: Coder &amp; FilmPlayer</span><br><span class="line">        location: Guangzhou, China</span><br><span class="line">        follow: https://github.com/QuincyJiang</span><br><span class="line">    highlight: androidstudio # 代码高亮风格，需要md文件格式支持，在代码块外 要显示标注代码语言 比如</span><br><span class="line">    ···java</span><br><span class="line">    public static void main()&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    sidebar: right # sidebar position, options: left, right or leave it empty</span><br><span class="line">    thumbnail: true # enable posts thumbnail, options: true, false</span><br><span class="line">    favicon: css/images/avatar.png</span><br><span class="line">    social_links:</span><br><span class="line">        github: https://github.com/QuincyJiang</span><br><span class="line">        weibo: https://weibo.com/2425393311/</span><br><span class="line">        photo: http://aquencyua11.lofter.com/</span><br><span class="line">    social_link_tooltip: true # enable the social link tooltip, options: true, false</span><br><span class="line"></span><br><span class="line"># Widgets</span><br><span class="line">widgets:</span><br><span class="line">    - recent_posts</span><br><span class="line">    - category</span><br><span class="line">    - archive</span><br><span class="line">    - tag</span><br><span class="line">    - tagcloud</span><br><span class="line">    - links</span><br><span class="line"></span><br><span class="line"># Search 是否启用insight搜索</span><br><span class="line">search:</span><br><span class="line">    insight: true # you need to install `hexo-generator-json-content` before using Insight Search</span><br><span class="line">    swiftype: # enter swiftype install key here</span><br><span class="line">    baidu: false # you need to disable other search engines to use Baidu search, options: true, false</span><br><span class="line"></span><br><span class="line"># Comment 是否开启评论功能 需要disqus账号</span><br><span class="line">comment: # </span><br><span class="line">    disqus: https-quincyjiang-github-io</span><br><span class="line">    duoshuo: # enter duoshuo shortname here</span><br><span class="line">    youyan: # enter youyan uid here</span><br><span class="line">    facebook: # enter true to enable</span><br><span class="line">    isso: # enter the domain name of your own comment isso server eg. comments.example.com</span><br><span class="line">    changyan: # please fill in `appid` and `conf` to enable</span><br><span class="line">        appid:</span><br><span class="line">        conf:</span><br><span class="line">    gitment:</span><br><span class="line">        owner: #QuincyJiang</span><br><span class="line">        repo: #https://github.com/QuincyJiang/comments.git</span><br><span class="line">        #Register an OAuth application, and you will get a client ID and a client secret.</span><br><span class="line">        client_id: </span><br><span class="line">        client_secret: </span><br><span class="line">    livere: # enter livere uid here</span><br><span class="line">    valine: # Valine Comment System https://github.com/xCss/Valine</span><br><span class="line">        on:  # enter true to enable</span><br><span class="line">        appId:  # enter the leancloud application appId here</span><br><span class="line">        appKey: # enter the leancloud application appKey here</span><br><span class="line">        notify: # enter true to enable &lt;Mail notifier&gt; https://github.com/xCss/Valine/wiki/Valine-%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E9%82%AE%E4%BB%B6%E6%8F%90%E9%86%92%E8%AE%BE%E7%BD%AE</span><br><span class="line">        verify: # enter true to enable &lt;Validation code&gt;</span><br><span class="line">        placeholder: Just Do It # enter the comment box placeholder</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"># Share</span><br><span class="line">share: default # options: jiathis, bdshare, addtoany, default</span><br><span class="line"></span><br><span class="line"># Plugins</span><br><span class="line">plugins:</span><br><span class="line">    lightgallery: true # options: true, false</span><br><span class="line">    justifiedgallery: true # options: true, false</span><br><span class="line">    google_analytics: # enter the tracking ID for your Google Analytics</span><br><span class="line">    google_site_verification: # enter Google site verification code</span><br><span class="line">    baidu_analytics: # enter Baidu Analytics hash key</span><br><span class="line">    mathjax: false # options: true, false</span><br><span class="line"></span><br><span class="line"># Miscellaneous</span><br><span class="line">miscellaneous:</span><br><span class="line">    open_graph: # see http://ogp.me</span><br><span class="line">        fb_app_id:</span><br><span class="line">        fb_admins:</span><br><span class="line">        twitter_id:</span><br><span class="line">        google_plus:</span><br><span class="line">    links:</span><br><span class="line">        github: https://github.com/QuincyJiang</span><br></pre></td></tr></table></figure>
<h1 id="托管hexo博客源码"><a href="#托管hexo博客源码" class="headerlink" title="托管hexo博客源码"></a>托管hexo博客源码</h1><p>为了保证切换电脑也可以保留原博客的风格，我们需要将博客的配置用git托管起来</p>
<h3 id="1-创建hexo源码仓库"><a href="#1-创建hexo源码仓库" class="headerlink" title="1.创建hexo源码仓库"></a>1.创建hexo源码仓库</h3><p>去gitub 新建一个 源码仓库 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/QuincyJiang/blog.git</span><br></pre></td></tr></table></figure>
<h3 id="2-将博客代码使用git托管"><a href="#2-将博客代码使用git托管" class="headerlink" title="2. 将博客代码使用git托管"></a>2. 将博客代码使用git托管</h3><p>博客根目录在我们创建hexo项目的时候，就已经生成了一个gitignore文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.DS_Store</span><br><span class="line">Thumbs.db</span><br><span class="line">db.json</span><br><span class="line">*.log</span><br><span class="line">node_modules/</span><br><span class="line">public/</span><br><span class="line">.deploy*/</span><br></pre></td></tr></table></figure>
<p>因为mode_modules public .deploy 文件夹都是会动态生成的，所以被添加到git忽略文件列表中了。注意，theme目录下我们克隆下来的第三方theme，它的远程仓库还是跟克隆时的目标仓库保持一致的，我们需要解除它远程仓库的关联，这样推送代码的时候才不会吧主题推送到其他地方。</p>
<h4 id="a-清除第三方主题的远程仓库"><a href="#a-清除第三方主题的远程仓库" class="headerlink" title="a 清除第三方主题的远程仓库"></a>a 清除第三方主题的远程仓库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd themes/icarus/</span><br><span class="line">rm -rf .git</span><br></pre></td></tr></table></figure>
<h4 id="b-修改主题目录下的gitignore文件"><a href="#b-修改主题目录下的gitignore文件" class="headerlink" title="b 修改主题目录下的gitignore文件"></a>b 修改主题目录下的gitignore文件</h4><p>因为主题的config配置文件我们也要托管起来，对博客的自定义配置主要都是在这里修改的。<br>修改很简单 删除忽略文件中的config.yml就好了</p>
<h4 id="c-创建版本库并与远程仓库链接"><a href="#c-创建版本库并与远程仓库链接" class="headerlink" title="c 创建版本库并与远程仓库链接"></a>c 创建版本库并与远程仓库链接</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd ../../</span><br><span class="line">git init</span><br><span class="line">git add . </span><br><span class="line">git remote add origin https://github/com/QuincyJiang/blog.git</span><br><span class="line">git commit -m &quot;init commit&quot;</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>
<h1 id="关于博客贴图"><a href="#关于博客贴图" class="headerlink" title="关于博客贴图"></a>关于博客贴图</h1><p>一般使用md文件写博客的时候，贴图是最痛苦的事情，一般是现将图片上传到图床之后，再获取图片链接。<br>这边安利一个软件 Mweb md文件编辑器，它可以用拖拽的方式来贴图，图片可以直接上传到github上。<a href="http://zh.mweb.im/" target="_blank" rel="noopener">官网地址了解一下</a></p>
<p>用法非常简单</p>
<h3 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h3><h3 id="选择外部模式"><a href="#选择外部模式" class="headerlink" title="选择外部模式"></a>选择外部模式</h3><p><img src="/media/15271330198211.jpg" alt=""></p>
<h3 id="点击右下角的加号-将hexo-博客的source文件夹添加进去"><a href="#点击右下角的加号-将hexo-博客的source文件夹添加进去" class="headerlink" title="点击右下角的加号 将hexo 博客的source文件夹添加进去"></a>点击右下角的加号 将hexo 博客的source文件夹添加进去</h3><h3 id="编辑该folders，右键点击folder"><a href="#编辑该folders，右键点击folder" class="headerlink" title="编辑该folders，右键点击folder"></a>编辑该folders，右键点击folder</h3><p><img src="/media/15271331311378.jpg" alt=""></p>
<h3 id="选择图片保存路径以及路径类型"><a href="#选择图片保存路径以及路径类型" class="headerlink" title="选择图片保存路径以及路径类型"></a>选择图片保存路径以及路径类型</h3><p><img src="/media/15271331832680.jpg" alt=""></p>
<h1 id="切换电脑后重新恢复博客环境"><a href="#切换电脑后重新恢复博客环境" class="headerlink" title="切换电脑后重新恢复博客环境"></a>切换电脑后重新恢复博客环境</h1><h3 id="克隆博客源码"><a href="#克隆博客源码" class="headerlink" title="克隆博客源码"></a>克隆博客源码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github/com/QuincyJiang/blog.git</span><br></pre></td></tr></table></figure>
<h3 id="配置基础环境"><a href="#配置基础环境" class="headerlink" title="配置基础环境"></a>配置基础环境</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">安装node</span><br><span class="line">安装git</span><br><span class="line">配置公钥到github</span><br></pre></td></tr></table></figure>
<h3 id="安装hexo-1"><a href="#安装hexo-1" class="headerlink" title="安装hexo"></a>安装hexo</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo</span><br><span class="line">npm install hexo --save</span><br><span class="line">npm install hexo-server</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>
<p>至此hexo安装完成，回到熟悉的source/_post 目录愉快开始写作吧</p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="http://wenyiqingnian.xyz/2018/05/14/hexo+icarus/" data-id="cjiih6wyg000whx0cuxnl0s6m" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fa fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fa fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fa fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fa fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    
        <a href="http://wenyiqingnian.xyz/2018/05/14/hexo+icarus/#comments" class="article-comment-link">Comments</a>
    

        </footer>
    </div>
    
</article>



    <nav id="page-nav">
        <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
</section>
            
                
<aside id="sidebar">
   
        
    <div class="widget-wrap">
        <h3 class="widget-title">recent</h3>
        <div class="widget">
            <ul id="recent-post" class="">
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2018/06/16/《现代艺术150年》未影印作品2/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/备忘录/">备忘录</a></p>
                            <p class="item-title"><a href="/2018/06/16/《现代艺术150年》未影印作品2/" class="title">《现代艺术150年》未影印作品2</a></p>
                            <p class="item-date"><time datetime="2018-06-16T06:00:50.000Z" itemprop="datePublished">2018-06-16</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2018/06/08/深度学习1-反向传播/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/机器学习/">机器学习</a></p>
                            <p class="item-title"><a href="/2018/06/08/深度学习1-反向传播/" class="title">深度学习1-反向传播</a></p>
                            <p class="item-date"><time datetime="2018-06-08T09:33:50.000Z" itemprop="datePublished">2018-06-08</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2018/06/02/《现代艺术150年》未影印作品1/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/备忘录/">备忘录</a></p>
                            <p class="item-title"><a href="/2018/06/02/《现代艺术150年》未影印作品1/" class="title">《现代艺术150年》未影印作品1</a></p>
                            <p class="item-date"><time datetime="2018-06-02T14:00:50.000Z" itemprop="datePublished">2018-06-02</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2018/06/02/从驱动角度理解binder/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/Android/">Android</a></p>
                            <p class="item-title"><a href="/2018/06/02/从驱动角度理解binder/" class="title">从驱动角度理解binder</a></p>
                            <p class="item-date"><time datetime="2018-06-02T11:00:50.000Z" itemprop="datePublished">2018-06-02</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2018/06/02/理解Liunx的FD与Inode/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/Linux/">Linux</a></p>
                            <p class="item-title"><a href="/2018/06/02/理解Liunx的FD与Inode/" class="title">理解Linux的FD与Inode</a></p>
                            <p class="item-date"><time datetime="2018-06-02T08:30:15.000Z" itemprop="datePublished">2018-06-02</time></p>
                        </div>
                    </li>
                
            </ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">categories</h3>
        <div class="widget">
            <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/AOSP/">AOSP</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/CoolUI/">CoolUI</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MQTT/">MQTT</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/bug记录/">bug记录</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java基础/">java基础</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/webrtc/">webrtc</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/备忘录/">备忘录</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/容器技术/">容器技术</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/机器学习/">机器学习</a><span class="category-list-count">1</span></li></ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">archives</h3>
        <div class="widget">
            <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a><span class="archive-list-count">1</span></li></ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">tags</h3>
        <div class="widget">
            <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AnimatedVectorDrawable/">AnimatedVectorDrawable</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Binder/">Binder</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SEAndroid/">SEAndroid</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tensorflow/">Tensorflow</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android/">android</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/aosp/">aosp</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/bugs/">bugs</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/">docker</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/">linux</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux命令/">linux命令</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mk/">mk</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mqtt/">mqtt</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/">python</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/qt/">qt</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/rxjava2/">rxjava2</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webrtc/">webrtc</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/句柄animation/">句柄animation</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/句柄泄露/">句柄泄露</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/垃圾回收/">垃圾回收</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/备忘录/">备忘录</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/多线程/">多线程</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/容器/">容器</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/开源框架/">开源框架</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/抓包/">抓包</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/机器学习/">机器学习</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/现代艺术150年/">现代艺术150年</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/编译/">编译</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a><span class="tag-list-count">1</span></li></ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">tag cloud</h3>
        <div class="widget tagcloud">
            <a href="/tags/AnimatedVectorDrawable/" style="font-size: 10px;">AnimatedVectorDrawable</a> <a href="/tags/Binder/" style="font-size: 15px;">Binder</a> <a href="/tags/SEAndroid/" style="font-size: 10px;">SEAndroid</a> <a href="/tags/Tensorflow/" style="font-size: 10px;">Tensorflow</a> <a href="/tags/android/" style="font-size: 20px;">android</a> <a href="/tags/aosp/" style="font-size: 10px;">aosp</a> <a href="/tags/bugs/" style="font-size: 10px;">bugs</a> <a href="/tags/docker/" style="font-size: 10px;">docker</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/java/" style="font-size: 17.5px;">java</a> <a href="/tags/linux/" style="font-size: 12.5px;">linux</a> <a href="/tags/linux命令/" style="font-size: 10px;">linux命令</a> <a href="/tags/mk/" style="font-size: 10px;">mk</a> <a href="/tags/mqtt/" style="font-size: 10px;">mqtt</a> <a href="/tags/python/" style="font-size: 10px;">python</a> <a href="/tags/qt/" style="font-size: 10px;">qt</a> <a href="/tags/rxjava2/" style="font-size: 10px;">rxjava2</a> <a href="/tags/webrtc/" style="font-size: 10px;">webrtc</a> <a href="/tags/句柄animation/" style="font-size: 10px;">句柄animation</a> <a href="/tags/句柄泄露/" style="font-size: 10px;">句柄泄露</a> <a href="/tags/垃圾回收/" style="font-size: 12.5px;">垃圾回收</a> <a href="/tags/备忘录/" style="font-size: 12.5px;">备忘录</a> <a href="/tags/多线程/" style="font-size: 10px;">多线程</a> <a href="/tags/容器/" style="font-size: 10px;">容器</a> <a href="/tags/开源框架/" style="font-size: 10px;">开源框架</a> <a href="/tags/抓包/" style="font-size: 10px;">抓包</a> <a href="/tags/机器学习/" style="font-size: 10px;">机器学习</a> <a href="/tags/现代艺术150年/" style="font-size: 12.5px;">现代艺术150年</a> <a href="/tags/编译/" style="font-size: 15px;">编译</a> <a href="/tags/设计模式/" style="font-size: 10px;">设计模式</a>
        </div>
    </div>

    
        
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">links</h3>
        <div class="widget">
            <ul>
                
                    <li>
                        <a href="https://github.com/QuincyJiang">github</a>
                    </li>
                
            </ul>
        </div>
    </div>


    
    <div id="toTop" class="fa fa-angle-up"></div>
</aside>

            
        </div>
        <footer id="footer">
<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <div class="outer">
        <div id="footer-info" class="inner">
            &copy; 2018 QuincyJiang<br>
            Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>. Theme by <a href="http://github.com/ppoffice">PPOffice</a>
            <br/>本站总访问量<span id="busuanzi_value_site_pv"></span>次，你是来本站的第<span id="busuanzi_value_site_uv"></span>位小伙伴，本文总阅读量<span id="busuanzi_value_page_pv"></span>次
        </div>
    </div>
</footer>
        
    
    
    <!-- 来必力City版安装代码 -->
    <script type="text/javascript">
     (function(d, s) {
         var j, e = d.getElementsByTagName(s)[0];

         if (typeof LivereTower === 'function') { return; }

         j = d.createElement(s);
         j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
         j.async = true;

         e.parentNode.insertBefore(j, e);
     })(document, 'script');
    </script>
  <noscript> 为正常使用来必力评论功能请激活JavaScript</noscript>
  <!-- City版安装代码已完成 -->





    
        <script src="/libs/lightgallery/js/lightgallery.min.js"></script>
        <script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script>
        <script src="/libs/lightgallery/js/lg-pager.min.js"></script>
        <script src="/libs/lightgallery/js/lg-autoplay.min.js"></script>
        <script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script>
        <script src="/libs/lightgallery/js/lg-zoom.min.js"></script>
        <script src="/libs/lightgallery/js/lg-hash.min.js"></script>
        <script src="/libs/lightgallery/js/lg-share.min.js"></script>
        <script src="/libs/lightgallery/js/lg-video.min.js"></script>
    
    
        <script src="/libs/justified-gallery/jquery.justifiedGallery.min.js"></script>
    
    



<!-- Custom Scripts -->
<script src="/js/main.js"></script>

    </div><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>
</html>